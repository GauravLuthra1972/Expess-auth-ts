/**
 * DevExtreme (esm/__internal/ui/list/list.base.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    fx
} from "../../../common/core/animation";
import {
    name as clickEventName
} from "../../../common/core/events/click";
import eventsEngine from "../../../common/core/events/core/events_engine";
import pointerEvents from "../../../common/core/events/pointer";
import {
    end as swipeEventEnd
} from "../../../common/core/events/swipe";
import {
    addNamespace
} from "../../../common/core/events/utils";
import messageLocalization from "../../../common/core/localization/message";
import devices from "../../../core/devices";
import {
    getPublicElement
} from "../../../core/element";
import Guid from "../../../core/guid";
import $ from "../../../core/renderer";
import {
    BindableTemplate
} from "../../../core/templates/bindable_template";
import {
    ensureDefined,
    noop
} from "../../../core/utils/common";
import {
    compileGetter
} from "../../../core/utils/data";
import {
    Deferred
} from "../../../core/utils/deferred";
import {
    getImageContainer
} from "../../../core/utils/icon";
import {
    each
} from "../../../core/utils/iterator";
import {
    getHeight,
    getOuterHeight,
    setHeight
} from "../../../core/utils/size";
import {
    isDefined,
    isPlainObject
} from "../../../core/utils/type";
import {
    hasWindow
} from "../../../core/utils/window";
import Button from "../../../ui/button";
import {
    current,
    isMaterial,
    isMaterialBased
} from "../../../ui/themes";
import {
    render
} from "../../core/utils/m_ink_ripple";
import supportUtils from "../../core/utils/m_support";
import {
    getDataSourceOptions
} from "../../data/data_converter/grouped";
import CollectionWidget from "../../ui/collection/collection_widget.live_update";
import ListItem from "../../ui/list/item";
import ScrollView from "../../ui/scroll_view/scroll_view";
import {
    deviceDependentOptions
} from "../../ui/scroll_view/scrollable.device";
import {
    getElementMargin
} from "../../ui/scroll_view/utils/get_element_style";
const LIST_CLASS = "dx-list";
const LIST_ITEMS_CLASS = "dx-list-items";
const LIST_ITEM_CLASS = "dx-list-item";
const LIST_ITEM_SELECTOR = ".dx-list-item";
const LIST_ITEM_ICON_CONTAINER_CLASS = "dx-list-item-icon-container";
const LIST_ITEM_ICON_CLASS = "dx-list-item-icon";
const LIST_GROUP_CLASS = "dx-list-group";
const LIST_GROUP_HEADER_CLASS = "dx-list-group-header";
const LIST_GROUP_BODY_CLASS = "dx-list-group-body";
const LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups";
const LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed";
const LIST_GROUP_HEADER_INDICATOR_CLASS = "dx-list-group-header-indicator";
const LIST_HAS_NEXT_CLASS = "dx-has-next";
const LIST_NEXT_BUTTON_CLASS = "dx-list-next-button";
const LIST_SELECT_CHECKBOX = "dx-list-select-checkbox";
const LIST_SELECT_RADIOBUTTON = "dx-list-select-radiobutton";
const WRAP_ITEM_TEXT_CLASS = "dx-wrap-item-text";
const SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
const LIST_ITEM_DATA_KEY = "dxListItemData";
const LIST_FEEDBACK_SHOW_TIMEOUT = 70;
let _scrollView = null;

function getScrollView() {
    return _scrollView ?? ScrollView
}
export function setScrollView(value) {
    _scrollView = value
}
export class ListBase extends CollectionWidget {
    _feedbackShowTimeout() {
        return 70
    }
    _supportedKeys() {
        return _extends({}, super._supportedKeys(), {
            leftArrow: noop,
            rightArrow: noop,
            pageUp(e) {
                this._moveFocusPerPage(e, "prev")
            },
            pageDown(e) {
                this._moveFocusPerPage(e, "next")
            }
        })
    }
    _moveFocusPerPage(e, direction) {
        if (this._isLastItemFocused(direction)) {
            return
        }
        e.preventDefault();
        e.stopPropagation();
        let $item = this._getEdgeVisibleItem(direction);
        const {
            focusedElement: focusedElement
        } = this.option();
        const isFocusedItem = $item.is($(focusedElement));
        if (isFocusedItem) {
            this.scrollTo(this._getItemLocation($item, direction));
            $item = this._getEdgeVisibleItem(direction)
        }
        this.option("focusedElement", getPublicElement($item));
        this.scrollToItem($item)
    }
    _isLastItemFocused(direction) {
        const lastItemInDirection = "prev" === direction ? this._itemElements().first() : this._itemElements().last();
        const {
            focusedElement: focusedElement
        } = this.option();
        return lastItemInDirection.is($(focusedElement))
    }
    _getNextItem($item, direction) {
        const $items = this._getAvailableItems();
        const itemIndex = $items.index($item);
        if ("prev" === direction) {
            return $($items[itemIndex - 1])
        }
        return $($items[itemIndex + 1])
    }
    _getEdgeVisibleItem(direction) {
        const scrollTop = this.scrollTop();
        const containerHeight = getHeight(this.$element());
        const {
            focusedElement: focusedElement
        } = this.option();
        let $item = $(focusedElement);
        let isItemVisible = true;
        if (!$item.length) {
            return $()
        }
        while (isItemVisible) {
            var _$nextItem$position;
            const $nextItem = this._getNextItem($item, direction);
            if (!$nextItem.length) {
                break
            }
            const nextItemLocation = ((null === (_$nextItem$position = $nextItem.position()) || void 0 === _$nextItem$position ? void 0 : _$nextItem$position.top) ?? 0) + getOuterHeight($nextItem) / 2;
            isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
            if (isItemVisible) {
                $item = $nextItem
            }
        }
        return $item
    }
    _getItemLocation($item, direction) {
        if ("prev" === direction) {
            return $item.position().top - getHeight(this.$element()) + getOuterHeight($item)
        }
        return $item.position().top
    }
    _getDefaultOptions() {
        return _extends({}, super._getDefaultOptions(), {
            hoverStateEnabled: true,
            pullRefreshEnabled: false,
            scrollingEnabled: true,
            selectByClick: true,
            showScrollbar: "onScroll",
            useNativeScrolling: true,
            bounceEnabled: true,
            scrollByContent: true,
            scrollByThumb: false,
            pullingDownText: messageLocalization.format("dxList-pullingDownText"),
            pulledDownText: messageLocalization.format("dxList-pulledDownText"),
            refreshingText: messageLocalization.format("dxList-refreshingText"),
            pageLoadingText: messageLocalization.format("dxList-pageLoadingText"),
            onScroll: null,
            onPullRefresh: null,
            onPageLoading: null,
            pageLoadMode: "scrollBottom",
            nextButtonText: messageLocalization.format("dxList-nextButtonText"),
            onItemSwipe: null,
            grouped: false,
            onGroupRendered: null,
            collapsibleGroups: false,
            groupTemplate: "group",
            indicateLoading: true,
            activeStateEnabled: true,
            _itemAttributes: {
                role: "option"
            },
            useInkRipple: false,
            wrapItemText: false,
            _swipeEnabled: true,
            showChevronExpr: data => null === data || void 0 === data ? void 0 : data.showChevron,
            badgeExpr: data => null === data || void 0 === data ? void 0 : data.badge,
            _onItemsRendered: () => {}
        })
    }
    _defaultOptionsRules() {
        const themeName = current();
        return super._defaultOptionsRules().concat(deviceDependentOptions(), [{
            device: () => !supportUtils.nativeScrolling,
            options: {
                useNativeScrolling: false
            }
        }, {
            device: device => !supportUtils.nativeScrolling && !devices.isSimulator() && "desktop" === devices.real().deviceType && "generic" === device.platform,
            options: {
                showScrollbar: "onHover",
                pageLoadMode: "nextButton"
            }
        }, {
            device: () => "desktop" === devices.real().deviceType && !devices.isSimulator(),
            options: {
                focusStateEnabled: true
            }
        }, {
            device: () => isMaterial(themeName),
            options: {
                useInkRipple: true
            }
        }, {
            device: () => isMaterialBased(themeName),
            options: {
                pullingDownText: "",
                pulledDownText: "",
                refreshingText: "",
                pageLoadingText: ""
            }
        }])
    }
    _visibilityChanged(visible) {
        if (visible) {
            this._updateLoadingState(true)
        }
    }
    _itemClass() {
        return "dx-list-item"
    }
    _itemDataKey() {
        return "dxListItemData"
    }
    _itemContainer() {
        return this._$container
    }
    _getItemsContainer() {
        return this._$listContainer
    }
    _cleanItemContainer() {
        super._cleanItemContainer();
        const listContainer = this._getItemsContainer();
        $(listContainer).empty();
        listContainer.appendTo(this._$container)
    }
    _saveSelectionChangeEvent(e) {
        this._selectionChangeEventInstance = e
    }
    _getSelectionChangeEvent() {
        return this._selectionChangeEventInstance
    }
    _refreshItemElements() {
        const {
            grouped: grouped
        } = this.option();
        const $itemsContainer = this._getItemsContainer();
        if (grouped) {
            this._itemElementsCache = $itemsContainer.children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector())
        } else {
            this._itemElementsCache = $itemsContainer.children(this._itemSelector())
        }
    }
    _getItemAndHeaderElements() {
        const itemSelector = `> .dx-list-group-body > ${this._itemSelector()}`;
        const itemAndHeaderSelector = `${itemSelector}, > .dx-list-group-header`;
        const $listGroup = this._getItemsContainer().children(".dx-list-group");
        return $listGroup.find(itemAndHeaderSelector)
    }
    _getAvailableItems($itemElements) {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        if (collapsibleGroups) {
            const $elements = this._getItemAndHeaderElements();
            return $elements.filter(((_index, element) => {
                if ($(element).hasClass("dx-list-group-header")) {
                    return true
                }
                return !$(element).closest(".dx-list-group").hasClass("dx-list-group-collapsed")
            }))
        }
        return super._getAvailableItems($itemElements)
    }
    _modifyByChanges(changes, isPartialRefresh) {
        super._modifyByChanges(changes, isPartialRefresh);
        this._refreshItemElements();
        this._updateLoadingState(true)
    }
    reorderItem(itemElement, toItemElement) {
        const promise = super.reorderItem(itemElement, toItemElement);
        return promise.done((() => {
            this._refreshItemElements()
        }))
    }
    deleteItem(itemElement) {
        const promise = super.deleteItem(itemElement);
        return promise.done((() => {
            this._refreshItemElements()
        }))
    }
    _itemElements() {
        return this._itemElementsCache
    }
    _itemSelectHandler(e) {
        const {
            selectionMode: selectionMode
        } = this.option();
        const isSingleSelectedItemClicked = "single" === selectionMode && this.isItemSelected(e.currentTarget);
        if (isSingleSelectedItemClicked) {
            return
        }
        const isSelectionControlClicked = $(e.target).closest(`.${LIST_SELECT_CHECKBOX}`).length || $(e.target).closest(`.${LIST_SELECT_RADIOBUTTON}`).length;
        if (isSelectionControlClicked) {
            this.option("focusedElement", getPublicElement($(e.currentTarget)))
        }
        return super._itemSelectHandler(e, isSelectionControlClicked)
    }
    _allowDynamicItemsAppend() {
        return true
    }
    _activeStateUnit() {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const selectors = [".dx-list-item", ".dx-list-select-all"];
        if (collapsibleGroups) {
            selectors.push(".dx-list-group-header")
        }
        return selectors.join(",")
    }
    _init() {
        super._init();
        this._dataController.resetDataSourcePageIndex();
        this._$container = this.$element();
        this._$listContainer = $("<div>").addClass("dx-list-items");
        this._initScrollView();
        this._createGroupRenderAction()
    }
    _scrollBottomMode() {
        const {
            pageLoadMode: pageLoadMode
        } = this.option();
        return "scrollBottom" === pageLoadMode
    }
    _nextButtonMode() {
        const {
            pageLoadMode: pageLoadMode
        } = this.option();
        return "nextButton" === pageLoadMode
    }
    _dataSourceOptions() {
        const scrollBottom = this._scrollBottomMode();
        const nextButton = this._nextButtonMode();
        return _extends({}, super._dataSourceOptions(), {
            paginate: ensureDefined(scrollBottom || nextButton, true)
        })
    }
    _getSpecificDataSourceOption() {
        const {
            grouped: grouped
        } = this.option();
        const dataSource = this.option("dataSource");
        if (dataSource && grouped) {
            return getDataSourceOptions(dataSource)
        }
        return dataSource
    }
    _getGroupContainerByIndex(groupIndex) {
        return this._getItemsContainer().find(".dx-list-group").eq(groupIndex).find(".dx-list-group-body")
    }
    _dataSourceFromUrlLoadMode() {
        return "raw"
    }
    _initScrollView() {
        const {
            height: height,
            width: width,
            disabled: disabled,
            showScrollbar: showScrollbar,
            useNativeScrolling: useNativeScrolling,
            bounceEnabled: bounceEnabled,
            scrollByContent: scrollByContent,
            scrollByThumb: scrollByThumb,
            pullingDownText: pullingDownText,
            pulledDownText: pulledDownText,
            refreshingText: refreshingText,
            pageLoadingText: pageLoadingText,
            scrollingEnabled: scrollingEnabled,
            pullRefreshEnabled: pullRefreshEnabled
        } = this.option();
        const isPullRefreshEnabled = scrollingEnabled && pullRefreshEnabled;
        const autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataController.getDataSource();
        this._scrollView = this._createComponent(this.$element(), getScrollView(), {
            height: height,
            width: width,
            disabled: disabled || !scrollingEnabled,
            onScroll: e => {
                this._scrollHandler(e)
            },
            onPullDown: isPullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
            onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
            showScrollbar: showScrollbar,
            useNative: useNativeScrolling,
            bounceEnabled: bounceEnabled,
            scrollByContent: scrollByContent,
            scrollByThumb: scrollByThumb,
            pullingDownText: pullingDownText,
            pulledDownText: pulledDownText,
            refreshingText: refreshingText,
            reachBottomText: pageLoadingText,
            useKeyboard: false
        });
        this._$container = $(this._scrollView.content());
        this._$listContainer.appendTo(this._$container);
        const {
            wrapItemText: wrapItemText
        } = this.option();
        this._toggleWrapItemText(wrapItemText);
        this._createScrollViewActions()
    }
    _toggleWrapItemText(value) {
        this._$listContainer.toggleClass("dx-wrap-item-text", value)
    }
    _createScrollViewActions() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._pullRefreshAction = this._createActionByOption("onPullRefresh");
        this._pageLoadingAction = this._createActionByOption("onPageLoading")
    }
    _scrollHandler(e) {
        var _this$_scrollAction;
        null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this, e)
    }
    _initTemplates() {
        this._templateManager.addDefaultTemplates({
            group: new BindableTemplate((($container, data) => {
                if (isPlainObject(data)) {
                    if (data.key) {
                        $container.text(data.key)
                    }
                } else {
                    $container.text(String(data))
                }
            }), ["key"], this.option("integrationOptions.watchMethod"))
        });
        super._initTemplates()
    }
    _prepareDefaultItemTemplate(data, $container) {
        super._prepareDefaultItemTemplate(data, $container);
        if (data.icon) {
            const $imageContainer = getImageContainer(data.icon);
            if (!$imageContainer) {
                return
            }
            const $icon = $imageContainer.addClass("dx-list-item-icon");
            const $iconContainer = $("<div>").addClass("dx-list-item-icon-container");
            $iconContainer.append($icon);
            $container.prepend($iconContainer)
        }
    }
    _getBindableFields() {
        return ["text", "html", "icon"]
    }
    _updateLoadingState(tryLoadMore) {
        const dataController = this._dataController;
        const scrollBottomMode = this._scrollBottomMode();
        const isDataControllerLoading = dataController.isLoading();
        const isLastPage = this._isLastPage();
        const shouldLoadNextPage = scrollBottomMode && Boolean(tryLoadMore) && !isDataControllerLoading && !isLastPage;
        if (this._shouldContinueLoading(shouldLoadNextPage)) {
            this._infiniteDataLoading()
        } else {
            this._scrollView.release(!shouldLoadNextPage && !dataController.isLoading());
            this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
            this._loadIndicationSuppressed(false)
        }
    }
    _shouldRenderNextButton() {
        return this._nextButtonMode() && this._dataController.isLoaded()
    }
    _isDataSourceFirstLoadCompleted(newValue) {
        if (isDefined(newValue)) {
            this._isFirstLoadCompleted = newValue
        }
        return this._isFirstLoadCompleted
    }
    _dataSourceLoadingChangedHandler(isLoading) {
        if (this._loadIndicationSuppressed()) {
            return
        }
        const {
            indicateLoading: indicateLoading
        } = this.option();
        if (isLoading && indicateLoading) {
            this._showLoadingIndicatorTimer = setTimeout((() => {
                const isEmpty = !this._itemElements().length;
                const shouldIndicateLoading = !isEmpty || this._isDataSourceFirstLoadCompleted();
                if (shouldIndicateLoading) {
                    var _this$_scrollView;
                    null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView || _this$_scrollView.startLoading()
                }
            }))
        } else {
            var _this$_scrollView2;
            clearTimeout(this._showLoadingIndicatorTimer);
            null === (_this$_scrollView2 = this._scrollView) || void 0 === _this$_scrollView2 || _this$_scrollView2.finishLoading()
        }
        if (!isLoading) {
            this._isDataSourceFirstLoadCompleted(false)
        }
    }
    _dataSourceChangedHandler(newItems, e) {
        if (!this._shouldAppendItems() && hasWindow()) {
            var _this$_scrollView3;
            null === (_this$_scrollView3 = this._scrollView) || void 0 === _this$_scrollView3 || _this$_scrollView3.scrollTo(0)
        }
        super._dataSourceChangedHandler(newItems, e);
        this._isDataSourceFirstLoadCompleted(true)
    }
    _refreshContent() {
        this._prepareContent();
        this._fireContentReadyAction()
    }
    _hideLoadingIfLoadIndicationOff() {
        const {
            indicateLoading: indicateLoading
        } = this.option();
        if (!indicateLoading) {
            this._dataSourceLoadingChangedHandler(false)
        }
    }
    _loadIndicationSuppressed(value) {
        if (arguments.length) {
            this._isLoadIndicationSuppressed = value
        }
        return this._isLoadIndicationSuppressed
    }
    _scrollViewIsFull() {
        const scrollView = this._scrollView;
        return !scrollView || getHeight(scrollView.content()) > getHeight(scrollView.container())
    }
    _pullDownHandler() {
        var _this$_pullRefreshAct;
        const pullRefreshArgs = {
            component: this,
            element: this.element()
        };
        null === (_this$_pullRefreshAct = this._pullRefreshAction) || void 0 === _this$_pullRefreshAct || _this$_pullRefreshAct.call(this, pullRefreshArgs);
        const dataController = this._dataController;
        if (dataController.getDataSource() && !dataController.isLoading()) {
            this._clearSelectedItems();
            dataController.pageIndex(0);
            dataController.reload()
        } else {
            this._updateLoadingState()
        }
    }
    _shouldContinueLoading(shouldLoadNextPage) {
        var _this$_scrollView$scr;
        if (!shouldLoadNextPage) {
            return false
        }
        const $content = this._scrollView.content();
        const $container = this._scrollView.container();
        const contentHeight = getHeight($content);
        const containerHeight = getHeight($container);
        const offsetTop = (null === (_this$_scrollView$scr = this._scrollView.scrollOffset()) || void 0 === _this$_scrollView$scr ? void 0 : _this$_scrollView$scr.top) ?? 0;
        const isBottomReached = contentHeight - containerHeight < offsetTop;
        const isFull = this._scrollViewIsFull();
        return shouldLoadNextPage && !isFull || isBottomReached
    }
    _infiniteDataLoading() {
        const isElementVisible = this.$element().is(":visible");
        if (isElementVisible) {
            clearTimeout(this._loadNextPageTimer);
            this._loadNextPageTimer = setTimeout((() => {
                this._loadNextPage()
            }))
        }
    }
    _scrollBottomHandler(e) {
        var _this$_pageLoadingAct;
        null === (_this$_pageLoadingAct = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct || _this$_pageLoadingAct.call(this, e);
        const dataController = this._dataController;
        if (!dataController.isLoading() && !this._isLastPage()) {
            this._loadNextPage()
        } else {
            this._updateLoadingState()
        }
    }
    _renderItems(items) {
        const {
            grouped: grouped
        } = this.option();
        if (grouped) {
            each(items, this._renderGroup.bind(this));
            this._attachGroupCollapseEvent();
            this._renderEmptyMessage();
            if (isMaterial(current())) {
                this.attachGroupHeaderInkRippleEvents()
            }
        } else {
            super._renderItems(items)
        }
        this._refreshItemElements();
        this._updateLoadingState(true)
    }
    _postProcessRenderItems() {
        const {
            _onItemsRendered: onItemsRendered
        } = this.option();
        null === onItemsRendered || void 0 === onItemsRendered || onItemsRendered()
    }
    _attachGroupCollapseEvent() {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const eventNameClick = addNamespace(clickEventName, this.NAME);
        const $element = this.$element();
        $element.toggleClass("dx-list-collapsible-groups", collapsibleGroups);
        eventsEngine.off($element, eventNameClick, ".dx-list-group-header");
        if (collapsibleGroups) {
            eventsEngine.on($element, eventNameClick, ".dx-list-group-header", (e => {
                this._processGroupCollapse(e)
            }))
        }
    }
    _processGroupCollapse(e) {
        const action = this._createAction((evt => {
            var _evt$event;
            const {
                focusStateEnabled: focusStateEnabled
            } = this.option();
            const $group = $(null === (_evt$event = evt.event) || void 0 === _evt$event ? void 0 : _evt$event.currentTarget).parent();
            this._collapseGroupHandler($group);
            if (focusStateEnabled) {
                const groupHeader = getPublicElement($group.find(".dx-list-group-header"));
                this.option({
                    focusedElement: groupHeader
                })
            }
        }), {
            validatingTargetName: "element"
        });
        action({
            event: e
        })
    }
    _enterKeyHandler(e) {
        const {
            collapsibleGroups: collapsibleGroups,
            focusedElement: focusedElement
        } = this.option();
        const isGroupHeader = $(focusedElement).hasClass("dx-list-group-header");
        if (collapsibleGroups && isGroupHeader) {
            const params = this._getHandlerExtendedParams(e, $(focusedElement));
            this._processGroupCollapse(params);
            return
        }
        super._enterKeyHandler(e)
    }
    _collapseGroupHandler($group, toggle) {
        const deferred = Deferred();
        const $groupHeader = $group.children(".dx-list-group-header");
        const collapsed = $group.hasClass("dx-list-group-collapsed");
        this._updateGroupHeaderAriaExpanded($groupHeader, collapsed);
        if (collapsed === toggle) {
            return deferred.resolve()
        }
        const $groupBody = $group.children(".dx-list-group-body");
        const startHeight = getOuterHeight($groupBody);
        let endHeight = 0;
        if (collapsed) {
            setHeight($groupBody, "auto");
            endHeight = getOuterHeight($groupBody)
        }
        $group.toggleClass("dx-list-group-collapsed", toggle);
        const groupBodyElement = $groupBody.get(0);
        if (fx.isAnimating(groupBodyElement)) {
            fx.stop(groupBodyElement, false)
        }
        fx.animate(groupBodyElement, {
            type: "custom",
            from: {
                height: startHeight
            },
            to: {
                height: endHeight
            },
            duration: 200,
            complete: () => {
                this.updateDimensions();
                this._updateLoadingState(true);
                deferred.resolve()
            }
        });
        return deferred.promise()
    }
    _dataSourceLoadErrorHandler() {
        this._forgetNextPageLoading();
        if (this._initialized) {
            this._renderEmptyMessage();
            this._updateLoadingState()
        }
    }
    _initMarkup() {
        this._itemElementsCache = $();
        this.$element().addClass("dx-list");
        super._initMarkup();
        const {
            useInkRipple: useInkRipple
        } = this.option();
        if (useInkRipple) {
            this._renderInkRipple()
        }
        const elementAria = {
            role: "group",
            roledescription: messageLocalization.format("dxList-ariaRoleDescription")
        };
        this.setAria(elementAria, this.$element());
        this.setAria({
            role: "application"
        }, this._focusTarget());
        this._setListAria()
    }
    _setListAria() {
        const {
            items: items,
            allowItemDeleting: allowItemDeleting,
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const label = allowItemDeleting ? messageLocalization.format("dxList-listAriaLabel-deletable") : messageLocalization.format("dxList-listAriaLabel");
        const shouldSetAria = (null === items || void 0 === items ? void 0 : items.length) && !collapsibleGroups;
        const listArea = {
            role: shouldSetAria ? "listbox" : void 0,
            label: shouldSetAria ? label : void 0
        };
        this.setAria(listArea, this._$listContainer)
    }
    _focusTarget() {
        return this._itemContainer()
    }
    _renderInkRipple() {
        this._inkRipple = render()
    }
    _toggleActiveState($element, value, event) {
        super._toggleActiveState($element, value);
        if (!this._inkRipple) {
            return
        }
        const config = {
            element: $element,
            event: event
        };
        if (value) {
            if (isMaterial(current())) {
                this._inkRippleTimer = setTimeout((() => {
                    var _this$_inkRipple;
                    null === (_this$_inkRipple = this._inkRipple) || void 0 === _this$_inkRipple || _this$_inkRipple.showWave(config)
                }), 35)
            } else {
                this._inkRipple.showWave(config)
            }
        } else {
            clearTimeout(this._inkRippleTimer);
            this._inkRipple.hideWave(config)
        }
    }
    _postprocessRenderItem(args) {
        this._refreshItemElements();
        super._postprocessRenderItem(args);
        const {
            _swipeEnabled: _swipeEnabled
        } = this.option();
        if (_swipeEnabled) {
            this._attachSwipeEvent($(args.itemElement))
        }
    }
    _getElementClassToSkipRefreshId() {
        return "dx-list-group-header"
    }
    _attachSwipeEvent($itemElement) {
        const endEventName = addNamespace(swipeEventEnd, this.NAME);
        eventsEngine.on($itemElement, endEventName, (e => {
            this._itemSwipeEndHandler(e)
        }))
    }
    _itemSwipeEndHandler(e) {
        this._itemDXEventHandler(e, "onItemSwipe", {
            direction: e.offset < 0 ? "left" : "right"
        })
    }
    _nextButtonHandler() {
        var _this$_pageLoadingAct2;
        const pageLoadingArgs = {
            component: this,
            element: this.element()
        };
        null === (_this$_pageLoadingAct2 = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct2 || _this$_pageLoadingAct2.call(this, pageLoadingArgs);
        const dataController = this._dataController;
        if (dataController.getDataSource() && !dataController.isLoading()) {
            var _this$_$nextButton;
            this._scrollView.toggleLoading(true);
            null === (_this$_$nextButton = this._$nextButton) || void 0 === _this$_$nextButton || _this$_$nextButton.detach();
            this._loadIndicationSuppressed(true);
            this._loadNextPage()
        }
    }
    _setGroupAria($group, groupHeaderId) {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const groupAria = {
            role: collapsibleGroups ? void 0 : "group",
            labelledby: collapsibleGroups ? void 0 : groupHeaderId
        };
        this.setAria(groupAria, $group)
    }
    _updateGroupHeaderAriaExpanded($groupHeader, expanded) {
        this.setAria({
            expanded: expanded
        }, $groupHeader)
    }
    _setGroupHeaderAria($groupHeader, listGroupBodyId) {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const groupHeaderAria = {
            role: collapsibleGroups ? "button" : void 0,
            expanded: collapsibleGroups ? true : void 0,
            controls: collapsibleGroups ? listGroupBodyId : void 0
        };
        this.setAria(groupHeaderAria, $groupHeader)
    }
    _setGroupBodyAria($groupBody, groupHeaderId) {
        const {
            collapsibleGroups: collapsibleGroups
        } = this.option();
        const groupHeaderAria = {
            role: collapsibleGroups ? "listbox" : void 0,
            labelledby: collapsibleGroups ? groupHeaderId : void 0
        };
        this.setAria(groupHeaderAria, $groupBody)
    }
    _renderGroup(index, group) {
        var _this$_groupRenderAct;
        const $groupElement = $("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer());
        const groupHeaderId = `dx-${(new Guid).toString()}`;
        const $groupHeaderElement = $("<div>").addClass("dx-list-group-header").attr("id", groupHeaderId).appendTo($groupElement);
        const {
            groupTemplate: templateName
        } = this.option();
        const groupTemplate = this._getTemplate(group.template ?? templateName, group, index, $groupHeaderElement);
        const renderArgs = {
            index: index,
            itemData: group,
            container: getPublicElement($groupHeaderElement)
        };
        this._createItemByTemplate(groupTemplate, renderArgs);
        $("<div>").addClass("dx-list-group-header-indicator").prependTo($groupHeaderElement);
        const groupBodyId = `dx-${(new Guid).toString()}`;
        const $groupBody = $("<div>").addClass("dx-list-group-body").attr("id", groupBodyId).appendTo($groupElement);
        const groupItemsGetter = compileGetter("items");
        each(groupItemsGetter(group) || [], ((itemIndex, item) => {
            this._renderItem({
                group: index,
                item: itemIndex
            }, item, $groupBody)
        }));
        null === (_this$_groupRenderAct = this._groupRenderAction) || void 0 === _this$_groupRenderAct || _this$_groupRenderAct.call(this, {
            groupElement: getPublicElement($groupElement),
            groupIndex: index,
            groupData: group
        });
        this._setGroupAria($groupElement, groupHeaderId);
        this._setGroupHeaderAria($groupHeaderElement, groupBodyId);
        this._setGroupBodyAria($groupBody, groupHeaderId)
    }
    downInkRippleHandler(e) {
        this._toggleActiveState($(e.currentTarget), true, e)
    }
    upInkRippleHandler(e) {
        this._toggleActiveState($(e.currentTarget), false, e)
    }
    attachGroupHeaderInkRippleEvents() {
        const selector = ".dx-list-group-header";
        const $element = this.$element();
        this._downInkRippleHandler = this._downInkRippleHandler ?? this.downInkRippleHandler.bind(this);
        this._upInkRippleHandler = this._upInkRippleHandler ?? this.upInkRippleHandler.bind(this);
        eventsEngine.off($element, pointerEvents.down, selector, this._downInkRippleHandler);
        eventsEngine.on($element, pointerEvents.down, selector, this._downInkRippleHandler);
        eventsEngine.off($element, [pointerEvents.up, pointerEvents.out].join(" "), selector, this._upInkRippleHandler);
        eventsEngine.on($element, [pointerEvents.up, pointerEvents.out].join(" "), selector, this._upInkRippleHandler)
    }
    _createGroupRenderAction() {
        this._groupRenderAction = this._createActionByOption("onGroupRendered")
    }
    _clean() {
        clearTimeout(this._inkRippleTimer);
        if (this._$nextButton) {
            this._$nextButton.remove();
            this._$nextButton = null
        }
        super._clean()
    }
    _dispose() {
        this._isDataSourceFirstLoadCompleted(false);
        clearTimeout(this._holdTimer);
        clearTimeout(this._loadNextPageTimer);
        clearTimeout(this._showLoadingIndicatorTimer);
        super._dispose()
    }
    _toggleDisabledState(value) {
        super._toggleDisabledState(value);
        const {
            scrollingEnabled: scrollingEnabled
        } = this.option();
        this._scrollView.option("disabled", value || !scrollingEnabled)
    }
    _toggleNextButton(value) {
        const dataController = this._dataController;
        const $nextButton = this._getNextButton();
        this.$element().toggleClass("dx-has-next", value);
        if (value && dataController.isLoaded()) {
            $nextButton.appendTo(this._itemContainer())
        }
        if (!value) {
            $nextButton.detach()
        }
    }
    _getNextButton() {
        if (!this._$nextButton) {
            this._$nextButton = this._createNextButton()
        }
        return this._$nextButton
    }
    _createNextButton() {
        const $result = $("<div>").addClass("dx-list-next-button");
        const $button = $("<div>").appendTo($result);
        const {
            nextButtonText: nextButtonText
        } = this.option();
        this._createComponent($button, Button, {
            text: nextButtonText,
            onClick: () => {
                this._nextButtonHandler()
            },
            type: isMaterialBased(current()) ? "default" : void 0,
            integrationOptions: {}
        });
        return $result
    }
    _moveFocus(location) {
        super._moveFocus(location);
        const {
            focusedElement: focusedElement
        } = this.option();
        if (focusedElement) {
            this.scrollToItem(focusedElement)
        }
    }
    _refresh() {
        if (!hasWindow()) {
            super._refresh()
        } else {
            const scrollTop = this._scrollView.scrollTop();
            super._refresh();
            if (scrollTop) {
                this._scrollView.scrollTo(scrollTop)
            }
        }
    }
    _optionChanged(args) {
        const {
            name: name,
            value: value
        } = args;
        switch (name) {
            case "pageLoadMode":
                this._toggleNextButton(!!value);
                this._initScrollView();
                break;
            case "dataSource":
                super._optionChanged(args);
                this._initScrollView();
                this._updateLoadingState(true);
                this._isDataSourceFirstLoadCompleted(false);
                break;
            case "items":
                super._optionChanged(args);
                this._isDataSourceFirstLoadCompleted(false);
                break;
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "pageLoadingText":
            case "showScrollbar":
            case "bounceEnabled":
            case "scrollByContent":
            case "scrollByThumb":
            case "useNativeScrolling":
            case "scrollingEnabled":
            case "pullRefreshEnabled":
                this._initScrollView();
                this._updateLoadingState(true);
                break;
            case "nextButtonText":
            case "onItemSwipe":
            case "useInkRipple":
            case "grouped":
            case "groupTemplate":
            case "collapsibleGroups":
            case "showChevronExpr":
            case "badgeExpr":
                this._invalidate();
                break;
            case "onScroll":
            case "onPullRefresh":
            case "onPageLoading":
                this._createScrollViewActions();
                break;
            case "wrapItemText":
                this._toggleWrapItemText(value);
                break;
            case "onGroupRendered":
                this._createGroupRenderAction();
                break;
            case "width":
            case "height":
                super._optionChanged(args);
                this._scrollView.option(name, value);
                this._scrollView.update();
                break;
            case "indicateLoading":
                this._hideLoadingIfLoadIndicationOff();
                break;
            case "visible":
                super._optionChanged(args);
                this._scrollView.update();
                break;
            case "rtlEnabled":
                this._initScrollView();
                super._optionChanged(args);
                break;
            case "_swipeEnabled":
            case "_onItemsRendered":
            case "selectByClick":
                break;
            default:
                super._optionChanged(args)
        }
    }
    _extendActionArgs($itemElement) {
        const {
            grouped: grouped
        } = this.option();
        if (!grouped) {
            return super._extendActionArgs($itemElement)
        }
        const $group = $itemElement.closest(".dx-list-group");
        const $item = $group.find(".dx-list-item");
        return _extends({}, super._extendActionArgs($itemElement), {
            itemIndex: {
                group: $group.index(),
                item: $item.index($itemElement)
            }
        })
    }
    expandGroup(groupIndex) {
        const deferred = Deferred();
        const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
        this._collapseGroupHandler($group, false).done((() => {
            deferred.resolveWith(this)
        }));
        return deferred.promise()
    }
    collapseGroup(groupIndex) {
        const deferred = Deferred();
        const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
        this._collapseGroupHandler($group, true).done((() => {
            deferred.resolveWith(this)
        }));
        return deferred
    }
    updateDimensions() {
        const deferred = Deferred();
        if (this._scrollView) {
            this._scrollView.update().done((() => {
                if (!this._scrollViewIsFull()) {
                    this._updateLoadingState(true)
                }
                deferred.resolveWith(this)
            }))
        } else {
            deferred.resolveWith(this)
        }
        return deferred.promise()
    }
    reload() {
        super.reload();
        this.scrollTo(0);
        this._pullDownHandler()
    }
    repaint() {
        this.scrollTo(0);
        super.repaint()
    }
    scrollTop() {
        return this._scrollView.scrollOffset().top ?? 0
    }
    clientHeight() {
        return this._scrollView.clientHeight()
    }
    scrollHeight() {
        return this._scrollView.scrollHeight()
    }
    scrollBy(distance) {
        this._scrollView.scrollBy(distance)
    }
    scrollTo(location) {
        this._scrollView.scrollTo(location)
    }
    scrollToItem(itemElement) {
        if (!isDefined(itemElement)) {
            return
        }
        const $item = this._editStrategy.getItemElement(itemElement);
        this._scrollView.scrollToElement($item, {
            bottom: getElementMargin(null === $item || void 0 === $item ? void 0 : $item.get(0), "bottom")
        })
    }
    _dimensionChanged() {
        this.updateDimensions()
    }
}
ListBase.ItemClass = ListItem;
