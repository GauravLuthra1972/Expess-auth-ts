/**
 * DevExtreme (esm/__internal/ui/map/provider.dynamic.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import Class from "../../../core/class";
import $ from "../../../core/renderer";
import {
    extend
} from "../../../core/utils/extend";
import Provider from "./provider";
const MAP_MARKER_CLASS = "dx-map-marker";
class DynamicProvider extends Provider {
    constructor(map, $container) {
        super(map, $container);
        this._geocodedLocations = {}
    }
    _geocodeLocation(location) {
        return new Promise((resolve => {
            const cache = this._geocodedLocations;
            const cachedLocation = cache[location];
            if (cachedLocation) {
                resolve(cachedLocation)
            } else {
                this._geocodeLocationImpl(location).then((geocodedLocation => {
                    cache[location] = geocodedLocation;
                    resolve(geocodedLocation)
                }))
            }
        }))
    }
    _renderImpl() {
        return this._load().then((() => this._init())).then((() => Promise.all([this.updateMapType(), this._areBoundsSet() ? this.updateBounds() : this.updateCenter()]))).then((() => {
            this._attachHandlers();
            return new Promise((resolve => {
                const timeout = setTimeout((() => {
                    clearTimeout(timeout);
                    resolve()
                }))
            }))
        }))
    }
    _load() {
        if (!this._mapsLoader) {
            this._mapsLoader = this._loadImpl()
        }
        this._markers = [];
        this._routes = [];
        return this._mapsLoader
    }
    _loadImpl() {
        return Promise.resolve()
    }
    _init() {
        return Promise.resolve()
    }
    _attachHandlers() {
        Class.abstract()
    }
    addMarkers(markers) {
        return Promise.all(markers.map((options => this._addMarker(options)))).then((markerObjects => {
            this._fitBounds();
            return [false, markerObjects.map((markerObject => markerObject.marker))]
        }))
    }
    _addMarker(options) {
        return this._renderMarker(options).then((markerObject => {
            this._markers.push(extend({
                options: options
            }, markerObject));
            this._fireMarkerAddedAction({
                options: options,
                originalMarker: markerObject.marker
            });
            return markerObject
        }))
    }
    _renderMarker(options) {
        return Promise.resolve({
            marker: {},
            location: {
                lat: 0,
                lng: 0
            }
        })
    }
    _createIconTemplate(iconSrc) {
        const $img = $("<img>");
        $img.attr("src", iconSrc);
        $img.attr("alt", "Marker icon");
        $img.addClass("dx-map-marker");
        return $img.get(0)
    }
    removeMarkers(markersOptionsToRemove) {
        markersOptionsToRemove.forEach((markerOptionToRemove => {
            this._removeMarker(markerOptionToRemove)
        }));
        return Promise.resolve()
    }
    _removeMarker(markersOptionToRemove) {
        this._markers.forEach(((markerObject, markerIndex) => {
            if (markerObject.options !== markersOptionToRemove) {
                return true
            }
            this._destroyMarker(markerObject);
            this._markers.splice(markerIndex, 1);
            this._fireMarkerRemovedAction({
                options: markerObject.options
            });
            return false
        }))
    }
    _destroyMarker(marker) {
        Class.abstract()
    }
    _clearMarkers() {
        while (this._markers.length > 0) {
            this._removeMarker(this._markers[0].options)
        }
    }
    addRoutes(routes) {
        return Promise.all(routes.map((options => this._addRoute(options)))).then((routeObjects => {
            this._fitBounds();
            return [false, routeObjects.map((routeObject => routeObject.instance))]
        }))
    }
    _addRoute(options) {
        return this._renderRoute(options).then((routeObject => {
            this._routes.push(extend({
                options: options
            }, routeObject));
            this._fireRouteAddedAction({
                options: options,
                originalRoute: routeObject.instance
            });
            return routeObject
        }))
    }
    _renderRoute(options) {
        return Promise.resolve({
            options: options,
            instance: {},
            northEast: [0, 0],
            southWest: [0, 0]
        })
    }
    removeRoutes() {
        let routes = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
        routes.forEach((routeObject => {
            this._removeRoute(routeObject)
        }));
        return Promise.resolve()
    }
    _removeRoute(options) {
        const routes = this._routes;
        routes.forEach(((routeObject, routeIndex) => {
            if (routeObject.options !== options) {
                return true
            }
            this._destroyRoute(routeObject);
            this._routes.splice(routeIndex, 1);
            this._fireRouteRemovedAction({
                options: options
            });
            return false
        }))
    }
    _destroyRoute(routeObject) {
        Class.abstract()
    }
    _geocodeLocationImpl(location) {
        return Promise.resolve([0, 0])
    }
    _clearRoutes() {
        while (this._routes.length > 0) {
            this._removeRoute(this._routes[0].options)
        }
    }
    adjustViewport() {
        return this._fitBounds()
    }
    isEventsCanceled(e) {
        return true
    }
    _fitBounds() {
        Class.abstract()
    }
    _updateBounds() {
        this._clearBounds();
        if (!this._option("autoAdjust")) {
            return
        }
        this._markers.forEach((markerObject => {
            this._extendBounds(markerObject.location)
        }));
        this._routes.forEach((routeObject => {
            if (routeObject.northEast) {
                this._extendBounds(routeObject.northEast)
            }
            if (routeObject.southWest) {
                this._extendBounds(routeObject.southWest)
            }
        }))
    }
    _clearBounds() {
        this._bounds = null
    }
    _extendBounds(location) {
        Class.abstract()
    }
}
export default DynamicProvider;
