/**
 * DevExtreme (esm/__internal/scheduler/recurrence/generate_dates.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import {
    dateUtilsTs
} from "../../core/utils/date";
import {
    RRule,
    RRuleSet
} from "rrule";
import timeZoneUtils from "../m_utils_time_zone";
import {
    getDateByAsciiString,
    parseRecurrenceRule
} from "./base";
import {
    validateRRuleObject
} from "./validate_rule";
const {
    addOffsets: addOffsets
} = dateUtilsTs;
const MS_IN_HOUR = 36e5;
const MS_IN_DAY = 864e5;
const RRULE_BROKEN_TIMEZONES = ["Etc/GMT-13", "MIT", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"];
const getRruleParams = options => {
    const {
        start: start,
        min: min,
        max: max,
        appointmentTimezoneOffset: appointmentTimezoneOffset
    } = options;
    const clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),
        clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),
        clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);
    const duration = options.end ? options.end.getTime() - options.start.getTime() : 0;
    const startIntervalDate = addOffsets(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);
    const minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;
    const minViewDate = new Date(minViewTime - duration);
    const maxViewDate = addOffsets(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);
    const startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);
    const switchToSummerTime = startDateDSTDifferenceMs < 0;
    return {
        startIntervalDate: startIntervalDate,
        minViewTime: minViewTime,
        minViewDate: minViewDate,
        maxViewDate: maxViewDate,
        startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,
        appointmentDuration: duration
    }
};
const getLocalMachineOffset = rruleDate => {
    const machineTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);
    const machineTimezoneName = timeZoneUtils.getMachineTimezoneName();
    const result = [machineTimezoneOffset];
    const isTimezoneOffsetInBrokenRange = machineTimezoneOffset / 36e5 <= -13;
    const isTimezoneNameInBrokenNames = !machineTimezoneName || RRULE_BROKEN_TIMEZONES.some((timezone => machineTimezoneName.includes(timezone)));
    if (isTimezoneOffsetInBrokenRange && isTimezoneNameInBrokenNames) {
        result.push(-864e5)
    }
    return result
};
const convertRruleResult = (rruleIntervalParams, options, rruleDate) => {
    const convertedBackDate = addOffsets(rruleDate, [...getLocalMachineOffset(rruleDate), -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);
    const convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);
    const switchToSummerTime = convertedDateDSTShift < 0;
    const resultDate = addOffsets(convertedBackDate, [convertedDateDSTShift]);
    const resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);
    if (resultDateDSTShift && switchToSummerTime) {
        return new Date(resultDate.getTime() + resultDateDSTShift)
    }
    return resultDate
};
const createRRule = (options, startDateUtc, until) => {
    const ruleOptions = RRule.parseString(String(options.rule));
    const {
        firstDayOfWeek: firstDayOfWeek
    } = options;
    ruleOptions.dtstart = startDateUtc;
    if (!ruleOptions.wkst && firstDayOfWeek) {
        const weekDayNumbers = [6, 0, 1, 2, 3, 4, 5];
        ruleOptions.wkst = weekDayNumbers[firstDayOfWeek]
    }
    if (until) {
        ruleOptions.until = addOffsets(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset])
    }
    const rRuleSet = new RRuleSet;
    const rRule = new RRule(ruleOptions);
    rRuleSet.rrule(rRule);
    if (options.exception) {
        const exceptionStrings = options.exception;
        const exceptionDates = exceptionStrings.split(",").map((rule => getDateByAsciiString(rule))).filter(Boolean);
        exceptionDates.forEach((date => {
            const rruleTimezoneOffsets = "function" === typeof options.getExceptionDateTimezoneOffsets ? options.getExceptionDateTimezoneOffsets(date) : [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset];
            const exceptionDateInPseudoUtc = addOffsets(date, rruleTimezoneOffsets);
            rRuleSet.exdate(exceptionDateInPseudoUtc)
        }))
    }
    return rRuleSet
};
export const generateDates = options => {
    if (!options.rule) {
        return []
    }
    const rule = parseRecurrenceRule(options.rule);
    const isValid = validateRRuleObject(rule, options.rule);
    if (!isValid) {
        return []
    }
    const rruleIntervalParams = getRruleParams(options);
    const {
        startIntervalDate: startIntervalDate,
        maxViewDate: maxViewDate,
        minViewDate: minViewDate,
        minViewTime: minViewTime,
        appointmentDuration: appointmentDuration
    } = rruleIntervalParams;
    const rRuleSet = createRRule(options, startIntervalDate, rule.until);
    return rRuleSet.between(minViewDate, maxViewDate, true).filter((date => date.getTime() + appointmentDuration >= minViewTime)).map((date => convertRruleResult(rruleIntervalParams, options, date)))
};
