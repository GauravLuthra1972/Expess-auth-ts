/**
 * DevExtreme (esm/__internal/scheduler/view_model/filtering/utils/get_appointment_filter/get_appointment_filter.offset.test.js)
 * Version: 25.1.6
 * Build date: Mon Oct 13 2025
 *
 * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
import _extends from "@babel/runtime/helpers/esm/extends";
import {
    describe,
    expect,
    it
} from "@jest/globals";
import {
    createTimeZoneCalculator
} from "../../../../r1/timezone_calculator";
import {
    getVisibleDateTimeIntervals
} from "../get_visible_date_time_intervals";
import {
    shiftIntervals
} from "../shift_intervals";
import {
    getAppointmentFilter
} from "./get_appointment_filter";
const minDay = 10;
const maxDay = 20;
const compareOptions = {
    startDayHour: 0,
    endDayHour: 24,
    min: new Date(2e3, 0, 10),
    max: new Date(2e3, 0, 20)
};
const getViewportOptions = options => _extends({}, compareOptions, {
    resources: [],
    viewOffset: 0,
    firstDayOfWeek: 1,
    allDayPanelMode: "all",
    supportAllDayRow: true
}, options, {
    visibleDateIntervals: shiftIntervals(getVisibleDateTimeIntervals(_extends({}, compareOptions, options), true), options.viewOffset ?? 0),
    visibleTimeIntervals: shiftIntervals(getVisibleDateTimeIntervals(_extends({}, compareOptions, options), false), options.viewOffset ?? 0)
});
const correctAppointment = {
    startDate: new Date(2e3, 0, 15, 10),
    endDate: new Date(2e3, 0, 15, 11),
    hasRecurrenceRule: false,
    allDay: false,
    visible: true,
    rawAppointment: {
        startDate: new Date(2e3, 0, 15, 10),
        endDate: new Date(2e3, 0, 15, 11)
    }
};
const mockTimeZoneCalculator = createTimeZoneCalculator(Intl.DateTimeFormat().resolvedOptions().timeZone);
const MS_IN_HOUR = 36e5;
describe("getAppointmentFilter", (() => {
    [{
        caseName: "all day appointment",
        isAllDay: true,
        durationDays: 0
    }, {
        caseName: "long appointment",
        isAllDay: false,
        durationDays: 2
    }, {
        caseName: "short appointment",
        isAllDay: false,
        durationDays: 0
    }].forEach((_ref => {
        let {
            caseName: caseName,
            isAllDay: isAllDay,
            durationDays: durationDays
        } = _ref;
        [12, -12].forEach((offsetInHours => {
            const viewOffset = 36e5 * offsetInHours;
            describe(`${caseName} ${offsetInHours} hours grid offset`, (() => {
                it("should filter appointment in the gap between intervals", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: 36e5 * offsetInHours,
                        endDayHour: 20,
                        startDayHour: 10
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 11, 21 - offsetInHours),
                        endDate: new Date(2e3, 0, 12 + durationDays, 9 - offsetInHours),
                        allDay: isAllDay
                    }))).toBe(isAllDay || durationDays > 0)
                }));
                it("should filter appointment near the interval start", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 10 - durationDays, offsetInHours),
                        endDate: new Date(2e3, 0, 10, 1 + offsetInHours),
                        allDay: isAllDay
                    }))).toBe(true)
                }));
                it("should filter appointment cross the interval start", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 10 - durationDays, -1 + offsetInHours, 30),
                        endDate: new Date(2e3, 0, 10, offsetInHours, 30),
                        allDay: isAllDay
                    }))).toBe(true)
                }));
                (durationDays > 0 ? it.skip : it)("should filter appointment out of interval start", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 10 - durationDays, -1 + offsetInHours),
                        endDate: new Date(2e3, 0, 10, offsetInHours),
                        allDay: isAllDay
                    }))).toBe(isAllDay)
                }));
                it("should filter appointment with day less then interval start", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 10 - durationDays - 1),
                        endDate: new Date(2e3, 0, 9),
                        allDay: isAllDay
                    }))).toBe(false)
                }));
                it("should filter appointment near the interval end", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 21, -1 + offsetInHours),
                        endDate: new Date(2e3, 0, 21 + durationDays, offsetInHours),
                        allDay: isAllDay
                    }))).toBe(true)
                }));
                it("should filter appointment out of interval end", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 21, offsetInHours),
                        endDate: new Date(2e3, 0, 21 + durationDays, 1 + offsetInHours),
                        allDay: isAllDay
                    }))).toBe(false)
                }));
                it("should filter appointment with day greater then interval end", (() => {
                    expect(getAppointmentFilter(getViewportOptions({
                        viewOffset: viewOffset
                    }), mockTimeZoneCalculator)(_extends({}, correctAppointment, {
                        startDate: new Date(2e3, 0, 22),
                        endDate: new Date(2e3, 0, 22 + durationDays),
                        allDay: isAllDay
                    }))).toBe(false)
                }))
            }))
        }))
    }))
}));
