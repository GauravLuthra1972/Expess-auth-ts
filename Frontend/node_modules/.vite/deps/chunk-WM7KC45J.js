import {
  Deferred,
  applyBatch,
  each,
  errors,
  handleError,
  indexByKey,
  insert,
  isFunction,
  m_abstract_store_default,
  m_array_query_default,
  rejectedPromise,
  remove,
  trivialPromise,
  update
} from "./chunk-3L5HXPQK.js";

// node_modules/devextreme/esm/common/data/query_adapters.js
var query_adapters_default = {};

// node_modules/devextreme/esm/__internal/data/m_remote_query.js
var remoteQueryImpl = function(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function(name, args) {
    return {
      name,
      args
    };
  };
  const exec = function(executorTask) {
    const d = new Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function(error) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      handleError(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction(_adapterFactory)) {
        _adapterFactory = query_adapters_default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const {
        optimize
      } = _adapter;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if ("enumerate" !== String(_currentTask.name)) {
            if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !(function() {
        const head = _taskQueue[0];
        const unmergedTasks = [];
        if (head && "multiSort" === head.name) {
          _taskQueue.shift();
          each(head.args[0], (function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          }));
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      })();
      _adapter.exec(url).done(((result, extra) => {
        if (!_taskQueue.length) {
          d.resolve(result, extra);
        } else {
          let clientChain = m_array_query_default(result, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, (function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          }));
          clientChain.done(d.resolve).fail(d.reject);
        }
      })).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], (function() {
    const name = String(this);
    query2[name] = function() {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)));
    };
  }));
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], (function() {
    const name = String(this);
    query2[name] = function() {
      return exec.call(this, createTask(name, arguments));
    };
  }));
  return query2;
};
var m_remote_query_default = remoteQueryImpl;

// node_modules/devextreme/esm/common/data/query_implementation.js
var queryImpl = {
  array: m_array_query_default,
  remote: m_remote_query_default
};

// node_modules/devextreme/esm/__internal/data/m_query.js
var query = function() {
  const impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var m_query_default = query;

// node_modules/devextreme/esm/__internal/data/m_array_store.js
var ArrayStore = m_abstract_store_default.inherit({
  ctor(options) {
    if (Array.isArray(options)) {
      options = {
        data: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    const initialArray = options.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery() {
    return m_query_default(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl(key) {
    const index = indexByKey(this, this._array, key);
    if (-1 === index) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise(this._array[index]);
  },
  _insertImpl(values) {
    return insert(this, this._array, values);
  },
  _pushImpl(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl(key) {
    return remove(this, this._array, key);
  },
  clear() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var m_array_store_default = ArrayStore;

export {
  query_adapters_default,
  m_query_default,
  m_array_store_default
};
//# sourceMappingURL=chunk-WM7KC45J.js.map
