{
  "version": 3,
  "sources": ["../../devextreme/esm/exporter/jspdf/common/normalizeOptions.js", "../../devextreme/esm/exporter/jspdf/common/pdf_utils.js", "../../devextreme/esm/exporter/jspdf/common/row_utils.js", "../../devextreme/esm/exporter/jspdf/common/height_updater.js", "../../devextreme/esm/exporter/jspdf/common/rows_generator.js", "../../devextreme/esm/exporter/jspdf/common/draw_utils.js", "../../devextreme/esm/exporter/jspdf/common/rows_spliting_utils/get_multipage_row_pages.js", "../../devextreme/esm/exporter/jspdf/common/rows_spliting_utils/create_on_split_multipage_row.js", "../../devextreme/esm/exporter/jspdf/common/rows_splitting.js", "../../devextreme/esm/exporter/jspdf/common/export.js", "../../devextreme/esm/exporter/jspdf/export_data_grid.js", "../../devextreme/esm/exporter/jspdf/autotable/export.js", "../../devextreme/esm/exporter/jspdf/autotable/export_data_grid.js", "../../devextreme/esm/exporter/jspdf/export_gantt.js"],
  "sourcesContent": ["/**\r\n * DevExtreme (esm/exporter/jspdf/common/normalizeOptions.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isNumeric\r\n} from \"../../../core/utils/type\";\r\n\r\nfunction normalizeBoundaryValue(value) {\r\n    if (isNumeric(value)) {\r\n        return {\r\n            top: value,\r\n            right: value,\r\n            bottom: value,\r\n            left: value\r\n        }\r\n    }\r\n    return {\r\n        top: (null === value || void 0 === value ? void 0 : value.top) ?? 0,\r\n        right: (null === value || void 0 === value ? void 0 : value.right) ?? 0,\r\n        bottom: (null === value || void 0 === value ? void 0 : value.bottom) ?? 0,\r\n        left: (null === value || void 0 === value ? void 0 : value.left) ?? 0\r\n    }\r\n}\r\n\r\nfunction normalizeRowsInfo(rowsInfo) {\r\n    rowsInfo.forEach((row => {\r\n        row.cells.forEach((_ref => {\r\n            let {\r\n                pdfCell: pdfCell\r\n            } = _ref;\r\n            pdfCell.padding = normalizeBoundaryValue(pdfCell.padding)\r\n        }))\r\n    }))\r\n}\r\nexport {\r\n    normalizeRowsInfo,\r\n    normalizeBoundaryValue\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/pdf_utils.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nconst DOTS_TEXT = \"...\";\r\n\r\nfunction toPdfUnit(doc, value) {\r\n    const coefficient = 1 / doc.internal.scaleFactor;\r\n    return value * coefficient\r\n}\r\n\r\nfunction getPageWidth(doc) {\r\n    return doc.internal.pageSize.getWidth()\r\n}\r\n\r\nfunction getPageHeight(doc) {\r\n    return doc.internal.pageSize.getHeight()\r\n}\r\n\r\nfunction getTextLines(doc, text, font, _ref) {\r\n    let {\r\n        wordWrapEnabled: wordWrapEnabled,\r\n        targetRectWidth: targetRectWidth\r\n    } = _ref;\r\n    if (wordWrapEnabled) {\r\n        const usedFont = doc.getFont(null === font || void 0 === font ? void 0 : font.name, null === font || void 0 === font ? void 0 : font.style);\r\n        return doc.splitTextToSize(text, targetRectWidth, {\r\n            fontSize: (null === font || void 0 === font ? void 0 : font.size) || doc.getFontSize(),\r\n            fontName: usedFont.fontName,\r\n            fontStyle: usedFont.fontStyle\r\n        })\r\n    }\r\n    let textWithoutLineBreak = text.split(\"\\n\").filter((ch => \"\" !== ch)).join(\" \");\r\n    if (getTextDimensions(doc, textWithoutLineBreak, font).w <= targetRectWidth) {\r\n        return [textWithoutLineBreak]\r\n    }\r\n    let textWidth = getTextDimensions(doc, textWithoutLineBreak + \"...\", font).w;\r\n    while (textWithoutLineBreak.length > 0 && textWidth > targetRectWidth) {\r\n        let symbolsCountToRemove = 0;\r\n        if (textWidth >= 2 * targetRectWidth) {\r\n            symbolsCountToRemove = textWithoutLineBreak.length / 2\r\n        }\r\n        if (symbolsCountToRemove < 1) {\r\n            symbolsCountToRemove = 1\r\n        }\r\n        textWithoutLineBreak = textWithoutLineBreak.substring(0, textWithoutLineBreak.length - symbolsCountToRemove);\r\n        textWidth = getTextDimensions(doc, textWithoutLineBreak + \"...\", font).w\r\n    }\r\n    return [textWithoutLineBreak + \"...\"]\r\n}\r\n\r\nfunction calculateTargetRectWidth(columnWidth, padding) {\r\n    const width = columnWidth - (padding.left + padding.right);\r\n    return width >= 0 ? width : 0\r\n}\r\n\r\nfunction getTextDimensions(doc, text, font) {\r\n    return doc.getTextDimensions(text, {\r\n        font: doc.getFont(null === font || void 0 === font ? void 0 : font.name, null === font || void 0 === font ? void 0 : font.style),\r\n        fontSize: (null === font || void 0 === font ? void 0 : font.size) || doc.getFontSize()\r\n    })\r\n}\r\n\r\nfunction calculateTextHeight(doc, text, font, _ref2) {\r\n    let {\r\n        wordWrapEnabled: wordWrapEnabled,\r\n        targetRectWidth: targetRectWidth\r\n    } = _ref2;\r\n    const heightOfOneLine = getTextDimensions(doc, text, font).h;\r\n    const linesCount = getTextLines(doc, text, font, {\r\n        wordWrapEnabled: wordWrapEnabled,\r\n        targetRectWidth: targetRectWidth\r\n    }).length;\r\n    return heightOfOneLine * linesCount * doc.getLineHeightFactor()\r\n}\r\n\r\nfunction calculateRowHeight(doc, cells, columnWidths) {\r\n    if (cells.length !== columnWidths.length) {\r\n        throw \"the cells count must be equal to the count of the columns\"\r\n    }\r\n    let rowHeight = 0;\r\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\r\n        if (isDefined(cells[cellIndex].rowSpan)) {\r\n            continue\r\n        }\r\n        const cellText = cells[cellIndex].pdfCell.text;\r\n        const cellPadding = cells[cellIndex].pdfCell.padding;\r\n        const font = cells[cellIndex].pdfCell.font;\r\n        const wordWrapEnabled = cells[cellIndex].pdfCell.wordWrapEnabled;\r\n        const columnWidth = columnWidths[cellIndex];\r\n        const targetRectWidth = calculateTargetRectWidth(columnWidth, cellPadding);\r\n        if (isDefined(cellText)) {\r\n            const textHeight = \"\" !== cellText ? calculateTextHeight(doc, cellText, font, {\r\n                wordWrapEnabled: wordWrapEnabled,\r\n                targetRectWidth: targetRectWidth\r\n            }) : 0;\r\n            const cellHeight = textHeight + cellPadding.top + cellPadding.bottom;\r\n            if (rowHeight < cellHeight) {\r\n                rowHeight = cellHeight\r\n            }\r\n        }\r\n    }\r\n    return rowHeight\r\n}\r\n\r\nfunction applyWordWrap(doc, rowsInfo) {\r\n    rowsInfo.forEach((row => {\r\n        row.cells.forEach((_ref3 => {\r\n            let {\r\n                pdfCell: pdfCell\r\n            } = _ref3;\r\n            if (isDefined(pdfCell.text)) {\r\n                const lines = getTextLines(doc, pdfCell.text, pdfCell.font, {\r\n                    wordWrapEnabled: pdfCell.wordWrapEnabled,\r\n                    targetRectWidth: calculateTargetRectWidth(pdfCell._rect.w, pdfCell.padding)\r\n                });\r\n                pdfCell.text = lines.join(\"\\n\")\r\n            }\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction applyRtl(doc, rectsByPages, options) {\r\n    rectsByPages.forEach((pageRects => {\r\n        pageRects.forEach((pdfCell => {\r\n            const mirroredX = getPageWidth(doc) - (pdfCell._rect.x + pdfCell._rect.w);\r\n            const marginDiff = options.margin.left - options.margin.right;\r\n            pdfCell._rect.x = mirroredX + marginDiff\r\n        }))\r\n    }))\r\n}\r\nexport {\r\n    calculateRowHeight,\r\n    calculateTextHeight,\r\n    calculateTargetRectWidth,\r\n    getTextDimensions,\r\n    getTextLines,\r\n    getPageWidth,\r\n    getPageHeight,\r\n    applyWordWrap,\r\n    toPdfUnit,\r\n    applyRtl\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/row_utils.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined,\r\n    isNumeric\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    calculateRowHeight,\r\n    getPageWidth,\r\n    toPdfUnit\r\n} from \"./pdf_utils\";\r\nconst getSum = (a, b) => a + b;\r\n\r\nfunction calculateColumnWidths(doc, dataProvider, topLeftX, margin, customerColumnWidths) {\r\n    const resultWidths = dataProvider.getColumnsWidths().map((width => toPdfUnit(doc, width ?? 150)));\r\n    const totalAutoColumnsWidth = resultWidths.filter(((width, index) => !isDefined(customerColumnWidths[index]))).reduce(getSum, 0);\r\n    const totalCustomerColumnsWidth = customerColumnWidths.filter((width => isNumeric(width))).reduce(getSum, 0);\r\n    const availablePageWidth = getAvailablePageAreaWidth(doc, topLeftX, margin);\r\n    const ratio = totalCustomerColumnsWidth < availablePageWidth ? (availablePageWidth - totalCustomerColumnsWidth) / totalAutoColumnsWidth : 1;\r\n    return resultWidths.map(((width, index) => customerColumnWidths[index] ?? width * ratio))\r\n}\r\n\r\nfunction getAvailablePageAreaWidth(doc, topLeftX, margin) {\r\n    return getPageWidth(doc) - topLeftX - margin.left - margin.right\r\n}\r\n\r\nfunction initializeCellsWidth(doc, dataProvider, rows, options) {\r\n    const columnWidths = calculateColumnWidths(doc, dataProvider, options.topLeft.x, options.margin, options.columnWidths);\r\n    rows.forEach((row => {\r\n        row.cells.forEach(((_ref, index) => {\r\n            let {\r\n                gridCell: gridCell,\r\n                pdfCell: pdfCell\r\n            } = _ref;\r\n            pdfCell._rect.w = columnWidths[index]\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction calculateHeights(doc, rows, options) {\r\n    rows.forEach((row => {\r\n        const pdfCells = row.cells.map((c => c.pdfCell));\r\n        let customerHeight;\r\n        if (options.onRowExporting) {\r\n            const args = {\r\n                rowCells: pdfCells\r\n            };\r\n            options.onRowExporting(args);\r\n            if (isDefined(args.rowHeight)) {\r\n                customerHeight = args.rowHeight\r\n            }\r\n        }\r\n        row.height = isDefined(customerHeight) ? customerHeight : calculateRowHeight(doc, row.cells, pdfCells.map((c => c._rect.w)));\r\n        pdfCells.forEach((cell => {\r\n            cell._rect.h = row.height\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction applyColSpans(rows) {\r\n    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n        const row = rows[rowIndex];\r\n        for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\r\n            const cell = row.cells[cellIndex];\r\n            if (isDefined(cell.colSpan) && !isDefined(cell.pdfCell.isMerged)) {\r\n                for (let spanIndex = 1; spanIndex <= cell.colSpan; spanIndex++) {\r\n                    const mergedCell = rows[rowIndex].cells[cellIndex + spanIndex];\r\n                    cell.pdfCell._rect.w += mergedCell.pdfCell._rect.w;\r\n                    mergedCell.pdfCell._rect.w = 0;\r\n                    mergedCell.pdfCell.isMerged = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction applyRowSpans(rows) {\r\n    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n        const row = rows[rowIndex];\r\n        for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\r\n            const cell = row.cells[cellIndex];\r\n            if (isDefined(cell.rowSpan) && !isDefined(cell.pdfCell.isMerged)) {\r\n                for (let spanIndex = 1; spanIndex <= cell.rowSpan; spanIndex++) {\r\n                    const mergedCell = rows[rowIndex + spanIndex].cells[cellIndex];\r\n                    cell.pdfCell._rect.h += mergedCell.pdfCell._rect.h;\r\n                    mergedCell.pdfCell._rect.h = 0;\r\n                    mergedCell.pdfCell.isMerged = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction resizeFirstColumnByIndentLevel(rows, options) {\r\n    rows.forEach((row => {\r\n        row.cells[0].pdfCell._rect.w -= row.indentLevel * options.indent\r\n    }))\r\n}\r\n\r\nfunction applyBordersConfig(rows) {\r\n    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\r\n        const cells = rows[rowIndex].cells;\r\n        for (let columnIndex = 0; columnIndex < cells.length; columnIndex++) {\r\n            const pdfCell = cells[columnIndex].pdfCell;\r\n            const leftPdfCell = columnIndex >= 1 ? cells[columnIndex - 1].pdfCell : null;\r\n            const topPdfCell = rowIndex >= 1 ? rows[rowIndex - 1].cells[columnIndex].pdfCell : null;\r\n            if (false === pdfCell.drawLeftBorder && !isDefined(cells[columnIndex].colSpan)) {\r\n                if (isDefined(leftPdfCell)) {\r\n                    leftPdfCell.drawRightBorder = false\r\n                }\r\n            } else if (!isDefined(pdfCell.drawLeftBorder)) {\r\n                if (isDefined(leftPdfCell) && false === leftPdfCell.drawRightBorder) {\r\n                    pdfCell.drawLeftBorder = false\r\n                }\r\n            }\r\n            if (false === pdfCell.drawTopBorder) {\r\n                if (isDefined(topPdfCell)) {\r\n                    topPdfCell.drawBottomBorder = false\r\n                }\r\n            } else if (!isDefined(pdfCell.drawTopBorder)) {\r\n                if (isDefined(topPdfCell) && false === topPdfCell.drawBottomBorder) {\r\n                    pdfCell.drawTopBorder = false\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction calculateCoordinates(doc, rows, options) {\r\n    const topLeft = null === options || void 0 === options ? void 0 : options.topLeft;\r\n    const margin = null === options || void 0 === options ? void 0 : options.margin;\r\n    let y = ((null === topLeft || void 0 === topLeft ? void 0 : topLeft.y) ?? 0) + margin.top;\r\n    rows.forEach((row => {\r\n        let x = ((null === topLeft || void 0 === topLeft ? void 0 : topLeft.x) ?? 0) + margin.left;\r\n        const intend = row.indentLevel * options.indent;\r\n        row.cells.forEach((cell => {\r\n            cell.pdfCell._rect.x = x + intend;\r\n            cell.pdfCell._rect.y = y;\r\n            x += cell.pdfCell._rect.w\r\n        }));\r\n        y += row.height\r\n    }))\r\n}\r\n\r\nfunction calculateTableSize(doc, cells, options) {\r\n    var _options$topLeft, _options$topLeft2;\r\n    let leftPos;\r\n    let topPos;\r\n    let rightPos;\r\n    let bottomPos;\r\n    cells.forEach((cell => {\r\n        if (!isDefined(leftPos) || leftPos > cell._rect.x) {\r\n            leftPos = cell._rect.x\r\n        }\r\n        if (!isDefined(topPos) || topPos > cell._rect.y) {\r\n            topPos = cell._rect.y\r\n        }\r\n        if (!isDefined(rightPos) || rightPos < cell._rect.x + cell._rect.w) {\r\n            rightPos = cell._rect.x + cell._rect.w\r\n        }\r\n        if (!isDefined(bottomPos) || bottomPos < cell._rect.y + cell._rect.h) {\r\n            bottomPos = cell._rect.y + cell._rect.h\r\n        }\r\n    }));\r\n    const x = leftPos ?? (null === options || void 0 === options || null === (_options$topLeft = options.topLeft) || void 0 === _options$topLeft ? void 0 : _options$topLeft.x) ?? 0;\r\n    const y = topPos ?? (null === options || void 0 === options || null === (_options$topLeft2 = options.topLeft) || void 0 === _options$topLeft2 ? void 0 : _options$topLeft2.y) ?? 0;\r\n    const w = isDefined(rightPos) ? rightPos - x : 0;\r\n    const h = isDefined(bottomPos) ? bottomPos - y : 0;\r\n    return {\r\n        x: x,\r\n        y: y,\r\n        w: w,\r\n        h: h\r\n    }\r\n}\r\nexport {\r\n    initializeCellsWidth,\r\n    applyColSpans,\r\n    applyRowSpans,\r\n    resizeFirstColumnByIndentLevel,\r\n    applyBordersConfig,\r\n    calculateHeights,\r\n    calculateCoordinates,\r\n    calculateTableSize\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/height_updater.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    calculateTextHeight,\r\n    calculateTargetRectWidth\r\n} from \"./pdf_utils\";\r\n\r\nfunction updateRowsAndCellsHeights(doc, rows) {\r\n    const rowsAdditionalHeights = calculateAdditionalRowsHeights(doc, rows);\r\n    rows.forEach((row => {\r\n        row.height += rowsAdditionalHeights[row.rowIndex]\r\n    }));\r\n    rows.forEach((row => {\r\n        row.cells.forEach((cell => {\r\n            const rowsCount = (cell.rowSpan ?? 0) + 1;\r\n            cell.pdfCell._rect.h = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce(((accumulator, rowInfo) => accumulator + rowInfo.height), 0)\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction calculateAdditionalRowsHeights(doc, rows) {\r\n    const rowsAdditionalHeights = Array.from({\r\n        length: rows.length\r\n    }, (() => 0));\r\n    const sortedRows = sortRowsByMaxRowSpanAsc(rows);\r\n    sortedRows.forEach((row => {\r\n        const cellsWithRowSpan = row.cells.filter((cell => isDefined(cell.rowSpan)));\r\n        cellsWithRowSpan.forEach((cell => {\r\n            const targetRectWidth = calculateTargetRectWidth(cell.pdfCell._rect.w, cell.pdfCell.padding);\r\n            const textHeight = calculateTextHeight(doc, cell.pdfCell.text, cell.pdfCell.font, {\r\n                wordWrapEnabled: cell.pdfCell.wordWrapEnabled,\r\n                targetRectWidth: targetRectWidth\r\n            });\r\n            const cellHeight = textHeight + cell.pdfCell.padding.top + cell.pdfCell.padding.bottom;\r\n            const rowsCount = cell.rowSpan + 1;\r\n            const currentRowSpanRowsHeight = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce(((accumulator, rowInfo) => accumulator + rowInfo.height + rowsAdditionalHeights[rowInfo.rowIndex]), 0);\r\n            if (cellHeight > currentRowSpanRowsHeight) {\r\n                const delta = (cellHeight - currentRowSpanRowsHeight) / rowsCount;\r\n                for (let spanIndex = row.rowIndex; spanIndex < row.rowIndex + rowsCount; spanIndex++) {\r\n                    rowsAdditionalHeights[spanIndex] += delta\r\n                }\r\n            }\r\n        }))\r\n    }));\r\n    return rowsAdditionalHeights\r\n}\r\n\r\nfunction sortRowsByMaxRowSpanAsc(rows) {\r\n    const getMaxRowSpan = row => {\r\n        const spansArray = row.cells.map((cell => cell.rowSpan ?? 0));\r\n        return Math.max(...spansArray)\r\n    };\r\n    return [...rows].sort(((row1, row2) => {\r\n        const row1RowSpan = getMaxRowSpan(row1);\r\n        const row2RowSpan = getMaxRowSpan(row2);\r\n        if (row1RowSpan > row2RowSpan) {\r\n            return 1\r\n        }\r\n        if (row2RowSpan > row1RowSpan) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }))\r\n}\r\nexport {\r\n    updateRowsAndCellsHeights\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_generator.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDate,\r\n    isDefined,\r\n    isNumeric\r\n} from \"../../../core/utils/type\";\r\nimport dateLocalization from \"../../../common/core/localization/date\";\r\nimport numberLocalization from \"../../../common/core/localization/number\";\r\nimport {\r\n    toPdfUnit\r\n} from \"./pdf_utils\";\r\nconst defaultStyles = {\r\n    base: {\r\n        font: {\r\n            size: 10\r\n        },\r\n        borderWidth: .5,\r\n        borderColor: \"#979797\"\r\n    },\r\n    header: {\r\n        textColor: \"#979797\"\r\n    },\r\n    group: {},\r\n    data: {},\r\n    groupFooter: {},\r\n    totalFooter: {}\r\n};\r\n\r\nfunction generateRowsInfo(doc, dataProvider, dataGrid, headerBackgroundColor) {\r\n    const result = [];\r\n    const rowsCount = dataProvider.getRowsCount();\r\n    const wordWrapEnabled = !!dataGrid.option(\"wordWrapEnabled\");\r\n    const rtlEnabled = !!dataGrid.option(\"rtlEnabled\");\r\n    const columns = dataProvider.getColumns();\r\n    const styles = dataProvider.getStyles();\r\n    for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {\r\n        const rowType = dataProvider.getCellData(rowIndex, 0, true).cellSourceData.rowType;\r\n        let indentLevel = \"header\" !== rowType ? dataProvider.getGroupLevel(rowIndex) : 0;\r\n        const previousRow = result[rowIndex - 1];\r\n        if (\"groupFooter\" === rowType && \"groupFooter\" === (null === previousRow || void 0 === previousRow ? void 0 : previousRow.rowType)) {\r\n            indentLevel = previousRow.indentLevel - 1\r\n        }\r\n        result.push({\r\n            rowType: rowType,\r\n            indentLevel: indentLevel,\r\n            cells: generateRowCells({\r\n                doc: doc,\r\n                dataProvider: dataProvider,\r\n                rowIndex: rowIndex,\r\n                wordWrapEnabled: wordWrapEnabled,\r\n                columns: columns,\r\n                styles: styles,\r\n                rowType: rowType,\r\n                backgroundColor: \"header\" === rowType ? headerBackgroundColor : void 0,\r\n                rtlEnabled: rtlEnabled\r\n            }),\r\n            rowIndex: rowIndex\r\n        })\r\n    }\r\n    return result\r\n}\r\n\r\nfunction generateRowCells(_ref) {\r\n    let {\r\n        doc: doc,\r\n        dataProvider: dataProvider,\r\n        rowIndex: rowIndex,\r\n        wordWrapEnabled: wordWrapEnabled,\r\n        columns: columns,\r\n        styles: styles,\r\n        rowType: rowType,\r\n        backgroundColor: backgroundColor,\r\n        rtlEnabled: rtlEnabled\r\n    } = _ref;\r\n    const result = [];\r\n    for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {\r\n        const cellData = dataProvider.getCellData(rowIndex, cellIndex, true);\r\n        const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];\r\n        const style = getPdfCellStyle(columns[cellIndex], rowType, cellStyle);\r\n        const defaultAlignment = rtlEnabled ? \"right\" : \"left\";\r\n        const paddingValue = toPdfUnit(doc, 5);\r\n        const pdfCell = {\r\n            text: getFormattedValue(cellData.value, cellStyle.format),\r\n            verticalAlign: \"middle\",\r\n            horizontalAlign: style.alignment ?? defaultAlignment,\r\n            wordWrapEnabled: wordWrapEnabled,\r\n            backgroundColor: backgroundColor,\r\n            padding: {\r\n                top: paddingValue,\r\n                right: paddingValue,\r\n                bottom: paddingValue,\r\n                left: paddingValue\r\n            },\r\n            _rect: {},\r\n            _internalTextOptions: {}\r\n        };\r\n        if (rtlEnabled) {\r\n            pdfCell._internalTextOptions.isInputVisual = false;\r\n            pdfCell._internalTextOptions.isOutputVisual = true;\r\n            pdfCell._internalTextOptions.isInputRtl = true;\r\n            pdfCell._internalTextOptions.isOutputRtl = false\r\n        }\r\n        const cellInfo = {\r\n            gridCell: cellData.cellSourceData,\r\n            pdfCell: Object.assign({}, pdfCell, style)\r\n        };\r\n        if (\"header\" === rowType) {\r\n            const cellMerging = dataProvider.getCellMerging(rowIndex, cellIndex);\r\n            if (cellMerging && cellMerging.rowspan > 0) {\r\n                cellInfo.rowSpan = cellMerging.rowspan\r\n            }\r\n            if (cellMerging && cellMerging.colspan > 0) {\r\n                cellInfo.colSpan = cellMerging.colspan\r\n            }\r\n        } else if (\"group\" === rowType) {\r\n            const drawLeftBorderField = rtlEnabled ? \"drawRightBorder\" : \"drawLeftBorder\";\r\n            const drawRightBorderField = rtlEnabled ? \"drawLeftBorder\" : \"drawRightBorder\";\r\n            cellInfo.pdfCell[drawLeftBorderField] = 0 === cellIndex;\r\n            cellInfo.pdfCell[drawRightBorderField] = cellIndex === columns.length - 1;\r\n            if (cellIndex > 0) {\r\n                const isEmptyCellsExceptFirst = result.slice(1).reduce(((accumulate, cellInfo) => accumulate && !isDefined(cellInfo.pdfCell.text)), true);\r\n                if (!isDefined(cellInfo.pdfCell.text) && isEmptyCellsExceptFirst) {\r\n                    result[0].pdfCell[drawRightBorderField] = true;\r\n                    for (let i = 0; i < result.length; i++) {\r\n                        result[i].colSpan = result.length\r\n                    }\r\n                    cellInfo.colSpan = result.length\r\n                }\r\n            }\r\n        }\r\n        result.push(cellInfo)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getBaseTableStyle() {\r\n    return defaultStyles.base\r\n}\r\n\r\nfunction getPdfCellStyle(column, rowType, cellStyle) {\r\n    const styles = Object.assign({}, defaultStyles.base, defaultStyles[rowType]);\r\n    const alignment = \"header\" === rowType ? column.alignment : cellStyle.alignment;\r\n    if (alignment) {\r\n        styles.alignment = alignment\r\n    }\r\n    if (cellStyle.bold && \"header\" !== rowType) {\r\n        styles.font = Object.assign({}, styles.font, {\r\n            style: \"bold\"\r\n        })\r\n    }\r\n    return styles\r\n}\r\n\r\nfunction getFormattedValue(value, format) {\r\n    if (isDefined(format)) {\r\n        if (isDate(value)) {\r\n            return dateLocalization.format(value, format)\r\n        }\r\n        if (isNumeric(value)) {\r\n            return numberLocalization.format(value, format)\r\n        }\r\n    }\r\n    return null === value || void 0 === value ? void 0 : value.toString()\r\n}\r\nexport {\r\n    generateRowsInfo,\r\n    getBaseTableStyle\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/draw_utils.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\r\nconst _excluded = [\"_rect\", \"gridCell\"];\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    calculateTextHeight,\r\n    toPdfUnit\r\n} from \"./pdf_utils\";\r\n\r\nfunction capitalizeFirstLetter(string) {\r\n    return string.charAt(0).toUpperCase() + string.slice(1)\r\n}\r\n\r\nfunction roundToThreeDecimals(value) {\r\n    return Math.round(1e3 * value) / 1e3\r\n}\r\n\r\nfunction drawCellsContent(doc, customDrawCell, cellsArray, docStyles) {\r\n    cellsArray.forEach((cell => {\r\n        const {\r\n            _rect: _rect,\r\n            gridCell: gridCell\r\n        } = cell, pdfCell = _objectWithoutPropertiesLoose(cell, _excluded);\r\n        const {\r\n            x: x,\r\n            y: y,\r\n            w: w,\r\n            h: h\r\n        } = _rect;\r\n        const rect = {\r\n            x: x,\r\n            y: y,\r\n            w: w,\r\n            h: h\r\n        };\r\n        const eventArg = {\r\n            doc: doc,\r\n            rect: rect,\r\n            pdfCell: pdfCell,\r\n            gridCell: gridCell,\r\n            cancel: false\r\n        };\r\n        null === customDrawCell || void 0 === customDrawCell || customDrawCell(eventArg);\r\n        if (!eventArg.cancel) {\r\n            drawCellBackground(doc, cell);\r\n            drawCellText(doc, cell, docStyles)\r\n        }\r\n    }))\r\n}\r\n\r\nfunction drawLine(doc, startX, startY, endX, endY) {\r\n    doc.line(roundToThreeDecimals(startX), roundToThreeDecimals(startY), roundToThreeDecimals(endX), roundToThreeDecimals(endY))\r\n}\r\n\r\nfunction drawRect(doc, x, y, width, height, style) {\r\n    if (isDefined(style)) {\r\n        doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height), style)\r\n    } else {\r\n        doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height))\r\n    }\r\n}\r\n\r\nfunction getLineHeightShift(doc) {\r\n    return (doc.getLineHeightFactor() - 1.15) * doc.getFontSize()\r\n}\r\n\r\nfunction drawTextInRect(doc, text, rect, verticalAlign, horizontalAlign, jsPDFTextOptions) {\r\n    const textArray = text.split(\"\\n\");\r\n    const linesCount = textArray.length;\r\n    const heightOfOneLine = calculateTextHeight(doc, textArray[0], doc.getFont(), {\r\n        wordWrapEnabled: false,\r\n        targetRectWidth: 1e9\r\n    });\r\n    const vAlign = verticalAlign ?? \"middle\";\r\n    const hAlign = horizontalAlign ?? \"left\";\r\n    const verticalAlignCoefficientsMap = {\r\n        top: 0,\r\n        middle: .5,\r\n        bottom: 1\r\n    };\r\n    const y = rect.y + rect.h * verticalAlignCoefficientsMap[vAlign] - heightOfOneLine * (linesCount - 1) * verticalAlignCoefficientsMap[vAlign] + getLineHeightShift(doc);\r\n    const x = rect.x + rect.w * {\r\n        left: 0,\r\n        center: .5,\r\n        right: 1\r\n    } [hAlign];\r\n    const textOptions = extend({\r\n        baseline: vAlign,\r\n        align: hAlign\r\n    }, jsPDFTextOptions);\r\n    doc.text(textArray.join(\"\\n\"), roundToThreeDecimals(x), roundToThreeDecimals(y), textOptions)\r\n}\r\n\r\nfunction drawCellBackground(doc, cell) {\r\n    if (isDefined(cell.backgroundColor)) {\r\n        trySetColor(doc, \"fill\", cell.backgroundColor);\r\n        drawRect(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h, \"F\")\r\n    }\r\n}\r\n\r\nfunction drawCellText(doc, cell, docStyles) {\r\n    if (isDefined(cell.text) && \"\" !== cell.text) {\r\n        const {\r\n            textColor: textColor,\r\n            font: font,\r\n            _rect: _rect,\r\n            padding: padding\r\n        } = cell;\r\n        setTextStyles(doc, {\r\n            textColor: textColor,\r\n            font: font\r\n        }, docStyles);\r\n        const textRect = {\r\n            x: _rect.x + padding.left,\r\n            y: _rect.y + padding.top,\r\n            w: _rect.w - (padding.left + padding.right),\r\n            h: _rect.h - (padding.top + padding.bottom)\r\n        };\r\n        if (isDefined(cell._textLeftOffset) || isDefined(cell._textTopOffset)) {\r\n            textRect.x = textRect.x + (cell._textLeftOffset ?? 0);\r\n            textRect.y = textRect.y + (cell._textTopOffset ?? 0);\r\n            doc.saveGraphicsState();\r\n            clipOutsideRectContent(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h)\r\n        }\r\n        drawTextInRect(doc, cell.text, textRect, cell.verticalAlign, cell.horizontalAlign, cell._internalTextOptions);\r\n        if (isDefined(cell._textLeftOffset) || isDefined(cell._textTopOffset)) {\r\n            doc.restoreGraphicsState()\r\n        }\r\n    }\r\n}\r\n\r\nfunction drawCellsLines(doc, cellsArray, docStyles) {\r\n    cellsArray.filter((cell => !isDefined(cell.borderColor))).forEach((cell => {\r\n        drawBorders(doc, cell._rect, cell, docStyles)\r\n    }));\r\n    cellsArray.filter((cell => isDefined(cell.borderColor))).forEach((cell => {\r\n        drawBorders(doc, cell._rect, cell, docStyles)\r\n    }))\r\n}\r\n\r\nfunction drawGridLines(doc, rect, options, docStyles) {\r\n    drawBorders(doc, rect, options, docStyles)\r\n}\r\n\r\nfunction drawBorders(doc, rect, _ref, docStyles) {\r\n    let {\r\n        borderWidth: borderWidth,\r\n        borderColor: borderColor,\r\n        drawLeftBorder: drawLeftBorder = true,\r\n        drawRightBorder: drawRightBorder = true,\r\n        drawTopBorder: drawTopBorder = true,\r\n        drawBottomBorder: drawBottomBorder = true\r\n    } = _ref;\r\n    if (!isDefined(rect)) {\r\n        throw \"rect is required\"\r\n    }\r\n    if (!drawLeftBorder && !drawRightBorder && !drawTopBorder && !drawBottomBorder) {\r\n        return\r\n    } else if (drawLeftBorder && drawRightBorder && drawTopBorder && drawBottomBorder) {\r\n        setLinesStyles(doc, {\r\n            borderWidth: borderWidth,\r\n            borderColor: borderColor\r\n        }, docStyles);\r\n        drawRect(doc, rect.x, rect.y, rect.w, rect.h)\r\n    } else {\r\n        setLinesStyles(doc, {\r\n            borderWidth: borderWidth,\r\n            borderColor: borderColor\r\n        }, docStyles);\r\n        if (drawTopBorder) {\r\n            drawLine(doc, rect.x, rect.y, rect.x + rect.w, rect.y)\r\n        }\r\n        if (drawLeftBorder) {\r\n            drawLine(doc, rect.x, rect.y, rect.x, rect.y + rect.h)\r\n        }\r\n        if (drawRightBorder) {\r\n            drawLine(doc, rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h)\r\n        }\r\n        if (drawBottomBorder) {\r\n            drawLine(doc, rect.x, rect.y + rect.h, rect.x + rect.w, rect.y + rect.h)\r\n        }\r\n    }\r\n}\r\n\r\nfunction setTextStyles(doc, _ref2, docStyles) {\r\n    let {\r\n        textColor: textColor,\r\n        font: font\r\n    } = _ref2;\r\n    trySetColor(doc, \"text\", isDefined(textColor) ? textColor : docStyles.textColor);\r\n    const currentFont = isDefined(font) ? extend({}, docStyles.font, font) : docStyles.font;\r\n    const docFont = doc.getFont();\r\n    if (currentFont.name !== docFont.fontName || currentFont.style !== docFont.fontStyle || isDefined(currentFont.weight)) {\r\n        doc.setFont(currentFont.name, currentFont.style, currentFont.weight)\r\n    }\r\n    if (currentFont.size !== doc.getFontSize()) {\r\n        doc.setFontSize(currentFont.size)\r\n    }\r\n}\r\n\r\nfunction setLinesStyles(doc, _ref3, docStyles) {\r\n    let {\r\n        borderWidth: borderWidth,\r\n        borderColor: borderColor\r\n    } = _ref3;\r\n    const currentBorderWidth = isDefined(borderWidth) ? borderWidth : docStyles.borderWidth;\r\n    if (currentBorderWidth !== getDocBorderWidth(doc)) {\r\n        setDocBorderWidth(doc, toPdfUnit(doc, currentBorderWidth))\r\n    }\r\n    trySetColor(doc, \"draw\", isDefined(borderColor) ? borderColor : docStyles.borderColor)\r\n}\r\n\r\nfunction trySetColor(doc, target, color) {\r\n    const getterName = `get${capitalizeFirstLetter(target)}Color`;\r\n    const setterName = `set${capitalizeFirstLetter(target)}Color`;\r\n    const {\r\n        ch1: ch1 = color,\r\n        ch2: ch2,\r\n        ch3: ch3,\r\n        ch4: ch4\r\n    } = color;\r\n    const normalizedColor = doc.__private__.decodeColorString(doc.__private__.encodeColorString({\r\n        ch1: ch1,\r\n        ch2: ch2,\r\n        ch3: ch3,\r\n        ch4: ch4,\r\n        precision: \"text\" === target ? 3 : 2\r\n    }));\r\n    if (normalizedColor !== doc[getterName]() || \"fill\" === target) {\r\n        doc[setterName].apply(doc, [ch1, ch2, ch3, ch4].filter((item => void 0 !== item)))\r\n    }\r\n}\r\n\r\nfunction getDocumentStyles(doc) {\r\n    const docFont = doc.getFont();\r\n    return {\r\n        borderWidth: getDocBorderWidth(doc),\r\n        borderColor: doc.getDrawColor(),\r\n        font: {\r\n            name: docFont.fontName,\r\n            style: docFont.fontStyle,\r\n            size: doc.getFontSize()\r\n        },\r\n        textColor: doc.getTextColor()\r\n    }\r\n}\r\n\r\nfunction setDocumentStyles(doc, styles) {\r\n    const {\r\n        borderWidth: borderWidth,\r\n        borderColor: borderColor,\r\n        font: font,\r\n        textColor: textColor\r\n    } = styles;\r\n    const docFont = doc.getFont();\r\n    if (docFont.fontName !== font.name || docFont.fontStyle !== font.style) {\r\n        doc.setFont(font.name, font.style, void 0)\r\n    }\r\n    const docFontSize = doc.getFontSize();\r\n    if (docFontSize !== font.size) {\r\n        doc.setFontSize(font.size)\r\n    }\r\n    if (getDocBorderWidth(doc) !== borderWidth) {\r\n        setDocBorderWidth(doc, borderWidth)\r\n    }\r\n    if (doc.getDrawColor() !== borderColor) {\r\n        doc.setDrawColor(borderColor)\r\n    }\r\n    if (doc.getTextColor() !== textColor) {\r\n        doc.setTextColor(textColor)\r\n    }\r\n}\r\n\r\nfunction addNewPage(doc) {\r\n    doc.addPage();\r\n    resetDocBorderWidth(doc)\r\n}\r\n\r\nfunction getDocBorderWidth(doc) {\r\n    if (isDefined(doc.getLineWidth)) {\r\n        return doc.getLineWidth()\r\n    }\r\n    return doc.__borderWidth ?? .200025\r\n}\r\n\r\nfunction setDocBorderWidth(doc, width) {\r\n    doc.setLineWidth(width);\r\n    if (!isDefined(doc.getLineWidth)) {\r\n        doc.__borderWidth = width\r\n    }\r\n}\r\n\r\nfunction resetDocBorderWidth(doc) {\r\n    if (!isDefined(doc.getLineWidth)) {\r\n        doc.__borderWidth = null\r\n    }\r\n}\r\n\r\nfunction clipOutsideRectContent(doc, x, y, w, h) {\r\n    doc.moveTo(roundToThreeDecimals(x), roundToThreeDecimals(y));\r\n    doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y));\r\n    doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y + h));\r\n    doc.lineTo(roundToThreeDecimals(x), roundToThreeDecimals(y + h));\r\n    doc.clip();\r\n    doc.discardPath()\r\n}\r\nexport {\r\n    drawCellsContent,\r\n    drawCellsLines,\r\n    drawGridLines,\r\n    getDocumentStyles,\r\n    setDocumentStyles,\r\n    drawTextInRect,\r\n    drawRect,\r\n    drawLine,\r\n    roundToThreeDecimals,\r\n    addNewPage\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_spliting_utils/get_multipage_row_pages.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nconst isHeader = rect => \"header\" === (null === rect || void 0 === rect ? void 0 : rect.sourceCellInfo.gridCell.rowType);\r\nconst spitMultiPageRows = (rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc) => {\r\n    let [newPageRects, remainPageRects] = splitMultiPageRowFunc(isCurrentPageContainsOnlyHeader, rectsToPatch);\r\n    const newPageRectsArray = [isCurrentPageContainsOnlyHeader ? newPageRects.map((rect => _extends({}, rect, {\r\n        y: firstRectYAdjustment\r\n    }))) : newPageRects];\r\n    while (!checkIsFitToPageFunc(false, remainPageRects[0].h)) {\r\n        [newPageRects, remainPageRects] = splitMultiPageRowFunc(false, remainPageRects);\r\n        newPageRectsArray.push(newPageRects)\r\n    }\r\n    return [newPageRectsArray, remainPageRects]\r\n};\r\nconst patchRects = (rectsToSplit, rectsToPatch, remainPageRects) => {\r\n    rectsToPatch.forEach(((rect, rectIndex) => {\r\n        rect.sourceCellInfo.text = remainPageRects[rectIndex].sourceCellInfo.text;\r\n        rect.h = remainPageRects[rectIndex].h\r\n    }));\r\n    const untouchedRowIdx = rectsToSplit.indexOf(rectsToPatch[rectsToPatch.length - 1]) + 1;\r\n    if (untouchedRowIdx >= rectsToSplit.length) {\r\n        return\r\n    }\r\n    const delta = rectsToSplit[untouchedRowIdx].y - (rectsToPatch[0].y + remainPageRects[0].h);\r\n    for (let idx = untouchedRowIdx; idx < rectsToSplit.length; idx++) {\r\n        rectsToSplit[idx].y = rectsToSplit[idx].y - delta\r\n    }\r\n};\r\nexport const checkPageContainsOnlyHeader = (pageRects, isFirstPage) => isFirstPage && isHeader(pageRects[pageRects.length - 1]);\r\nexport const getMultiPageRowPages = (currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, splitMultiPageRowFunc, checkIsFitToPageFunc) => {\r\n    if (!splitMultiPageRowFunc) {\r\n        return []\r\n    }\r\n    const currentPageLastRect = currentPageRects[currentPageRects.length - 1];\r\n    const nextPageFirstRect = rectsToSplit[currentPageRects.length];\r\n    if (!nextPageFirstRect || isHeader(nextPageFirstRect)) {\r\n        return []\r\n    }\r\n    const isRectsFitsToPage = checkIsFitToPageFunc(isCurrentPageContainsOnlyHeader, nextPageFirstRect.h);\r\n    if (isRectsFitsToPage && !isCurrentPageContainsOnlyHeader) {\r\n        return []\r\n    }\r\n    const rectsToPatch = rectsToSplit.filter((_ref => {\r\n        let {\r\n            y: y\r\n        } = _ref;\r\n        return y === nextPageFirstRect.y\r\n    }));\r\n    const firstRectYAdjustment = currentPageLastRect.y + currentPageLastRect.h;\r\n    const [multiPageRowPages, remainPageRects] = spitMultiPageRows(rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc);\r\n    patchRects(rectsToSplit, rectsToPatch, remainPageRects);\r\n    return multiPageRowPages\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_spliting_utils/create_on_split_multipage_row.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport {\r\n    getTextLines,\r\n    getTextDimensions,\r\n    calculateTextHeight\r\n} from \"../pdf_utils\";\r\n\r\nfunction createMultiCellRect(rect, text, marginTop) {\r\n    return _extends({}, rect, {\r\n        sourceCellInfo: _extends({}, rect.sourceCellInfo, {\r\n            text: text\r\n        }),\r\n        y: marginTop\r\n    })\r\n}\r\nexport const createOnSplitMultiPageRow = (doc, options, headerHeight, maxBottomRight) => (isFirstPage, pageRects) => {\r\n    const currentPageRects = [];\r\n    const nextPageRects = [];\r\n    let maxCurrentPageHeight = 0;\r\n    let maxNextPageHeight = 0;\r\n    pageRects.forEach((rect => {\r\n        const {\r\n            w: w,\r\n            sourceCellInfo: sourceCellInfo\r\n        } = rect;\r\n        const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : headerHeight + options.topLeft.y;\r\n        const heightOfOneLine = getTextDimensions(doc, sourceCellInfo.text, sourceCellInfo.font).h;\r\n        const paddingHeight = sourceCellInfo.padding.top + sourceCellInfo.padding.bottom;\r\n        const fullPageHeight = maxBottomRight.y - additionalHeight - paddingHeight - options.margin.top;\r\n        const possibleLinesCount = Math.floor(fullPageHeight / (heightOfOneLine * doc.getLineHeightFactor()));\r\n        const allLines = getTextLines(doc, sourceCellInfo.text, sourceCellInfo.font, {\r\n            wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\r\n            targetRectWidth: w\r\n        });\r\n        if (possibleLinesCount < allLines.length) {\r\n            const currentPageText = allLines.slice(0, possibleLinesCount).join(\"\\n\");\r\n            const currentPageHeight = calculateTextHeight(doc, currentPageText, sourceCellInfo.font, {\r\n                wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\r\n                targetRectWidth: w\r\n            });\r\n            maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);\r\n            maxNextPageHeight = rect.h - currentPageHeight;\r\n            currentPageRects.push(createMultiCellRect(rect, currentPageText, options.margin.top));\r\n            nextPageRects.push(createMultiCellRect(rect, allLines.slice(possibleLinesCount).join(\"\\n\"), options.margin.top))\r\n        } else {\r\n            const currentPageHeight = calculateTextHeight(doc, sourceCellInfo.text, sourceCellInfo.font, {\r\n                wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\r\n                targetRectWidth: w\r\n            });\r\n            maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);\r\n            maxNextPageHeight = Math.max(maxNextPageHeight, currentPageHeight + paddingHeight);\r\n            currentPageRects.push(createMultiCellRect(rect, sourceCellInfo.text, options.margin.top));\r\n            nextPageRects.push(createMultiCellRect(rect, \"\", options.margin.top))\r\n        }\r\n    }));\r\n    currentPageRects.forEach((rect => rect.h = maxCurrentPageHeight));\r\n    nextPageRects.forEach((rect => rect.h = maxNextPageHeight));\r\n    return [currentPageRects, nextPageRects]\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_splitting.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    getPageWidth,\r\n    getPageHeight\r\n} from \"./pdf_utils\";\r\nimport {\r\n    roundToThreeDecimals\r\n} from \"./draw_utils\";\r\nimport {\r\n    getMultiPageRowPages,\r\n    checkPageContainsOnlyHeader\r\n} from \"./rows_spliting_utils/get_multipage_row_pages\";\r\nimport {\r\n    createOnSplitMultiPageRow\r\n} from \"./rows_spliting_utils/create_on_split_multipage_row\";\r\nconst COORDINATE_EPSILON = .001;\r\n\r\nfunction convertToCellsArray(rows) {\r\n    return [].concat.apply([], rows.map((rowInfo => rowInfo.cells.filter((cell => !isDefined(cell.pdfCell.isMerged))).map((cellInfo => Object.assign({}, cellInfo.pdfCell._rect, {\r\n        sourceCellInfo: _extends({}, cellInfo.pdfCell, {\r\n            gridCell: cellInfo.gridCell\r\n        })\r\n    }))))))\r\n}\r\n\r\nfunction splitByPages(doc, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically) {\r\n    if (0 === rowsInfo.length) {\r\n        return [\r\n            []\r\n        ]\r\n    }\r\n    const maxBottomRight = {\r\n        x: getPageWidth(doc) - options.margin.right,\r\n        y: getPageHeight(doc) - options.margin.bottom\r\n    };\r\n    const headerRows = rowsInfo.filter((r => \"header\" === r.rowType));\r\n    const headerHeight = headerRows.reduce(((accumulator, row) => accumulator + row.height), 0);\r\n    const verticallyPages = splitRectsByPages(convertToCellsArray(rowsInfo), options.margin.top, \"y\", \"h\", ((isFirstPage, currentCoordinate) => {\r\n        const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : 0;\r\n        return roundToThreeDecimals(currentCoordinate + additionalHeight) <= roundToThreeDecimals(maxBottomRight.y)\r\n    }), ((rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {\r\n        const args = {\r\n            sourceRect: rect,\r\n            topRect: {\r\n                x: rect.x,\r\n                y: rect.y,\r\n                w: rect.w,\r\n                h: currentPageMaxRectCoordinate - rect.y\r\n            },\r\n            bottomRect: {\r\n                x: rect.x,\r\n                y: currentPageMaxRectCoordinate,\r\n                w: rect.w,\r\n                h: rect.h - (currentPageMaxRectCoordinate - rect.y)\r\n            }\r\n        };\r\n        onSeparateRectVertically(args);\r\n        currentPageRects.push(args.topRect);\r\n        rectsToSplit.push(args.bottomRect)\r\n    }), createOnSplitMultiPageRow(doc, options, headerHeight, maxBottomRight));\r\n    if (options.repeatHeaders) {\r\n        for (let i = 1; i < verticallyPages.length; i++) {\r\n            verticallyPages[i].forEach((rect => rect.y += headerHeight));\r\n            const headerCells = convertToCellsArray(headerRows);\r\n            headerCells.forEach((cell => {\r\n                cell.y -= options.topLeft.y\r\n            }));\r\n            verticallyPages[i] = [...headerCells, ...verticallyPages[i]]\r\n        }\r\n    }\r\n    let pageIndex = 0;\r\n    while (pageIndex < verticallyPages.length) {\r\n        const horizontallyPages = splitRectsByPages(verticallyPages[pageIndex], options.margin.left, \"x\", \"w\", ((pagesLength, currentCoordinate) => roundToThreeDecimals(currentCoordinate) <= roundToThreeDecimals(maxBottomRight.x)), ((rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {\r\n            const args = {\r\n                sourceRect: rect,\r\n                leftRect: {\r\n                    x: rect.x,\r\n                    y: rect.y,\r\n                    w: currentPageMaxRectCoordinate - rect.x,\r\n                    h: rect.h\r\n                },\r\n                rightRect: {\r\n                    x: currentPageMaxRectCoordinate,\r\n                    y: rect.y,\r\n                    w: rect.w - (currentPageMaxRectCoordinate - rect.x),\r\n                    h: rect.h\r\n                }\r\n            };\r\n            onSeparateRectHorizontally(args);\r\n            currentPageRects.push(args.leftRect);\r\n            rectsToSplit.push(args.rightRect)\r\n        }));\r\n        if (horizontallyPages.length > 1) {\r\n            verticallyPages.splice(pageIndex, 1, ...horizontallyPages);\r\n            pageIndex += horizontallyPages.length\r\n        } else {\r\n            pageIndex += 1\r\n        }\r\n    }\r\n    return verticallyPages.map((rects => rects.map((rect => Object.assign({}, rect.sourceCellInfo, {\r\n        _rect: rect\r\n    })))))\r\n}\r\n\r\nfunction splitRectsByPages(rects, marginValue, coordinate, dimension, isFitToPage, onSeparateCallback, onSplitMultiPageRow) {\r\n    const pages = [];\r\n    const rectsToSplit = [...rects];\r\n    const isFitToPageForMultiPageRow = (isFirstPage, rectHeight) => isFitToPage(isFirstPage, rectHeight + marginValue);\r\n    while (rectsToSplit.length > 0) {\r\n        let currentPageMaxRectCoordinate = 0;\r\n        const currentPageRects = rectsToSplit.filter((rect => {\r\n            const currentRectCoordinate = rect[coordinate] + rect[dimension];\r\n            if (isFitToPage(0 === pages.length, currentRectCoordinate)) {\r\n                if (currentPageMaxRectCoordinate <= currentRectCoordinate) {\r\n                    currentPageMaxRectCoordinate = currentRectCoordinate\r\n                }\r\n                return true\r\n            } else {\r\n                return false\r\n            }\r\n        }));\r\n        const isCurrentPageContainsOnlyHeader = checkPageContainsOnlyHeader(currentPageRects, 0 === pages.length);\r\n        const multiPageRowPages = getMultiPageRowPages(currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, onSplitMultiPageRow, isFitToPageForMultiPageRow);\r\n        const rectsToSeparate = rectsToSplit.filter((rect => {\r\n            const currentRectLeft = rect[coordinate];\r\n            const currentRectRight = rect[coordinate] + rect[dimension];\r\n            return currentPageMaxRectCoordinate - currentRectLeft > .001 && currentRectRight - currentPageMaxRectCoordinate > .001\r\n        }));\r\n        rectsToSeparate.forEach((rect => {\r\n            onSeparateCallback(rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit);\r\n            const index = rectsToSplit.indexOf(rect);\r\n            if (-1 !== index) {\r\n                rectsToSplit.splice(index, 1)\r\n            }\r\n        }));\r\n        currentPageRects.forEach((rect => {\r\n            const index = rectsToSplit.indexOf(rect);\r\n            if (-1 !== index) {\r\n                rectsToSplit.splice(index, 1)\r\n            }\r\n        }));\r\n        rectsToSplit.forEach((rect => {\r\n            rect[coordinate] = isDefined(currentPageMaxRectCoordinate) ? rect[coordinate] - currentPageMaxRectCoordinate + marginValue : rect[coordinate]\r\n        }));\r\n        const firstPageContainsHeaderAndMultiPageRow = isCurrentPageContainsOnlyHeader && multiPageRowPages.length > 0;\r\n        if (firstPageContainsHeaderAndMultiPageRow) {\r\n            const [firstPage, ...restOfPages] = multiPageRowPages;\r\n            pages.push([...currentPageRects, ...firstPage]);\r\n            pages.push(...restOfPages)\r\n        } else if (currentPageRects.length > 0) {\r\n            pages.push(currentPageRects);\r\n            pages.push(...multiPageRowPages)\r\n        } else if (multiPageRowPages.length > 0) {\r\n            pages.push(...multiPageRowPages);\r\n            pages.push(rectsToSplit)\r\n        } else {\r\n            pages.push(rectsToSplit);\r\n            break\r\n        }\r\n    }\r\n    return pages\r\n}\r\nexport {\r\n    splitByPages\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/export.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport {\r\n    normalizeRowsInfo,\r\n    normalizeBoundaryValue\r\n} from \"./normalizeOptions\";\r\nimport {\r\n    initializeCellsWidth,\r\n    applyColSpans,\r\n    applyRowSpans,\r\n    applyBordersConfig,\r\n    calculateHeights,\r\n    calculateCoordinates,\r\n    calculateTableSize,\r\n    resizeFirstColumnByIndentLevel\r\n} from \"./row_utils\";\r\nimport {\r\n    updateRowsAndCellsHeights\r\n} from \"./height_updater\";\r\nimport {\r\n    generateRowsInfo,\r\n    getBaseTableStyle\r\n} from \"./rows_generator\";\r\nimport {\r\n    splitByPages\r\n} from \"./rows_splitting\";\r\nimport {\r\n    drawCellsContent,\r\n    drawCellsLines,\r\n    drawGridLines,\r\n    getDocumentStyles,\r\n    setDocumentStyles,\r\n    addNewPage\r\n} from \"./draw_utils\";\r\nimport {\r\n    applyRtl,\r\n    applyWordWrap,\r\n    toPdfUnit\r\n} from \"./pdf_utils\";\r\nimport messageLocalization from \"../../../common/core/localization/message\";\r\nimport {\r\n    ExportLoadPanel\r\n} from \"../../common/export_load_panel\";\r\nimport {\r\n    hasWindow\r\n} from \"../../../core/utils/window\";\r\n\r\nfunction _getFullOptions(options) {\r\n    const {\r\n        jsPDFDocument: jsPDFDocument\r\n    } = options;\r\n    const fullOptions = extend({}, options);\r\n    if (!isDefined(fullOptions.topLeft)) {\r\n        fullOptions.topLeft = {\r\n            x: 0,\r\n            y: 0\r\n        }\r\n    }\r\n    if (!isDefined(fullOptions.indent)) {\r\n        fullOptions.indent = 0\r\n    }\r\n    if (!isDefined(fullOptions.repeatHeaders)) {\r\n        fullOptions.repeatHeaders = true\r\n    }\r\n    if (!isDefined(fullOptions.margin)) {\r\n        fullOptions.margin = toPdfUnit(jsPDFDocument, 40)\r\n    }\r\n    fullOptions.margin = normalizeBoundaryValue(fullOptions.margin);\r\n    if (!Array.isArray(fullOptions.columnWidths)) {\r\n        fullOptions.columnWidths = []\r\n    }\r\n    if (!isDefined(fullOptions.loadPanel)) {\r\n        fullOptions.loadPanel = {}\r\n    }\r\n    if (!isDefined(fullOptions.loadPanel.enabled)) {\r\n        fullOptions.loadPanel.enabled = true\r\n    }\r\n    if (!isDefined(fullOptions.loadPanel.text)) {\r\n        fullOptions.loadPanel.text = messageLocalization.format(\"dxDataGrid-exporting\")\r\n    }\r\n    return fullOptions\r\n}\r\n\r\nfunction exportDataGrid(options) {\r\n    var _component$_getIntern;\r\n    const {\r\n        jsPDFDocument: jsPDFDocument,\r\n        component: component,\r\n        selectedRowsOnly: selectedRowsOnly,\r\n        loadPanel: loadPanel\r\n    } = options;\r\n    const internalComponent = (null === (_component$_getIntern = component._getInternalInstance) || void 0 === _component$_getIntern ? void 0 : _component$_getIntern.call(component)) || component;\r\n    const initialLoadPanelEnabledOption = internalComponent.option(\"loadPanel\") && internalComponent.option(\"loadPanel\").enabled;\r\n    if (initialLoadPanelEnabledOption) {\r\n        component.option(\"loadPanel.enabled\", false)\r\n    }\r\n    let exportLoadPanel;\r\n    if (loadPanel.enabled && hasWindow()) {\r\n        const rowsView = component.getView(\"rowsView\");\r\n        exportLoadPanel = new ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);\r\n        exportLoadPanel.show()\r\n    }\r\n    const dataProvider = component.getDataProvider(selectedRowsOnly);\r\n    return new Promise((resolve => {\r\n        dataProvider.ready().done((() => {\r\n            var _options$rowOptions;\r\n            const rowsInfo = generateRowsInfo(jsPDFDocument, dataProvider, component, null === (_options$rowOptions = options.rowOptions) || void 0 === _options$rowOptions || null === (_options$rowOptions = _options$rowOptions.headerStyles) || void 0 === _options$rowOptions ? void 0 : _options$rowOptions.backgroundColor);\r\n            if (options.customizeCell) {\r\n                rowsInfo.forEach((rowInfo => rowInfo.cells.forEach((cellInfo => options.customizeCell(cellInfo)))))\r\n            }\r\n            normalizeRowsInfo(rowsInfo);\r\n            initializeCellsWidth(jsPDFDocument, dataProvider, rowsInfo, options);\r\n            resizeFirstColumnByIndentLevel(rowsInfo, options);\r\n            applyColSpans(rowsInfo);\r\n            calculateHeights(jsPDFDocument, rowsInfo, options);\r\n            applyRowSpans(rowsInfo);\r\n            updateRowsAndCellsHeights(jsPDFDocument, rowsInfo);\r\n            calculateCoordinates(jsPDFDocument, rowsInfo, options);\r\n            applyBordersConfig(rowsInfo);\r\n            applyWordWrap(jsPDFDocument, rowsInfo);\r\n            const docStyles = getDocumentStyles(jsPDFDocument);\r\n            const rtlEnabled = !!component.option(\"rtlEnabled\");\r\n            const rectsByPages = splitByPages(jsPDFDocument, rowsInfo, options, (_ref => {\r\n                var _sourceRect$sourceCel;\r\n                let {\r\n                    sourceRect: sourceRect,\r\n                    leftRect: leftRect,\r\n                    rightRect: rightRect\r\n                } = _ref;\r\n                let leftRectTextOptions = {};\r\n                let rightRectTextOptions = {};\r\n                const isTextNotEmpty = (null === (_sourceRect$sourceCel = sourceRect.sourceCellInfo.text) || void 0 === _sourceRect$sourceCel ? void 0 : _sourceRect$sourceCel.length) > 0;\r\n                if (isTextNotEmpty) {\r\n                    if (rtlEnabled) {\r\n                        const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;\r\n                        const isTextRightAlignment = !isDefined(sourceRect.sourceCellInfo.horizontalAlign) || \"right\" === sourceRect.sourceCellInfo.horizontalAlign;\r\n                        if (isTextWidthGreaterThanRect || !isTextRightAlignment) {\r\n                            var _sourceRect$sourceCel2, _sourceRect$sourceCel3, _sourceRect$sourceCel4;\r\n                            let rightRectTextOffset;\r\n                            let leftRectTextOffset;\r\n                            if (\"right\" === (null === (_sourceRect$sourceCel2 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel2 ? void 0 : _sourceRect$sourceCel2.horizontalAlign)) {\r\n                                rightRectTextOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\r\n                                leftRectTextOffset = rightRectTextOffset + leftRect.w\r\n                            } else if (\"center\" === (null === (_sourceRect$sourceCel3 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel3 ? void 0 : _sourceRect$sourceCel3.horizontalAlign)) {\r\n                                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w) + sourceRect.sourceCellInfo._rect.w / 2 - leftRect.w / 2;\r\n                                rightRectTextOffset = leftRectTextOffset - rightRect.w\r\n                            } else if (\"left\" === (null === (_sourceRect$sourceCel4 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel4 ? void 0 : _sourceRect$sourceCel4.horizontalAlign)) {\r\n                                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);\r\n                                rightRectTextOffset = leftRectTextOffset - rightRect.w\r\n                            }\r\n                            leftRectTextOptions = Object.assign({}, {\r\n                                _textLeftOffset: rightRectTextOffset\r\n                            });\r\n                            rightRectTextOptions = Object.assign({}, {\r\n                                _textLeftOffset: leftRectTextOffset\r\n                            })\r\n                        } else {\r\n                            rightRectTextOptions = Object.assign({}, {\r\n                                text: \"\"\r\n                            })\r\n                        }\r\n                    } else {\r\n                        const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;\r\n                        const isTextLeftAlignment = !isDefined(sourceRect.sourceCellInfo.horizontalAlign) || \"left\" === sourceRect.sourceCellInfo.horizontalAlign;\r\n                        if (isTextWidthGreaterThanRect || !isTextLeftAlignment) {\r\n                            var _sourceRect$sourceCel5, _sourceRect$sourceCel6, _sourceRect$sourceCel7;\r\n                            let leftTextLeftOffset;\r\n                            let rightTextLeftOffset;\r\n                            if (\"left\" === (null === (_sourceRect$sourceCel5 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel5 ? void 0 : _sourceRect$sourceCel5.horizontalAlign)) {\r\n                                leftTextLeftOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\r\n                                rightTextLeftOffset = leftTextLeftOffset - leftRect.w\r\n                            } else if (\"center\" === (null === (_sourceRect$sourceCel6 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel6 ? void 0 : _sourceRect$sourceCel6.horizontalAlign)) {\r\n                                const offset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\r\n                                leftTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (leftRect.x + leftRect.w / 2);\r\n                                rightTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (rightRect.x + rightRect.w / 2)\r\n                            } else if (\"right\" === (null === (_sourceRect$sourceCel7 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel7 ? void 0 : _sourceRect$sourceCel7.horizontalAlign)) {\r\n                                leftTextLeftOffset = sourceRect.x + sourceRect.w - (leftRect.x + leftRect.w);\r\n                                rightTextLeftOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w)\r\n                            }\r\n                            leftRectTextOptions = Object.assign({}, {\r\n                                _textLeftOffset: leftTextLeftOffset\r\n                            });\r\n                            rightRectTextOptions = Object.assign({}, {\r\n                                _textLeftOffset: rightTextLeftOffset\r\n                            })\r\n                        } else {\r\n                            rightRectTextOptions = Object.assign({}, {\r\n                                text: \"\"\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n                leftRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\r\n                    debugSourceCellInfo: sourceRect.sourceCellInfo\r\n                }, leftRectTextOptions);\r\n                rightRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\r\n                    debugSourceCellInfo: sourceRect.sourceCellInfo\r\n                }, rightRectTextOptions)\r\n            }), (_ref2 => {\r\n                var _sourceRect$sourceCel8;\r\n                let {\r\n                    sourceRect: sourceRect,\r\n                    topRect: topRect,\r\n                    bottomRect: bottomRect\r\n                } = _ref2;\r\n                let topRectTextOptions = {};\r\n                let bottomRectTextOptions = {};\r\n                const isTextNotEmpty = (null === (_sourceRect$sourceCel8 = sourceRect.sourceCellInfo.text) || void 0 === _sourceRect$sourceCel8 ? void 0 : _sourceRect$sourceCel8.length) > 0;\r\n                if (isTextNotEmpty) {\r\n                    var _sourceRect$sourceCel9;\r\n                    const isTextHeightGreaterThanRect = jsPDFDocument.getTextDimensions(sourceRect.sourceCellInfo.text).h > topRect.h;\r\n                    const isTextTopAlignment = \"top\" === (null === (_sourceRect$sourceCel9 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel9 ? void 0 : _sourceRect$sourceCel9.verticalAlign);\r\n                    if (isTextHeightGreaterThanRect || !isTextTopAlignment) {\r\n                        var _sourceRect$sourceCel10, _sourceRect$sourceCel11, _sourceRect$sourceCel12;\r\n                        let topTextTopOffset;\r\n                        let bottomTextTopOffset;\r\n                        if (\"top\" === (null === (_sourceRect$sourceCel10 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel10 ? void 0 : _sourceRect$sourceCel10.verticalAlign)) {\r\n                            topTextTopOffset = sourceRect.sourceCellInfo._textTopOffset ?? 0;\r\n                            bottomTextTopOffset = topTextTopOffset - topRect.h\r\n                        } else if (\"middle\" === (null === (_sourceRect$sourceCel11 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel11 ? void 0 : _sourceRect$sourceCel11.verticalAlign)) {\r\n                            const offset = sourceRect.sourceCellInfo._textTopOffset ?? 0;\r\n                            topTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (topRect.y + topRect.h / 2);\r\n                            bottomTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (bottomRect.y + bottomRect.h / 2)\r\n                        } else if (\"bottom\" === (null === (_sourceRect$sourceCel12 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel12 ? void 0 : _sourceRect$sourceCel12.verticalAlign)) {\r\n                            topTextTopOffset = sourceRect.y + sourceRect.h - (topRect.y + topRect.h);\r\n                            bottomTextTopOffset = sourceRect.y + sourceRect.h - (bottomRect.y + bottomRect.h)\r\n                        }\r\n                        topRectTextOptions = Object.assign({}, {\r\n                            _textTopOffset: topTextTopOffset\r\n                        });\r\n                        bottomRectTextOptions = Object.assign({}, {\r\n                            _textTopOffset: bottomTextTopOffset\r\n                        })\r\n                    } else {\r\n                        bottomRectTextOptions = Object.assign({}, {\r\n                            text: \"\"\r\n                        })\r\n                    }\r\n                }\r\n                topRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\r\n                    debugSourceCellInfo: sourceRect.sourceCellInfo\r\n                }, topRectTextOptions);\r\n                bottomRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\r\n                    debugSourceCellInfo: sourceRect.sourceCellInfo\r\n                }, bottomRectTextOptions)\r\n            }));\r\n            if (rtlEnabled) {\r\n                applyRtl(jsPDFDocument, rectsByPages, options)\r\n            }\r\n            rectsByPages.forEach(((pdfCellsInfo, index) => {\r\n                if (index > 0) {\r\n                    addNewPage(jsPDFDocument)\r\n                }\r\n                drawCellsContent(jsPDFDocument, options.customDrawCell, pdfCellsInfo, docStyles);\r\n                drawCellsLines(jsPDFDocument, pdfCellsInfo, docStyles);\r\n                const isEmptyPdfCellsInfoSpecified = isDefined(pdfCellsInfo) && 0 === pdfCellsInfo.length;\r\n                if (isEmptyPdfCellsInfoSpecified) {\r\n                    const tableRect = calculateTableSize(jsPDFDocument, pdfCellsInfo, options);\r\n                    const baseStyle = getBaseTableStyle();\r\n                    drawGridLines(jsPDFDocument, tableRect, baseStyle, docStyles)\r\n                }\r\n            }));\r\n            setDocumentStyles(jsPDFDocument, docStyles);\r\n            resolve()\r\n        })).always((() => {\r\n            if (initialLoadPanelEnabledOption) {\r\n                component.option(\"loadPanel.enabled\", initialLoadPanelEnabledOption)\r\n            }\r\n            if (loadPanel.enabled && hasWindow()) {\r\n                exportLoadPanel.dispose()\r\n            }\r\n        }))\r\n    }))\r\n}\r\nexport const Export = {\r\n    getFullOptions: _getFullOptions,\r\n    export: exportDataGrid\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/export_data_grid.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined,\r\n    isObject\r\n} from \"../../core/utils/type\";\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    Export\r\n} from \"./common/export\";\r\nconst HOW_TO_MIGRATE_ARTICLE = \"https://supportcenter.devexpress.com/ticket/details/t1077554\";\r\n\r\nfunction _getFullOptions(options) {\r\n    if (!(isDefined(options) && isObject(options))) {\r\n        throw Error('The \"exportDataGrid\" method requires a configuration object.')\r\n    }\r\n    if (!(isDefined(options.component) && isObject(options.component) && \"dxDataGrid\" === options.component.NAME)) {\r\n        throw Error('The \"component\" field must contain a DataGrid instance.')\r\n    }\r\n    if (!(isDefined(options.jsPDFDocument) && isObject(options.jsPDFDocument))) {\r\n        throw Error('The \"jsPDFDocument\" field must contain a jsPDF instance.')\r\n    }\r\n    if (isDefined(options.autoTableOptions)) {\r\n        errors.log(\"W0001\", \"Export\", \"autoTableOptions\", \"22.1\", `You can migrate from exporting to PDF with the AutoTable plugin to a new export system. See the following topic for more information: ${HOW_TO_MIGRATE_ARTICLE}`)\r\n    }\r\n    return Export.getFullOptions(options)\r\n}\r\n\r\nfunction exportDataGrid(options) {\r\n    return Export.export(_getFullOptions(options))\r\n}\r\nexport {\r\n    exportDataGrid\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/autotable/export.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDate,\r\n    isDefined,\r\n    isObject,\r\n    isFunction,\r\n    isNumeric\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../../core/utils/extend\";\r\nimport dateLocalization from \"../../../common/core/localization/date\";\r\nimport numberLocalization from \"../../../common/core/localization/number\";\r\nimport messageLocalization from \"../../../common/core/localization/message\";\r\nimport {\r\n    ExportLoadPanel\r\n} from \"../../common/export_load_panel\";\r\nimport {\r\n    hasWindow\r\n} from \"../../../core/utils/window\";\r\nexport const Export = {\r\n    getFullOptions: function(options) {\r\n        const fullOptions = extend({}, options);\r\n        if (!(isDefined(fullOptions.jsPDFDocument) && isObject(fullOptions.jsPDFDocument))) {\r\n            throw Error('The \"jsPDFDocument\" field must contain a jsPDF instance.')\r\n        }\r\n        if (!(isDefined(fullOptions.jsPDFDocument.autoTable) && isFunction(fullOptions.jsPDFDocument.autoTable))) {\r\n            throw Error('The \"exportDataGrid\" method requires a autoTable plugin for jsPDF object.')\r\n        }\r\n        if (!isDefined(fullOptions.keepColumnWidths)) {\r\n            fullOptions.keepColumnWidths = true\r\n        }\r\n        if (!isDefined(fullOptions.autoTableOptions)) {\r\n            fullOptions.autoTableOptions = this._getDefaultAutoTableOptions()\r\n        } else {\r\n            if (!isObject(fullOptions.autoTableOptions)) {\r\n                throw Error('The \"autoTableOptions\" option must be of object type.')\r\n            }\r\n            fullOptions.autoTableOptions = extend(true, {}, this._getDefaultAutoTableOptions(), fullOptions.autoTableOptions)\r\n        }\r\n        if (!isDefined(fullOptions.loadPanel)) {\r\n            fullOptions.loadPanel = {}\r\n        }\r\n        if (!isDefined(fullOptions.loadPanel.enabled)) {\r\n            fullOptions.loadPanel.enabled = true\r\n        }\r\n        if (!isDefined(fullOptions.loadPanel.text)) {\r\n            fullOptions.loadPanel.text = messageLocalization.format(\"dxDataGrid-exporting\")\r\n        }\r\n        return fullOptions\r\n    },\r\n    _getDefaultAutoTableOptions: function() {\r\n        return {\r\n            theme: \"plain\",\r\n            tableLineColor: 149,\r\n            tableLineWidth: .1,\r\n            styles: {\r\n                textColor: 51,\r\n                lineColor: 149,\r\n                lineWidth: 0\r\n            },\r\n            columnStyles: {},\r\n            headStyles: {\r\n                fontStyle: \"normal\",\r\n                textColor: 149,\r\n                lineWidth: .1\r\n            },\r\n            bodyStyles: {\r\n                lineWidth: .1\r\n            },\r\n            head: [],\r\n            body: []\r\n        }\r\n    },\r\n    export: function(options) {\r\n        var _component$_getIntern;\r\n        const {\r\n            jsPDFDocument: jsPDFDocument,\r\n            autoTableOptions: autoTableOptions,\r\n            component: component,\r\n            customizeCell: customizeCell,\r\n            keepColumnWidths: keepColumnWidths,\r\n            selectedRowsOnly: selectedRowsOnly,\r\n            loadPanel: loadPanel\r\n        } = options;\r\n        const internalComponent = (null === (_component$_getIntern = component._getInternalInstance) || void 0 === _component$_getIntern ? void 0 : _component$_getIntern.call(component)) || component;\r\n        const initialLoadPanelEnabledOption = internalComponent.option(\"loadPanel\") && internalComponent.option(\"loadPanel\").enabled;\r\n        if (initialLoadPanelEnabledOption) {\r\n            component.option(\"loadPanel.enabled\", false)\r\n        }\r\n        let exportLoadPanel;\r\n        if (loadPanel.enabled && hasWindow()) {\r\n            const rowsView = component.getView(\"rowsView\");\r\n            exportLoadPanel = new ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);\r\n            exportLoadPanel.show()\r\n        }\r\n        const dataProvider = component.getDataProvider(selectedRowsOnly);\r\n        const wrapText = !!component.option(\"wordWrapEnabled\");\r\n        return new Promise((resolve => {\r\n            dataProvider.ready().done((() => {\r\n                const columns = dataProvider.getColumns();\r\n                const styles = dataProvider.getStyles();\r\n                const dataRowsCount = dataProvider.getRowsCount();\r\n                const headerRowCount = dataProvider.getHeaderRowCount();\r\n                const mergedCells = [];\r\n                if (keepColumnWidths) {\r\n                    const pdfColumnWidths = this._tryGetPdfColumnWidths(autoTableOptions.tableWidth, dataProvider.getColumnsWidths());\r\n                    if (isDefined(pdfColumnWidths) && isDefined(autoTableOptions.columnStyles)) {\r\n                        this._setColumnWidths(autoTableOptions.columnStyles, pdfColumnWidths)\r\n                    }\r\n                }\r\n                for (let rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {\r\n                    const row = [];\r\n                    for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {\r\n                        const {\r\n                            value: value,\r\n                            cellSourceData: gridCell\r\n                        } = dataProvider.getCellData(rowIndex, cellIndex, true);\r\n                        const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];\r\n                        const pdfCell = {\r\n                            content: this._getFormattedValue(value, cellStyle.format),\r\n                            styles: this._getPDFCellStyles(gridCell.rowType, columns[cellIndex].alignment, cellStyle, wrapText)\r\n                        };\r\n                        if (\"header\" === gridCell.rowType) {\r\n                            const mergedRange = this._tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);\r\n                            if (mergedRange && mergedRange.rowSpan > 0) {\r\n                                pdfCell.rowSpan = mergedRange.rowSpan + 1\r\n                            }\r\n                            if (mergedRange && mergedRange.colSpan > 0) {\r\n                                pdfCell.colSpan = mergedRange.colSpan + 1\r\n                            }\r\n                            const isMergedCell = mergedCells[rowIndex] && mergedCells[rowIndex][cellIndex];\r\n                            if (!isMergedCell || pdfCell.rowSpan > 1 || pdfCell.colSpan > 1) {\r\n                                if (isFunction(customizeCell)) {\r\n                                    customizeCell({\r\n                                        gridCell: gridCell,\r\n                                        pdfCell: pdfCell\r\n                                    })\r\n                                }\r\n                                row.push(pdfCell)\r\n                            }\r\n                        } else if (\"group\" === gridCell.rowType && !isDefined(pdfCell.content) && 1 === row.length) {\r\n                            row[0].colSpan = row[0].colSpan ?? 1;\r\n                            row[0].colSpan++\r\n                        } else {\r\n                            pdfCell.content = pdfCell.content ?? \"\";\r\n                            if (isFunction(customizeCell)) {\r\n                                customizeCell({\r\n                                    gridCell: gridCell,\r\n                                    pdfCell: pdfCell\r\n                                })\r\n                            }\r\n                            row.push(pdfCell)\r\n                        }\r\n                    }\r\n                    if (rowIndex < headerRowCount) {\r\n                        autoTableOptions.head.push(row)\r\n                    } else {\r\n                        autoTableOptions.body.push(row)\r\n                    }\r\n                }\r\n                jsPDFDocument.autoTable(autoTableOptions);\r\n                resolve()\r\n            })).always((() => {\r\n                if (initialLoadPanelEnabledOption) {\r\n                    component.option(\"loadPanel.enabled\", initialLoadPanelEnabledOption)\r\n                }\r\n                if (loadPanel.enabled && hasWindow()) {\r\n                    exportLoadPanel.dispose()\r\n                }\r\n            }))\r\n        }))\r\n    },\r\n    _getFormattedValue: function(value, format) {\r\n        if (isDefined(format)) {\r\n            if (isDate(value)) {\r\n                return dateLocalization.format(value, format)\r\n            }\r\n            if (isNumeric(value)) {\r\n                return numberLocalization.format(value, format)\r\n            }\r\n        }\r\n        return value\r\n    },\r\n    _getPDFCellStyles: function(rowType, columnAlignment, cellStyle, wrapText) {\r\n        const {\r\n            alignment: cellAlignment,\r\n            bold: bold\r\n        } = cellStyle;\r\n        const align = \"header\" === rowType ? columnAlignment : cellAlignment;\r\n        const pdfCellStyle = {};\r\n        if (align) {\r\n            pdfCellStyle.halign = align\r\n        }\r\n        if (bold && \"header\" !== rowType) {\r\n            pdfCellStyle.fontStyle = \"bold\"\r\n        }\r\n        if (wrapText) {\r\n            pdfCellStyle.cellWidth = \"wrap\"\r\n        }\r\n        return pdfCellStyle\r\n    },\r\n    _tryGetMergeRange: function(rowIndex, cellIndex, mergedCells, dataProvider) {\r\n        if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {\r\n            const {\r\n                colspan: colspan,\r\n                rowspan: rowspan\r\n            } = dataProvider.getCellMerging(rowIndex, cellIndex);\r\n            if (colspan || rowspan) {\r\n                for (let i = rowIndex; i <= rowIndex + rowspan || 0; i++) {\r\n                    for (let j = cellIndex; j <= cellIndex + colspan || 0; j++) {\r\n                        if (!mergedCells[i]) {\r\n                            mergedCells[i] = []\r\n                        }\r\n                        mergedCells[i][j] = true\r\n                    }\r\n                }\r\n                return {\r\n                    rowSpan: rowspan,\r\n                    colSpan: colspan\r\n                }\r\n            }\r\n        }\r\n    },\r\n    _tryGetPdfColumnWidths(autoTableWidth, columnWidths) {\r\n        if (isNumeric(autoTableWidth) && isDefined(columnWidths)) {\r\n            const tableWidth = columnWidths.reduce(((a, b) => a + b), 0);\r\n            return columnWidths.map((columnWidth => autoTableWidth * columnWidth / tableWidth))\r\n        }\r\n    },\r\n    _setColumnWidths: function(autoTableColumnStyles, pdfColumnWidths) {\r\n        pdfColumnWidths.forEach(((width, index) => {\r\n            autoTableColumnStyles[index] = autoTableColumnStyles[index] || {};\r\n            autoTableColumnStyles[index].cellWidth = width\r\n        }))\r\n    }\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/autotable/export_data_grid.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined,\r\n    isObject\r\n} from \"../../../core/utils/type\";\r\nimport {\r\n    Export\r\n} from \"./export\";\r\n\r\nfunction _getFullOptions(options) {\r\n    if (!(isDefined(options) && isObject(options))) {\r\n        throw Error('The \"exportDataGrid\" method requires a configuration object.')\r\n    }\r\n    if (!(isDefined(options.component) && isObject(options.component) && \"dxDataGrid\" === options.component.NAME)) {\r\n        throw Error('The \"component\" field must contain a DataGrid instance.')\r\n    }\r\n    if (!isDefined(options.selectedRowsOnly)) {\r\n        options.selectedRowsOnly = false\r\n    }\r\n    return Export.getFullOptions(options)\r\n}\r\n\r\nfunction exportDataGrid(options) {\r\n    return Export.export(_getFullOptions(options))\r\n}\r\nexport {\r\n    exportDataGrid\r\n};\r\n", "/**\r\n * DevExtreme (esm/exporter/jspdf/export_gantt.js)\r\n * Version: 24.2.11\r\n * Build date: Mon Oct 13 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nfunction exportGantt(options) {\r\n    const component = options.component;\r\n    return null === component || void 0 === component ? void 0 : component.exportToPdf(options)\r\n}\r\nexport {\r\n    exportGantt\r\n};\r\n"],
  "mappings": "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",
  "names": ["cellInfo", "_getFullOptions", "exportDataGrid", "Export", "_getFullOptions", "Export", "exportDataGrid"]
}
