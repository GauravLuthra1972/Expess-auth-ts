import {
  data_grid_default
} from "./chunk-74TCYI2V.js";
import "./chunk-SXTCFAVG.js";
import {
  callbacks_default,
  config_default2 as config_default,
  dom_adapter_default,
  m_events_engine_default
} from "./chunk-QYBRL3PZ.js";
import {
  Comment,
  PatchFlags,
  createApp,
  defineComponent,
  h,
  toRaw
} from "./chunk-JEBGSWJT.js";
import "./chunk-PR4QN5HX.js";

// node_modules/devextreme/esm/common/core/events.js
var on = m_events_engine_default.on;
var one = m_events_engine_default.one;
var off = m_events_engine_default.off;
var trigger = m_events_engine_default.trigger;
var Event = m_events_engine_default.Event;

// node_modules/devextreme/esm/events/events.types.js
var triggerHandler = m_events_engine_default.triggerHandler;

// node_modules/devextreme-vue/esm/core/helpers.js
function getTemplatePropName(props, templateName) {
  for (const propName in props) {
    if (props[propName] === templateName) {
      return propName;
    }
  }
  return templateName;
}
function uppercaseFirst(value) {
  return value[0].toUpperCase() + value.substr(1);
}
function lowercaseFirst(value) {
  return value[0].toLowerCase() + value.substr(1);
}
function camelize(value) {
  return lowercaseFirst(value.split("-").map((v) => uppercaseFirst(v)).join(""));
}
function toComparable(value) {
  return value instanceof Date ? value.getTime() : value;
}
function isEqual(value1, value2) {
  if (toComparable(value1) === toComparable(value2)) {
    return true;
  }
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return value1.length === 0 && value2.length === 0;
  }
  return false;
}
function forEachChildNode(el, callback) {
  Array.prototype.slice.call(el.childNodes).forEach(callback);
}
function allKeysAreEqual(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  if (obj1Keys.length !== Object.keys(obj2).length) {
    return false;
  }
  for (const key of obj1Keys) {
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function getOptionValue(options, optionPath) {
  let value = options;
  optionPath.split(".").forEach((p) => {
    const optionInfo = getOptionInfo(p);
    if (value) {
      value = optionInfo.isCollection ? value[optionInfo.name] && value[optionInfo.name][optionInfo.index] : value[optionInfo.name];
    }
  });
  return value;
}
function getOptionInfo(name) {
  const parts = name.split("[");
  if (parts.length === 1) {
    return {
      isCollection: false,
      name,
      fullName: name
    };
  }
  return {
    isCollection: true,
    name: parts[0],
    fullName: name,
    index: Number(parts[1].slice(0, -1))
  };
}

// node_modules/devextreme-vue/esm/core/children-processing.js
function pullAllChildren(directChildren, allChildren, config2) {
  if (!directChildren || directChildren.length === 0) {
    return;
  }
  pullConfigComponents(directChildren, allChildren, config2);
}
function isFragment(node) {
  const { patchFlag } = node;
  return patchFlag === PatchFlags.KEYED_FRAGMENT || patchFlag === PatchFlags.UNKEYED_FRAGMENT || patchFlag === PatchFlags.STABLE_FRAGMENT || patchFlag === PatchFlags.BAIL;
}
function pullConfigComponents(children, nodes, ownerConfig) {
  children.forEach((node) => {
    if (isFragment(node) && Array.isArray(node.children)) {
      pullConfigComponents(node.children, nodes, ownerConfig);
    }
    if (!isFragment(node)) {
      nodes.push(node);
    }
    if (!node) {
      return;
    }
    const componentInfo = getComponentInfo(node);
    if (!componentInfo || !componentInfo.$_optionName) {
      return;
    }
    const componentChildren = configurationChildren(node);
    const initialValues = {
      ...componentInfo.$_predefinedProps,
      ...getNormalizedProps(node.props || {})
    };
    const config2 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
    node.$_config = config2;
    node.$_innerChanges = {};
    if (componentChildren) {
      pullConfigComponents(componentChildren, nodes, config2);
    }
  });
}

// node_modules/devextreme-vue/esm/core/vue-helper.js
var VMODEL_NAME = "modelValue";
function getChildren(component) {
  if (!hasChildren(component) || !component.$_config) {
    return [];
  }
  const children = component.$.subTree && component.$.subTree.children;
  if (!Array.isArray(children)) {
    return [];
  }
  return children.filter((child) => {
    if (!isFragment(child)) {
      return child;
    }
  });
}
function getComponentInfo(component) {
  return getConfigurationOptions(component);
}
function getNormalizedProps(props) {
  const result = {};
  for (const propName in props) {
    if (props.hasOwnProperty(propName)) {
      result[camelize(propName)] = props[propName];
    }
  }
  return result;
}
function configurationChildren(component) {
  if (!component.children || !component.children.default) {
    return [];
  }
  return findConfigurationComponents(component.children.default());
}
function configurationDefaultTemplate(node) {
  if (!node.children || node.children === "object" || !node.children.default) {
    return;
  }
  return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
}
function configurationTemplate(node) {
  return configurationDefaultTemplate(node);
}
function declaredTemplates(component) {
  return component.$slots;
}
function defaultSlots(component) {
  const templates = declaredTemplates(component);
  if (!templates.default) {
    return [];
  }
  return templates.default();
}
function mount(options, parent, el) {
  const template = createApp(options);
  template.provide("eventBus", parent.eventBus);
  setAppContext(template, parent);
  return template.mount(el);
}
function getComponentProps(component) {
  const props = component.$.vnode.props || {};
  return getNormalizedProps(props);
}
function getNodeOptions(component) {
  if (component.$) {
    return component.$.vnode;
  }
  return component;
}
function getNodeTypeOfComponent(component) {
  return component.$.vnode.type;
}
function getVModelValue(options) {
  return options[VMODEL_NAME];
}
function setVModel(config2) {
  const eventName = `update:${VMODEL_NAME}`;
  config2.model.prop = VMODEL_NAME;
  config2.model.event = eventName;
  config2.props.modelValue = {};
  config2.emits = { ...config2.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
  for (const prop in parentAppContext) {
    if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
      appContext[prop] = parentAppContext[prop];
    }
  }
}
function setAppContext(template, parent) {
  template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
  Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
  Object.assign(template._context.provides, parent.$.appContext.provides);
  template._context.config = parent.$.appContext.config;
  template._context.directives = parent.$.appContext.directives;
  template._context.mixins = parent.$.appContext.mixins;
  setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
  return children.filter((child) => {
    if (isFragment(child)) {
      return findConfigurationComponents(child.children || []);
    }
    const childType = child.type;
    if (childType && typeof childType === "object" && childType.$_optionName) {
      delete child.$_config;
      delete child.$_innerChanges;
      return child;
    }
  });
}
function hasInlineTemplate(children) {
  let hasTemplate2 = false;
  children.forEach((child) => {
    if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
      hasTemplate2 = true;
    }
  });
  return hasTemplate2;
}
function isComment(node) {
  return node.type === Comment || node.type.toString() === "Symbol()" && !node.children;
}
function isConfiguration(child) {
  return child.type && typeof child.type === "object" && child.type.$_optionName;
}
function getConfigurationOptions(node) {
  return node.type;
}
function hasChildren(component) {
  return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}

// node_modules/devextreme-vue/esm/core/config.js
var config = {
  deepWatch: false
};
function getOption(optionName) {
  return config[optionName];
}

// node_modules/devextreme-vue/esm/core/configuration.js
var Configuration = class _Configuration {
  constructor(updateFunc, name, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
    this._updateFunc = updateFunc;
    this._name = name;
    this._initialValues = initialValues || {};
    this._nestedConfigurations = [];
    this._isCollectionItem = !!isCollectionItem;
    this._collectionItemIndex = collectionItemIndex;
    this._expectedChildren = expectedChildren || {};
    this._ownerConfig = ownerConfig;
    this._componentChanges = [];
    this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig && this._ownerConfig.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(options) {
    this._options = options || [];
  }
  set emitOptionChanged(handler) {
    this._emitOptionChanged = handler;
  }
  setPrevNestedOptions(value) {
    this._prevNestedConfigOptions = value;
  }
  onOptionChanged(args) {
    if (isEqual(args.value, args.previousValue)) {
      return;
    }
    this._onOptionChanged(args.fullName.split("."), args);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(name, initialValues, isCollectionItem, expectedChildren) {
    const expected = this._expectedChildren[name];
    let actualName = name;
    let actualIsCollectionItem = isCollectionItem;
    if (expected) {
      actualIsCollectionItem = expected.isCollectionItem;
      if (expected.optionName) {
        actualName = expected.optionName;
      }
    }
    let collectionItemIndex = -1;
    if (actualIsCollectionItem && actualName) {
      collectionItemIndex = this._nestedConfigurations.filter((c) => c._name && c._name === actualName).length;
    }
    const configuration = new _Configuration(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
    this._nestedConfigurations.push(configuration);
    return configuration;
  }
  updateValue(nestedName, value) {
    const fullName = [this.fullPath, nestedName].filter((n) => n).join(".");
    this._updateFunc(fullName, value);
  }
  getNestedOptionValues() {
    const values = {};
    this._nestedConfigurations.forEach((o) => {
      if (!o._name) {
        return;
      }
      const nestedValue = { ...o.initialValues, ...o.getNestedOptionValues() };
      if (!nestedValue) {
        return;
      }
      if (!o._isCollectionItem) {
        values[o._name] = nestedValue;
      } else {
        let arr = values[o._name];
        if (!arr || !Array.isArray(arr)) {
          arr = [];
          values[o._name] = arr;
        }
        arr.push(nestedValue);
      }
    });
    return values;
  }
  getOptionsToWatch() {
    const blackList = {};
    this._nestedConfigurations.forEach((c) => c._name && (blackList[c._name] = true));
    return this._options.filter((o) => !blackList[o]);
  }
  _onOptionChanged(optionRelPath, args) {
    if (optionRelPath.length === 0) {
      return;
    }
    const optionInfo = getOptionInfo(optionRelPath[0]);
    if (optionInfo.isCollection || optionRelPath.length > 1) {
      const nestedConfig = this._getNestedConfig(optionInfo.fullName);
      if (nestedConfig) {
        nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
        return;
      }
      this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? `${this.fullPath}.${optionInfo.name}` : optionInfo.name));
    } else {
      this._tryEmitOptionChanged(optionInfo.name, args.value);
    }
  }
  _getNestedConfig(fullName) {
    for (const nestedConfig of this._nestedConfigurations) {
      if (nestedConfig.fullName === fullName) {
        return nestedConfig;
      }
    }
    return void 0;
  }
  _tryEmitOptionChanged(name, value) {
    if (this._emitOptionChanged) {
      this._emitOptionChanged(name, value);
    }
  }
};
function bindOptionWatchers(config2, vueInstance, innerChanges) {
  const targets = config2 && config2.getOptionsToWatch();
  if (targets) {
    targets.forEach((optionName) => {
      vueInstance.$watch(optionName, (value) => {
        const rawValue = toRaw(value);
        if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
          config2.updateValue(optionName, value);
        }
        delete innerChanges[optionName];
      }, { deep: getOption("deepWatch") });
    });
  }
}
function hasProp(vueInstance, propName) {
  const { props } = vueInstance.$options;
  return props && props.hasOwnProperty(propName);
}
function hasVModelValue(options, props, vnode) {
  return options.model && props.hasOwnProperty(VMODEL_NAME) && vnode?.props?.hasOwnProperty(VMODEL_NAME);
}
function setEmitOptionChangedFunc(config2, vueInstance, innerChanges) {
  config2.emitOptionChanged = (name, value) => {
    const props = vueInstance.$props;
    const vnode = vueInstance?.$?.vnode;
    const propsName = name === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? VMODEL_NAME : name;
    const eventName = `update:${propsName}`;
    if (hasProp(vueInstance, name) && !isEqual(value, props[propsName]) && vueInstance.$emit) {
      innerChanges[propsName] = toRaw(value);
      vueInstance.$emit(eventName, value);
    }
  };
}
var configuration_default = Configuration;

// node_modules/devextreme-vue/esm/core/configuration-component.js
function getConfig(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_config || vueInstance.$_config;
}
function getInnerChanges(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
}
function initOptionChangedFunc(config2, props, vueInstance, innerChanges) {
  if (!config2) {
    return;
  }
  config2.init(Object.keys(props));
  if (vueInstance) {
    setEmitOptionChangedFunc(config2, vueInstance, innerChanges);
  }
}
function getComponentInfo2({ name, isCollectionItem, ownerConfig }, removed) {
  const parentPath = ownerConfig && ownerConfig.fullPath;
  const optionPath = name && parentPath ? `${parentPath}.${name}` : name || "";
  return {
    optionPath,
    isCollection: isCollectionItem,
    removed
  };
}
function initDxConfiguration() {
  return defineComponent({
    beforeMount() {
      const thisComponent = this;
      const config2 = getConfig(thisComponent);
      const innerChanges = getInnerChanges(thisComponent);
      initOptionChangedFunc(config2, getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
      bindOptionWatchers(config2, this, innerChanges);
    },
    mounted() {
      if (this.$parent.$_instance) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(getConfig(this)));
      }
    },
    beforeUnmount() {
      const config2 = getConfig(this);
      if (config2) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(config2, true));
      }
    },
    render() {
      return null;
    }
  });
}

// node_modules/devextreme-vue/esm/core/constants.js
var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_REMOVE_EVENT = "dxremove";

// node_modules/devextreme-vue/esm/core/templates-discovering.js
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
  const componentOptions = component;
  if (!componentOptions) {
    return;
  }
  if (!componentOptions.$_config || !componentOptions.$_config.name) {
    return void 0;
  }
  return componentOptions;
}
function hasTemplate(component) {
  return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
  const templates = {};
  const namedTeplates = declaredTemplates(component);
  for (const slotName in namedTeplates) {
    if (slotName === "default" && component.$slots.default) {
      continue;
    }
    const slot = namedTeplates[slotName];
    if (!slot) {
      continue;
    }
    templates[slotName] = slot;
  }
  const componentChildren = getChildren(component);
  for (const childComponent of componentChildren) {
    const configurable = asConfigurable(childComponent);
    if (!configurable) {
      continue;
    }
    const defaultSlot = configurationDefaultTemplate(childComponent);
    if (!defaultSlot || !hasTemplate(childComponent)) {
      continue;
    }
    const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
    templates[templateName] = defaultSlot;
  }
  return templates;
}
function clearConfiguration(content) {
  const newContent = [];
  content.forEach((item) => {
    const configurable = getConfigurationOptions(item);
    if (!configurable || !configurable.$_optionName) {
      newContent.push(item);
    }
  });
  return newContent;
}
function mountTemplate(getSlot, parent, data, name, placeholder) {
  return mount({
    name,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      data.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const content = clearConfiguration(getSlot()(data));
      if (!content) {
        return h("div");
      }
      return content.length > 1 ? content : content[0];
    }
  }, parent, placeholder);
}

// node_modules/devextreme-vue/esm/core/templates-manager.js
var TemplatesManager = class {
  constructor(component) {
    this._slots = {};
    this._templates = {};
    this._isDirty = false;
    this._component = component;
    this.discover();
  }
  discover() {
    this._slots = {
      ...discover(this._component)
    };
    if (!allKeysAreEqual(this._templates, this._slots)) {
      this._prepareTemplates();
    }
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = false;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const name of Object.keys(this._slots)) {
      this._templates[name] = this.createDxTemplate(name);
    }
    this._isDirty = true;
  }
  createDxTemplate(name) {
    return {
      render: (data) => {
        const rendered = /* @__PURE__ */ ((onRendered, counter = 0) => () => {
          if (counter === 1 && onRendered) {
            onRendered();
          }
          counter++;
        })(data.onRendered);
        const scopeData = { data: data.model, index: data.index, onRendered: rendered };
        const placeholder = document.createElement("div");
        const container = data.container.get ? data.container.get(0) : data.container;
        container.appendChild(placeholder);
        const mountedTemplate = mountTemplate(() => this._slots[name], this._component, scopeData, name, placeholder);
        const element = mountedTemplate.$el;
        container.removeChild(placeholder);
        while (placeholder.firstChild) {
          container.appendChild(placeholder.firstChild);
        }
        dom_adapter_default.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);
        if (element.nodeType === Node.TEXT_NODE) {
          const removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
          removalListener.style.display = "none";
          container.insertBefore(removalListener, container.firstChild);
          one(removalListener, DX_REMOVE_EVENT, () => {
            mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate)();
            removalListener.remove();
          });
        } else {
          one(element, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        }
        rendered();
        return element;
      }
    };
  }
};

// node_modules/devextreme-vue/esm/core/component.js
var includeAttrs = ["id", "class", "style"];
var dxClassesPrefix = "dx-";
config_default({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx",
  licensingDocLink: "https://go.devexpress.com/Licensing_Documentation_DevExtremeVue.aspx"
});
function parseClassList(classList) {
  return classList.trim().split(/\s+/);
}
function prepareAttrs(attrs, dxClassesSyncedWithClassAttr) {
  const attributes = {};
  includeAttrs.forEach((attr) => {
    const attrValue = attrs[attr];
    if (attrValue !== void 0 && attrValue !== null) {
      if (attr === "class") {
        const nonDXClassesFromAttr = attrValue.split(" ").filter((classFromAttr) => !classFromAttr.startsWith(dxClassesPrefix)).join(" ");
        attributes[attr] = [nonDXClassesFromAttr, dxClassesSyncedWithClassAttr].filter((item) => item !== "").join(" ");
      } else {
        attributes[attr] = attrValue;
      }
    }
  });
  return attributes;
}
function initBaseComponent() {
  return defineComponent({
    inheritAttrs: false,
    data() {
      return {
        eventBus: callbacks_default(),
        prevClassAttr: ""
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const thisComponent = this;
      const children = [];
      const dxClasses = pickOutDxClasses(this.$el) || [];
      if (thisComponent.$_config.cleanNested) {
        thisComponent.$_config.cleanNested();
      }
      pullAllChildren(defaultSlots(this), children, thisComponent.$_config);
      this.$_processChildren(children);
      return h("div", {
        ...prepareAttrs(this.$attrs, dxClasses.join(" "))
      }, children);
    },
    beforeUpdate() {
      const thisComponent = this;
      thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
      this.$_syncElementClassesWithClassAttr();
    },
    updated() {
      const thisComponent = this;
      const nodes = cleanWidgetNode(this.$el);
      getChildren(thisComponent).forEach((child) => {
        initOptionChangedFunc(child.$_config, child.type.props || {}, child?.component?.proxy, child.$_innerChanges);
      });
      thisComponent.$_templatesManager.discover();
      thisComponent.$_instance.beginUpdate();
      this.$_applyConfigurationChanges();
      if (thisComponent.$_templatesManager.isDirty) {
        thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
        const { props } = thisComponent.$.vnode;
        for (const name of Object.keys(thisComponent.$_templatesManager.templates)) {
          thisComponent.$_instance.option(getTemplatePropName(props, name), name);
        }
        thisComponent.$_templatesManager.resetDirtyFlag();
      }
      for (const name of Object.keys(thisComponent.$_pendingOptions)) {
        thisComponent.$_instance.option(name, thisComponent.$_pendingOptions[name]);
      }
      thisComponent.$_pendingOptions = {};
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      this.eventBus.fire();
    },
    beforeUnmount() {
      const thisComponent = this;
      const instance = thisComponent.$_instance;
      if (instance) {
        triggerHandler(this.$el, DX_REMOVE_EVENT);
        instance.dispose();
      }
    },
    created() {
      const thisComponent = this;
      const props = getComponentProps(this);
      thisComponent.$_config = new configuration_default((n, v) => {
        if (Array.isArray(v)) {
          thisComponent.$_instance.option(n, v);
        } else {
          thisComponent.$_pendingOptions[n === VMODEL_NAME ? "value" : n] = v;
        }
      }, null, props && { ...props }, thisComponent.$_expectedChildren);
      thisComponent.$_innerChanges = {};
      thisComponent.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_syncElementClassesWithClassAttr() {
        const newClassAttr = typeof this.$attrs?.class === "string" ? this.$attrs?.class : "";
        if (this.prevClassAttr === newClassAttr) {
          return;
        }
        if (this.prevClassAttr.length) {
          this.$el.classList.remove(...parseClassList(this.prevClassAttr));
        }
        if (newClassAttr.length) {
          this.$el.classList.add(...parseClassList(newClassAttr));
        }
        this.prevClassAttr = newClassAttr;
      },
      $_applyConfigurationChanges() {
        const thisComponent = this;
        thisComponent.$_config.componentsCountChanged.forEach(({ optionPath, isCollection, removed }) => {
          const options = thisComponent.$_config.getNestedOptionValues();
          if (!isCollection && removed) {
            thisComponent.$_instance.resetOption(optionPath);
          } else {
            thisComponent.$_instance.option(optionPath, getOptionValue(options, optionPath));
          }
        });
        thisComponent.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(element) {
        const thisComponent = this;
        thisComponent.$_pendingOptions = {};
        thisComponent.$_templatesManager = new TemplatesManager(this);
        const widgetConfig = thisComponent.$_config;
        if (widgetConfig.initialValues.hasOwnProperty(VMODEL_NAME)) {
          widgetConfig.initialValues.value = getVModelValue(widgetConfig.initialValues);
        }
        const options = {
          templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate,
          ...getComponentProps(thisComponent),
          ...widgetConfig.initialValues,
          ...widgetConfig.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        };
        const instance = new thisComponent.$_WidgetClass(element, options);
        thisComponent.$_instance = instance;
        instance.on("optionChanged", (args) => widgetConfig.onOptionChanged(args));
        setEmitOptionChangedFunc(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        bindOptionWatchers(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        this.$_createEmitters(instance);
      },
      $_getIntegrationOptions() {
        const thisComponent = this;
        const result = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (thisComponent.$_templatesManager.isDirty) {
          const { templates } = thisComponent.$_templatesManager;
          result.integrationOptions.templates = templates;
          const { props } = thisComponent.$.vnode;
          for (const name of Object.keys(templates)) {
            result[getTemplatePropName(props, name)] = name;
          }
          thisComponent.$_templatesManager.resetDirtyFlag();
        }
        return result;
      },
      $_getWatchMethod() {
        return (valueGetter, valueChangeCallback, options) => {
          options = options || {};
          if (!options.skipImmediate) {
            valueChangeCallback(valueGetter());
          }
          return this.$watch(() => valueGetter(), (newValue, oldValue) => {
            if (toComparable(oldValue) !== toComparable(newValue) || options.deep) {
              valueChangeCallback(newValue);
            }
          }, {
            deep: options.deep
          });
        };
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(_children) {
      },
      $_createEmitters(instance) {
        if (this.$attrs) {
          Object.keys(this.$attrs).forEach((listenerName) => {
            const eventName = camelize(listenerName);
            instance.on(eventName, (e) => {
              this.$emit(listenerName, e);
            });
          });
        }
      }
    }
  });
}
function cleanWidgetNode(node) {
  const removedNodes = [];
  forEachChildNode(node, (childNode) => {
    const parent = childNode.parentNode;
    const isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
    if ((childNode.nodeName === "#comment" || isExtension) && parent) {
      removedNodes.push(childNode);
      parent.removeChild(childNode);
    }
  });
  return removedNodes;
}
function pickOutDxClasses(el) {
  return el && Array.from(el.classList).filter((item) => item.startsWith(dxClassesPrefix));
}
function restoreNodes(el, nodes) {
  nodes.forEach((node) => {
    el.appendChild(node);
  });
}
function initDxComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(children) {
        children.forEach((childNode) => {
          if (!childNode || typeof childNode !== "object") {
            return;
          }
          childNode.$_hasOwner = true;
        });
      }
    },
    mounted() {
      const nodes = cleanWidgetNode(this.$el);
      const thisComponent = this;
      this.$_createWidget(this.$el);
      this.$_syncElementClassesWithClassAttr();
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      if (this.$slots && this.$slots.default) {
        getChildren(thisComponent).forEach((child) => {
          const childExtenton = child;
          if (childExtenton && childExtenton.$_isExtension) {
            childExtenton.$_attachTo(this.$el);
          }
        });
      }
    }
  });
}

// node_modules/devextreme-vue/esm/core/index.js
function prepareComponentConfig(config2) {
  config2.extends = initDxComponent();
  if (config2.model) {
    setVModel(config2);
  }
}
function prepareConfigurationComponentConfig(config2) {
  config2.extends = initDxConfiguration();
}

// node_modules/devextreme-vue/esm/data-grid.js
var componentConfig = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowColumnReordering: Boolean,
    allowColumnResizing: Boolean,
    autoNavigateToFocusedRow: Boolean,
    cacheEnabled: Boolean,
    cellHintEnabled: Boolean,
    columnAutoWidth: Boolean,
    columnChooser: Object,
    columnFixing: Object,
    columnHidingEnabled: Boolean,
    columnMinWidth: Number,
    columnResizingMode: String,
    columns: Array,
    columnWidth: [String, Number],
    customizeColumns: Function,
    dataRowTemplate: {},
    dataSource: [Array, Object, String],
    dateSerializationFormat: String,
    disabled: Boolean,
    editing: Object,
    elementAttr: Object,
    errorRowEnabled: Boolean,
    export: Object,
    filterBuilder: Object,
    filterBuilderPopup: Object,
    filterPanel: Object,
    filterRow: Object,
    filterSyncEnabled: [Boolean, String],
    filterValue: [Array, Function, String],
    focusedColumnIndex: Number,
    focusedRowEnabled: Boolean,
    focusedRowIndex: Number,
    focusedRowKey: {},
    grouping: Object,
    groupPanel: Object,
    headerFilter: Object,
    height: [Function, Number, String],
    highlightChanges: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    keyboardNavigation: Object,
    keyExpr: [Array, String],
    loadPanel: Object,
    masterDetail: Object,
    noDataText: String,
    onAdaptiveDetailRowPreparing: Function,
    onCellClick: Function,
    onCellDblClick: Function,
    onCellHoverChanged: Function,
    onCellPrepared: Function,
    onContentReady: Function,
    onContextMenuPreparing: Function,
    onDataErrorOccurred: Function,
    onDisposing: Function,
    onEditCanceled: Function,
    onEditCanceling: Function,
    onEditingStart: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onExporting: Function,
    onFocusedCellChanged: Function,
    onFocusedCellChanging: Function,
    onFocusedRowChanged: Function,
    onFocusedRowChanging: Function,
    onInitialized: Function,
    onInitNewRow: Function,
    onKeyDown: Function,
    onOptionChanged: Function,
    onRowClick: Function,
    onRowCollapsed: Function,
    onRowCollapsing: Function,
    onRowDblClick: Function,
    onRowExpanded: Function,
    onRowExpanding: Function,
    onRowInserted: Function,
    onRowInserting: Function,
    onRowPrepared: Function,
    onRowRemoved: Function,
    onRowRemoving: Function,
    onRowUpdated: Function,
    onRowUpdating: Function,
    onRowValidating: Function,
    onSaved: Function,
    onSaving: Function,
    onSelectionChanged: Function,
    onToolbarPreparing: Function,
    pager: Object,
    paging: Object,
    remoteOperations: [Boolean, String, Object],
    renderAsync: Boolean,
    repaintChangesOnly: Boolean,
    rowAlternationEnabled: Boolean,
    rowDragging: Object,
    rowTemplate: {},
    rtlEnabled: Boolean,
    scrolling: Object,
    searchPanel: Object,
    selectedRowKeys: Array,
    selection: Object,
    selectionFilter: [Array, Function, String],
    showBorders: Boolean,
    showColumnHeaders: Boolean,
    showColumnLines: Boolean,
    showRowLines: Boolean,
    sortByGroupSummaryInfo: Array,
    sorting: Object,
    stateStoring: Object,
    summary: Object,
    syncLookupFilterValues: Boolean,
    tabIndex: Number,
    toolbar: Object,
    twoWayBindingEnabled: Boolean,
    visible: Boolean,
    width: [Function, Number, String],
    wordWrapEnabled: Boolean
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowColumnReordering": null,
    "update:allowColumnResizing": null,
    "update:autoNavigateToFocusedRow": null,
    "update:cacheEnabled": null,
    "update:cellHintEnabled": null,
    "update:columnAutoWidth": null,
    "update:columnChooser": null,
    "update:columnFixing": null,
    "update:columnHidingEnabled": null,
    "update:columnMinWidth": null,
    "update:columnResizingMode": null,
    "update:columns": null,
    "update:columnWidth": null,
    "update:customizeColumns": null,
    "update:dataRowTemplate": null,
    "update:dataSource": null,
    "update:dateSerializationFormat": null,
    "update:disabled": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:errorRowEnabled": null,
    "update:export": null,
    "update:filterBuilder": null,
    "update:filterBuilderPopup": null,
    "update:filterPanel": null,
    "update:filterRow": null,
    "update:filterSyncEnabled": null,
    "update:filterValue": null,
    "update:focusedColumnIndex": null,
    "update:focusedRowEnabled": null,
    "update:focusedRowIndex": null,
    "update:focusedRowKey": null,
    "update:grouping": null,
    "update:groupPanel": null,
    "update:headerFilter": null,
    "update:height": null,
    "update:highlightChanges": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:keyboardNavigation": null,
    "update:keyExpr": null,
    "update:loadPanel": null,
    "update:masterDetail": null,
    "update:noDataText": null,
    "update:onAdaptiveDetailRowPreparing": null,
    "update:onCellClick": null,
    "update:onCellDblClick": null,
    "update:onCellHoverChanged": null,
    "update:onCellPrepared": null,
    "update:onContentReady": null,
    "update:onContextMenuPreparing": null,
    "update:onDataErrorOccurred": null,
    "update:onDisposing": null,
    "update:onEditCanceled": null,
    "update:onEditCanceling": null,
    "update:onEditingStart": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onExporting": null,
    "update:onFocusedCellChanged": null,
    "update:onFocusedCellChanging": null,
    "update:onFocusedRowChanged": null,
    "update:onFocusedRowChanging": null,
    "update:onInitialized": null,
    "update:onInitNewRow": null,
    "update:onKeyDown": null,
    "update:onOptionChanged": null,
    "update:onRowClick": null,
    "update:onRowCollapsed": null,
    "update:onRowCollapsing": null,
    "update:onRowDblClick": null,
    "update:onRowExpanded": null,
    "update:onRowExpanding": null,
    "update:onRowInserted": null,
    "update:onRowInserting": null,
    "update:onRowPrepared": null,
    "update:onRowRemoved": null,
    "update:onRowRemoving": null,
    "update:onRowUpdated": null,
    "update:onRowUpdating": null,
    "update:onRowValidating": null,
    "update:onSaved": null,
    "update:onSaving": null,
    "update:onSelectionChanged": null,
    "update:onToolbarPreparing": null,
    "update:pager": null,
    "update:paging": null,
    "update:remoteOperations": null,
    "update:renderAsync": null,
    "update:repaintChangesOnly": null,
    "update:rowAlternationEnabled": null,
    "update:rowDragging": null,
    "update:rowTemplate": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:searchPanel": null,
    "update:selectedRowKeys": null,
    "update:selection": null,
    "update:selectionFilter": null,
    "update:showBorders": null,
    "update:showColumnHeaders": null,
    "update:showColumnLines": null,
    "update:showRowLines": null,
    "update:sortByGroupSummaryInfo": null,
    "update:sorting": null,
    "update:stateStoring": null,
    "update:summary": null,
    "update:syncLookupFilterValues": null,
    "update:tabIndex": null,
    "update:toolbar": null,
    "update:twoWayBindingEnabled": null,
    "update:visible": null,
    "update:width": null,
    "update:wordWrapEnabled": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = data_grid_default;
    this.$_hasAsyncTemplate = false;
    this.$_expectedChildren = {
      column: { isCollectionItem: true, optionName: "columns" },
      columnChooser: { isCollectionItem: false, optionName: "columnChooser" },
      columnFixing: { isCollectionItem: false, optionName: "columnFixing" },
      dataGridHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
      dataGridSelection: { isCollectionItem: false, optionName: "selection" },
      editing: { isCollectionItem: false, optionName: "editing" },
      export: { isCollectionItem: false, optionName: "export" },
      filterBuilder: { isCollectionItem: false, optionName: "filterBuilder" },
      filterBuilderPopup: { isCollectionItem: false, optionName: "filterBuilderPopup" },
      filterPanel: { isCollectionItem: false, optionName: "filterPanel" },
      filterRow: { isCollectionItem: false, optionName: "filterRow" },
      grouping: { isCollectionItem: false, optionName: "grouping" },
      groupPanel: { isCollectionItem: false, optionName: "groupPanel" },
      headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
      keyboardNavigation: { isCollectionItem: false, optionName: "keyboardNavigation" },
      loadPanel: { isCollectionItem: false, optionName: "loadPanel" },
      masterDetail: { isCollectionItem: false, optionName: "masterDetail" },
      pager: { isCollectionItem: false, optionName: "pager" },
      paging: { isCollectionItem: false, optionName: "paging" },
      remoteOperations: { isCollectionItem: false, optionName: "remoteOperations" },
      rowDragging: { isCollectionItem: false, optionName: "rowDragging" },
      scrolling: { isCollectionItem: false, optionName: "scrolling" },
      searchPanel: { isCollectionItem: false, optionName: "searchPanel" },
      selection: { isCollectionItem: false, optionName: "selection" },
      sortByGroupSummaryInfo: { isCollectionItem: true, optionName: "sortByGroupSummaryInfo" },
      sorting: { isCollectionItem: false, optionName: "sorting" },
      stateStoring: { isCollectionItem: false, optionName: "stateStoring" },
      summary: { isCollectionItem: false, optionName: "summary" },
      toolbar: { isCollectionItem: false, optionName: "toolbar" }
    };
  }
};
prepareComponentConfig(componentConfig);
var DxDataGrid = defineComponent(componentConfig);
var DxAnimationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
prepareConfigurationComponentConfig(DxAnimationConfig);
var DxAnimation = defineComponent(DxAnimationConfig);
DxAnimation.$_optionName = "animation";
DxAnimation.$_expectedChildren = {
  hide: { isCollectionItem: false, optionName: "hide" },
  show: { isCollectionItem: false, optionName: "show" }
};
var DxAsyncRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxAsyncRuleConfig);
var DxAsyncRule = defineComponent(DxAsyncRuleConfig);
DxAsyncRule.$_optionName = "validationRules";
DxAsyncRule.$_isCollectionItem = true;
DxAsyncRule.$_predefinedProps = {
  type: "async"
};
var DxAtConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxAtConfig);
var DxAt = defineComponent(DxAtConfig);
DxAt.$_optionName = "at";
var DxBoundaryOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxBoundaryOffsetConfig);
var DxBoundaryOffset = defineComponent(DxBoundaryOffsetConfig);
DxBoundaryOffset.$_optionName = "boundaryOffset";
var DxButtonConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:hint": null,
    "update:icon": null,
    "update:name": null,
    "update:onClick": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    cssClass: String,
    disabled: [Boolean, Function],
    hint: String,
    icon: String,
    name: String,
    onClick: Function,
    template: {},
    text: String,
    visible: [Boolean, Function]
  }
};
prepareConfigurationComponentConfig(DxButtonConfig);
var DxButton = defineComponent(DxButtonConfig);
DxButton.$_optionName = "buttons";
DxButton.$_isCollectionItem = true;
var DxChangeConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:data": null,
    "update:insertAfterKey": null,
    "update:insertBeforeKey": null,
    "update:type": null
  },
  props: {
    data: {},
    insertAfterKey: {},
    insertBeforeKey: {},
    type: String
  }
};
prepareConfigurationComponentConfig(DxChangeConfig);
var DxChange = defineComponent(DxChangeConfig);
DxChange.$_optionName = "changes";
DxChange.$_isCollectionItem = true;
var DxColCountByScreenConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:lg": null,
    "update:md": null,
    "update:sm": null,
    "update:xs": null
  },
  props: {
    lg: Number,
    md: Number,
    sm: Number,
    xs: Number
  }
};
prepareConfigurationComponentConfig(DxColCountByScreenConfig);
var DxColCountByScreen = defineComponent(DxColCountByScreenConfig);
DxColCountByScreen.$_optionName = "colCountByScreen";
var DxCollisionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxCollisionConfig);
var DxCollision = defineComponent(DxCollisionConfig);
DxCollision.$_optionName = "collision";
var DxColumnConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:allowEditing": null,
    "update:allowExporting": null,
    "update:allowFiltering": null,
    "update:allowFixing": null,
    "update:allowGrouping": null,
    "update:allowHeaderFiltering": null,
    "update:allowHiding": null,
    "update:allowReordering": null,
    "update:allowResizing": null,
    "update:allowSearch": null,
    "update:allowSorting": null,
    "update:autoExpandGroup": null,
    "update:buttons": null,
    "update:calculateCellValue": null,
    "update:calculateDisplayValue": null,
    "update:calculateFilterExpression": null,
    "update:calculateGroupValue": null,
    "update:calculateSortValue": null,
    "update:caption": null,
    "update:cellTemplate": null,
    "update:columns": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editCellTemplate": null,
    "update:editorOptions": null,
    "update:encodeHtml": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:filterType": null,
    "update:filterValue": null,
    "update:filterValues": null,
    "update:fixed": null,
    "update:fixedPosition": null,
    "update:format": null,
    "update:formItem": null,
    "update:groupCellTemplate": null,
    "update:groupIndex": null,
    "update:headerCellTemplate": null,
    "update:headerFilter": null,
    "update:hidingPriority": null,
    "update:isBand": null,
    "update:lookup": null,
    "update:minWidth": null,
    "update:name": null,
    "update:ownerBand": null,
    "update:renderAsync": null,
    "update:selectedFilterOperation": null,
    "update:setCellValue": null,
    "update:showEditorAlways": null,
    "update:showInColumnChooser": null,
    "update:showWhenGrouped": null,
    "update:sortIndex": null,
    "update:sortingMethod": null,
    "update:sortOrder": null,
    "update:trueText": null,
    "update:type": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null,
    "update:width": null
  },
  props: {
    alignment: String,
    allowEditing: Boolean,
    allowExporting: Boolean,
    allowFiltering: Boolean,
    allowFixing: Boolean,
    allowGrouping: Boolean,
    allowHeaderFiltering: Boolean,
    allowHiding: Boolean,
    allowReordering: Boolean,
    allowResizing: Boolean,
    allowSearch: Boolean,
    allowSorting: Boolean,
    autoExpandGroup: Boolean,
    buttons: Array,
    calculateCellValue: Function,
    calculateDisplayValue: [Function, String],
    calculateFilterExpression: Function,
    calculateGroupValue: [Function, String],
    calculateSortValue: [Function, String],
    caption: String,
    cellTemplate: {},
    columns: Array,
    cssClass: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editCellTemplate: {},
    editorOptions: {},
    encodeHtml: Boolean,
    falseText: String,
    filterOperations: Array,
    filterType: String,
    filterValue: {},
    filterValues: Array,
    fixed: Boolean,
    fixedPosition: String,
    format: [Object, String, Function],
    formItem: Object,
    groupCellTemplate: {},
    groupIndex: Number,
    headerCellTemplate: {},
    headerFilter: Object,
    hidingPriority: Number,
    isBand: Boolean,
    lookup: Object,
    minWidth: Number,
    name: String,
    ownerBand: Number,
    renderAsync: Boolean,
    selectedFilterOperation: String,
    setCellValue: Function,
    showEditorAlways: Boolean,
    showInColumnChooser: Boolean,
    showWhenGrouped: Boolean,
    sortIndex: Number,
    sortingMethod: Function,
    sortOrder: String,
    trueText: String,
    type: String,
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnConfig);
var DxColumn = defineComponent(DxColumnConfig);
DxColumn.$_optionName = "columns";
DxColumn.$_isCollectionItem = true;
DxColumn.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  button: { isCollectionItem: true, optionName: "buttons" },
  columnHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
  columnLookup: { isCollectionItem: false, optionName: "lookup" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  format: { isCollectionItem: false, optionName: "format" },
  formItem: { isCollectionItem: false, optionName: "formItem" },
  headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
  lookup: { isCollectionItem: false, optionName: "lookup" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxColumnChooserConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:container": null,
    "update:emptyPanelText": null,
    "update:enabled": null,
    "update:height": null,
    "update:mode": null,
    "update:position": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:selection": null,
    "update:sortOrder": null,
    "update:title": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    container: {},
    emptyPanelText: String,
    enabled: Boolean,
    height: [Number, String],
    mode: String,
    position: Object,
    search: Object,
    searchTimeout: Number,
    selection: Object,
    sortOrder: String,
    title: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnChooserConfig);
var DxColumnChooser = defineComponent(DxColumnChooserConfig);
DxColumnChooser.$_optionName = "columnChooser";
DxColumnChooser.$_expectedChildren = {
  columnChooserSearch: { isCollectionItem: false, optionName: "search" },
  columnChooserSelection: { isCollectionItem: false, optionName: "selection" },
  position: { isCollectionItem: false, optionName: "position" },
  search: { isCollectionItem: false, optionName: "search" },
  selection: { isCollectionItem: false, optionName: "selection" }
};
var DxColumnChooserSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSearchConfig);
var DxColumnChooserSearch = defineComponent(DxColumnChooserSearchConfig);
DxColumnChooserSearch.$_optionName = "search";
var DxColumnChooserSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:recursive": null,
    "update:selectByClick": null
  },
  props: {
    allowSelectAll: Boolean,
    recursive: Boolean,
    selectByClick: Boolean
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSelectionConfig);
var DxColumnChooserSelection = defineComponent(DxColumnChooserSelectionConfig);
DxColumnChooserSelection.$_optionName = "selection";
var DxColumnFixingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:icons": null,
    "update:texts": null
  },
  props: {
    enabled: Boolean,
    icons: Object,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxColumnFixingConfig);
var DxColumnFixing = defineComponent(DxColumnFixingConfig);
DxColumnFixing.$_optionName = "columnFixing";
DxColumnFixing.$_expectedChildren = {
  columnFixingTexts: { isCollectionItem: false, optionName: "texts" },
  icons: { isCollectionItem: false, optionName: "icons" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxColumnFixingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxColumnFixingTextsConfig);
var DxColumnFixingTexts = defineComponent(DxColumnFixingTextsConfig);
DxColumnFixingTexts.$_optionName = "texts";
var DxColumnHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterConfig);
var DxColumnHeaderFilter = defineComponent(DxColumnHeaderFilterConfig);
DxColumnHeaderFilter.$_optionName = "headerFilter";
DxColumnHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  search: { isCollectionItem: false, optionName: "search" }
};
var DxColumnHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterSearchConfig);
var DxColumnHeaderFilterSearch = defineComponent(DxColumnHeaderFilterSearchConfig);
DxColumnHeaderFilterSearch.$_optionName = "search";
var DxColumnLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: String
  }
};
prepareConfigurationComponentConfig(DxColumnLookupConfig);
var DxColumnLookup = defineComponent(DxColumnLookupConfig);
DxColumnLookup.$_optionName = "lookup";
var DxCompareRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxCompareRuleConfig);
var DxCompareRule = defineComponent(DxCompareRuleConfig);
DxCompareRule.$_optionName = "validationRules";
DxCompareRule.$_isCollectionItem = true;
DxCompareRule.$_predefinedProps = {
  type: "compare"
};
var DxCursorOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxCursorOffsetConfig);
var DxCursorOffset = defineComponent(DxCursorOffsetConfig);
DxCursorOffset.$_optionName = "cursorOffset";
var DxCustomOperationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataTypes": null,
    "update:editorTemplate": null,
    "update:hasValue": null,
    "update:icon": null,
    "update:name": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataTypes: Array,
    editorTemplate: {},
    hasValue: Boolean,
    icon: String,
    name: String
  }
};
prepareConfigurationComponentConfig(DxCustomOperationConfig);
var DxCustomOperation = defineComponent(DxCustomOperationConfig);
DxCustomOperation.$_optionName = "customOperations";
DxCustomOperation.$_isCollectionItem = true;
var DxCustomRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxCustomRuleConfig);
var DxCustomRule = defineComponent(DxCustomRuleConfig);
DxCustomRule.$_optionName = "validationRules";
DxCustomRule.$_isCollectionItem = true;
DxCustomRule.$_predefinedProps = {
  type: "custom"
};
var DxDataGridHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:height": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    height: [Number, String],
    search: Object,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterConfig);
var DxDataGridHeaderFilter = defineComponent(DxDataGridHeaderFilterConfig);
DxDataGridHeaderFilter.$_optionName = "headerFilter";
DxDataGridHeaderFilter.$_expectedChildren = {
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" },
  search: { isCollectionItem: false, optionName: "search" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxDataGridHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterSearchConfig);
var DxDataGridHeaderFilterSearch = defineComponent(DxDataGridHeaderFilterSearchConfig);
DxDataGridHeaderFilterSearch.$_optionName = "search";
var DxDataGridHeaderFilterTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cancel": null,
    "update:emptyValue": null,
    "update:ok": null
  },
  props: {
    cancel: String,
    emptyValue: String,
    ok: String
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterTextsConfig);
var DxDataGridHeaderFilterTexts = defineComponent(DxDataGridHeaderFilterTextsConfig);
DxDataGridHeaderFilterTexts.$_optionName = "texts";
var DxDataGridSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:selectAllMode": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    selectAllMode: String,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxDataGridSelectionConfig);
var DxDataGridSelection = defineComponent(DxDataGridSelectionConfig);
DxDataGridSelection.$_optionName = "selection";
var DxEditingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowUpdating": null,
    "update:changes": null,
    "update:confirmDelete": null,
    "update:editColumnName": null,
    "update:editRowKey": null,
    "update:form": null,
    "update:mode": null,
    "update:newRowPosition": null,
    "update:popup": null,
    "update:refreshMode": null,
    "update:selectTextOnEditStart": null,
    "update:startEditAction": null,
    "update:texts": null,
    "update:useIcons": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: [Boolean, Function],
    allowUpdating: [Boolean, Function],
    changes: Array,
    confirmDelete: Boolean,
    editColumnName: String,
    editRowKey: {},
    form: Object,
    mode: String,
    newRowPosition: String,
    popup: Object,
    refreshMode: String,
    selectTextOnEditStart: Boolean,
    startEditAction: String,
    texts: {},
    useIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxEditingConfig);
var DxEditing = defineComponent(DxEditingConfig);
DxEditing.$_optionName = "editing";
DxEditing.$_expectedChildren = {
  change: { isCollectionItem: true, optionName: "changes" },
  editingTexts: { isCollectionItem: false, optionName: "texts" },
  form: { isCollectionItem: false, optionName: "form" },
  popup: { isCollectionItem: false, optionName: "popup" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxEditingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:undeleteRow": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    deleteRow: String,
    editRow: String,
    saveAllChanges: String,
    saveRowChanges: String,
    undeleteRow: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxEditingTextsConfig);
var DxEditingTexts = defineComponent(DxEditingTextsConfig);
DxEditingTexts.$_optionName = "texts";
var DxEmailRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxEmailRuleConfig);
var DxEmailRule = defineComponent(DxEmailRuleConfig);
DxEmailRule.$_optionName = "validationRules";
DxEmailRule.$_isCollectionItem = true;
DxEmailRule.$_predefinedProps = {
  type: "email"
};
var DxExportConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowExportSelectedData": null,
    "update:enabled": null,
    "update:formats": null,
    "update:texts": null
  },
  props: {
    allowExportSelectedData: Boolean,
    enabled: Boolean,
    formats: Array,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxExportConfig);
var DxExport = defineComponent(DxExportConfig);
DxExport.$_optionName = "export";
DxExport.$_expectedChildren = {
  exportTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxExportTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null
  },
  props: {
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String
  }
};
prepareConfigurationComponentConfig(DxExportTextsConfig);
var DxExportTexts = defineComponent(DxExportTextsConfig);
DxExportTexts.$_optionName = "texts";
var DxFieldConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editorOptions": null,
    "update:editorTemplate": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:format": null,
    "update:lookup": null,
    "update:name": null,
    "update:trueText": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editorOptions: {},
    editorTemplate: {},
    falseText: String,
    filterOperations: Array,
    format: [Object, String, Function],
    lookup: Object,
    name: String,
    trueText: String
  }
};
prepareConfigurationComponentConfig(DxFieldConfig);
var DxField = defineComponent(DxFieldConfig);
DxField.$_optionName = "fields";
DxField.$_isCollectionItem = true;
DxField.$_expectedChildren = {
  fieldLookup: { isCollectionItem: false, optionName: "lookup" },
  format: { isCollectionItem: false, optionName: "format" },
  lookup: { isCollectionItem: false, optionName: "lookup" }
};
var DxFieldLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    dataSource: [Array, Object],
    displayExpr: [Function, String],
    valueExpr: [Function, String]
  }
};
prepareConfigurationComponentConfig(DxFieldLookupConfig);
var DxFieldLookup = defineComponent(DxFieldLookupConfig);
DxFieldLookup.$_optionName = "lookup";
var DxFilterBuilderConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowHierarchicalFields": null,
    "update:bindingOptions": null,
    "update:customOperations": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:fields": null,
    "update:filterOperationDescriptions": null,
    "update:focusStateEnabled": null,
    "update:groupOperationDescriptions": null,
    "update:groupOperations": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxGroupLevel": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onValueChanged": null,
    "update:rtlEnabled": null,
    "update:tabIndex": null,
    "update:value": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowHierarchicalFields: Boolean,
    bindingOptions: Object,
    customOperations: Array,
    disabled: Boolean,
    elementAttr: Object,
    fields: Array,
    filterOperationDescriptions: Object,
    focusStateEnabled: Boolean,
    groupOperationDescriptions: Object,
    groupOperations: Array,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    maxGroupLevel: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onValueChanged: Function,
    rtlEnabled: Boolean,
    tabIndex: Number,
    value: [Array, Function, String],
    visible: Boolean,
    width: [Function, Number, String]
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderConfig);
var DxFilterBuilder = defineComponent(DxFilterBuilderConfig);
DxFilterBuilder.$_optionName = "filterBuilder";
DxFilterBuilder.$_expectedChildren = {
  customOperation: { isCollectionItem: true, optionName: "customOperations" },
  field: { isCollectionItem: true, optionName: "fields" },
  filterOperationDescriptions: { isCollectionItem: false, optionName: "filterOperationDescriptions" },
  groupOperationDescriptions: { isCollectionItem: false, optionName: "groupOperationDescriptions" }
};
var DxFilterBuilderPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderPopupConfig);
var DxFilterBuilderPopup = defineComponent(DxFilterBuilderPopupConfig);
DxFilterBuilderPopup.$_optionName = "filterBuilderPopup";
DxFilterBuilderPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxFilterOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:isBlank": null,
    "update:isNotBlank": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    isBlank: String,
    isNotBlank: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxFilterOperationDescriptionsConfig);
var DxFilterOperationDescriptions = defineComponent(DxFilterOperationDescriptionsConfig);
DxFilterOperationDescriptions.$_optionName = "filterOperationDescriptions";
var DxFilterPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customizeText": null,
    "update:filterEnabled": null,
    "update:texts": null,
    "update:visible": null
  },
  props: {
    customizeText: Function,
    filterEnabled: Boolean,
    texts: Object,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterPanelConfig);
var DxFilterPanel = defineComponent(DxFilterPanelConfig);
DxFilterPanel.$_optionName = "filterPanel";
DxFilterPanel.$_expectedChildren = {
  filterPanelTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxFilterPanelTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:clearFilter": null,
    "update:createFilter": null,
    "update:filterEnabledHint": null
  },
  props: {
    clearFilter: String,
    createFilter: String,
    filterEnabledHint: String
  }
};
prepareConfigurationComponentConfig(DxFilterPanelTextsConfig);
var DxFilterPanelTexts = defineComponent(DxFilterPanelTextsConfig);
DxFilterPanelTexts.$_optionName = "texts";
var DxFilterRowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:applyFilter": null,
    "update:applyFilterText": null,
    "update:betweenEndText": null,
    "update:betweenStartText": null,
    "update:operationDescriptions": null,
    "update:resetOperationText": null,
    "update:showAllText": null,
    "update:showOperationChooser": null,
    "update:visible": null
  },
  props: {
    applyFilter: String,
    applyFilterText: String,
    betweenEndText: String,
    betweenStartText: String,
    operationDescriptions: Object,
    resetOperationText: String,
    showAllText: String,
    showOperationChooser: Boolean,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterRowConfig);
var DxFilterRow = defineComponent(DxFilterRowConfig);
DxFilterRow.$_optionName = "filterRow";
DxFilterRow.$_expectedChildren = {
  operationDescriptions: { isCollectionItem: false, optionName: "operationDescriptions" }
};
var DxFormConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:alignItemLabels": null,
    "update:alignItemLabelsInAllGroups": null,
    "update:bindingOptions": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:customizeItem": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:formData": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:isDirty": null,
    "update:items": null,
    "update:labelLocation": null,
    "update:labelMode": null,
    "update:minColWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorEnterKey": null,
    "update:onFieldDataChanged": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:optionalMark": null,
    "update:readOnly": null,
    "update:requiredMark": null,
    "update:requiredMessage": null,
    "update:rtlEnabled": null,
    "update:screenByWidth": null,
    "update:scrollingEnabled": null,
    "update:showColonAfterLabel": null,
    "update:showOptionalMark": null,
    "update:showRequiredMark": null,
    "update:showValidationSummary": null,
    "update:tabIndex": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    alignItemLabels: Boolean,
    alignItemLabelsInAllGroups: Boolean,
    bindingOptions: Object,
    colCount: [String, Number],
    colCountByScreen: Object,
    customizeItem: Function,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    formData: {},
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    isDirty: Boolean,
    items: Array,
    labelLocation: String,
    labelMode: String,
    minColWidth: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorEnterKey: Function,
    onFieldDataChanged: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    optionalMark: String,
    readOnly: Boolean,
    requiredMark: String,
    requiredMessage: String,
    rtlEnabled: Boolean,
    screenByWidth: Function,
    scrollingEnabled: Boolean,
    showColonAfterLabel: Boolean,
    showOptionalMark: Boolean,
    showRequiredMark: Boolean,
    showValidationSummary: Boolean,
    tabIndex: Number,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
prepareConfigurationComponentConfig(DxFormConfig);
var DxForm = defineComponent(DxFormConfig);
DxForm.$_optionName = "form";
DxForm.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: false, optionName: "colCountByScreen" }
};
var DxFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxFormatConfig);
var DxFormat = defineComponent(DxFormatConfig);
DxFormat.$_optionName = "format";
var DxFormItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:isRequired": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:template": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    dataField: String,
    editorOptions: {},
    editorType: String,
    helpText: String,
    isRequired: Boolean,
    itemType: String,
    label: Object,
    name: String,
    template: {},
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
prepareConfigurationComponentConfig(DxFormItemConfig);
var DxFormItem = defineComponent(DxFormItemConfig);
DxFormItem.$_optionName = "formItem";
DxFormItem.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  label: { isCollectionItem: false, optionName: "label" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxFromConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxFromConfig);
var DxFrom = defineComponent(DxFromConfig);
DxFrom.$_optionName = "from";
DxFrom.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxGroupingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowCollapsing": null,
    "update:autoExpandAll": null,
    "update:contextMenuEnabled": null,
    "update:expandMode": null,
    "update:texts": null
  },
  props: {
    allowCollapsing: Boolean,
    autoExpandAll: Boolean,
    contextMenuEnabled: Boolean,
    expandMode: String,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxGroupingConfig);
var DxGrouping = defineComponent(DxGroupingConfig);
DxGrouping.$_optionName = "grouping";
DxGrouping.$_expectedChildren = {
  groupingTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxGroupingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:ungroup": null,
    "update:ungroupAll": null
  },
  props: {
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    ungroup: String,
    ungroupAll: String
  }
};
prepareConfigurationComponentConfig(DxGroupingTextsConfig);
var DxGroupingTexts = defineComponent(DxGroupingTextsConfig);
DxGroupingTexts.$_optionName = "texts";
var DxGroupItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignByColumn": null,
    "update:column": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:showInGroupFooter": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignByColumn: Boolean,
    column: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    showInGroupFooter: Boolean,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxGroupItemConfig);
var DxGroupItem = defineComponent(DxGroupItemConfig);
DxGroupItem.$_optionName = "groupItems";
DxGroupItem.$_isCollectionItem = true;
DxGroupItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxGroupOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:and": null,
    "update:notAnd": null,
    "update:notOr": null,
    "update:or": null
  },
  props: {
    and: String,
    notAnd: String,
    notOr: String,
    or: String
  }
};
prepareConfigurationComponentConfig(DxGroupOperationDescriptionsConfig);
var DxGroupOperationDescriptions = defineComponent(DxGroupOperationDescriptionsConfig);
DxGroupOperationDescriptions.$_optionName = "groupOperationDescriptions";
var DxGroupPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowColumnDragging": null,
    "update:emptyPanelText": null,
    "update:visible": null
  },
  props: {
    allowColumnDragging: Boolean,
    emptyPanelText: String,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxGroupPanelConfig);
var DxGroupPanel = defineComponent(DxGroupPanelConfig);
DxGroupPanel.$_optionName = "groupPanel";
var DxHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxHeaderFilterConfig);
var DxHeaderFilter = defineComponent(DxHeaderFilterConfig);
DxHeaderFilter.$_optionName = "headerFilter";
DxHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" }
};
var DxHideConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxHideConfig);
var DxHide = defineComponent(DxHideConfig);
DxHide.$_optionName = "hide";
DxHide.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxIconsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxIconsConfig);
var DxIcons = defineComponent(DxIconsConfig);
DxIcons.$_optionName = "icons";
var DxItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:name": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    name: String,
    options: {},
    showText: String,
    template: {},
    text: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxItemConfig);
var DxItem = defineComponent(DxItemConfig);
DxItem.$_optionName = "items";
DxItem.$_isCollectionItem = true;
var DxKeyboardNavigationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editOnKeyPress": null,
    "update:enabled": null,
    "update:enterKeyAction": null,
    "update:enterKeyDirection": null
  },
  props: {
    editOnKeyPress: Boolean,
    enabled: Boolean,
    enterKeyAction: String,
    enterKeyDirection: String
  }
};
prepareConfigurationComponentConfig(DxKeyboardNavigationConfig);
var DxKeyboardNavigation = defineComponent(DxKeyboardNavigationConfig);
DxKeyboardNavigation.$_optionName = "keyboardNavigation";
var DxLabelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:location": null,
    "update:showColon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    alignment: String,
    location: String,
    showColon: Boolean,
    template: {},
    text: String,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxLabelConfig);
var DxLabel = defineComponent(DxLabelConfig);
DxLabel.$_optionName = "label";
var DxLoadPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:height": null,
    "update:indicatorSrc": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showIndicator": null,
    "update:showPane": null,
    "update:text": null,
    "update:width": null
  },
  props: {
    enabled: [Boolean, String],
    height: [Number, String],
    indicatorSrc: String,
    shading: Boolean,
    shadingColor: String,
    showIndicator: Boolean,
    showPane: Boolean,
    text: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxLoadPanelConfig);
var DxLoadPanel = defineComponent(DxLoadPanelConfig);
DxLoadPanel.$_optionName = "loadPanel";
var DxLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: [String, Function]
  }
};
prepareConfigurationComponentConfig(DxLookupConfig);
var DxLookup = defineComponent(DxLookupConfig);
DxLookup.$_optionName = "lookup";
var DxMasterDetailConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoExpandAll": null,
    "update:enabled": null,
    "update:template": null
  },
  props: {
    autoExpandAll: Boolean,
    enabled: Boolean,
    template: {}
  }
};
prepareConfigurationComponentConfig(DxMasterDetailConfig);
var DxMasterDetail = defineComponent(DxMasterDetailConfig);
DxMasterDetail.$_optionName = "masterDetail";
var DxMyConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxMyConfig);
var DxMy = defineComponent(DxMyConfig);
DxMy.$_optionName = "my";
var DxNumericRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxNumericRuleConfig);
var DxNumericRule = defineComponent(DxNumericRuleConfig);
DxNumericRule.$_optionName = "validationRules";
DxNumericRule.$_isCollectionItem = true;
DxNumericRule.$_predefinedProps = {
  type: "numeric"
};
var DxOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxOffsetConfig);
var DxOffset = defineComponent(DxOffsetConfig);
DxOffset.$_optionName = "offset";
var DxOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxOperationDescriptionsConfig);
var DxOperationDescriptions = defineComponent(DxOperationDescriptionsConfig);
DxOperationDescriptions.$_optionName = "operationDescriptions";
var DxPagerConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowedPageSizes": null,
    "update:displayMode": null,
    "update:infoText": null,
    "update:label": null,
    "update:showInfo": null,
    "update:showNavigationButtons": null,
    "update:showPageSizeSelector": null,
    "update:visible": null
  },
  props: {
    allowedPageSizes: [Array, String],
    displayMode: String,
    infoText: String,
    label: String,
    showInfo: Boolean,
    showNavigationButtons: Boolean,
    showPageSizeSelector: Boolean,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxPagerConfig);
var DxPager = defineComponent(DxPagerConfig);
DxPager.$_optionName = "pager";
var DxPagingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:pageIndex": null,
    "update:pageSize": null
  },
  props: {
    enabled: Boolean,
    pageIndex: Number,
    pageSize: Number
  }
};
prepareConfigurationComponentConfig(DxPagingConfig);
var DxPaging = defineComponent(DxPagingConfig);
DxPaging.$_optionName = "paging";
var DxPatternRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:pattern": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    pattern: [RegExp, String],
    type: String
  }
};
prepareConfigurationComponentConfig(DxPatternRuleConfig);
var DxPatternRule = defineComponent(DxPatternRuleConfig);
DxPatternRule.$_optionName = "validationRules";
DxPatternRule.$_isCollectionItem = true;
DxPatternRule.$_predefinedProps = {
  type: "pattern"
};
var DxPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxPopupConfig);
var DxPopup = defineComponent(DxPopupConfig);
DxPopup.$_optionName = "popup";
DxPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxPositionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
prepareConfigurationComponentConfig(DxPositionConfig);
var DxPosition = defineComponent(DxPositionConfig);
DxPosition.$_optionName = "position";
DxPosition.$_expectedChildren = {
  at: { isCollectionItem: false, optionName: "at" },
  boundaryOffset: { isCollectionItem: false, optionName: "boundaryOffset" },
  collision: { isCollectionItem: false, optionName: "collision" },
  my: { isCollectionItem: false, optionName: "my" },
  offset: { isCollectionItem: false, optionName: "offset" }
};
var DxRangeRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:reevaluate": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    reevaluate: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRangeRuleConfig);
var DxRangeRule = defineComponent(DxRangeRuleConfig);
DxRangeRule.$_optionName = "validationRules";
DxRangeRule.$_isCollectionItem = true;
DxRangeRule.$_predefinedProps = {
  type: "range"
};
var DxRemoteOperationsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:filtering": null,
    "update:grouping": null,
    "update:groupPaging": null,
    "update:paging": null,
    "update:sorting": null,
    "update:summary": null
  },
  props: {
    filtering: Boolean,
    grouping: Boolean,
    groupPaging: Boolean,
    paging: Boolean,
    sorting: Boolean,
    summary: Boolean
  }
};
prepareConfigurationComponentConfig(DxRemoteOperationsConfig);
var DxRemoteOperations = defineComponent(DxRemoteOperationsConfig);
DxRemoteOperations.$_optionName = "remoteOperations";
var DxRequiredRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:message": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    message: String,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRequiredRuleConfig);
var DxRequiredRule = defineComponent(DxRequiredRuleConfig);
DxRequiredRule.$_optionName = "validationRules";
DxRequiredRule.$_isCollectionItem = true;
DxRequiredRule.$_predefinedProps = {
  type: "required"
};
var DxRowDraggingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowDropInsideItem": null,
    "update:allowReordering": null,
    "update:autoScroll": null,
    "update:boundary": null,
    "update:container": null,
    "update:cursorOffset": null,
    "update:data": null,
    "update:dragDirection": null,
    "update:dragTemplate": null,
    "update:dropFeedbackMode": null,
    "update:filter": null,
    "update:group": null,
    "update:handle": null,
    "update:onAdd": null,
    "update:onDragChange": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:onReorder": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null,
    "update:showDragIcons": null
  },
  props: {
    allowDropInsideItem: Boolean,
    allowReordering: Boolean,
    autoScroll: Boolean,
    boundary: {},
    container: {},
    cursorOffset: [Object, String],
    data: {},
    dragDirection: String,
    dragTemplate: {},
    dropFeedbackMode: String,
    filter: String,
    group: String,
    handle: String,
    onAdd: Function,
    onDragChange: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    onReorder: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number,
    showDragIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxRowDraggingConfig);
var DxRowDragging = defineComponent(DxRowDraggingConfig);
DxRowDragging.$_optionName = "rowDragging";
DxRowDragging.$_expectedChildren = {
  cursorOffset: { isCollectionItem: false, optionName: "cursorOffset" }
};
var DxScrollingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:columnRenderingMode": null,
    "update:mode": null,
    "update:preloadEnabled": null,
    "update:renderAsync": null,
    "update:rowRenderingMode": null,
    "update:scrollByContent": null,
    "update:scrollByThumb": null,
    "update:showScrollbar": null,
    "update:useNative": null
  },
  props: {
    columnRenderingMode: String,
    mode: String,
    preloadEnabled: Boolean,
    renderAsync: Boolean,
    rowRenderingMode: String,
    scrollByContent: Boolean,
    scrollByThumb: Boolean,
    showScrollbar: String,
    useNative: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxScrollingConfig);
var DxScrolling = defineComponent(DxScrollingConfig);
DxScrolling.$_optionName = "scrolling";
var DxSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxSearchConfig);
var DxSearch = defineComponent(DxSearchConfig);
DxSearch.$_optionName = "search";
var DxSearchPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:highlightCaseSensitive": null,
    "update:highlightSearchText": null,
    "update:placeholder": null,
    "update:searchVisibleColumnsOnly": null,
    "update:text": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    highlightCaseSensitive: Boolean,
    highlightSearchText: Boolean,
    placeholder: String,
    searchVisibleColumnsOnly: Boolean,
    text: String,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSearchPanelConfig);
var DxSearchPanel = defineComponent(DxSearchPanelConfig);
DxSearchPanel.$_optionName = "searchPanel";
var DxSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:recursive": null,
    "update:selectAllMode": null,
    "update:selectByClick": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    recursive: Boolean,
    selectAllMode: String,
    selectByClick: Boolean,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxSelectionConfig);
var DxSelection = defineComponent(DxSelectionConfig);
DxSelection.$_optionName = "selection";
var DxShowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxShowConfig);
var DxShow = defineComponent(DxShowConfig);
DxShow.$_optionName = "show";
DxShow.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxSortByGroupSummaryInfoConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupColumn": null,
    "update:sortOrder": null,
    "update:summaryItem": null
  },
  props: {
    groupColumn: String,
    sortOrder: String,
    summaryItem: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSortByGroupSummaryInfoConfig);
var DxSortByGroupSummaryInfo = defineComponent(DxSortByGroupSummaryInfoConfig);
DxSortByGroupSummaryInfo.$_optionName = "sortByGroupSummaryInfo";
DxSortByGroupSummaryInfo.$_isCollectionItem = true;
var DxSortingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ascendingText": null,
    "update:clearText": null,
    "update:descendingText": null,
    "update:mode": null,
    "update:showSortIndexes": null
  },
  props: {
    ascendingText: String,
    clearText: String,
    descendingText: String,
    mode: String,
    showSortIndexes: Boolean
  }
};
prepareConfigurationComponentConfig(DxSortingConfig);
var DxSorting = defineComponent(DxSortingConfig);
DxSorting.$_optionName = "sorting";
var DxStateStoringConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customLoad": null,
    "update:customSave": null,
    "update:enabled": null,
    "update:savingTimeout": null,
    "update:storageKey": null,
    "update:type": null
  },
  props: {
    customLoad: Function,
    customSave: Function,
    enabled: Boolean,
    savingTimeout: Number,
    storageKey: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStateStoringConfig);
var DxStateStoring = defineComponent(DxStateStoringConfig);
DxStateStoring.$_optionName = "stateStoring";
var DxStringLengthRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: Number,
    message: String,
    min: Number,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStringLengthRuleConfig);
var DxStringLengthRule = defineComponent(DxStringLengthRuleConfig);
DxStringLengthRule.$_optionName = "validationRules";
DxStringLengthRule.$_isCollectionItem = true;
DxStringLengthRule.$_predefinedProps = {
  type: "stringLength"
};
var DxSummaryConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateCustomSummary": null,
    "update:groupItems": null,
    "update:recalculateWhileEditing": null,
    "update:skipEmptyValues": null,
    "update:texts": null,
    "update:totalItems": null
  },
  props: {
    calculateCustomSummary: Function,
    groupItems: Array,
    recalculateWhileEditing: Boolean,
    skipEmptyValues: Boolean,
    texts: Object,
    totalItems: Array
  }
};
prepareConfigurationComponentConfig(DxSummaryConfig);
var DxSummary = defineComponent(DxSummaryConfig);
DxSummary.$_optionName = "summary";
DxSummary.$_expectedChildren = {
  groupItem: { isCollectionItem: true, optionName: "groupItems" },
  summaryTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" },
  totalItem: { isCollectionItem: true, optionName: "totalItems" }
};
var DxSummaryTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:count": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:sum": null,
    "update:sumOtherColumn": null
  },
  props: {
    avg: String,
    avgOtherColumn: String,
    count: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    sum: String,
    sumOtherColumn: String
  }
};
prepareConfigurationComponentConfig(DxSummaryTextsConfig);
var DxSummaryTexts = defineComponent(DxSummaryTextsConfig);
DxSummaryTexts.$_optionName = "texts";
var DxTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:cancel": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:clearFilter": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:count": null,
    "update:createFilter": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:emptyValue": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null,
    "update:filterEnabledHint": null,
    "update:fix": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:leftPosition": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:ok": null,
    "update:rightPosition": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:stickyPosition": null,
    "update:sum": null,
    "update:sumOtherColumn": null,
    "update:undeleteRow": null,
    "update:unfix": null,
    "update:ungroup": null,
    "update:ungroupAll": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    avg: String,
    avgOtherColumn: String,
    cancel: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    clearFilter: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    count: String,
    createFilter: String,
    deleteRow: String,
    editRow: String,
    emptyValue: String,
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String,
    filterEnabledHint: String,
    fix: String,
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    leftPosition: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    ok: String,
    rightPosition: String,
    saveAllChanges: String,
    saveRowChanges: String,
    stickyPosition: String,
    sum: String,
    sumOtherColumn: String,
    undeleteRow: String,
    unfix: String,
    ungroup: String,
    ungroupAll: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxTextsConfig);
var DxTexts = defineComponent(DxTextsConfig);
DxTexts.$_optionName = "texts";
var DxToConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxToConfig);
var DxTo = defineComponent(DxToConfig);
DxTo.$_optionName = "to";
DxTo.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxToolbarConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:disabled": null,
    "update:items": null,
    "update:visible": null
  },
  props: {
    disabled: Boolean,
    items: Array,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxToolbarConfig);
var DxToolbar = defineComponent(DxToolbarConfig);
DxToolbar.$_optionName = "toolbar";
DxToolbar.$_expectedChildren = {
  item: { isCollectionItem: true, optionName: "items" }
};
var DxToolbarItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxToolbarItemConfig);
var DxToolbarItem = defineComponent(DxToolbarItemConfig);
DxToolbarItem.$_optionName = "toolbarItems";
DxToolbarItem.$_isCollectionItem = true;
var DxTotalItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:column": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignment: String,
    column: String,
    cssClass: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxTotalItemConfig);
var DxTotalItem = defineComponent(DxTotalItemConfig);
DxTotalItem.$_optionName = "totalItems";
DxTotalItem.$_isCollectionItem = true;
DxTotalItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxValidationRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:pattern": null,
    "update:reevaluate": null,
    "update:trim": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    pattern: [RegExp, String],
    reevaluate: Boolean,
    trim: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxValidationRuleConfig);
var DxValidationRule = defineComponent(DxValidationRuleConfig);
DxValidationRule.$_optionName = "validationRules";
DxValidationRule.$_isCollectionItem = true;
DxValidationRule.$_predefinedProps = {
  type: "required"
};
var DxValueFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxValueFormatConfig);
var DxValueFormat = defineComponent(DxValueFormatConfig);
DxValueFormat.$_optionName = "valueFormat";
var data_grid_default2 = DxDataGrid;
export {
  DxAnimation,
  DxAsyncRule,
  DxAt,
  DxBoundaryOffset,
  DxButton,
  DxChange,
  DxColCountByScreen,
  DxCollision,
  DxColumn,
  DxColumnChooser,
  DxColumnChooserSearch,
  DxColumnChooserSelection,
  DxColumnFixing,
  DxColumnFixingTexts,
  DxColumnHeaderFilter,
  DxColumnHeaderFilterSearch,
  DxColumnLookup,
  DxCompareRule,
  DxCursorOffset,
  DxCustomOperation,
  DxCustomRule,
  DxDataGrid,
  DxDataGridHeaderFilter,
  DxDataGridHeaderFilterSearch,
  DxDataGridHeaderFilterTexts,
  DxDataGridSelection,
  DxEditing,
  DxEditingTexts,
  DxEmailRule,
  DxExport,
  DxExportTexts,
  DxField,
  DxFieldLookup,
  DxFilterBuilder,
  DxFilterBuilderPopup,
  DxFilterOperationDescriptions,
  DxFilterPanel,
  DxFilterPanelTexts,
  DxFilterRow,
  DxForm,
  DxFormItem,
  DxFormat,
  DxFrom,
  DxGroupItem,
  DxGroupOperationDescriptions,
  DxGroupPanel,
  DxGrouping,
  DxGroupingTexts,
  DxHeaderFilter,
  DxHide,
  DxIcons,
  DxItem,
  DxKeyboardNavigation,
  DxLabel,
  DxLoadPanel,
  DxLookup,
  DxMasterDetail,
  DxMy,
  DxNumericRule,
  DxOffset,
  DxOperationDescriptions,
  DxPager,
  DxPaging,
  DxPatternRule,
  DxPopup,
  DxPosition,
  DxRangeRule,
  DxRemoteOperations,
  DxRequiredRule,
  DxRowDragging,
  DxScrolling,
  DxSearch,
  DxSearchPanel,
  DxSelection,
  DxShow,
  DxSortByGroupSummaryInfo,
  DxSorting,
  DxStateStoring,
  DxStringLengthRule,
  DxSummary,
  DxSummaryTexts,
  DxTexts,
  DxTo,
  DxToolbar,
  DxToolbarItem,
  DxTotalItem,
  DxValidationRule,
  DxValueFormat,
  data_grid_default2 as default
};
/*! Bundled license information:

devextreme-vue/esm/core/helpers.js:
devextreme-vue/esm/core/children-processing.js:
devextreme-vue/esm/core/vue-helper.js:
devextreme-vue/esm/core/config.js:
devextreme-vue/esm/core/configuration.js:
devextreme-vue/esm/core/configuration-component.js:
devextreme-vue/esm/core/constants.js:
devextreme-vue/esm/core/templates-discovering.js:
devextreme-vue/esm/core/templates-manager.js:
devextreme-vue/esm/core/component.js:
devextreme-vue/esm/core/extension-component.js:
devextreme-vue/esm/core/index.js:
devextreme-vue/esm/data-grid.js:
  (*!
   * devextreme-vue
   * Version: 24.2.9
   * Build date: Tue Aug 05 2025
   *
   * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=devextreme-vue_data-grid.js.map
