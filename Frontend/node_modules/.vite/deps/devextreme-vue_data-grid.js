import {
  ACTIVE_EVENT_NAME,
  CLICK_EVENT_NAME,
  ChildDefaultTemplate,
  DRAG_END_EVENT,
  DRAG_ENTER_EVENT,
  DRAG_EVENT,
  DRAG_LEAVE_EVENT,
  DRAG_START_EVENT,
  DataSource,
  EVENT_NAME,
  EmptyTemplate,
  FOCUSED_STATE_CLASS,
  FunctionTemplate,
  HOVEREND,
  HOVERSTART,
  OverlayPositionController,
  TemplateBase,
  _objectWithoutPropertiesLoose,
  action_default,
  addNamespace,
  adjust,
  attachInstanceToElement,
  browser_default,
  cancelAnimationFrame,
  click,
  clipboardText,
  closestCommonParent,
  compare,
  component_registrator_default,
  contains,
  convertRulesToOptions,
  create,
  createDefaultOptionRules,
  createEvent,
  createTextElementHiddenCopy,
  current,
  data_source_default,
  date_default,
  date_default2,
  date_serialization_default,
  default_date_names_default,
  devices_default,
  dom_component_default,
  dxClick,
  eventData,
  eventDelta,
  filtering_default,
  findTemplates,
  fireEvent,
  fitIntoRange,
  focus,
  focusable,
  focused,
  format_helper_default,
  fx_default,
  getBoundingRect,
  getChar,
  getDefaultAlignment,
  getFormat,
  getFormat2,
  getInstanceByElement,
  getName,
  getPatternSetters,
  getPublicElement,
  getRegExpInfo,
  getSessionStorage,
  getUniqueValues,
  inRange,
  inputType,
  isCommandKeyPressed,
  isDxMouseWheelEvent,
  isElementInDom,
  isFluent,
  isGeneric,
  isLastZIndexInStack,
  isMaterial,
  isMaterialBased,
  isMouseEvent,
  isTouchEvent,
  keyboard,
  load_indicator_default,
  locate,
  lock,
  m_array_store_default,
  m_devices_default,
  m_dom_default,
  m_emitter_default,
  m_emitter_gesture_default,
  m_emitter_registrator_default,
  m_event_registrator_default,
  m_keyboard_processor_default,
  m_load_panel_default,
  m_overlay_default,
  m_pointer_default,
  m_query_default,
  m_support_default,
  m_utils_default,
  message_default,
  move,
  needSkipEvent,
  normalizeDataSourceOptions,
  normalizeIndexes,
  normalizeKeyName,
  normalizeLoadResult,
  number_default,
  originalViewPort,
  position_default,
  remove,
  removeDuplicates,
  removeEvent,
  replaceWith,
  requestAnimationFrame,
  resetPosition,
  resize,
  resize_callbacks_default,
  sign,
  swatch_container_default,
  triggerResizeEvent,
  triggerShownEvent,
  ui_errors_default,
  value,
  visibility,
  waitWebFont,
  widget_default
} from "./chunk-YG3ZHDI5.js";
import {
  Deferred,
  EventsStrategy,
  _extends,
  addOffsetToMaxHeight,
  addOffsetToMinHeight,
  aggregators,
  applyBatch,
  applyServerDecimalSeparator,
  asyncNoop,
  callbacks_default,
  camelize,
  captionize,
  class_default,
  cleanDataRecursive,
  compileGetter,
  compileSetter,
  config_default,
  config_default2,
  createObjectWithChanges,
  dasherize,
  data,
  deepExtendArraySafe,
  defaultScreenFactorFunc,
  deferRender,
  deferRenderer,
  deferUpdate,
  deferUpdater,
  dependency_injector_default,
  dom_adapter_default,
  each,
  encodeHtml,
  ensureDefined,
  equalByValue,
  errors,
  errors_default,
  escapeRegExp,
  executeAsync,
  extend,
  format,
  fromPromise,
  getCurrentScreenFactor,
  getHeight,
  getInnerHeight,
  getInnerWidth,
  getKeyHash,
  getOffset,
  getOuterHeight,
  getOuterWidth,
  getPathParts,
  getVerticalOffsets,
  getVisibleHeight,
  getWidth,
  getWindow,
  grep,
  guid_default,
  hasWindow,
  indexByKey,
  insert,
  isBoolean,
  isDate,
  isDeferred,
  isDefined,
  isEmpty,
  isEmptyObject,
  isFunction,
  isNumeric,
  isObject,
  isPlainObject,
  isPrimitive,
  isPromise,
  isRenderer,
  isString,
  isWindow,
  keysEqual,
  logger,
  m_abstract_store_default,
  m_common_default,
  m_custom_store_default,
  m_events_engine_default,
  m_inflector_default,
  m_store_helper_default,
  m_window_default,
  map,
  noop,
  normalizeSortingInfo,
  normalizeStyleProp,
  orderEach,
  pairToObject,
  quadToObject,
  ready_callbacks_default,
  renderer_default,
  setHeight,
  setHeight2,
  setOuterHeight,
  setOuterWidth,
  setStyle,
  setWidth,
  setWidth2,
  splitPair,
  styleProp,
  stylePropPrefix,
  titleize,
  toComparable,
  type,
  update,
  variable_wrapper_default,
  when
} from "./chunk-3CI7IFHK.js";
import {
  Comment,
  PatchFlags,
  createApp,
  defineComponent,
  h,
  toRaw
} from "./chunk-JEBGSWJT.js";
import "./chunk-PR4QN5HX.js";

// node_modules/devextreme/esm/common/core/events.js
var on = m_events_engine_default.on;
var one = m_events_engine_default.one;
var off = m_events_engine_default.off;
var trigger = m_events_engine_default.trigger;
var Event = m_events_engine_default.Event;

// node_modules/devextreme/esm/events/events.types.js
var triggerHandler = m_events_engine_default.triggerHandler;

// node_modules/devextreme-vue/esm/core/helpers.js
function getTemplatePropName(props, templateName) {
  for (const propName in props) {
    if (props[propName] === templateName) {
      return propName;
    }
  }
  return templateName;
}
function uppercaseFirst(value2) {
  return value2[0].toUpperCase() + value2.substr(1);
}
function lowercaseFirst(value2) {
  return value2[0].toLowerCase() + value2.substr(1);
}
function camelize2(value2) {
  return lowercaseFirst(value2.split("-").map((v) => uppercaseFirst(v)).join(""));
}
function toComparable2(value2) {
  return value2 instanceof Date ? value2.getTime() : value2;
}
function isEqual(value1, value2) {
  if (toComparable2(value1) === toComparable2(value2)) {
    return true;
  }
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return value1.length === 0 && value2.length === 0;
  }
  return false;
}
function forEachChildNode(el, callback) {
  Array.prototype.slice.call(el.childNodes).forEach(callback);
}
function allKeysAreEqual(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  if (obj1Keys.length !== Object.keys(obj2).length) {
    return false;
  }
  for (const key of obj1Keys) {
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function getOptionValue(options2, optionPath) {
  let value2 = options2;
  optionPath.split(".").forEach((p2) => {
    const optionInfo = getOptionInfo(p2);
    if (value2) {
      value2 = optionInfo.isCollection ? value2[optionInfo.name] && value2[optionInfo.name][optionInfo.index] : value2[optionInfo.name];
    }
  });
  return value2;
}
function getOptionInfo(name2) {
  const parts = name2.split("[");
  if (parts.length === 1) {
    return {
      isCollection: false,
      name: name2,
      fullName: name2
    };
  }
  return {
    isCollection: true,
    name: parts[0],
    fullName: name2,
    index: Number(parts[1].slice(0, -1))
  };
}

// node_modules/devextreme-vue/esm/core/children-processing.js
function pullAllChildren(directChildren, allChildren, config2) {
  if (!directChildren || directChildren.length === 0) {
    return;
  }
  pullConfigComponents(directChildren, allChildren, config2);
}
function isFragment(node) {
  const { patchFlag } = node;
  return patchFlag === PatchFlags.KEYED_FRAGMENT || patchFlag === PatchFlags.UNKEYED_FRAGMENT || patchFlag === PatchFlags.STABLE_FRAGMENT || patchFlag === PatchFlags.BAIL;
}
function pullConfigComponents(children, nodes, ownerConfig) {
  children.forEach((node) => {
    if (isFragment(node) && Array.isArray(node.children)) {
      pullConfigComponents(node.children, nodes, ownerConfig);
    }
    if (!isFragment(node)) {
      nodes.push(node);
    }
    if (!node) {
      return;
    }
    const componentInfo = getComponentInfo(node);
    if (!componentInfo || !componentInfo.$_optionName) {
      return;
    }
    const componentChildren = configurationChildren(node);
    const initialValues = {
      ...componentInfo.$_predefinedProps,
      ...getNormalizedProps(node.props || {})
    };
    const config2 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
    node.$_config = config2;
    node.$_innerChanges = {};
    if (componentChildren) {
      pullConfigComponents(componentChildren, nodes, config2);
    }
  });
}

// node_modules/devextreme-vue/esm/core/vue-helper.js
var VMODEL_NAME = "modelValue";
function getChildren(component) {
  if (!hasChildren(component) || !component.$_config) {
    return [];
  }
  const children = component.$.subTree && component.$.subTree.children;
  if (!Array.isArray(children)) {
    return [];
  }
  return children.filter((child) => {
    if (!isFragment(child)) {
      return child;
    }
  });
}
function getComponentInfo(component) {
  return getConfigurationOptions(component);
}
function getNormalizedProps(props) {
  const result2 = {};
  for (const propName in props) {
    if (props.hasOwnProperty(propName)) {
      result2[camelize2(propName)] = props[propName];
    }
  }
  return result2;
}
function configurationChildren(component) {
  if (!component.children || !component.children.default) {
    return [];
  }
  return findConfigurationComponents(component.children.default());
}
function configurationDefaultTemplate(node) {
  if (!node.children || node.children === "object" || !node.children.default) {
    return;
  }
  return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
}
function configurationTemplate(node) {
  return configurationDefaultTemplate(node);
}
function declaredTemplates(component) {
  return component.$slots;
}
function defaultSlots(component) {
  const templates = declaredTemplates(component);
  if (!templates.default) {
    return [];
  }
  return templates.default();
}
function mount(options2, parent, el) {
  const template = createApp(options2);
  template.provide("eventBus", parent.eventBus);
  setAppContext(template, parent);
  return template.mount(el);
}
function getComponentProps(component) {
  const props = component.$.vnode.props || {};
  return getNormalizedProps(props);
}
function getNodeOptions(component) {
  if (component.$) {
    return component.$.vnode;
  }
  return component;
}
function getNodeTypeOfComponent(component) {
  return component.$.vnode.type;
}
function getVModelValue(options2) {
  return options2[VMODEL_NAME];
}
function setVModel(config2) {
  const eventName = `update:${VMODEL_NAME}`;
  config2.model.prop = VMODEL_NAME;
  config2.model.event = eventName;
  config2.props.modelValue = {};
  config2.emits = { ...config2.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
  for (const prop in parentAppContext) {
    if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
      appContext[prop] = parentAppContext[prop];
    }
  }
}
function setAppContext(template, parent) {
  template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
  Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
  Object.assign(template._context.provides, parent.$.appContext.provides);
  template._context.config = parent.$.appContext.config;
  template._context.directives = parent.$.appContext.directives;
  template._context.mixins = parent.$.appContext.mixins;
  setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
  return children.filter((child) => {
    if (isFragment(child)) {
      return findConfigurationComponents(child.children || []);
    }
    const childType = child.type;
    if (childType && typeof childType === "object" && childType.$_optionName) {
      delete child.$_config;
      delete child.$_innerChanges;
      return child;
    }
  });
}
function hasInlineTemplate(children) {
  let hasTemplate3 = false;
  children.forEach((child) => {
    if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
      hasTemplate3 = true;
    }
  });
  return hasTemplate3;
}
function isComment(node) {
  return node.type === Comment || node.type.toString() === "Symbol()" && !node.children;
}
function isConfiguration(child) {
  return child.type && typeof child.type === "object" && child.type.$_optionName;
}
function getConfigurationOptions(node) {
  return node.type;
}
function hasChildren(component) {
  return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}

// node_modules/devextreme-vue/esm/core/config.js
var config = {
  deepWatch: false
};
function getOption(optionName) {
  return config[optionName];
}

// node_modules/devextreme-vue/esm/core/configuration.js
var Configuration = class _Configuration {
  constructor(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
    this._updateFunc = updateFunc;
    this._name = name2;
    this._initialValues = initialValues || {};
    this._nestedConfigurations = [];
    this._isCollectionItem = !!isCollectionItem;
    this._collectionItemIndex = collectionItemIndex;
    this._expectedChildren = expectedChildren || {};
    this._ownerConfig = ownerConfig;
    this._componentChanges = [];
    this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig && this._ownerConfig.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(options2) {
    this._options = options2 || [];
  }
  set emitOptionChanged(handler) {
    this._emitOptionChanged = handler;
  }
  setPrevNestedOptions(value2) {
    this._prevNestedConfigOptions = value2;
  }
  onOptionChanged(args) {
    if (isEqual(args.value, args.previousValue)) {
      return;
    }
    this._onOptionChanged(args.fullName.split("."), args);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(name2, initialValues, isCollectionItem, expectedChildren) {
    const expected = this._expectedChildren[name2];
    let actualName = name2;
    let actualIsCollectionItem = isCollectionItem;
    if (expected) {
      actualIsCollectionItem = expected.isCollectionItem;
      if (expected.optionName) {
        actualName = expected.optionName;
      }
    }
    let collectionItemIndex = -1;
    if (actualIsCollectionItem && actualName) {
      collectionItemIndex = this._nestedConfigurations.filter((c) => c._name && c._name === actualName).length;
    }
    const configuration = new _Configuration(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
    this._nestedConfigurations.push(configuration);
    return configuration;
  }
  updateValue(nestedName, value2) {
    const fullName = [this.fullPath, nestedName].filter((n) => n).join(".");
    this._updateFunc(fullName, value2);
  }
  getNestedOptionValues() {
    const values = {};
    this._nestedConfigurations.forEach((o) => {
      if (!o._name) {
        return;
      }
      const nestedValue = { ...o.initialValues, ...o.getNestedOptionValues() };
      if (!nestedValue) {
        return;
      }
      if (!o._isCollectionItem) {
        values[o._name] = nestedValue;
      } else {
        let arr = values[o._name];
        if (!arr || !Array.isArray(arr)) {
          arr = [];
          values[o._name] = arr;
        }
        arr.push(nestedValue);
      }
    });
    return values;
  }
  getOptionsToWatch() {
    const blackList = {};
    this._nestedConfigurations.forEach((c) => c._name && (blackList[c._name] = true));
    return this._options.filter((o) => !blackList[o]);
  }
  _onOptionChanged(optionRelPath, args) {
    if (optionRelPath.length === 0) {
      return;
    }
    const optionInfo = getOptionInfo(optionRelPath[0]);
    if (optionInfo.isCollection || optionRelPath.length > 1) {
      const nestedConfig = this._getNestedConfig(optionInfo.fullName);
      if (nestedConfig) {
        nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
        return;
      }
      this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? `${this.fullPath}.${optionInfo.name}` : optionInfo.name));
    } else {
      this._tryEmitOptionChanged(optionInfo.name, args.value);
    }
  }
  _getNestedConfig(fullName) {
    for (const nestedConfig of this._nestedConfigurations) {
      if (nestedConfig.fullName === fullName) {
        return nestedConfig;
      }
    }
    return void 0;
  }
  _tryEmitOptionChanged(name2, value2) {
    if (this._emitOptionChanged) {
      this._emitOptionChanged(name2, value2);
    }
  }
};
function bindOptionWatchers(config2, vueInstance, innerChanges) {
  const targets = config2 && config2.getOptionsToWatch();
  if (targets) {
    targets.forEach((optionName) => {
      vueInstance.$watch(optionName, (value2) => {
        const rawValue = toRaw(value2);
        if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
          config2.updateValue(optionName, value2);
        }
        delete innerChanges[optionName];
      }, { deep: getOption("deepWatch") });
    });
  }
}
function hasProp(vueInstance, propName) {
  const { props } = vueInstance.$options;
  return props && props.hasOwnProperty(propName);
}
function hasVModelValue(options2, props, vnode) {
  return options2.model && props.hasOwnProperty(VMODEL_NAME) && vnode?.props?.hasOwnProperty(VMODEL_NAME);
}
function setEmitOptionChangedFunc(config2, vueInstance, innerChanges) {
  config2.emitOptionChanged = (name2, value2) => {
    const props = vueInstance.$props;
    const vnode = vueInstance?.$?.vnode;
    const propsName = name2 === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? VMODEL_NAME : name2;
    const eventName = `update:${propsName}`;
    if (hasProp(vueInstance, name2) && !isEqual(value2, props[propsName]) && vueInstance.$emit) {
      innerChanges[propsName] = toRaw(value2);
      vueInstance.$emit(eventName, value2);
    }
  };
}
var configuration_default = Configuration;

// node_modules/devextreme-vue/esm/core/configuration-component.js
function getConfig(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_config || vueInstance.$_config;
}
function getInnerChanges(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
}
function initOptionChangedFunc(config2, props, vueInstance, innerChanges) {
  if (!config2) {
    return;
  }
  config2.init(Object.keys(props));
  if (vueInstance) {
    setEmitOptionChangedFunc(config2, vueInstance, innerChanges);
  }
}
function getComponentInfo2({ name: name2, isCollectionItem, ownerConfig }, removed) {
  const parentPath = ownerConfig && ownerConfig.fullPath;
  const optionPath = name2 && parentPath ? `${parentPath}.${name2}` : name2 || "";
  return {
    optionPath,
    isCollection: isCollectionItem,
    removed
  };
}
function initDxConfiguration() {
  return defineComponent({
    beforeMount() {
      const thisComponent = this;
      const config2 = getConfig(thisComponent);
      const innerChanges = getInnerChanges(thisComponent);
      initOptionChangedFunc(config2, getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
      bindOptionWatchers(config2, this, innerChanges);
    },
    mounted() {
      if (this.$parent.$_instance) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(getConfig(this)));
      }
    },
    beforeUnmount() {
      const config2 = getConfig(this);
      if (config2) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(config2, true));
      }
    },
    render() {
      return null;
    }
  });
}

// node_modules/devextreme-vue/esm/core/constants.js
var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_REMOVE_EVENT = "dxremove";

// node_modules/devextreme-vue/esm/core/templates-discovering.js
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
  const componentOptions = component;
  if (!componentOptions) {
    return;
  }
  if (!componentOptions.$_config || !componentOptions.$_config.name) {
    return void 0;
  }
  return componentOptions;
}
function hasTemplate(component) {
  return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
  const templates = {};
  const namedTeplates = declaredTemplates(component);
  for (const slotName in namedTeplates) {
    if (slotName === "default" && component.$slots.default) {
      continue;
    }
    const slot = namedTeplates[slotName];
    if (!slot) {
      continue;
    }
    templates[slotName] = slot;
  }
  const componentChildren = getChildren(component);
  for (const childComponent of componentChildren) {
    const configurable = asConfigurable(childComponent);
    if (!configurable) {
      continue;
    }
    const defaultSlot = configurationDefaultTemplate(childComponent);
    if (!defaultSlot || !hasTemplate(childComponent)) {
      continue;
    }
    const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
    templates[templateName] = defaultSlot;
  }
  return templates;
}
function clearConfiguration(content) {
  const newContent = [];
  content.forEach((item) => {
    const configurable = getConfigurationOptions(item);
    if (!configurable || !configurable.$_optionName) {
      newContent.push(item);
    }
  });
  return newContent;
}
function mountTemplate(getSlot, parent, data17, name2, placeholder) {
  return mount({
    name: name2,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      data17.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const content = clearConfiguration(getSlot()(data17));
      if (!content) {
        return h("div");
      }
      return content.length > 1 ? content : content[0];
    }
  }, parent, placeholder);
}

// node_modules/devextreme-vue/esm/core/templates-manager.js
var TemplatesManager = class {
  constructor(component) {
    this._slots = {};
    this._templates = {};
    this._isDirty = false;
    this._component = component;
    this.discover();
  }
  discover() {
    this._slots = {
      ...discover(this._component)
    };
    if (!allKeysAreEqual(this._templates, this._slots)) {
      this._prepareTemplates();
    }
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = false;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const name2 of Object.keys(this._slots)) {
      this._templates[name2] = this.createDxTemplate(name2);
    }
    this._isDirty = true;
  }
  createDxTemplate(name2) {
    return {
      render: (data17) => {
        const rendered = /* @__PURE__ */ ((onRendered, counter = 0) => () => {
          if (counter === 1 && onRendered) {
            onRendered();
          }
          counter++;
        })(data17.onRendered);
        const scopeData = { data: data17.model, index: data17.index, onRendered: rendered };
        const placeholder = document.createElement("div");
        const container = data17.container.get ? data17.container.get(0) : data17.container;
        container.appendChild(placeholder);
        const mountedTemplate = mountTemplate(() => this._slots[name2], this._component, scopeData, name2, placeholder);
        const element = mountedTemplate.$el;
        container.removeChild(placeholder);
        while (placeholder.firstChild) {
          container.appendChild(placeholder.firstChild);
        }
        dom_adapter_default.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);
        if (element.nodeType === Node.TEXT_NODE) {
          const removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
          removalListener.style.display = "none";
          container.insertBefore(removalListener, container.firstChild);
          one(removalListener, DX_REMOVE_EVENT, () => {
            mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate)();
            removalListener.remove();
          });
        } else {
          one(element, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        }
        rendered();
        return element;
      }
    };
  }
};

// node_modules/devextreme-vue/esm/core/component.js
var includeAttrs = ["id", "class", "style"];
var dxClassesPrefix = "dx-";
config_default2({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx",
  licensingDocLink: "https://go.devexpress.com/Licensing_Documentation_DevExtremeVue.aspx"
});
function parseClassList(classList) {
  return classList.trim().split(/\s+/);
}
function prepareAttrs(attrs, dxClassesSyncedWithClassAttr) {
  const attributes = {};
  includeAttrs.forEach((attr) => {
    const attrValue = attrs[attr];
    if (attrValue !== void 0 && attrValue !== null) {
      if (attr === "class") {
        const nonDXClassesFromAttr = attrValue.split(" ").filter((classFromAttr) => !classFromAttr.startsWith(dxClassesPrefix)).join(" ");
        attributes[attr] = [nonDXClassesFromAttr, dxClassesSyncedWithClassAttr].filter((item) => item !== "").join(" ");
      } else {
        attributes[attr] = attrValue;
      }
    }
  });
  return attributes;
}
function initBaseComponent() {
  return defineComponent({
    inheritAttrs: false,
    data() {
      return {
        eventBus: callbacks_default(),
        prevClassAttr: ""
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const thisComponent = this;
      const children = [];
      const dxClasses = pickOutDxClasses(this.$el) || [];
      if (thisComponent.$_config.cleanNested) {
        thisComponent.$_config.cleanNested();
      }
      pullAllChildren(defaultSlots(this), children, thisComponent.$_config);
      this.$_processChildren(children);
      return h("div", {
        ...prepareAttrs(this.$attrs, dxClasses.join(" "))
      }, children);
    },
    beforeUpdate() {
      const thisComponent = this;
      thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
      this.$_syncElementClassesWithClassAttr();
    },
    updated() {
      const thisComponent = this;
      const nodes = cleanWidgetNode(this.$el);
      getChildren(thisComponent).forEach((child) => {
        initOptionChangedFunc(child.$_config, child.type.props || {}, child?.component?.proxy, child.$_innerChanges);
      });
      thisComponent.$_templatesManager.discover();
      thisComponent.$_instance.beginUpdate();
      this.$_applyConfigurationChanges();
      if (thisComponent.$_templatesManager.isDirty) {
        thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
        const { props } = thisComponent.$.vnode;
        for (const name2 of Object.keys(thisComponent.$_templatesManager.templates)) {
          thisComponent.$_instance.option(getTemplatePropName(props, name2), name2);
        }
        thisComponent.$_templatesManager.resetDirtyFlag();
      }
      for (const name2 of Object.keys(thisComponent.$_pendingOptions)) {
        thisComponent.$_instance.option(name2, thisComponent.$_pendingOptions[name2]);
      }
      thisComponent.$_pendingOptions = {};
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      this.eventBus.fire();
    },
    beforeUnmount() {
      const thisComponent = this;
      const instance = thisComponent.$_instance;
      if (instance) {
        triggerHandler(this.$el, DX_REMOVE_EVENT);
        instance.dispose();
      }
    },
    created() {
      const thisComponent = this;
      const props = getComponentProps(this);
      thisComponent.$_config = new configuration_default((n, v) => {
        if (Array.isArray(v)) {
          thisComponent.$_instance.option(n, v);
        } else {
          thisComponent.$_pendingOptions[n === VMODEL_NAME ? "value" : n] = v;
        }
      }, null, props && { ...props }, thisComponent.$_expectedChildren);
      thisComponent.$_innerChanges = {};
      thisComponent.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_syncElementClassesWithClassAttr() {
        const newClassAttr = typeof this.$attrs?.class === "string" ? this.$attrs?.class : "";
        if (this.prevClassAttr === newClassAttr) {
          return;
        }
        if (this.prevClassAttr.length) {
          this.$el.classList.remove(...parseClassList(this.prevClassAttr));
        }
        if (newClassAttr.length) {
          this.$el.classList.add(...parseClassList(newClassAttr));
        }
        this.prevClassAttr = newClassAttr;
      },
      $_applyConfigurationChanges() {
        const thisComponent = this;
        thisComponent.$_config.componentsCountChanged.forEach(({ optionPath, isCollection, removed }) => {
          const options2 = thisComponent.$_config.getNestedOptionValues();
          if (!isCollection && removed) {
            thisComponent.$_instance.resetOption(optionPath);
          } else {
            thisComponent.$_instance.option(optionPath, getOptionValue(options2, optionPath));
          }
        });
        thisComponent.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(element) {
        const thisComponent = this;
        thisComponent.$_pendingOptions = {};
        thisComponent.$_templatesManager = new TemplatesManager(this);
        const widgetConfig = thisComponent.$_config;
        if (widgetConfig.initialValues.hasOwnProperty(VMODEL_NAME)) {
          widgetConfig.initialValues.value = getVModelValue(widgetConfig.initialValues);
        }
        const options2 = {
          templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate,
          ...getComponentProps(thisComponent),
          ...widgetConfig.initialValues,
          ...widgetConfig.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        };
        const instance = new thisComponent.$_WidgetClass(element, options2);
        thisComponent.$_instance = instance;
        instance.on("optionChanged", (args) => widgetConfig.onOptionChanged(args));
        setEmitOptionChangedFunc(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        bindOptionWatchers(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        this.$_createEmitters(instance);
      },
      $_getIntegrationOptions() {
        const thisComponent = this;
        const result2 = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (thisComponent.$_templatesManager.isDirty) {
          const { templates } = thisComponent.$_templatesManager;
          result2.integrationOptions.templates = templates;
          const { props } = thisComponent.$.vnode;
          for (const name2 of Object.keys(templates)) {
            result2[getTemplatePropName(props, name2)] = name2;
          }
          thisComponent.$_templatesManager.resetDirtyFlag();
        }
        return result2;
      },
      $_getWatchMethod() {
        return (valueGetter, valueChangeCallback, options2) => {
          options2 = options2 || {};
          if (!options2.skipImmediate) {
            valueChangeCallback(valueGetter());
          }
          return this.$watch(() => valueGetter(), (newValue, oldValue) => {
            if (toComparable2(oldValue) !== toComparable2(newValue) || options2.deep) {
              valueChangeCallback(newValue);
            }
          }, {
            deep: options2.deep
          });
        };
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(_children) {
      },
      $_createEmitters(instance) {
        if (this.$attrs) {
          Object.keys(this.$attrs).forEach((listenerName) => {
            const eventName = camelize2(listenerName);
            instance.on(eventName, (e) => {
              this.$emit(listenerName, e);
            });
          });
        }
      }
    }
  });
}
function cleanWidgetNode(node) {
  const removedNodes = [];
  forEachChildNode(node, (childNode) => {
    const parent = childNode.parentNode;
    const isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
    if ((childNode.nodeName === "#comment" || isExtension) && parent) {
      removedNodes.push(childNode);
      parent.removeChild(childNode);
    }
  });
  return removedNodes;
}
function pickOutDxClasses(el) {
  return el && Array.from(el.classList).filter((item) => item.startsWith(dxClassesPrefix));
}
function restoreNodes(el, nodes) {
  nodes.forEach((node) => {
    el.appendChild(node);
  });
}
function initDxComponent() {
  return defineComponent({
    extends: initBaseComponent(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(children) {
        children.forEach((childNode) => {
          if (!childNode || typeof childNode !== "object") {
            return;
          }
          childNode.$_hasOwner = true;
        });
      }
    },
    mounted() {
      const nodes = cleanWidgetNode(this.$el);
      const thisComponent = this;
      this.$_createWidget(this.$el);
      this.$_syncElementClassesWithClassAttr();
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      if (this.$slots && this.$slots.default) {
        getChildren(thisComponent).forEach((child) => {
          const childExtenton = child;
          if (childExtenton && childExtenton.$_isExtension) {
            childExtenton.$_attachTo(this.$el);
          }
        });
      }
    }
  });
}

// node_modules/devextreme-vue/esm/core/index.js
function prepareComponentConfig(config2) {
  config2.extends = initDxComponent();
  if (config2.model) {
    setVModel(config2);
  }
}
function prepareConfigurationComponentConfig(config2) {
  config2.extends = initDxConfiguration();
}

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/const.js
var CLASSES = {
  draggableColumn: "draggable-column"
};

// node_modules/devextreme/esm/ui/shared/accessibility.js
var FOCUS_STATE_CLASS = "dx-state-focused";
var FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var GRID_ROW_SELECTOR = ".dx-datagrid-rowsview .dx-row";
var GRID_CELL_SELECTOR = `${GRID_ROW_SELECTOR} > td`;
var TREELIST_ROW_SELECTOR = ".dx-treelist-rowsview .dx-row";
var TREELIST_CELL_SELECTOR = `${TREELIST_ROW_SELECTOR} > td`;
var viewItemSelectorMap = {
  groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
  columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
  filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
  rowsView: [".dx-row-focused", `${GRID_ROW_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}`, `${TREELIST_ROW_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}`],
  footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
  filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
  pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
};
var isMouseDown = false;
var isHiddenFocusing = false;
var focusedElementInfo = null;
function processKeyDown(viewName2, instance, event, action, $mainElement, executeKeyDown) {
  const isHandled = fireKeyDownEvent(instance, event.originalEvent, executeKeyDown);
  if (isHandled) {
    return;
  }
  const keyName = normalizeKeyName(event);
  if ("enter" === keyName || "space" === keyName) {
    saveFocusedElementInfo(event.target, instance);
    action && action({
      event
    });
  } else if ("tab" === keyName) {
    $mainElement.addClass(FOCUS_STATE_CLASS);
  } else {
    selectView(viewName2, instance, event);
  }
}
function saveFocusedElementInfo(target, instance) {
  const $target = renderer_default(target);
  const ariaLabel = $target.attr("aria-label");
  const $activeElements = getActiveAccessibleElements(ariaLabel, instance.element());
  const targetIndex = $activeElements.index($target);
  focusedElementInfo = extend({}, {
    ariaLabel,
    index: targetIndex
  }, {
    viewInstance: instance
  });
}
function getActiveAccessibleElements(ariaLabel, viewElement) {
  const $viewElement = renderer_default(viewElement);
  let $activeElements;
  if (ariaLabel) {
    const escapedAriaLabel = null === ariaLabel || void 0 === ariaLabel ? void 0 : ariaLabel.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    $activeElements = $viewElement.find(`[aria-label="${escapedAriaLabel}"][tabindex]`);
  } else {
    $activeElements = $viewElement.find("[tabindex]");
  }
  return $activeElements;
}
function findFocusedViewElement(instanceRootDomNode, viewSelectors, element) {
  const root = instanceRootDomNode ?? (null === element || void 0 === element ? void 0 : element.getRootNode()) ?? dom_adapter_default.getDocument();
  if (!root) {
    return;
  }
  const $root = renderer_default(root);
  for (const index in viewSelectors) {
    const selector = viewSelectors[index];
    const $focusViewElement = $root.find(selector).first();
    if ($focusViewElement.length) {
      return $focusViewElement;
    }
  }
}
function fireKeyDownEvent(instance, event, executeAction) {
  const args = {
    event,
    handled: false
  };
  if (executeAction) {
    executeAction(args);
  } else {
    instance._createActionByOption("onKeyDown")(args);
  }
  return args.handled;
}
function onDocumentVisibilityChange() {
  isHiddenFocusing = "visible" === dom_adapter_default.getDocument().visibilityState;
}
function subscribeVisibilityChange() {
  m_events_engine_default.on(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function unsubscribeVisibilityChange() {
  m_events_engine_default.off(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function hiddenFocus(element, preventScroll) {
  isHiddenFocusing = true;
  element.focus({
    preventScroll
  });
  isHiddenFocusing = false;
}
function registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown) {
  if (instance.option("useLegacyKeyboardNavigation")) {
    return noop;
  }
  const getMainElement = () => renderer_default(instance.element());
  const keyDownHandler = (e) => processKeyDown(viewName2, instance, e, action, getMainElement(), executeKeyDown);
  const mouseDownHandler = () => {
    isMouseDown = true;
    getMainElement().removeClass(FOCUS_STATE_CLASS);
  };
  const focusinHandler = () => {
    const needShowOverlay = !isMouseDown && !isHiddenFocusing;
    if (needShowOverlay) {
      getMainElement().addClass(FOCUS_STATE_CLASS);
    }
    isMouseDown = false;
  };
  m_events_engine_default.on($element, "keydown", selector, keyDownHandler);
  m_events_engine_default.on($element, "mousedown", selector, mouseDownHandler);
  m_events_engine_default.on($element, "focusin", selector, focusinHandler);
  return () => {
    m_events_engine_default.off($element, "keydown", selector, keyDownHandler);
    m_events_engine_default.off($element, "mousedown", selector, mouseDownHandler);
    m_events_engine_default.off($element, "focusin", selector, focusinHandler);
  };
}
function restoreFocus(instance) {
  if (!instance.option("useLegacyKeyboardNavigation") && focusedElementInfo) {
    const viewInstance = focusedElementInfo.viewInstance;
    if (viewInstance) {
      const $activeElements = getActiveAccessibleElements(focusedElementInfo.ariaLabel, viewInstance.element());
      const $targetElement = $activeElements.eq(focusedElementInfo.index);
      focusedElementInfo = null;
      m_events_engine_default.trigger($targetElement, "focus");
    }
  }
}
function selectView(viewName2, instance, event) {
  const keyName = normalizeKeyName(event);
  if (event.ctrlKey && ("upArrow" === keyName || "downArrow" === keyName)) {
    var _instance$component, _instance$component$e;
    const viewNames = Object.keys(viewItemSelectorMap);
    let viewItemIndex = viewNames.indexOf(viewName2);
    const instanceRootDomNode = null === instance || void 0 === instance || null === (_instance$component = instance.component) || void 0 === _instance$component || null === (_instance$component$e = _instance$component.element) || void 0 === _instance$component$e ? void 0 : _instance$component$e.call(_instance$component);
    while (viewItemIndex >= 0 && viewItemIndex < viewNames.length) {
      viewItemIndex = "upArrow" === keyName ? --viewItemIndex : ++viewItemIndex;
      const viewName3 = viewNames[viewItemIndex];
      const viewSelectors = viewItemSelectorMap[viewName3];
      const $focusViewElement = findFocusedViewElement(instanceRootDomNode, viewSelectors, event.target);
      if ($focusViewElement && $focusViewElement.length) {
        $focusViewElement.attr("tabindex", instance.option("tabindex") || 0);
        m_events_engine_default.trigger($focusViewElement, "focus");
        $focusViewElement.removeClass(FOCUS_DISABLED_CLASS);
        break;
      }
    }
  }
}
function setTabIndex(instance, $element) {
  if (!instance.option("useLegacyKeyboardnavigation")) {
    $element.attr("tabindex", instance.option("tabindex") || 0);
  }
}

// node_modules/devextreme/esm/__internal/grids/grid_core/m_accessibility.js
var registerKeyboardAction2 = function(viewName2, instance, $element, selector, action) {
  const keyboardController = instance.getController("keyboardNavigation");
  if (instance.option("useLegacyKeyboardNavigation") || keyboardController && !keyboardController.isKeyboardEnabled()) {
    return;
  }
  instance.createAction("onKeyDown");
  registerKeyboardAction(viewName2, instance, $element, selector, action, ((args) => {
    instance.executeAction("onKeyDown", args);
  }));
};

// node_modules/devextreme/esm/__internal/events/m_dblclick.js
var DBLCLICK_EVENT_NAME = "dxdblclick";
var NAMESPACED_CLICK_EVENT = addNamespace(CLICK_EVENT_NAME, "dxDblClick");
var DblClick = class_default.inherit({
  ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -300;
  },
  add() {
    if (this._handlerCount <= 0) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount += 1;
  },
  _clickHandler(e) {
    const timeStamp = e.timeStamp || Date.now();
    const timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    const isSimulated = timeBetweenClicks < 0;
    const isDouble = !isSimulated && timeBetweenClicks < 300;
    if (isDouble) {
      fireEvent({
        type: "dxdblclick",
        target: closestCommonParent(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
      clearTimeout(this._lastClickClearTimeout);
      this._lastClickClearTimeout = setTimeout((() => {
        this._forgetLastClick();
      }), 600);
    }
  },
  remove() {
    this._handlerCount -= 1;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      m_events_engine_default.off(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, void 0);
      clearTimeout(this._lastClickClearTimeout);
      this._handlerCount = 0;
    }
  }
});
var dblClick = new DblClick();

// node_modules/devextreme/esm/common/core/events/double_click.js
m_event_registrator_default(DBLCLICK_EVENT_NAME, dblClick);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_state_mixin/m_column_state_mixin.js
var ColumnStateMixin = (Base) => class extends Base {
  _applyColumnState(options2) {
    var _that$component;
    const rtlEnabled = this.option("rtlEnabled");
    const columnAlignment = this._getColumnAlignment(options2.column.alignment, rtlEnabled);
    const parameters = extend(true, {
      columnAlignment
    }, options2);
    const isGroupPanelItem = parameters.rootElement.hasClass("dx-group-panel-item");
    const $indicatorsContainer = this._createIndicatorContainer(parameters, isGroupPanelItem);
    const $span = renderer_default("<span>").addClass(this._getIndicatorClassName(options2.name));
    const columnsController = null === (_that$component = this.component) || void 0 === _that$component ? void 0 : _that$component.getController("columns");
    const indicatorAlignment = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
    parameters.container = $indicatorsContainer;
    parameters.indicator = $span;
    this._renderIndicator(parameters);
    $indicatorsContainer[(isGroupPanelItem || !options2.showColumnLines) && "left" === indicatorAlignment ? "appendTo" : "prependTo"](options2.rootElement);
    return $span;
  }
  _getIndicatorClassName(name2) {
  }
  _getColumnAlignment(alignment, rtlEnabled) {
    rtlEnabled = rtlEnabled || this.option("rtlEnabled");
    return alignment && "center" !== alignment ? alignment : getDefaultAlignment(rtlEnabled);
  }
  _createIndicatorContainer(options2, ignoreIndicatorAlignment) {
    let $indicatorsContainer = this._getIndicatorContainer(options2.rootElement);
    const indicatorAlignment = "left" === options2.columnAlignment ? "right" : "left";
    if (!$indicatorsContainer.length) {
      $indicatorsContainer = renderer_default("<div>").addClass("dx-column-indicators");
    }
    this.setAria("role", "presentation", $indicatorsContainer);
    return $indicatorsContainer.css("float", options2.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null);
  }
  _getIndicatorContainer($cell) {
    return $cell && $cell.find(".dx-column-indicators");
  }
  _getIndicatorElements($cell) {
    const $indicatorContainer = this._getIndicatorContainer($cell);
    return $indicatorContainer && $indicatorContainer.children();
  }
  _renderIndicator(options2) {
    const $container = options2.container;
    const $indicator = options2.indicator;
    $container && $indicator && $container.append($indicator);
  }
  _updateIndicators(indicatorName) {
    const that = this;
    const columns7 = that.getColumns();
    const $cells = that.getColumnElements();
    let $cell;
    if (!$cells || columns7.length !== $cells.length) {
      return;
    }
    for (let i = 0; i < columns7.length; i++) {
      $cell = $cells.eq(i);
      that._updateIndicator($cell, columns7[i], indicatorName);
      const rowOptions = $cell.parent().data("options");
      if (rowOptions && rowOptions.cells) {
        rowOptions.cells[$cell.index()].column = columns7[i];
      }
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    if (!column.command) {
      return this._applyColumnState({
        name: indicatorName,
        rootElement: $cell,
        column,
        showColumnLines: this.option("showColumnLines")
      });
    }
    return;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/utils/update_views_borders.js
var _excluded = ["rowsView"];
var CLASSES2 = {
  borderedTop: "dx-bordered-top-view",
  borderedBottom: "dx-bordered-bottom-view"
};
var getFirstVisibleViewElement = (_ref) => {
  let {
    columnHeadersView: columnHeadersView9,
    rowsView: rowsView18
  } = _ref;
  if (null !== columnHeadersView9 && void 0 !== columnHeadersView9 && columnHeadersView9.isVisible()) {
    return columnHeadersView9.element();
  }
  return rowsView18.element();
};
var getLastVisibleViewElement = (_ref2) => {
  let {
    filterPanelView,
    footerView: footerView3,
    rowsView: rowsView18
  } = _ref2;
  if (null !== filterPanelView && void 0 !== filterPanelView && filterPanelView.isVisible()) {
    return filterPanelView.element();
  }
  if (null !== footerView3 && void 0 !== footerView3 && footerView3.isVisible()) {
    return footerView3.element();
  }
  return rowsView18.element();
};
var getViewElementWithClass = (viewsWithBorder, className) => {
  const borderedView = Object.values(viewsWithBorder).find(((view) => {
    var _view$element;
    return null === view || void 0 === view || null === (_view$element = view.element()) || void 0 === _view$element ? void 0 : _view$element.hasClass(className);
  }));
  return (null === borderedView || void 0 === borderedView ? void 0 : borderedView.element()) ?? null;
};
var shouldUpdateBorders = (viewName2, viewsWithBorder) => {
  var _rowsView$element;
  if (!Object.keys(viewsWithBorder).includes(viewName2)) {
    return false;
  }
  const {
    rowsView: rowsView18
  } = viewsWithBorder, otherViews = _objectWithoutPropertiesLoose(viewsWithBorder, _excluded);
  if (!isDefined(null === rowsView18 || void 0 === rowsView18 || null === (_rowsView$element = rowsView18.element) || void 0 === _rowsView$element ? void 0 : _rowsView$element.call(rowsView18))) {
    return false;
  }
  return Object.values(otherViews).filter(((view) => {
    var _view$isVisible;
    return null === view || void 0 === view || null === (_view$isVisible = view.isVisible) || void 0 === _view$isVisible ? void 0 : _view$isVisible.call(view);
  })).every(((view) => isDefined(null === view || void 0 === view ? void 0 : view.element())));
};
var updateViewsBorders = (viewName2, viewsWithBorder) => {
  if (!shouldUpdateBorders(viewName2, viewsWithBorder)) {
    return;
  }
  const $oldFirst = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedTop);
  const $oldLast = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedBottom);
  const $newFirst = getFirstVisibleViewElement(viewsWithBorder);
  const $newLast = getLastVisibleViewElement(viewsWithBorder);
  if ($oldFirst && !$oldFirst.is($newFirst)) {
    $oldFirst.removeClass(CLASSES2.borderedTop);
  }
  if ($oldLast && !$oldLast.is($newLast)) {
    $oldLast.removeClass(CLASSES2.borderedBottom);
  }
  if (!$newFirst.hasClass(CLASSES2.borderedTop)) {
    $newFirst.addClass(CLASSES2.borderedTop);
  }
  if (!$newLast.hasClass(CLASSES2.borderedBottom)) {
    $newLast.addClass(CLASSES2.borderedBottom);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/m_modules.js
var ModuleItem = class {
  constructor(component) {
    const that = this;
    that._updateLockCount = 0;
    that.component = component;
    that._actions = {};
    that._actionConfigs = {};
    each(this.callbackNames() || [], (function(index, name2) {
      const flags = that.callbackFlags(name2) || {};
      flags.unique = true;
      flags.syncStrategy = true;
      that[this] = callbacks_default(flags);
    }));
  }
  _endUpdateCore() {
  }
  init() {
  }
  callbackNames() {
    return;
  }
  callbackFlags(name2) {
  }
  publicMethods() {
    return [];
  }
  beginUpdate() {
    this._updateLockCount++;
  }
  endUpdate() {
    if (this._updateLockCount > 0) {
      this._updateLockCount--;
      if (!this._updateLockCount) {
        this._endUpdateCore();
      }
    }
  }
  option(name2) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (1 === arguments.length && optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = component.option(name2);
      }
      return optionCache[name2];
    }
    return component.option.apply(component, arguments);
  }
  _silentOption(name2, value2) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (optionCache) {
      optionCache[name2] = value2;
    }
    return component._setOptionWithoutOptionChange(name2, value2);
  }
  localize(name2) {
    const optionCache = this.component._optionCache;
    if (optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = message_default.format(name2);
      }
      return optionCache[name2];
    }
    return message_default.format(name2);
  }
  on(event, callback) {
    return this.component.on.apply(this.component, arguments);
  }
  off() {
    return this.component.off.apply(this.component, arguments);
  }
  optionChanged(args) {
    if (args.name in this._actions) {
      this.createAction(args.name, this._actionConfigs[args.name]);
      args.handled = true;
    }
  }
  getAction(actionName) {
    return this._actions[actionName];
  }
  setAria(name2, value2, $target) {
    const target = $target.get(0);
    const prefix = "role" !== name2 && "id" !== name2 ? "aria-" : "";
    if (target.setAttribute) {
      target.setAttribute(prefix + name2, value2);
    } else {
      $target.attr(prefix + name2, value2);
    }
  }
  _createComponent($container, component, options2) {
    return this.component._createComponent($container, component, options2);
  }
  getController(name2) {
    return this.component._controllers[name2];
  }
  createAction(actionName, config2) {
    if (isFunction(actionName)) {
      const action = this.component._createAction(actionName.bind(this), config2);
      return function(e) {
        action({
          event: e
        });
      };
    }
    this._actions[actionName] = this.component._createActionByOption(actionName, config2);
    this._actionConfigs[actionName] = config2;
    return;
  }
  executeAction(actionName, options2) {
    const action = this._actions[actionName];
    return action && action(options2);
  }
  dispose() {
    const that = this;
    each(that.callbackNames() || [], (function() {
      that[this].empty();
    }));
  }
  addWidgetPrefix(className) {
    const componentName = this.component.NAME;
    return `dx-${componentName.slice(2).toLowerCase()}${className ? `-${className}` : ""}`;
  }
  getWidgetContainerClass() {
    const containerName = "dxDataGrid" === this.component.NAME ? null : "container";
    return this.addWidgetPrefix(containerName);
  }
  elementIsInsideGrid($element) {
    const $gridElement = $element.closest(`.${this.getWidgetContainerClass()}`).parent();
    return $gridElement.is(this.component.$element());
  }
};
var Controller = class extends ModuleItem {
};
var ViewController = class extends Controller {
  getView(name2) {
    return this.component._views[name2];
  }
  getViews() {
    return this.component._views;
  }
};
var View = class extends ModuleItem {
  constructor(component) {
    super(component);
    this.renderCompleted = callbacks_default();
    this.resizeCompleted = callbacks_default();
  }
  _isReady() {
    return this.component.isReady();
  }
  _endUpdateCore() {
    super._endUpdateCore();
    if (!this._isReady() && this._requireReady) {
      this._requireRender = false;
      this.component._requireResize = false;
    }
    if (this._requireRender) {
      this._requireRender = false;
      this.render(this._$parent);
    }
  }
  _invalidate(requireResize, requireReady) {
    this._requireRender = true;
    this.component._requireResize = hasWindow() && (this.component._requireResize || requireResize);
    this._requireReady = this._requireReady || requireReady;
  }
  _renderCore(options2) {
  }
  _resizeCore() {
  }
  _parentElement() {
    return this._$parent;
  }
  element() {
    return this._$element;
  }
  getElementHeight() {
    const $element = this.element();
    if (!$element) {
      return 0;
    }
    const marginTop = parseFloat($element.css("marginTop")) || 0;
    const marginBottom = parseFloat($element.css("marginBottom")) || 0;
    const {
      offsetHeight
    } = $element.get(0);
    return offsetHeight + marginTop + marginBottom;
  }
  isVisible() {
    return true;
  }
  getTemplate(name2) {
    return this.component._getTemplate(name2);
  }
  getView(name2) {
    return this.component._views[name2];
  }
  _getBorderedViews() {
    return {
      columnHeadersView: this.component._views.columnHeadersView,
      rowsView: this.component._views.rowsView,
      filterPanelView: this.component._views.filterPanelView,
      footerView: this.component._views.footerView
    };
  }
  render($parent, options2) {
    let $element = this._$element;
    const isVisible = this.isVisible();
    if (!$element && !$parent) {
      return;
    }
    this._requireReady = false;
    if (!$element) {
      $element = this._$element = renderer_default("<div>").appendTo($parent);
      this._$parent = $parent;
    }
    $element.toggleClass("dx-hidden", !isVisible);
    if (this.component._views) {
      updateViewsBorders(this.name, this._getBorderedViews());
    }
    if (isVisible) {
      this.component._optionCache = {};
      const deferred = this._renderCore(options2);
      this.component._optionCache = void 0;
      if (deferred) {
        deferred.done((() => {
          this.renderCompleted.fire(options2);
        }));
      } else {
        this.renderCompleted.fire(options2);
      }
    }
  }
  resize() {
    this.isResizing = true;
    this._resizeCore();
    this.resizeCompleted.fire();
    this.isResizing = false;
  }
  focus(preventScroll) {
    this.element().get(0).focus({
      preventScroll
    });
  }
};
function getExtendedTypes(types) {
  let moduleExtenders = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const extendTypes = {};
  Object.entries(moduleExtenders).forEach(((_ref) => {
    let [name2, extender] = _ref;
    const currentType = types[name2];
    if (currentType) {
      if (isFunction(extender)) {
        extendTypes[name2] = extender(currentType);
      } else {
        const classType = currentType;
        extendTypes[name2] = classType.inherit(extender);
      }
    }
  }));
  return extendTypes;
}
function registerPublicMethods(componentInstance, name2, moduleItem) {
  const publicMethods = moduleItem.publicMethods();
  if (publicMethods) {
    each(publicMethods, ((_, methodName) => {
      if (moduleItem[methodName]) {
        if (!componentInstance[methodName]) {
          componentInstance[methodName] = function() {
            return moduleItem[methodName](...arguments);
          };
        } else {
          throw ui_errors_default.Error("E1005", methodName);
        }
      } else {
        throw ui_errors_default.Error("E1006", name2, methodName);
      }
    }));
  }
}
function processModules(componentInstance, componentClass) {
  const {
    modules
  } = componentClass;
  const {
    modulesOrder
  } = componentClass;
  function createModuleItems(moduleTypes) {
    const moduleItems = {};
    each(moduleTypes, ((name2, moduleType) => {
      const moduleItem = new moduleType(componentInstance);
      moduleItem.name = name2;
      registerPublicMethods(componentInstance, name2, moduleItem);
      moduleItems[name2] = moduleItem;
    }));
    return moduleItems;
  }
  if (modulesOrder) {
    modules.sort(((module1, module2) => {
      let orderIndex1 = modulesOrder.indexOf(module1.name);
      let orderIndex2 = modulesOrder.indexOf(module2.name);
      if (orderIndex1 < 0) {
        orderIndex1 = 1e6;
      }
      if (orderIndex2 < 0) {
        orderIndex2 = 1e6;
      }
      return orderIndex1 - orderIndex2;
    }));
  }
  const rootControllerTypes = {};
  const rootViewTypes = {};
  modules.forEach(((_ref2) => {
    let {
      name: moduleName,
      controllers = {},
      views = {}
    } = _ref2;
    Object.entries(controllers).forEach(((_ref3) => {
      let [name2, type2] = _ref3;
      if (rootControllerTypes[name2]) {
        throw ui_errors_default.Error("E1001", moduleName, name2);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof Controller)) {
        throw ui_errors_default.Error("E1002", moduleName, name2);
      }
      rootControllerTypes[name2] = type2;
    }));
    Object.entries(views).forEach(((_ref4) => {
      let [name2, type2] = _ref4;
      if (rootViewTypes[name2]) {
        throw ui_errors_default.Error("E1003", moduleName, name2);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof View)) {
        throw ui_errors_default.Error("E1004", moduleName, name2);
      }
      rootViewTypes[name2] = type2;
    }));
  }));
  const moduleExtenders = modules.filter(((_ref5) => {
    let {
      extenders
    } = _ref5;
    return !!extenders;
  }));
  const controllerTypes = moduleExtenders.reduce(((types, _ref6) => {
    let {
      extenders
    } = _ref6;
    return _extends({}, types, getExtendedTypes(types, null === extenders || void 0 === extenders ? void 0 : extenders.controllers));
  }), rootControllerTypes);
  const viewTypes = moduleExtenders.reduce(((types, _ref7) => {
    let {
      extenders
    } = _ref7;
    return _extends({}, types, getExtendedTypes(types, null === extenders || void 0 === extenders ? void 0 : extenders.views));
  }), rootViewTypes);
  componentInstance._controllers = createModuleItems(controllerTypes);
  componentInstance._views = createModuleItems(viewTypes);
}
var callModuleItemsMethod = function(that, methodName, args) {
  args = args || [];
  if (that._controllers) {
    each(that._controllers, (function() {
      this[methodName] && this[methodName].apply(this, args);
    }));
  }
  if (that._views) {
    each(that._views, (function() {
      this[methodName] && this[methodName].apply(this, args);
    }));
  }
};
var m_modules_default = {
  modules: [],
  View,
  ViewController,
  Controller,
  registerModule(name2, module) {
    const {
      modules
    } = this;
    for (let i = 0; i < modules.length; i++) {
      if (modules[i].name === name2) {
        return;
      }
    }
    module.name = name2;
    modules.push(module);
  },
  registerModulesOrder(moduleNames) {
    this.modulesOrder = moduleNames;
  },
  unregisterModule(name2) {
    this.modules = grep(this.modules, ((module) => module.name !== name2));
  },
  processModules,
  callModuleItemsMethod
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_columns_view.js
var DETAIL_ROW_CLASS = "dx-master-detail-row";
var CELL_HINT_VISIBLE = "dxCellHintVisible";
var appendElementTemplate = {
  render(options2) {
    options2.container.append(options2.content);
  }
};
var subscribeToRowEvents = function(that, $table) {
  let touchTarget;
  let touchCurrentTarget;
  let timeoutId;
  function clearTouchTargets(timeout) {
    return setTimeout((() => {
      touchTarget = touchCurrentTarget = null;
    }), timeout);
  }
  m_events_engine_default.on($table, "touchstart touchend", ".dx-row", ((e) => {
    var _e$event;
    if (null !== e && void 0 !== e && null !== (_e$event = e.event) && void 0 !== _e$event && _e$event.target && !m_utils_default.isElementInCurrentGrid(that, renderer_default(e.event.target))) {
      return;
    }
    clearTimeout(timeoutId);
    if ("touchstart" === e.type) {
      touchTarget = e.target;
      touchCurrentTarget = e.currentTarget;
      timeoutId = clearTouchTargets(1e3);
    } else {
      timeoutId = clearTouchTargets();
    }
  }));
  m_events_engine_default.on($table, [CLICK_EVENT_NAME, DBLCLICK_EVENT_NAME, m_pointer_default.down].join(" "), ".dx-row", that.createAction(((e) => {
    var _e$event2;
    const {
      event
    } = e;
    if (null !== e && void 0 !== e && null !== (_e$event2 = e.event) && void 0 !== _e$event2 && _e$event2.target && !m_utils_default.isElementInCurrentGrid(that, renderer_default(event.target))) {
      return;
    }
    if (touchTarget) {
      event.target = touchTarget;
      event.currentTarget = touchCurrentTarget;
    }
    if (!renderer_default(event.target).closest("a").length) {
      e.rowIndex = that.getRowIndex(event.currentTarget);
      if (e.rowIndex >= 0) {
        e.rowElement = getPublicElement(renderer_default(event.currentTarget));
        e.columns = that.getColumns();
        if (event.type === m_pointer_default.down) {
          that._rowPointerDown(e);
        } else if (event.type === CLICK_EVENT_NAME) {
          that._rowClick(e);
        } else {
          that._rowDblClick(e);
        }
      }
    }
  })));
};
var getWidthStyle = function(width) {
  if ("auto" === width) {
    return "";
  }
  return isNumeric(width) ? `${width}px` : width;
};
var setCellWidth = function(cell, column, width) {
  cell.style.width = cell.style.maxWidth = "auto" === column.width ? "" : width;
};
var copyAttributes = function(element, newElement) {
  if (!element || !newElement) {
    return;
  }
  const oldAttributes = element.attributes;
  const newAttributes = newElement.attributes;
  let i;
  for (i = 0; i < oldAttributes.length; i++) {
    const name2 = oldAttributes[i].nodeName;
    if (!newElement.hasAttribute(name2)) {
      element.removeAttribute(name2);
    }
  }
  for (i = 0; i < newAttributes.length; i++) {
    element.setAttribute(newAttributes[i].nodeName, newAttributes[i].nodeValue);
  }
};
var removeHandler = function(templateDeferred) {
  templateDeferred.resolve();
};
var normalizeWidth = (width) => {
  if ("number" === typeof width) {
    return `${width.toFixed(3)}px`;
  }
  if ("adaptiveHidden" === width) {
    return "0.0001px";
  }
  return width;
};
var ColumnsView = class extends ColumnStateMixin(m_modules_default.View) {
  init() {
    this._scrollLeft = -1;
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnChooserController = this.getController("columnChooser");
    this._editorFactoryController = this.getController("editorFactory");
    this._selectionController = this.getController("selection");
    this._columnChooserView = this.getView("columnChooserView");
    this._delayedTemplates = [];
    this._templateDeferreds = /* @__PURE__ */ new Set();
    this._templatesCache = {};
    this._templateTimeouts = /* @__PURE__ */ new Set();
    this.createAction("onCellClick");
    this.createAction("onRowClick");
    this.createAction("onCellDblClick");
    this.createAction("onRowDblClick");
    this.createAction("onCellHoverChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onCellPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onRowPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering",
      afterExecute: (e) => {
        this._afterRowPrepared(e);
      }
    });
    this._columnsController.columnsChanged.add(this._columnOptionChanged.bind(this));
    this._dataController && this._dataController.changed.add(this._handleDataChanged.bind(this));
  }
  dispose() {
    if (hasWindow()) {
      var _this$_templateTimeou, _this$_templateTimeou2;
      const window15 = getWindow();
      null === (_this$_templateTimeou = this._templateTimeouts) || void 0 === _this$_templateTimeou || _this$_templateTimeou.forEach(((templateTimeout) => window15.clearTimeout(templateTimeout)));
      null === (_this$_templateTimeou2 = this._templateTimeouts) || void 0 === _this$_templateTimeou2 || _this$_templateTimeou2.clear();
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    switch (args.name) {
      case "cellHintEnabled":
      case "onCellPrepared":
      case "onRowPrepared":
      case "onCellHoverChanged":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this._invalidate(true, true);
        }
        args.handled = true;
    }
  }
  _createScrollableOptions() {
    const scrollingOptions = this.option("scrolling");
    let useNativeScrolling = this.option("scrolling.useNative");
    const options2 = extend({}, scrollingOptions, {
      direction: "both",
      bounceEnabled: false,
      useKeyboard: false
    });
    if (void 0 === useNativeScrolling) {
      useNativeScrolling = true;
    }
    if ("auto" === useNativeScrolling) {
      delete options2.useNative;
      delete options2.useSimulatedScrollbar;
    } else {
      options2.useNative = !!useNativeScrolling;
      options2.useSimulatedScrollbar = !useNativeScrolling;
    }
    return options2;
  }
  _updateCell($cell, parameters) {
    if (parameters.rowType) {
      this._cellPrepared($cell, parameters);
    }
  }
  _needToSetCellWidths() {
    return this.option("columnAutoWidth");
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const alignment = column.alignment || getDefaultAlignment(this.option("rtlEnabled"));
    const needToSetCellWidths = this._needToSetCellWidths();
    const cell = dom_adapter_default.createElement("td");
    cell.style.textAlign = alignment;
    const $cell = renderer_default(cell);
    if (column.cssClass) {
      $cell.addClass(column.cssClass);
    }
    if (Array.isArray(column.elementAttr)) {
      column.elementAttr.forEach(((_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        $cell.attr(name2, value2);
      }));
    }
    if ("expand" === column.command) {
      $cell.addClass(column.cssClass);
      $cell.addClass(this.addWidgetPrefix("group-space"));
    }
    if (column.colspan > 1) {
      $cell.attr("colSpan", column.colspan);
    } else if (!column.isBand && "auto" !== column.visibleWidth && needToSetCellWidths) {
      if (column.width || column.minWidth) {
        cell.style.minWidth = getWidthStyle(column.minWidth || column.width);
      }
      if (column.width) {
        setCellWidth(cell, column, getWidthStyle(column.width));
      }
    }
    return $cell;
  }
  _createRow(rowObject, tagName) {
    tagName = tagName || "tr";
    const $element = renderer_default(`<${tagName}>`).addClass("dx-row");
    if ("tr" === tagName) {
      this.setAria("role", "row", $element);
    }
    return $element;
  }
  _isAltRow(row) {
    return row && row.dataIndex % 2 === 1;
  }
  _createTable(columns7, isAppend) {
    const $table = renderer_default("<table>").addClass(this.addWidgetPrefix("table")).addClass(this.addWidgetPrefix("table-fixed"));
    if (columns7 && !isAppend) {
      $table.attr("id", `dx-${new guid_default()}`).append(this._createColGroup(columns7));
      if (browser_default.safari) {
        $table.append(renderer_default("<thead>").append("<tr>"));
      }
      this.setAria("role", "presentation", $table);
    } else {
      this.setAria("hidden", true, $table);
    }
    this.setAria("role", "presentation", renderer_default("<tbody>").appendTo($table));
    if (isAppend) {
      return $table;
    }
    if (browser_default.mozilla) {
      m_events_engine_default.on($table, "mousedown", "td", ((e) => {
        if (e.ctrlKey) {
          e.preventDefault();
        }
      }));
    }
    if (this.option("cellHintEnabled")) {
      m_events_engine_default.on($table, "mousemove", ".dx-row > td", this.createAction(((args) => {
        const e = args.event;
        const $element = renderer_default(e.target);
        const $cell = renderer_default(e.currentTarget);
        const $row = $cell.parent();
        const visibleColumns = this._columnsController.getVisibleColumns();
        const rowOptions = $row.data("options");
        const columnIndex = $cell.index();
        const cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex];
        const column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
        const isHeaderRow = $row.hasClass("dx-header-row");
        const isDataRow2 = $row.hasClass("dx-data-row");
        const isMasterDetailRow = $row.hasClass(DETAIL_ROW_CLASS);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isFilterRow = $row.hasClass(this.addWidgetPrefix("filter-row"));
        const isDataRowWithTemplate = isDataRow2 && (!column || column.cellTemplate);
        const isEditorShown = isDataRow2 && cellOptions && (rowOptions.isEditing || cellOptions.isEditing || (null === column || void 0 === column ? void 0 : column.showEditorAlways));
        const isHeaderRowWithTemplate = isHeaderRow && (!column || column.headerCellTemplate);
        const isGroupCellWithTemplate = isGroupRow3 && (!column || column.groupIndex && column.groupCellTemplate);
        const shouldShowHint = !isMasterDetailRow && !isFilterRow && !isEditorShown && !isDataRowWithTemplate && !isHeaderRowWithTemplate && !isGroupCellWithTemplate;
        if (shouldShowHint) {
          if ($element.data(CELL_HINT_VISIBLE)) {
            $element.removeAttr("title");
            $element.data(CELL_HINT_VISIBLE, false);
          }
          const difference = $element[0].scrollWidth - $element[0].clientWidth;
          if (difference > 0 && !isDefined($element.attr("title"))) {
            $element.attr("title", $element.text());
            $element.data(CELL_HINT_VISIBLE, true);
          }
        }
      })));
    }
    const getOptions = (event) => {
      const $cell = renderer_default(event.currentTarget);
      const $fieldItemContent = renderer_default(event.target).closest(".dx-field-item-content");
      const $row = $cell.parent();
      const rowOptions = $row.data("options");
      const options2 = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
      if (!$cell.closest("table").is(event.delegateTarget)) {
        return;
      }
      const resultOptions = extend({}, options2, {
        cellElement: getPublicElement($cell),
        event,
        eventType: event.type
      });
      resultOptions.rowIndex = this.getRowIndex($row);
      if ($fieldItemContent.length) {
        const formItemOptions = $fieldItemContent.data("dx-form-item");
        if (formItemOptions.column) {
          resultOptions.column = formItemOptions.column;
          resultOptions.columnIndex = this._columnsController.getVisibleIndex(resultOptions.column.index);
        }
      }
      return resultOptions;
    };
    m_events_engine_default.on($table, "mouseover", ".dx-row > td", ((e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellHoverChanged", options2);
    }));
    m_events_engine_default.on($table, "mouseout", ".dx-row > td", ((e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellHoverChanged", options2);
    }));
    m_events_engine_default.on($table, CLICK_EVENT_NAME, ".dx-row > td", ((e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellClick", options2);
    }));
    m_events_engine_default.on($table, DBLCLICK_EVENT_NAME, ".dx-row > td", ((e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellDblClick", options2);
    }));
    subscribeToRowEvents(this, $table);
    return $table;
  }
  _rowPointerDown(e) {
  }
  _rowClick() {
  }
  _rowDblClick() {
  }
  _createColGroup(columns7) {
    const colgroupElement = renderer_default("<colgroup>");
    for (let i = 0; i < columns7.length; i++) {
      const colspan = columns7[i].colspan || 1;
      for (let j = 0; j < colspan; j++) {
        colgroupElement.append(this._createCol(columns7[i]));
      }
    }
    return colgroupElement;
  }
  _createCol(column) {
    let width = column.visibleWidth || column.width;
    if ("adaptiveHidden" === width) {
      width = "0.0001px";
    }
    const col = renderer_default("<col>");
    setWidth2(col, width);
    return col;
  }
  renderDelayedTemplates(change) {
    const delayedTemplates = this._delayedTemplates;
    const syncTemplates = delayedTemplates.filter(((template) => !template.async));
    const asyncTemplates = delayedTemplates.filter(((template) => template.async));
    this._delayedTemplates = [];
    this._renderDelayedTemplatesCore(syncTemplates, false, change);
    this._renderDelayedTemplatesCoreAsync(asyncTemplates);
  }
  _renderDelayedTemplatesCoreAsync(templates) {
    if (templates.length) {
      const templateTimeout = getWindow().setTimeout((() => {
        this._templateTimeouts.delete(templateTimeout);
        this._renderDelayedTemplatesCore(templates, true);
      }));
      this._templateTimeouts.add(templateTimeout);
    }
  }
  _renderDelayedTemplatesCore(templates, isAsync, change) {
    const date = /* @__PURE__ */ new Date();
    while (templates.length) {
      const templateParameters = templates.shift();
      const {
        options: options2
      } = templateParameters;
      const doc = dom_adapter_default.getRootNode(renderer_default(options2.container).get(0));
      const needWaitAsyncTemplates = this.needWaitAsyncTemplates();
      if (!isAsync || renderer_default(options2.container).closest(doc).length || needWaitAsyncTemplates) {
        if (change) {
          options2.change = change;
        }
        templateParameters.template.render(options2);
      }
      if (isAsync && /* @__PURE__ */ new Date() - date > 30) {
        this._renderDelayedTemplatesCoreAsync(templates);
        break;
      }
    }
    if (!templates.length && this._delayedTemplates.length) {
      this.renderDelayedTemplates();
    }
  }
  _processTemplate(template, options2) {
    const that = this;
    let renderingTemplate;
    if (template && template.render && !isRenderer(template)) {
      renderingTemplate = {
        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
        render(options3) {
          template.render(options3.container, options3.model, options3.change);
          options3.deferred && options3.deferred.resolve();
        }
      };
    } else if (isFunction(template)) {
      renderingTemplate = {
        render(options3) {
          const renderedTemplate = template(getPublicElement(options3.container), options3.model, options3.change);
          if (renderedTemplate && (renderedTemplate.nodeType || isRenderer(renderedTemplate))) {
            options3.container.append(renderedTemplate);
          }
          options3.deferred && options3.deferred.resolve();
        }
      };
    } else {
      const templateID = isString(template) ? template : renderer_default(template).attr("id");
      if (!templateID) {
        renderingTemplate = that.getTemplate(template);
      } else {
        if (!that._templatesCache[templateID]) {
          that._templatesCache[templateID] = that.getTemplate(template);
        }
        renderingTemplate = that._templatesCache[templateID];
      }
    }
    return renderingTemplate;
  }
  renderTemplate(container, template, options2, allowRenderToDetachedContainer, change) {
    const renderingTemplate = this._processTemplate(template, options2);
    const {
      column
    } = options2;
    const isDataRow2 = "data" === options2.rowType;
    const templateDeferred = new Deferred();
    const templateOptions = {
      container,
      model: options2,
      deferred: templateDeferred,
      onRendered: () => {
        if (this.isDisposed()) {
          templateDeferred.reject();
        } else {
          templateDeferred.resolve();
        }
      }
    };
    if (renderingTemplate) {
      options2.component = this.component;
      const columnAsync = column && (column.renderAsync && isDataRow2 || this.option("renderAsync") && (false !== column.renderAsync && (column.command || column.showEditorAlways) && isDataRow2 || "filter" === options2.rowType));
      const async = options2.renderAsync ?? columnAsync;
      if ((renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) && !async) {
        renderingTemplate.render(templateOptions);
      } else {
        this._delayedTemplates.push({
          template: renderingTemplate,
          options: templateOptions,
          async
        });
      }
      this._templateDeferreds.add(templateDeferred);
      m_events_engine_default.on(container, removeEvent, removeHandler.bind(null, templateDeferred));
    } else {
      templateDeferred.reject();
    }
    return templateDeferred.promise().always((() => {
      this._templateDeferreds.delete(templateDeferred);
    }));
  }
  _getBodies(tableElement) {
    return renderer_default(tableElement).children("tbody").not(".dx-header").not(".dx-footer");
  }
  _needWrapRow($tableElement) {
    var _this$_getBodies;
    const hasRowTemplate = !!this.option().rowTemplate;
    return hasRowTemplate && !!(null !== (_this$_getBodies = this._getBodies($tableElement)) && void 0 !== _this$_getBodies && _this$_getBodies.filter(".dx-row").length);
  }
  _wrapRowIfNeed($table, $row, isRefreshing) {
    const $tableElement = isRefreshing ? $table || this._tableElement : this._tableElement || $table;
    const needWrapRow = this._needWrapRow($tableElement);
    if (needWrapRow) {
      const $tbody = renderer_default("<tbody>").addClass($row.attr("class"));
      this.setAria("role", "presentation", $tbody);
      return $tbody.append($row);
    }
    return $row;
  }
  _appendRow($table, $row, appendTemplate) {
    appendTemplate = appendTemplate || appendElementTemplate;
    appendTemplate.render({
      content: $row,
      container: $table
    });
  }
  _resizeCore() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  _renderCore(e) {
    const $root = this.element().parent();
    if (!$root || $root.parent().length) {
      this.renderDelayedTemplates(e);
    }
    return new Deferred().resolve();
  }
  _renderTable(options2) {
    options2 = options2 || {};
    options2.columns = this._columnsController.getVisibleColumns();
    const changeType = options2.change && options2.change.changeType;
    const $table = this._createTable(options2.columns, "append" === changeType || "prepend" === changeType || "update" === changeType);
    this._renderRows($table, options2);
    return $table;
  }
  _renderRows($table, options2) {
    const that = this;
    const rows = that._getRows(options2.change);
    const columnIndices = options2.change && options2.change.columnIndices || [];
    const changeTypes = options2.change && options2.change.changeTypes || [];
    for (let i = 0; i < rows.length; i++) {
      that._renderRow($table, extend({
        row: rows[i],
        columnIndices: columnIndices[i],
        changeType: changeTypes[i]
      }, options2));
    }
  }
  _renderRow($table, options2) {
    if (!options2.columnIndices) {
      options2.row.cells = [];
    }
    const $row = this._createRow(options2.row);
    const $wrappedRow = this._wrapRowIfNeed($table, $row);
    if ("remove" !== options2.changeType) {
      this._renderCells($row, options2);
    }
    this._appendRow($table, $wrappedRow);
    const rowOptions = extend({
      columns: options2.columns
    }, options2.row);
    this._addWatchMethod(rowOptions, options2.row);
    this._rowPrepared($wrappedRow, rowOptions, options2.row);
  }
  _needRenderCell(columnIndex, columnIndices) {
    return !columnIndices || columnIndices.indexOf(columnIndex) >= 0;
  }
  _renderCells($row, options2) {
    const that = this;
    let columnIndex = 0;
    const {
      row
    } = options2;
    const {
      columns: columns7
    } = options2;
    for (let i = 0; i < columns7.length; i++) {
      if (this._needRenderCell(i, options2.columnIndices)) {
        that._renderCell($row, extend({
          column: columns7[i],
          columnIndex,
          value: row.values && row.values[columnIndex],
          oldValue: row.oldValues && row.oldValues[columnIndex]
        }, options2));
      }
      if (columns7[i].colspan > 1) {
        columnIndex += columns7[i].colspan;
      } else {
        columnIndex++;
      }
    }
  }
  _updateCells($rowElement, $newRowElement, columnIndices, options2) {
    var _options$node;
    const that = this;
    const $cells = $rowElement.children();
    const $newCells = $newRowElement.children();
    const highlightChanges = this.option("highlightChanges");
    const cellUpdatedClass = this.addWidgetPrefix("cell-updated-animation");
    if (null !== options2 && void 0 !== options2 && null !== (_options$node = options2.node) && void 0 !== _options$node && _options$node.hasChildren) {
      $cells.each((function() {
        that.setAria("expanded", options2.isExpanded, renderer_default(this));
      }));
    }
    columnIndices.forEach(((columnIndex, index) => {
      const $cell = $cells.eq(columnIndex);
      const $newCell = $newCells.eq(index);
      $cell.replaceWith($newCell);
      if (highlightChanges && !$newCell.hasClass("dx-command-expand")) {
        $newCell.addClass(cellUpdatedClass);
      }
    }));
    copyAttributes($rowElement.get(0), $newRowElement.get(0));
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    var _row$node;
    const {
      row
    } = options2;
    const isFreeSpaceRow = "freeSpace" === cellOptions.rowType;
    const isGroupRow3 = "group" === cellOptions.rowType;
    const rowHasChildren = null === row || void 0 === row || null === (_row$node = row.node) || void 0 === _row$node ? void 0 : _row$node.hasChildren;
    if (isFreeSpaceRow) {
      return;
    }
    this.setAria("role", "gridcell", $cell);
    if (rowHasChildren) {
      this.setAria("expanded", row.isExpanded, $cell);
    }
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    const ariaColIndex = isGroupRow3 ? cellOptions.columnIndex + 1 : cellOptions.columnIndex + columnIndexOffset + 1;
    this.setAria("colindex", ariaColIndex, $cell);
  }
  _renderCell($row, options2) {
    const cellOptions = this._getCellOptions(options2);
    if (options2.columnIndices) {
      if (options2.row.cells) {
        const cellIndex = options2.row.cells.findIndex(((cell) => cell.columnIndex === cellOptions.columnIndex));
        options2.row.cells[cellIndex] = cellOptions;
      }
    } else {
      options2.row.cells.push(cellOptions);
    }
    const $cell = this._createCell(cellOptions);
    this._setCellAriaAttributes($cell, cellOptions, options2);
    this._renderCellContent($cell, cellOptions, options2);
    $row.get(0).appendChild($cell.get(0));
    return $cell;
  }
  _renderCellContent($cell, options2, renderOptions) {
    const template = this._getCellTemplate(options2);
    when(!template || this.renderTemplate($cell, template, options2, void 0, renderOptions.change)).done((() => {
      this._updateCell($cell, options2);
    }));
  }
  _getCellTemplate(options2) {
  }
  _getRows(change) {
    return [];
  }
  _getCellOptions(options2) {
    const cellOptions = {
      column: options2.column,
      columnIndex: options2.columnIndex,
      rowType: options2.row.rowType,
      rowIndex: options2.row.rowIndex,
      isAltRow: this._isAltRow(options2.row)
    };
    this._addWatchMethod(cellOptions);
    return cellOptions;
  }
  _addWatchMethod(options2, source) {
    if (!this.option("repaintChangesOnly")) {
      return;
    }
    const watchers = [];
    source = source || options2;
    source.watch = source.watch || function(getter, updateValueFunc, updateRowFunc) {
      let oldValue = getter(source.data);
      const watcher = function(row) {
        if (row && updateRowFunc) {
          updateRowFunc(row);
        }
        const newValue = getter(source.data);
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          if (row) {
            updateValueFunc(newValue);
          }
          oldValue = newValue;
        }
      };
      watchers.push(watcher);
      return function() {
        const index = watchers.indexOf(watcher);
        if (index >= 0) {
          watchers.splice(index, 1);
        }
      };
    };
    source.update = source.update || function(row, keepRow) {
      if (row) {
        this.data = options2.data = row.data;
        this.rowIndex = options2.rowIndex = row.rowIndex;
        this.dataIndex = options2.dataIndex = row.dataIndex;
        this.isExpanded = options2.isExpanded = row.isExpanded;
        if (options2.row && !keepRow) {
          options2.row = row;
        }
      }
      watchers.forEach(((watcher) => {
        watcher(row);
      }));
    };
    if (source !== options2) {
      options2.watch = source.watch.bind(source);
    }
    return options2;
  }
  _cellPrepared(cell, options2) {
    options2.cellElement = getPublicElement(renderer_default(cell));
    this.executeAction("onCellPrepared", options2);
  }
  _rowPrepared($row, options2, row) {
    data($row.get(0), "options", options2);
    options2.rowElement = getPublicElement($row);
    this.executeAction("onRowPrepared", options2);
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (m_utils_default.checkChanges(optionNames, ["width", "visibleWidth"])) {
      const visibleColumns = this._columnsController.getVisibleColumns();
      const widths = visibleColumns.map(((column) => column.visibleWidth || column.width));
      this.setColumnWidths({
        widths,
        optionNames
      });
      return;
    }
    if (!this._requireReady) {
      this.render();
    }
  }
  getCellIndex($cell, rowIndex) {
    const cellIndex = $cell.length ? $cell[0].cellIndex : -1;
    return cellIndex;
  }
  getTableElements() {
    return this._tableElement || renderer_default();
  }
  getTableElement(isFixedTableRendering) {
    return this._tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    this._tableElement = tableElement;
  }
  _afterRowPrepared(e) {
  }
  _handleDataChanged(e) {
  }
  callbackNames() {
    return ["scrollChanged"];
  }
  _updateScrollLeftPosition() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  scrollTo(pos) {
    const $element = this.element();
    const $scrollContainer = $element && $element.children(`.${this.addWidgetPrefix("scroll-container")}`).not(`.${this.addWidgetPrefix("content-fixed")}`);
    if (isDefined(pos) && isDefined(pos.left) && this._scrollLeft !== pos.left) {
      this._scrollLeft = pos.left;
      $scrollContainer && $scrollContainer.scrollLeft(pos.left);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_tableElement;
    return null === (_this$_tableElement = this._tableElement) || void 0 === _this$_tableElement ? void 0 : _this$_tableElement.parent();
  }
  _removeContent(isFixedTableRendering) {
    const $scrollContainer = this.getContent(isFixedTableRendering);
    if (null !== $scrollContainer && void 0 !== $scrollContainer && $scrollContainer.length) {
      $scrollContainer.remove();
    }
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = renderer_default("<div>");
    const useNative = this.option("scrolling.useNative");
    if (false === useNative || "auto" === useNative && !m_support_default.nativeScrolling) {
      $scrollContainer.addClass(this.addWidgetPrefix("scrollable-simulated"));
    }
    m_events_engine_default.on($scrollContainer, "scroll", (() => {
      const scrollLeft = $scrollContainer.scrollLeft();
      if (scrollLeft !== this._scrollLeft) {
        this.scrollChanged.fire({
          left: scrollLeft
        }, this.name);
      }
    }));
    $scrollContainer.addClass(this.addWidgetPrefix("content")).addClass(this.addWidgetPrefix("scroll-container")).append($table).appendTo(this.element());
    this.setAria("role", "presentation", $scrollContainer);
    return $scrollContainer;
  }
  needWaitAsyncTemplates() {
    return this.option("templatesRenderAsynchronously") && false === this.option("renderAsync");
  }
  waitAsyncTemplates() {
    let forceWaiting = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const result2 = new Deferred();
    const needWaitAsyncTemplates = forceWaiting || this.needWaitAsyncTemplates();
    if (!needWaitAsyncTemplates || !isDefined(this._templateDeferreds)) {
      return result2.resolve();
    }
    const waitTemplatesRecursion = () => when.apply(this, Array.from(this._templateDeferreds)).done((() => {
      if (this.isDisposed()) {
        result2.reject();
      } else if (this._templateDeferreds.size > 0) {
        waitTemplatesRecursion();
      } else {
        result2.resolve();
      }
    })).fail(result2.reject);
    waitTemplatesRecursion();
    return result2.promise();
  }
  _updateContent($newTableElement, change, isFixedTableRendering) {
    return this.waitAsyncTemplates().done((() => {
      this._removeContent(isFixedTableRendering);
      this.setTableElement($newTableElement, isFixedTableRendering);
      this._wrapTableInScrollContainer($newTableElement, isFixedTableRendering);
    }));
  }
  _findContentElement(isFixedTableRendering) {
  }
  _getWidths($cellElements) {
    if (!$cellElements) {
      return [];
    }
    const result2 = [];
    const cellElements = $cellElements.toArray();
    cellElements.forEach(((cell) => {
      let width = cell.offsetWidth;
      if (cell.getBoundingClientRect) {
        const rect = getBoundingRect(cell);
        if (rect.width > cell.offsetWidth - 1) {
          width = rect.width;
        }
      }
      result2.push(width);
    }));
    return result2;
  }
  getColumnWidths($tableElement, rowIndex) {
    (this.option("forceApplyBindings") || noop)();
    $tableElement = $tableElement ?? this.getTableElement();
    if ($tableElement) {
      const $rows = $tableElement.children("tbody:not(.dx-header)").children();
      for (let i = 0; i < $rows.length; i++) {
        const $row = $rows.eq(i);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isDetailRow3 = $row.hasClass(DETAIL_ROW_CLASS);
        const isErrorRow = $row.hasClass("dx-error-row");
        const isRowVisible = "none" !== $row.get(0).style.display && !$row.hasClass("dx-state-invisible");
        const isRelevantRow = !isGroupRow3 && !isDetailRow3 && !isErrorRow;
        if (isRowVisible && isRelevantRow) {
          const $cells = $row.children("td");
          const result2 = this._getWidths($cells);
          return result2;
        }
      }
    }
    return [];
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    return columnIndex;
  }
  setCellPropertiesCore(styleProps, $row, visibleCellIndex) {
    const $cell = $row.hasClass("dx-group-row") ? $row.find(`td[aria-colindex='${visibleCellIndex + 1}']:not(.dx-group-cell)`) : $row.find("td").eq(visibleCellIndex);
    for (let i = 0; i < $cell.length; i += 1) {
      const cell = $cell.get(i);
      Object.assign(cell.style, styleProps);
    }
  }
  setCellProperties(styleProps, columnIndex, rowIndex) {
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length)) {
      return;
    }
    const $rows = $tableElement.children().children(".dx-row").not(`.${DETAIL_ROW_CLASS}`);
    if (isDefined(rowIndex)) {
      this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex), columnIndex);
    } else {
      for (let rowIndex2 = 0; rowIndex2 < $rows.length; rowIndex2++) {
        const visibleIndex = this.getVisibleColumnIndex(columnIndex, rowIndex2);
        if (visibleIndex >= 0) {
          this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex2), visibleIndex);
        }
      }
    }
  }
  setColumnWidths(_ref2) {
    let {
      widths,
      optionNames
    } = _ref2;
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length) || !widths) {
      return;
    }
    const columns7 = this.getColumns();
    const needToSetCellWidths = this._needToSetCellWidths();
    const $cols = $tableElement.children("colgroup").children("col");
    $cols.toArray().forEach(((col) => col.removeAttribute("style")));
    columns7.forEach(((column, columnIndex) => {
      if (needToSetCellWidths && column.width && !column.command) {
        const styleProps = {};
        const width = getWidthStyle(column.visibleWidth || column.width);
        const minWidth = getWidthStyle(column.minWidth || width);
        styleProps.width = "auto" === column.width ? "" : width;
        styleProps.maxWidth = styleProps.width;
        styleProps.minWidth = minWidth;
        this.setCellProperties(styleProps, columnIndex);
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
    }));
  }
  getCellElements(rowIndex) {
    return this._getCellElementsCore(rowIndex);
  }
  _getCellElementsCore(rowIndex) {
    if (rowIndex < 0) {
      return;
    }
    const $row = this._getRowElements().eq(rowIndex);
    return $row.children();
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const $cells = this.getCellElements(rowIndex);
    const columnVisibleIndex = this._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
    if (!(null !== $cells && void 0 !== $cells && $cells.length) || columnVisibleIndex < 0) {
      return;
    }
    const $cell = $cells.eq(columnVisibleIndex);
    return $cell.length > 0 ? $cell : void 0;
  }
  _getRowElement(rowIndex) {
    const that = this;
    let $rowElement = renderer_default();
    const $tableElements = that.getTableElements();
    each($tableElements, ((_, tableElement) => {
      $rowElement = $rowElement.add(that._getRowElements(renderer_default(tableElement)).eq(rowIndex));
    }));
    if ($rowElement.length) {
      return $rowElement;
    }
    return;
  }
  getCellElement(rowIndex, columnIdentifier) {
    const $cell = this._getCellElement(rowIndex, columnIdentifier);
    if ($cell) {
      return getPublicElement($cell);
    }
    return;
  }
  getRowElement(rowIndex) {
    const $rows = this._getRowElement(rowIndex);
    let elements = [];
    if ($rows && !getPublicElement($rows).get) {
      for (let i = 0; i < $rows.length; i++) {
        elements.push($rows[i]);
      }
    } else {
      elements = $rows;
    }
    return elements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    if (isString(columnIdentifier)) {
      const columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
      return this._columnsController.getVisibleIndex(columnIndex);
    }
    return columnIdentifier;
  }
  getColumnElements() {
  }
  getColumns(rowIndex, $tableElement) {
    return this._columnsController.getVisibleColumns(rowIndex);
  }
  getCell(cellPosition, rows, cells) {
    const $rows = rows || this._getRowElements();
    let $cells;
    if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
      var _$cells;
      if ("virtual" !== this.option("scrolling.mode") && "virtual" !== this.option("scrolling.rowRenderingMode")) {
        cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
      }
      $cells = cells || this.getCellElements(cellPosition.rowIndex);
      if ((null === (_$cells = $cells) || void 0 === _$cells ? void 0 : _$cells.length) > 0) {
        return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1);
      }
    }
  }
  getRowsCount() {
    const tableElement = this.getTableElement();
    if (tableElement && 1 === tableElement.length) {
      return tableElement[0].rows.length;
    }
    return 0;
  }
  _getRowElementsCore(tableElement) {
    tableElement = tableElement || this.getTableElement();
    if (tableElement) {
      const hasRowTemplate = this.option().rowTemplate || this.option("dataRowTemplate");
      const tBodies = hasRowTemplate && tableElement.find("> tbody.dx-row");
      return tBodies && tBodies.length ? tBodies : tableElement.find("> tbody > .dx-row, > .dx-row");
    }
    return renderer_default();
  }
  _getRowElements(tableElement) {
    return this._getRowElementsCore(tableElement);
  }
  getRowIndex($row) {
    return this._getRowElements().index($row);
  }
  getBoundingRect() {
  }
  getName() {
  }
  setScrollerSpacing(width) {
    const $element = this.element();
    const rtlEnabled = this.option("rtlEnabled");
    $element && $element.css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isScrollbarVisible(isHorizontal) {
    const $element = this.element();
    const $tableElement = this._tableElement;
    if ($element && $tableElement) {
      return isHorizontal ? getOuterWidth($tableElement) - getWidth($element) > 0 : getOuterHeight($tableElement) - getHeight($element) > 0;
    }
    return false;
  }
  isDisposed() {
    var _this$component;
    return null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component._disposed;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_headers/m_column_headers.js
var LINK = "dx-link";
var createCellContent = function(that, $cell, options2) {
  const $cellContent = renderer_default("<div>").addClass(that.addWidgetPrefix("text-content"));
  that.setAria("role", "presentation", $cellContent);
  addCssClassesToCellContent(that, $cell, options2.column, $cellContent);
  const showColumnLines = that.option("showColumnLines");
  const contentAlignment = that.getController("columns").getHeaderContentAlignment(options2.column.alignment);
  return $cellContent[showColumnLines || "right" === contentAlignment ? "appendTo" : "prependTo"]($cell);
};
function addCssClassesToCellContent(that, $cell, column, $cellContent) {
  const $indicatorElements = that._getIndicatorElements($cell, true);
  const $visibleIndicatorElements = that._getIndicatorElements($cell);
  const indicatorCount = $indicatorElements && $indicatorElements.length;
  const columnAlignment = that._getColumnAlignment(column.alignment);
  const sortIndicatorClassName = `.${that._getIndicatorClassName("sort")}`;
  const sortIndexIndicatorClassName = `.${that._getIndicatorClassName("sortIndex")}`;
  const $sortIndicator = $visibleIndicatorElements.filter(sortIndicatorClassName);
  const $sortIndexIndicator = $visibleIndicatorElements.children().filter(sortIndexIndicatorClassName);
  $cellContent = $cellContent || $cell.children(`.${that.addWidgetPrefix("text-content")}`);
  $cellContent.toggleClass("dx-text-content-alignment-" + columnAlignment, indicatorCount > 0).toggleClass("dx-text-content-alignment-" + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass("dx-sort-indicator", !!$sortIndicator.length).toggleClass("dx-sort-index-indicator", !!$sortIndexIndicator.length).toggleClass("dx-header-filter-indicator", !!$visibleIndicatorElements.filter(`.${that._getIndicatorClassName("headerFilter")}`).length);
}
var ColumnHeadersView = class extends ColumnsView {
  init() {
    super.init();
    this._headerPanelView = this.getView("headerPanel");
    this._headerFilterController = this.getController("headerFilter");
    this._dataController = this.getController("data");
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    m_events_engine_default.on($table, "mousedown selectstart", this.createAction(((e) => {
      const {
        event
      } = e;
      if (event.shiftKey) {
        event.preventDefault();
      }
    })));
    return $table;
  }
  _isLegacyKeyboardNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDefaultTemplate(column) {
    const that = this;
    return function($container, options2) {
      const {
        caption
      } = column;
      const needCellContent = !column.command || caption && "expand" !== column.command;
      if ("empty" === column.command) {
        that._renderEmptyMessage($container, options2);
      } else if (needCellContent) {
        const $content = createCellContent(that, $container, options2);
        $content.text(caption);
      } else if (column.command) {
        $container.html("&nbsp;");
      }
    };
  }
  _renderEmptyMessage($container, options2) {
    const textEmpty = this._getEmptyHeaderText();
    if (!textEmpty) {
      $container.html("&nbsp;");
      return;
    }
    const $cellContent = createCellContent(this, $container, options2);
    const needSplit = textEmpty.includes("{0}");
    if (needSplit) {
      const [leftPart, rightPart] = textEmpty.split("{0}");
      const columnChooserTitle = message_default.format("dxDataGrid-emptyHeaderColumnChooserText");
      const columnChooserView = this._columnChooserView;
      const $link = renderer_default("<a>").text(columnChooserTitle).addClass(LINK);
      m_events_engine_default.on($link, "click", this.createAction((() => columnChooserView.showColumnChooser())));
      $cellContent.append(dom_adapter_default.createTextNode(leftPart)).append($link).append(dom_adapter_default.createTextNode(rightPart));
    } else {
      $cellContent.text(textEmpty);
    }
  }
  _getEmptyHeaderText() {
    const hasHiddenColumns = !!this._columnChooserView.hasHiddenColumns();
    const hasGroupedColumns = !!this._headerPanelView.hasGroupedColumns();
    switch (true) {
      case (hasHiddenColumns && hasGroupedColumns):
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText");
      case hasGroupedColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithGroupPanelText");
      case hasHiddenColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserText");
      default:
        return "";
    }
  }
  _getHeaderTemplate(column) {
    return column.headerCellTemplate || {
      allowRenderToDetachedContainer: true,
      render: this._getDefaultTemplate(column)
    };
  }
  _processTemplate(template, options2) {
    const that = this;
    let resultTemplate;
    const {
      column
    } = options2;
    const renderingTemplate = super._processTemplate(template);
    if ("header" === options2.rowType && renderingTemplate && column.headerCellTemplate && !column.command) {
      resultTemplate = {
        render(options3) {
          const $content = createCellContent(that, options3.container, options3.model);
          renderingTemplate.render(extend({}, options3, {
            container: $content
          }));
        }
      };
    } else {
      resultTemplate = renderingTemplate;
    }
    return resultTemplate;
  }
  _handleDataChanged(e) {
    if ("refresh" !== e.changeType) {
      return;
    }
    if (this._isGroupingChanged || this._requireReady) {
      this._isGroupingChanged = false;
      this.render();
    }
  }
  _renderCell($row, options2) {
    const $cell = super._renderCell($row, options2);
    if ("header" === options2.row.rowType) {
      $cell.addClass("dx-cell-focus-disabled");
      if (!this._isLegacyKeyboardNavigation()) {
        if (options2.column && !options2.column.type) {
          $cell.attr("tabindex", this.option("tabindex") || 0);
        }
      }
    }
    return $cell;
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    super._setCellAriaAttributes($cell, cellOptions, options2);
    if ("header" === cellOptions.rowType) {
      if (!cellOptions.column.type) {
        this.setAria("role", "columnheader", $cell);
      }
      if (cellOptions.column && !cellOptions.column.command && !cellOptions.column.isBand) {
        $cell.attr("id", cellOptions.column.headerId);
        this.setAria("label", `${message_default.format("dxDataGrid-ariaColumn")} ${cellOptions.column.caption}`, $cell);
      }
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    $row.toggleClass("dx-column-lines", this.option("showColumnLines"));
    if ("header" === row.rowType) {
      $row.addClass("dx-header-row");
      if (!this._isLegacyKeyboardNavigation()) {
        registerKeyboardAction2("columnHeaders", this, $row, "td", this._handleActionKeyDown.bind(this));
      }
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    this._lastActionElement = event.target;
    if ($target.is(".dx-header-filter")) {
      const headerFilterController = this._headerFilterController;
      const $column = $target.closest("td");
      const columnIndex = this.getColumnIndexByElement($column);
      if (columnIndex >= 0) {
        headerFilterController.showHeaderFilterMenu(columnIndex, false);
      }
    } else {
      const $row = $target.closest(".dx-row");
      this._processHeaderAction(event, $row);
    }
    event.preventDefault();
  }
  _renderCore() {
    const $container = this.element();
    const change = {};
    if (this._tableElement && !this._dataController.isLoaded() && !this._hasRowElements) {
      return new Deferred().resolve();
    }
    $container.addClass(this.addWidgetPrefix("headers")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    this.setAria("role", "presentation", $container);
    const deferred = this._updateContent(this._renderTable({
      change
    }), change);
    $container.toggleClass("dx-header-multi-row", this.getRowCount() > 1);
    super._renderCore.apply(this, arguments);
    return deferred;
  }
  _renderRows() {
    const that = this;
    if (that._dataController.isLoaded() || that._hasRowElements) {
      super._renderRows.apply(that, arguments);
      that._hasRowElements = true;
    }
  }
  _renderRow($table, options2) {
    const rowIndex = 1 === this.getRowCount() ? null : options2.row.rowIndex;
    options2.columns = this.getColumns(rowIndex);
    super._renderRow($table, options2);
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const $cellElement = super._createCell.apply(this, arguments);
    column.rowspan > 1 && "header" === options2.rowType && $cellElement.attr("rowSpan", column.rowspan);
    return $cellElement;
  }
  _getRows() {
    const result2 = [];
    const rowCount = this.getRowCount();
    if (this.option("showColumnHeaders")) {
      for (let i = 0; i < rowCount; i++) {
        result2.push({
          rowType: "header",
          rowIndex: i
        });
      }
    }
    return result2;
  }
  _getCellTemplate(options2) {
    if ("header" === options2.rowType) {
      return this._getHeaderTemplate(options2.column);
    }
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    if (changeTypes.grouping || changeTypes.groupExpanding) {
      if (changeTypes.grouping) {
        this._isGroupingChanged = true;
      }
      return;
    }
    super._columnOptionChanged(e);
    if (optionNames.width || optionNames.visible) {
      this.resizeCompleted.fire();
    }
  }
  _isElementVisible(elementOptions) {
    return elementOptions && elementOptions.visible;
  }
  _alignCaptionByCenter($cell) {
    let $indicatorsContainer = this._getIndicatorContainer($cell, true);
    if ($indicatorsContainer && $indicatorsContainer.length) {
      $indicatorsContainer.filter(".dx-visibility-hidden").remove();
      $indicatorsContainer = this._getIndicatorContainer($cell);
      $indicatorsContainer.clone().addClass("dx-visibility-hidden").css("float", "").insertBefore($cell.children(`.${this.addWidgetPrefix("text-content")}`));
    }
  }
  _updateCell($cell, options2) {
    if ("header" === options2.rowType && "center" === options2.column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    super._updateCell.apply(this, arguments);
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicatorElement = super._updateIndicator.apply(this, arguments);
    if ("center" === column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    addCssClassesToCellContent(this, $cell, column);
    return $indicatorElement;
  }
  _getIndicatorContainer($cell, returnAll) {
    const $indicatorsContainer = super._getIndicatorContainer($cell);
    return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(.dx-visibility-hidden)");
  }
  _isSortableElement($target) {
    return true;
  }
  getHeadersRowHeight() {
    const $tableElement = this.getTableElement();
    const $headerRows = $tableElement && $tableElement.find(".dx-header-row");
    return $headerRows && $headerRows.toArray().reduce(((sum, headerRow) => sum + getHeight(headerRow)), 0) || 0;
  }
  getHeaderElement(index) {
    const $columnElements = this.getColumnElements();
    return (null === $columnElements || void 0 === $columnElements ? void 0 : $columnElements.eq(index)) ?? renderer_default("");
  }
  getColumnElements(index, bandColumnIndex) {
    const that = this;
    let $cellElement;
    const columnsController = that._columnsController;
    const rowCount = that.getRowCount();
    if (that.option("showColumnHeaders")) {
      if (rowCount > 1 && (!isDefined(index) || isDefined(bandColumnIndex))) {
        const result2 = [];
        const visibleColumns = isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
        each(visibleColumns, ((_, column) => {
          const rowIndex = isDefined(index) ? index : columnsController.getRowIndex(column.index);
          $cellElement = that._getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
          $cellElement && result2.push($cellElement.get(0));
        }));
        return renderer_default(result2);
      }
      if (!index || index < rowCount) {
        return that.getCellElements(index || 0);
      }
    }
    return;
  }
  getColumnIndexByElement($cell) {
    const cellIndex = this.getCellIndex($cell);
    const $row = $cell.closest(".dx-row");
    const {
      rowIndex
    } = $row[0];
    const column = this.getColumns(rowIndex)[cellIndex];
    return column ? column.index : -1;
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    const column = this.getColumns()[columnIndex];
    return column ? this._columnsController.getVisibleIndex(column.index, rowIndex) : -1;
  }
  getColumnWidths($tableElement, rowIndex) {
    const $columnElements = this.getColumnElements(rowIndex);
    if ($columnElements && $columnElements.length) {
      return this._getWidths($columnElements);
    }
    return super.getColumnWidths.apply(this, arguments);
  }
  allowDragging(column) {
    const rowIndex = column && this._columnsController.getRowIndex(column.index);
    const columns7 = this.getColumns(rowIndex);
    const isReorderingEnabled = this.option("allowColumnReordering") ?? this._columnsController.isColumnOptionUsed("allowReordering");
    return isReorderingEnabled && column.allowReordering && columns7.length > 1;
  }
  getBoundingRect() {
    const that = this;
    const $columnElements = that.getColumnElements();
    if ($columnElements && $columnElements.length) {
      const offset = that.getTableElement().offset();
      return {
        top: offset.top
      };
    }
    return null;
  }
  getName() {
    return "headers";
  }
  getColumnCount() {
    const $columnElements = this.getColumnElements();
    return $columnElements ? $columnElements.length : 0;
  }
  isVisible() {
    return this.option("showColumnHeaders");
  }
  optionChanged(args) {
    const that = this;
    switch (args.name) {
      case "showColumnHeaders":
      case "wordWrapEnabled":
      case "showColumnLines":
        that._invalidate(true, true);
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  getHeight() {
    return this.getElementHeight();
  }
  getContextMenuItems(options2) {
    const that = this;
    const {
      column
    } = options2;
    if (options2.row && ("header" === options2.row.rowType || "detailAdaptive" === options2.row.rowType)) {
      const sortingOptions = that.option("sorting");
      if (sortingOptions && "none" !== sortingOptions.mode && column && column.allowSorting) {
        const onItemClick = function(params) {
          setTimeout((() => {
            that._columnsController.changeSortOrder(column.index, params.itemData.value);
          }));
        };
        return [{
          text: sortingOptions.ascendingText,
          value: "asc",
          disabled: "asc" === column.sortOrder,
          icon: "context-menu-sort-asc",
          onItemClick
        }, {
          text: sortingOptions.descendingText,
          value: "desc",
          disabled: "desc" === column.sortOrder,
          icon: "context-menu-sort-desc",
          onItemClick
        }, {
          text: sortingOptions.clearText,
          value: "none",
          disabled: !column.sortOrder,
          icon: "context-menu-sort-none",
          onItemClick
        }];
      }
    }
    return;
  }
  getRowCount() {
    return this._columnsController && this._columnsController.getRowCount();
  }
  toggleDraggableColumnClass(columnIndex, value2, rowIndex) {
    let i;
    let columnElements;
    const rowCount = this.getRowCount();
    const columns7 = this._columnsController.getColumns();
    const column = columns7 && columns7[columnIndex];
    const columnID = column && column.isBand && column.index;
    const setColumnClass = (column2, index) => {
      if (column2.ownerBand === columnID) {
        columnElements.eq(index).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
        if (column2.isBand) {
          this.toggleDraggableColumnClass(column2.index, value2, i + 1);
        }
      }
    };
    if (isDefined(columnID)) {
      rowIndex = rowIndex || 0;
      for (i = rowIndex; i < rowCount; i++) {
        columnElements = this.getCellElements(i);
        if (columnElements) {
          const rowColumns = this.getColumns(i);
          rowColumns.forEach(setColumnClass);
        }
      }
    }
  }
  isFilterRowCell($cell) {
    return false;
  }
};
var columnHeadersModule = {
  defaultOptions: () => ({
    showColumnHeaders: true,
    cellHintEnabled: true
  }),
  views: {
    columnHeadersView: ColumnHeadersView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_core.js
var m_core_default = _extends({}, m_modules_default, m_utils_default, {
  modules: []
});

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_headers.js
var ColumnHeadersView2 = columnHeadersModule.views.columnHeadersView;
m_core_default.registerModule("columnHeaders", columnHeadersModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/const.js
var STICKY_BORDER_WIDTH = 2;
var StickyPosition;
!(function(StickyPosition2) {
  StickyPosition2.Left = "left";
  StickyPosition2.Right = "right";
  StickyPosition2.Sticky = "sticky";
})(StickyPosition || (StickyPosition = {}));
var CLASSES3 = {
  stickyColumn: "sticky-column",
  stickyColumnLeft: "sticky-column-left",
  stickyColumnRight: "sticky-column-right",
  stickyColumnBorderRight: "sticky-column-border-right",
  stickyColumnBorderLeft: "sticky-column-border-left",
  stickyColumns: "sticky-columns",
  firstHeader: "first-header",
  columnNoBorder: "column-no-border",
  groupRowContainer: "group-row-container",
  focusedFixedElement: "dx-focused-fixed-element",
  focused: "dx-focused",
  hidden: "dx-hidden"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/const.js
var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"];
var USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1);
var IGNORE_COLUMN_OPTION_NAMES = {
  visibleWidth: true,
  bestFitWidth: true,
  bufferedFilterValue: true
};
var COMMAND_EXPAND_CLASS = "dx-command-expand";
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var GROUP_COMMAND_COLUMN_NAME = "groupExpand";
var DETAIL_COMMAND_COLUMN_NAME = "detailExpand";
var COLUMN_OPTION_REGEXP = /columns\[(\d+)\]\.?/gi;
var DEFAULT_COLUMN_OPTIONS = {
  visible: true,
  showInColumnChooser: true
};
var DATATYPE_OPERATIONS = {
  number: ["=", "<>", "<", ">", "<=", ">=", "between"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
  date: ["=", "<>", "<", ">", "<=", ">=", "between"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
};
var COLUMN_INDEX_OPTIONS = {
  visibleIndex: true,
  groupIndex: true,
  grouped: true,
  sortIndex: true,
  sortOrder: true
};
var GROUP_LOCATION = "group";
var COLUMN_CHOOSER_LOCATION = "columnChooser";
var UNSUPPORTED_PROPERTIES_FOR_CHILD_COLUMNS = ["fixed", "fixedPosition", "type", "buttons"];

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/const.js
var HIDDEN_COLUMNS_WIDTH = "adaptiveHidden";

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/utils.js
var getColumnFixedPosition = (that, column) => {
  const {
    fixedPosition
  } = column;
  const rtlEnabled = that.option("rtlEnabled");
  const isExceptionCommandColumn = column.command && "expand" === column.command;
  const isDefaultCommandColumn = column.command && !m_utils_default.isCustomCommandColumn(that._columns, column);
  if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {
    return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right;
  }
  return fixedPosition ?? StickyPosition.Left;
};
var needToDisableStickyColumn = function(that, column) {
  return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky;
};
var processFixedColumns = function(that, columns7) {
  return columns7.map(((column) => {
    if (needToDisableStickyColumn(that, column)) {
      return _extends({}, column, {
        fixed: false,
        fixedPosition: ""
      });
    }
    return column;
  }));
};
var isVisibleColumn = function(that, column) {
  return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length);
};
var areNextOnlyFixedOrHiddenColumns = function(that, columns7) {
  return !columns7.some(((column) => !column.fixed && isVisibleColumn(that, column)));
};
var getStickyOffsetCore = function(that, columns7, widths, columnIndex, fixedPosition, offsets) {
  const column = columns7[columnIndex];
  const isChildColumn = isDefined(column.ownerBand);
  const targetColumnIsRight = fixedPosition === StickyPosition.Right;
  const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;
  const nextOrPrevColumns = targetColumnIsRight ? columns7.slice(columnIndex + 1) : columns7.slice(0, columnIndex).reverse();
  const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();
  let offset = 0;
  let adjacentStickyColumnIndex = 0;
  let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;
  nextOrPrevColumns.forEach(((col, colIndex) => {
    if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {
      const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;
      offset += nextOrPrevColumnWidths[colIndex] ?? col.visibleWidth;
      if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {
        if (colIndex !== adjacentStickyColumnIndex) {
          nonSiblingStickyColumnCount += 1;
          adjacentStickyColumnIndex = colIndex + 1;
        } else {
          adjacentStickyColumnIndex += 1;
        }
      }
    } else if (!isVisibleColumn(that, col)) {
      adjacentStickyColumnIndex += 1;
    }
  }));
  if (isChildColumn && isDefined(offsets)) {
    var _offsets$column$owner;
    offset += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;
    return offset;
  }
  return offset - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH;
};
var isFirstOrLastColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const rtlEnabled = that.option("rtlEnabled");
  const methodName = rtlEnabled !== isLast ? "isLastColumn" : "isFirstColumn";
  if (column.fixedPosition === StickyPosition.Sticky) {
    const parentColumn = that.getParentColumn(column) ?? column;
    if (that[methodName](parentColumn, 0)) {
      return false;
    }
  }
  return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition);
};
var getPrevColumn = function(that, column, visibleColumns, rowIndex) {
  const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);
  return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find(((col) => isVisibleColumn(that, col)));
};
var getStickyOffset = function(that, columns7, widths, columnIndex, offsets) {
  const result2 = {};
  const column = columns7[columnIndex];
  if (column) {
    const fixedPosition = getColumnFixedPosition(that, column);
    switch (fixedPosition) {
      case StickyPosition.Sticky: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result2.left = offsetLeft;
        result2.right = offsetRight;
        break;
      }
      case StickyPosition.Right: {
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result2.right = offsetRight;
        break;
      }
      default: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        result2.left = offsetLeft;
      }
    }
  }
  return result2;
};
var needToRemoveColumnBorderCore = function(that, column, visibleColumns, rowIndex) {
  const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);
  const columnFixedPosition = getColumnFixedPosition(that, column);
  const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);
  return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky);
};
var needToRemoveColumnBorder = function(that, column, rowIndex) {
  let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);
  const parentColumn = that.getParentColumn(column);
  if (parentColumn) {
    const isFirstColumn = that.isFirstColumn(column, rowIndex, true);
    return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0);
  }
  return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex);
};
var normalizeOffset = function(offset) {
  const styleProps = {};
  if (isDefined(offset.left)) {
    styleProps.left = `${offset.left}px`;
  }
  if (isDefined(offset.right)) {
    styleProps.right = `${offset.right}px`;
  }
  return styleProps;
};
var isFirstFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
};
var isLastFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
};
var isFixedEdge = function(point, column, nextColumn) {
  const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);
  return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js
var warnFixedInChildColumnsOnce = (controller, childColumns) => {
  if (null !== controller && void 0 !== controller && controller._isWarnedAboutUnsupportedProperties) {
    return;
  }
  if (!childColumns || !Array.isArray(childColumns) || 0 === (null === childColumns || void 0 === childColumns ? void 0 : childColumns.length)) {
    return;
  }
  let unsupportedProperty = null;
  for (const column of childColumns) {
    if (unsupportedProperty) {
      break;
    }
    if (!column || "object" !== typeof column || null === column) {
      continue;
    }
    for (const property of UNSUPPORTED_PROPERTIES_FOR_CHILD_COLUMNS) {
      if (property in column) {
        unsupportedProperty = property;
        break;
      }
    }
  }
  if (unsupportedProperty) {
    controller && (controller._isWarnedAboutUnsupportedProperties = true);
    ui_errors_default.log("W1028", unsupportedProperty);
  }
};
var setFilterOperationsAsDefaultValues = function(column) {
  column.filterOperations = column.defaultFilterOperations;
};
var globalColumnId = 1;
var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
  let commonColumnOptions = {};
  if (columnOptions) {
    if (isString(columnOptions)) {
      columnOptions = {
        dataField: columnOptions
      };
    }
    that.setName(columnOptions);
    let result2 = {};
    if (columnOptions.command) {
      result2 = deepExtendArraySafe(commonColumnOptions, columnOptions);
    } else {
      commonColumnOptions = that.getCommonSettings(columnOptions);
      if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
        columnOptions = extend({}, columnOptions, {
          dataField: userStateColumnOptions.dataField
        });
      }
      const calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
      if (!columnOptions.type) {
        result2 = {
          headerId: "dx-col-" + globalColumnId++
        };
      }
      result2 = deepExtendArraySafe(result2, DEFAULT_COLUMN_OPTIONS, false, true);
      deepExtendArraySafe(result2, commonColumnOptions, false, true);
      deepExtendArraySafe(result2, calculatedColumnOptions, false, true);
      deepExtendArraySafe(result2, columnOptions, false, true);
      deepExtendArraySafe(result2, {
        selector: null
      }, false, true);
    }
    if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {
      setFilterOperationsAsDefaultValues(result2);
    }
    return result2;
  }
};
var createColumnsFromOptions = function(that, columnsOptions, bandColumn, createdColumnCount) {
  let result2 = [];
  if (columnsOptions) {
    each(columnsOptions, ((index, columnOptions) => {
      const currentIndex = (createdColumnCount ?? 0) + result2.length;
      const userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[currentIndex]) && that._columnsUserState[currentIndex];
      const column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
      if (column) {
        if (bandColumn) {
          column.ownerBand = bandColumn;
        }
        result2.push(column);
        if (column.columns) {
          warnFixedInChildColumnsOnce(that, column.columns);
          result2 = result2.concat(createColumnsFromOptions(that, column.columns, column, result2.length));
          delete column.columns;
          column.hasColumns = true;
        }
      }
    }));
  }
  return result2;
};
var getParentBandColumns = function(columnIndex, columnParentByIndex) {
  const result2 = [];
  let parent = columnParentByIndex[columnIndex];
  while (parent) {
    result2.unshift(parent);
    columnIndex = parent.index;
    parent = columnParentByIndex[columnIndex];
  }
  return result2;
};
var getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
  let result2 = [];
  const children = columnChildrenByIndex[columnIndex];
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const column = children[i];
      if (!isDefined(column.groupIndex) || column.showWhenGrouped) {
        result2.push(column);
        if (recursive && column.isBand) {
          result2 = result2.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));
        }
      }
    }
  }
  return result2;
};
var getColumnByIndexes = function(that, columnIndexes) {
  let result2;
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(column) {
    const ownerBand = result2 ? result2.index : void 0;
    return column.ownerBand === ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    result2 = that._columns[columnIndexes[0]];
  } else {
    columns7 = that._columns.filter(callbackFilter);
    for (let i = 0; i < columnIndexes.length; i++) {
      result2 = columns7[columnIndexes[i]];
      if (result2) {
        columns7 = that._columns.filter(callbackFilter);
      }
    }
  }
  return result2;
};
var getColumnFullPath = function(that, column) {
  let result2 = [];
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(item) {
    return item.ownerBand === column.ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    const columnIndex = that._columns.indexOf(column);
    if (columnIndex >= 0) {
      result2 = [`columns[${columnIndex}]`];
    }
  } else {
    columns7 = that._columns.filter(callbackFilter);
    while (columns7.length && -1 !== columns7.indexOf(column)) {
      result2.unshift(`columns[${columns7.indexOf(column)}]`);
      column = bandColumnsCache.columnParentByIndex[column.index];
      columns7 = column ? that._columns.filter(callbackFilter) : [];
    }
  }
  return result2.join(".");
};
var calculateColspan = function(that, columnID) {
  let colspan = 0;
  const columns7 = that.getChildrenByBandColumn(columnID, true);
  each(columns7, ((_, column) => {
    if (column.isBand) {
      column.colspan = column.colspan || calculateColspan(that, column.index);
      colspan += column.colspan || 1;
    } else {
      colspan += 1;
    }
  }));
  return colspan;
};
var processBandColumns = function(that, columns7, bandColumnsCache) {
  let rowspan;
  for (let i = 0; i < columns7.length; i++) {
    const column = columns7[i];
    if (column.visible || column.command) {
      if (column.isBand) {
        column.colspan = column.colspan || calculateColspan(that, column.index);
      }
      if (!column.isBand || !column.colspan) {
        rowspan = that.getRowCount();
        if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
          rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length;
        }
        if (rowspan > 1) {
          column.rowspan = rowspan;
        }
      }
    }
  }
};
var getValueDataType = function(value2) {
  let dataType = type(value2);
  if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
    dataType = void 0;
  }
  return dataType;
};
var getSerializationFormat = function(dataType, value2) {
  switch (dataType) {
    case "date":
    case "datetime":
      return date_serialization_default.getDateSerializationFormat(value2);
    case "number":
      if (isString(value2)) {
        return "string";
      }
      if (isNumeric(value2)) {
        return null;
      }
  }
};
var updateSerializers = function(options2, dataType) {
  if (!options2.deserializeValue) {
    if (m_utils_default.isDateType(dataType)) {
      options2.deserializeValue = function(value2) {
        return date_serialization_default.deserializeDate(value2);
      };
      options2.serializeValue = function(value2) {
        return isString(value2) ? value2 : date_serialization_default.serializeDate(value2, this.serializationFormat);
      };
    }
    if ("number" === dataType) {
      options2.deserializeValue = function(value2) {
        const parsedValue = parseFloat(value2);
        return isNaN(parsedValue) ? value2 : parsedValue;
      };
      options2.serializeValue = function(value2, target) {
        if ("filter" === target) {
          return value2;
        }
        return isDefined(value2) && "string" === this.serializationFormat ? value2.toString() : value2;
      };
    }
  }
};
var getAlignmentByDataType = function(dataType, isRTL) {
  switch (dataType) {
    case "number":
      return "right";
    case "boolean":
      return "center";
    default:
      return getDefaultAlignment(isRTL);
  }
};
var customizeTextForBooleanDataType = function(e) {
  if (true === e.value) {
    return this.trueText || "true";
  }
  if (false === e.value) {
    return this.falseText || "false";
  }
  return e.valueText || "";
};
var getCustomizeTextByDataType = function(dataType) {
  if ("boolean" === dataType) {
    return customizeTextForBooleanDataType;
  }
};
var createColumnsFromDataSource = function(that, dataSource) {
  const firstItems = that._getFirstItems(dataSource);
  let fieldName;
  const processedFields = {};
  const result2 = [];
  for (let i = 0; i < firstItems.length; i++) {
    if (firstItems[i]) {
      for (fieldName in firstItems[i]) {
        if (!isFunction(firstItems[i][fieldName]) || variable_wrapper_default.isWrapped(firstItems[i][fieldName])) {
          processedFields[fieldName] = true;
        }
      }
    }
  }
  for (fieldName in processedFields) {
    if (0 !== fieldName.indexOf("__")) {
      const column = createColumn(that, fieldName);
      result2.push(column);
    }
  }
  return result2;
};
var updateColumnIndexes = function(that) {
  each(that._columns, ((index, column) => {
    column.index = index;
  }));
  each(that._columns, ((index, column) => {
    if (isObject(column.ownerBand)) {
      column.ownerBand = column.ownerBand.index;
    }
  }));
  each(that._commandColumns, ((index, column) => {
    column.index = -(index + 1);
  }));
};
var updateColumnGroupIndexes = function(that, currentColumn) {
  normalizeIndexes(that._columns, "groupIndex", currentColumn, ((column) => {
    const {
      grouped
    } = column;
    delete column.grouped;
    return grouped;
  }));
};
var updateColumnSortIndexes = function(that, currentColumn) {
  each(that._columns, ((index, column) => {
    if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
      delete column.sortIndex;
    }
  }));
  normalizeIndexes(that._columns, "sortIndex", currentColumn, ((column) => !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder)));
};
var updateColumnVisibleIndexes = function(that, currentColumn) {
  let column;
  const result2 = [];
  const bandColumnsCache = that.getBandColumnsCache();
  const bandedColumns = [];
  const columns7 = that._columns.filter(((column2) => !column2.command));
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    const parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns.length) {
      bandedColumns.push(column);
    } else {
      result2.push(column);
    }
  }
  normalizeIndexes(bandedColumns, "visibleIndex", currentColumn);
  normalizeIndexes(result2, "visibleIndex", currentColumn);
};
var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
  const rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;
  const columns7 = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);
  let column;
  visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
  column = columns7[visibleIndex];
  if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {
    column = that._columns.filter(((col) => column.type === col.type))[0] || column;
  }
  return column && isDefined(column.index) ? column.index : -1;
};
var moveColumnToGroup = function(that, column, groupIndex) {
  const groupColumns = that.getGroupColumns();
  let i;
  if (groupIndex >= 0) {
    for (i = 0; i < groupColumns.length; i++) {
      if (groupColumns[i].groupIndex >= groupIndex) {
        groupColumns[i].groupIndex++;
      }
    }
  } else {
    groupIndex = 0;
    for (i = 0; i < groupColumns.length; i++) {
      groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);
    }
  }
  return groupIndex;
};
function checkUserStateColumn(column, userStateColumn) {
  return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name);
}
var applyUserState = function(that) {
  const columnsUserState = that._columnsUserState;
  const ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];
  const columns7 = that._columns;
  const columnCountById = {};
  let resultColumns = [];
  let allColumnsHaveState = true;
  const userStateColumnIndexes = [];
  let column;
  let userStateColumnIndex;
  let i;
  function applyFieldsState(column2, userStateColumn) {
    if (!userStateColumn) {
      return;
    }
    for (let index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
      const fieldName = USER_STATE_FIELD_NAMES[index];
      if (ignoreColumnOptionNames.includes(fieldName)) {
        continue;
      }
      if ("dataType" === fieldName) {
        column2[fieldName] = column2[fieldName] || userStateColumn[fieldName];
      } else if (USER_STATE_FIELD_NAMES_15_1.includes(fieldName)) {
        if (fieldName in userStateColumn) {
          column2[fieldName] = userStateColumn[fieldName];
        }
      } else {
        if ("selectedFilterOperation" === fieldName && userStateColumn[fieldName]) {
          column2.defaultSelectedFilterOperation = column2[fieldName] || null;
        }
        column2[fieldName] = userStateColumn[fieldName];
      }
    }
  }
  function findUserStateColumn(columnsUserState2, column2) {
    const id = column2.name || column2.dataField;
    let count = columnCountById[id] || 0;
    for (let j = 0; j < columnsUserState2.length; j++) {
      if (checkUserStateColumn(column2, columnsUserState2[j])) {
        if (count) {
          count--;
        } else {
          columnCountById[id] = columnCountById[id] || 0;
          columnCountById[id]++;
          return j;
        }
      }
    }
    return -1;
  }
  if (columnsUserState) {
    for (i = 0; i < columns7.length; i++) {
      userStateColumnIndex = findUserStateColumn(columnsUserState, columns7[i]);
      allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
      userStateColumnIndexes.push(userStateColumnIndex);
    }
    for (i = 0; i < columns7.length; i++) {
      column = columns7[i];
      userStateColumnIndex = userStateColumnIndexes[i];
      if (that._hasUserState || allColumnsHaveState) {
        applyFieldsState(column, columnsUserState[userStateColumnIndex]);
      }
      if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
        resultColumns[userStateColumnIndex] = column;
      } else {
        resultColumns.push(column);
      }
    }
    let hasAddedBands = false;
    for (i = 0; i < columnsUserState.length; i++) {
      const columnUserState = columnsUserState[i];
      if (columnUserState.added && findUserStateColumn(columns7, columnUserState) < 0) {
        column = createColumn(that, columnUserState.added);
        applyFieldsState(column, columnUserState);
        resultColumns.push(column);
        if (columnUserState.added.columns) {
          hasAddedBands = true;
        }
      }
    }
    if (hasAddedBands) {
      updateColumnIndexes(that);
      resultColumns = createColumnsFromOptions(that, resultColumns);
    }
    assignColumns(that, resultColumns);
  }
};
var updateIndexes = function(that, column) {
  updateColumnIndexes(that);
  updateColumnGroupIndexes(that, column);
  updateColumnSortIndexes(that, column);
  resetBandColumnsCache(that);
  updateColumnVisibleIndexes(that, column);
};
var resetColumnsCache = function(that) {
  that.resetColumnsCache();
};
function assignColumns(that, columns7) {
  that._previousColumns = that._columns;
  that._columns = columns7;
  resetColumnsCache(that);
  that.updateColumnDataTypes();
}
var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
  const columnChanges = that._columnChanges || {
    optionNames: {
      length: 0
    },
    changeTypes: {
      length: 0
    },
    columnIndex
  };
  optionName = optionName || "all";
  optionName = optionName.split(".")[0];
  const {
    changeTypes
  } = columnChanges;
  if (changeType && !changeTypes[changeType]) {
    changeTypes[changeType] = true;
    changeTypes.length++;
  }
  const {
    optionNames
  } = columnChanges;
  if (optionName && !optionNames[optionName]) {
    optionNames[optionName] = true;
    optionNames.length++;
  }
  if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
    if (isDefined(columnIndex)) {
      columnChanges.columnIndices ?? (columnChanges.columnIndices = []);
      if (isDefined(columnChanges.columnIndex)) {
        columnChanges.columnIndices.push(columnChanges.columnIndex);
      }
      columnChanges.columnIndices.push(columnIndex);
    }
    delete columnChanges.columnIndex;
  }
  that._columnChanges = columnChanges;
  resetColumnsCache(that);
};
var fireColumnsChanged = function(that) {
  const onColumnsChanging = that.option("onColumnsChanging");
  const columnChanges = that._columnChanges;
  const reinitOptionNames = ["dataField", "lookup", "dataType", "columns"];
  if (that.isInitialized() && !that._updateLockCount && columnChanges) {
    if (onColumnsChanging) {
      that._updateLockCount++;
      onColumnsChanging(extend({
        component: that.component
      }, columnChanges));
      that._updateLockCount--;
    }
    that._columnChanges = void 0;
    if (options2 = columnChanges.optionNames, options2 && reinitOptionNames.some(((name2) => options2[name2]))) {
      that._reinitAfterLookupChanges = null === columnChanges || void 0 === columnChanges ? void 0 : columnChanges.optionNames.lookup;
      that.reinit();
      that._reinitAfterLookupChanges = void 0;
    } else {
      that.columnsChanged.fire(columnChanges);
    }
  }
  var options2;
};
var updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {
  const columnWasGrouped = prevGroupIndex >= 0;
  if (groupIndex >= 0) {
    if (!columnWasGrouped) {
      column.lastSortOrder = column.sortOrder;
    }
  } else {
    const sortMode = that.option("sorting.mode");
    let sortOrder = column.lastSortOrder;
    if ("single" === sortMode) {
      const sortedByAnotherColumn = that._columns.some(((col) => col !== column && isDefined(col.sortIndex)));
      if (sortedByAnotherColumn) {
        sortOrder = void 0;
      }
    }
    column.sortOrder = sortOrder;
  }
};
var fireOptionChanged = function(that, options2) {
  const {
    value: value2
  } = options2;
  const {
    optionName
  } = options2;
  const {
    prevValue
  } = options2;
  const {
    fullOptionName
  } = options2;
  const fullOptionPath = `${fullOptionName}.${optionName}`;
  if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {
    that._skipProcessingColumnsChange = fullOptionPath;
    that.component._notifyOptionChanged(fullOptionPath, value2, prevValue);
    that._skipProcessingColumnsChange = false;
  }
};
var columnOptionCore = function(that, column, optionName, value2, notFireEvent) {
  const optionGetter = compileGetter(optionName);
  const columnIndex = column.index;
  let columns7;
  let changeType;
  let initialColumn;
  if (3 === arguments.length) {
    return optionGetter(column, {
      functionsAsIs: true
    });
  }
  const prevValue = optionGetter(column, {
    functionsAsIs: true
  });
  if (!equalByValue(prevValue, value2, {
    maxDepth: 5
  })) {
    if ("groupIndex" === optionName) {
      changeType = "grouping";
      updateSortOrderWhenGrouping(that, column, value2, prevValue);
    } else if ("calculateGroupValue" === optionName) {
      changeType = "grouping";
    } else if ("sortIndex" === optionName || "sortOrder" === optionName || "calculateSortValue" === optionName) {
      changeType = "sorting";
    } else {
      changeType = "columns";
    }
    const optionSetter = compileSetter(optionName);
    optionSetter(column, value2, {
      functionsAsIs: true
    });
    const fullOptionName = getColumnFullPath(that, column);
    if (COLUMN_INDEX_OPTIONS[optionName]) {
      updateIndexes(that, column);
      value2 = optionGetter(column);
    }
    if ("name" === optionName || "allowEditing" === optionName) {
      that._checkColumns();
    }
    if (!isDefined(prevValue) && !isDefined(value2) && 0 !== optionName.indexOf("buffer") && false !== notFireEvent) {
      notFireEvent = true;
    }
    if (!notFireEvent) {
      if (!USER_STATE_FIELD_NAMES.includes(optionName) && "visibleWidth" !== optionName) {
        columns7 = that.option("columns");
        initialColumn = that.getColumnByPath(fullOptionName, columns7);
        if (isString(initialColumn)) {
          initialColumn = columns7[columnIndex] = {
            dataField: initialColumn
          };
        }
        if (initialColumn && checkUserStateColumn(initialColumn, column)) {
          optionSetter(initialColumn, value2, {
            functionsAsIs: true
          });
        }
      }
      updateColumnChanges(that, changeType, optionName, columnIndex);
    } else {
      resetColumnsCache(that);
    }
    fullOptionName && fireOptionChanged(that, {
      fullOptionName,
      optionName,
      value: value2,
      prevValue
    });
  }
};
function isSortOrderValid(sortOrder) {
  return "asc" === sortOrder || "desc" === sortOrder;
}
var addExpandColumn = function(that) {
  const options2 = that._getExpandColumnOptions();
  that.addCommandColumn(options2);
};
var defaultSetCellValue = function(data17, value2) {
  if (!this.dataField) {
    return;
  }
  const path = this.dataField.split(".");
  const dotCount = path.length - 1;
  if (this.serializeValue) {
    value2 = this.serializeValue(value2);
  }
  for (let i = 0; i < dotCount; i++) {
    const name2 = path[i];
    data17 = data17[name2] = data17[name2] || {};
  }
  data17[path[dotCount]] = value2;
};
var getDataColumns = function(columns7, rowIndex, bandColumnID) {
  const result2 = [];
  rowIndex = rowIndex || 0;
  columns7[rowIndex] && each(columns7[rowIndex], ((_, column) => {
    if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (!column.isBand || !column.colspan) {
        if (!column.command || rowIndex < 1) {
          result2.push(column);
        }
      } else {
        result2.push.apply(result2, getDataColumns(columns7, rowIndex + 1, column.index));
      }
    }
  }));
  return result2;
};
var getRowCount = function(that) {
  let rowCount = 1;
  const bandColumnsCache = that.getBandColumnsCache();
  const {
    columnParentByIndex
  } = bandColumnsCache;
  that._columns.forEach(((column) => {
    const parents = getParentBandColumns(column.index, columnParentByIndex);
    const invisibleParents = parents.filter(((column2) => !column2.visible));
    if (column.visible && !invisibleParents.length) {
      rowCount = Math.max(rowCount, parents.length + 1);
    }
  }));
  return rowCount;
};
var getFixedPosition = function(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (column.command && !m_utils_default.isCustomCommandColumn(that._columns, column) || !column.fixedPosition) {
    return rtlEnabled ? "right" : "left";
  }
  return column.fixedPosition;
};
var processExpandColumns = function(columns7, expandColumns, type2, columnIndex) {
  let customColumnIndex;
  const rowCount = this.getRowCount();
  let rowspan = columns7[columnIndex] && columns7[columnIndex].rowspan;
  let expandColumnsByType = expandColumns.filter(((column) => column.type === type2));
  columns7.forEach(((column, index) => {
    if (column.type === type2) {
      customColumnIndex = index;
      rowspan = columns7[index + 1] ? columns7[index + 1].rowspan : rowCount;
    }
  }));
  if (rowspan > 1) {
    expandColumnsByType = map(expandColumnsByType, ((expandColumn) => extend({}, expandColumn, {
      rowspan
    })));
  }
  expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);
  columns7.splice.apply(columns7, expandColumnsByType);
  return rowspan || 1;
};
var digitsCount = function(number) {
  let i;
  for (i = 0; number > 1; i++) {
    number /= 10;
  }
  return i;
};
var numberToString = function(number, digitsCount2) {
  let str = number ? number.toString() : "0";
  while (str.length < digitsCount2) {
    str = `0${str}`;
  }
  return str;
};
var mergeColumns = (that, columns7, commandColumns, needToExtend) => {
  let column;
  let commandColumnIndex;
  let result2 = columns7.slice().map(((column2) => extend({}, column2)));
  const isColumnFixing = that._isColumnFixing();
  let defaultCommandColumns = commandColumns.slice().map(((column2) => extend({
    fixed: isColumnFixing
  }, column2)));
  const getCommandColumnIndex = (column2) => commandColumns.reduce(((result3, commandColumn, index) => {
    const columnType = needToExtend && column2.type === GROUP_COMMAND_COLUMN_NAME ? "expand" : column2.type;
    return commandColumn.type === columnType || commandColumn.command === column2.command ? index : result3;
  }), -1);
  const callbackFilter = (commandColumn) => commandColumn.command !== commandColumns[commandColumnIndex].command;
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;
    if (commandColumnIndex >= 0) {
      if (needToExtend) {
        result2[i] = extend({
          fixed: isColumnFixing
        }, commandColumns[commandColumnIndex], column);
        if (column.type !== GROUP_COMMAND_COLUMN_NAME) {
          defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);
        }
      } else {
        const columnOptions = {
          visibleIndex: column.visibleIndex,
          index: column.index,
          headerId: column.headerId,
          allowFixing: 0 === column.groupIndex,
          allowReordering: 0 === column.groupIndex,
          groupIndex: column.groupIndex
        };
        result2[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);
      }
    }
  }
  if (columns7.length && needToExtend && defaultCommandColumns.length) {
    result2 = result2.concat(defaultCommandColumns);
  }
  return result2;
};
var isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed && column.fixedPosition !== StickyPosition.Sticky : that._isColumnFixing();
var convertOwnerBandToColumnReference = (columns7) => {
  columns7.forEach(((column) => {
    if (isDefined(column.ownerBand)) {
      column.ownerBand = columns7[column.ownerBand];
    }
  }));
};
var resetBandColumnsCache = (that) => {
  that._bandColumnsCache = void 0;
};
var findColumn = (columns7, identifier) => {
  const identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(":"));
  let column;
  if (void 0 === identifier) {
    return;
  }
  if (identifierOptionName) {
    identifier = identifier.substr(identifierOptionName.length + 1);
  }
  if (identifierOptionName) {
    column = columns7.filter(((column2) => `${column2[identifierOptionName]}` === identifier))[0];
  } else {
    ["index", "name", "dataField", "caption"].some(((optionName) => {
      column = columns7.filter(((column2) => column2[optionName] === identifier))[0];
      return !!column;
    }));
  }
  return column;
};
var sortColumns = (columns7, sortOrder) => {
  if ("asc" !== sortOrder && "desc" !== sortOrder) {
    return columns7;
  }
  const sign2 = "asc" === sortOrder ? 1 : -1;
  columns7.sort(((column1, column2) => {
    const caption1 = column1.caption || "";
    const caption2 = column2.caption || "";
    return sign2 * caption1.localeCompare(caption2);
  }));
  return columns7;
};
var strictParseNumber = function(text, format2) {
  const parsedValue = number_default.parse(text);
  if (isNumeric(parsedValue)) {
    const formattedValue = number_default.format(parsedValue, format2);
    const formattedValueWithDefaultFormat = number_default.format(parsedValue, "decimal");
    if (formattedValue === text || formattedValueWithDefaultFormat === text) {
      return parsedValue;
    }
  }
};
var isFirstOrLastBandColumn = function(that, bandColumns) {
  let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  let isLast = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return bandColumns.every(((column, index) => onlyWithinBandColumn && 0 === index || isFirstOrLastColumnCore(that, column, index, onlyWithinBandColumn, isLast, fixedPosition)));
};
var isFirstOrLastColumnCore = function(that, column, rowIndex) {
  var _columns, _columns$;
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const columnIndex = column.index;
  const columns7 = (index = rowIndex, that.getVisibleColumns(index).filter(((col) => {
    let res = true;
    if (col.visibleWidth === HIDDEN_COLUMNS_WIDTH) {
      return false;
    }
    if (onlyWithinBandColumn && column) {
      res && (res = col.ownerBand === column.ownerBand);
    } else if (fixedPosition) {
      res && (res = col.fixed && getColumnFixedPosition(that, col) === fixedPosition);
    }
    return res;
  })));
  var index;
  const visibleColumnIndex = that.getVisibleIndex(columnIndex, rowIndex);
  return isLast ? visibleColumnIndex === that.getVisibleIndex(null === (_columns = columns7[columns7.length - 1]) || void 0 === _columns ? void 0 : _columns.index, rowIndex) : visibleColumnIndex === that.getVisibleIndex(null === (_columns$ = columns7[0]) || void 0 === _columns$ ? void 0 : _columns$.index, rowIndex);
};
var isFirstOrLastColumn2 = function(that, targetColumn, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const targetColumnIndex = targetColumn.index;
  const bandColumnsCache = that.getBandColumnsCache();
  const parentBandColumns = !isDefined(targetColumn.type) && getParentBandColumns(targetColumnIndex, bandColumnsCache.columnParentByIndex);
  if (null !== parentBandColumns && void 0 !== parentBandColumns && parentBandColumns.length) {
    return isFirstOrLastBandColumn(that, parentBandColumns.concat([targetColumn]), onlyWithinBandColumn, isLast, fixedPosition);
  }
  return onlyWithinBandColumn || isFirstOrLastColumnCore(that, targetColumn, rowIndex, onlyWithinBandColumn, isLast, fixedPosition);
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js
var ColumnsController = class extends m_modules_default.Controller {
  init(isApplyingUserState) {
    this._dataController = this.getController("data");
    this._focusController = this.getController("focus");
    this._stateStoringController = this.getController("stateStoring");
    const columns7 = this.option("columns");
    this._commandColumns = this._commandColumns || [];
    this._columns = this._columns || [];
    this._isColumnsFromOptions = !!columns7;
    if (this._isColumnsFromOptions) {
      assignColumns(this, columns7 ? createColumnsFromOptions(this, columns7) : []);
      applyUserState(this);
    } else {
      assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);
    }
    addExpandColumn(this);
    if (this._dataSourceApplied) {
      this.applyDataSource(this._dataSource, true, isApplyingUserState);
    } else {
      updateIndexes(this);
    }
    this._checkColumns();
  }
  _getExpandColumnOptions() {
    return {
      type: "expand",
      command: "expand",
      width: "auto",
      cssClass: COMMAND_EXPAND_CLASS,
      allowEditing: false,
      allowGrouping: false,
      allowSorting: false,
      allowResizing: false,
      allowReordering: false,
      allowHiding: false
    };
  }
  _getFirstItems(dataSource) {
    let groupsCount;
    let items = [];
    const getFirstItemsCore = function(items2, groupsCount2) {
      if (!items2 || !groupsCount2) {
        return items2;
      }
      for (let i = 0; i < items2.length; i++) {
        const childItems = getFirstItemsCore(items2[i].items || items2[i].collapsedItems, groupsCount2 - 1);
        if (childItems && childItems.length) {
          return childItems;
        }
      }
    };
    if (dataSource && dataSource.items().length > 0) {
      groupsCount = m_utils_default.normalizeSortingInfo(dataSource.group()).length;
      items = getFirstItemsCore(dataSource.items(), groupsCount) || [];
    }
    return items;
  }
  _endUpdateCore() {
    !this._skipProcessingColumnsChange && fireColumnsChanged(this);
  }
  callbackNames() {
    return ["columnsChanged"];
  }
  getColumnByPath(path, columns7) {
    const that = this;
    let column;
    const columnIndexes = [];
    path.replace(COLUMN_OPTION_REGEXP, ((_, columnIndex) => {
      columnIndexes.push(parseInt(columnIndex));
      return "";
    }));
    if (columnIndexes.length) {
      if (columns7) {
        column = columnIndexes.reduce(((column2, index) => column2 && column2.columns && column2.columns[index]), {
          columns: columns7
        });
      } else {
        column = getColumnByIndexes(that, columnIndexes);
      }
    }
    return column;
  }
  optionChanged(args) {
    let needUpdateRequireResize;
    switch (args.name) {
      case "adaptColumnWidthByRatio":
        args.handled = true;
        break;
      case "dataSource":
        if (args.value !== args.previousValue && !this.option("columns") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {
          this._columns = [];
        }
        break;
      case "columns":
        needUpdateRequireResize = this._skipProcessingColumnsChange;
        args.handled = true;
        if (!this._skipProcessingColumnsChange) {
          if (args.name === args.fullName) {
            this._columnsUserState = null;
            this._ignoreColumnOptionNames = null;
            this.init();
          } else {
            this._columnOptionChanged(args);
            needUpdateRequireResize = true;
          }
        }
        if (needUpdateRequireResize) {
          this._updateRequireResize(args);
        }
        break;
      case "commonColumnSettings":
      case "columnAutoWidth":
      case "allowColumnResizing":
      case "allowColumnReordering":
      case "columnFixing":
      case "grouping":
      case "groupPanel":
      case "regenerateColumnsByVisibleItems":
      case "customizeColumns":
      case "columnHidingEnabled":
      case "dateSerializationFormat":
      case "columnResizingMode":
      case "columnMinWidth":
      case "columnWidth": {
        args.handled = true;
        const ignoreColumnOptionNames = "columnWidth" === args.fullName && ["width"];
        this.reinit(ignoreColumnOptionNames);
        break;
      }
      case "rtlEnabled":
        this.reinit();
        break;
      default:
        super.optionChanged(args);
    }
  }
  _columnOptionChanged(args) {
    let columnOptionValue = {};
    const column = this.getColumnByPath(args.fullName);
    const columnOptionName = args.fullName.replace(COLUMN_OPTION_REGEXP, "");
    if (column) {
      if (columnOptionName) {
        columnOptionValue[columnOptionName] = args.value;
      } else {
        columnOptionValue = args.value;
      }
      this._skipProcessingColumnsChange = args.fullName;
      this.columnOption(column.index, columnOptionValue);
      this._skipProcessingColumnsChange = false;
    }
  }
  _updateRequireResize(args) {
    const {
      component
    } = this;
    if ("width" === args.fullName.replace(COLUMN_OPTION_REGEXP, "") && component._updateLockCount) {
      component._requireResize = true;
    }
  }
  publicMethods() {
    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex", "getColumns"];
  }
  applyDataSource(dataSource, forceApplying, isApplyingUserState) {
    const that = this;
    const isDataSourceLoaded = dataSource && dataSource.isLoaded();
    that._dataSource = dataSource;
    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
      if (isDataSourceLoaded) {
        if (!that._isColumnsFromOptions) {
          const columnsFromDataSource = createColumnsFromDataSource(that, dataSource);
          if (columnsFromDataSource.length) {
            assignColumns(that, columnsFromDataSource);
            that._dataSourceColumnsCount = that._columns.length;
            applyUserState(that);
          }
        }
        return that.updateColumns(dataSource, forceApplying, isApplyingUserState);
      }
      that._dataSourceApplied = false;
      updateIndexes(that);
    } else if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {
      updateColumnChanges(that, "columns");
      fireColumnsChanged(that);
      return new Deferred().reject().promise();
    }
  }
  reset() {
    this._dataSource = null;
    this._dataSourceApplied = false;
    this._dataSourceColumnsCount = void 0;
    this.reinit();
  }
  resetColumnsCache() {
    this._visibleColumns = void 0;
    this._fixedColumns = void 0;
    this._rowCount = void 0;
    resetBandColumnsCache(this);
  }
  reinit(ignoreColumnOptionNames) {
    this._columnsUserState = this.getUserState();
    this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;
    this.init();
    if (ignoreColumnOptionNames) {
      this._ignoreColumnOptionNames = null;
    }
  }
  isInitialized() {
    return !!this._columns.length || !!this.option("columns");
  }
  isDataSourceApplied() {
    return this._dataSourceApplied;
  }
  getCommonSettings(column) {
    const commonColumnSettings = (!column || !column.type) && this.option("commonColumnSettings") || {};
    const groupingOptions = this.option("grouping") ?? {};
    const groupPanelOptions = this.option("groupPanel") ?? {};
    return extend({
      allowFixing: this.option("columnFixing.enabled"),
      allowResizing: this.option("allowColumnResizing") || void 0,
      allowReordering: this.option("allowColumnReordering"),
      minWidth: this.option("columnMinWidth"),
      width: this.option("columnWidth"),
      autoExpandGroup: groupingOptions.autoExpandAll,
      allowCollapsing: groupingOptions.allowCollapsing,
      allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
    }, commonColumnSettings);
  }
  isColumnOptionUsed(optionName) {
    for (let i = 0; i < this._columns.length; i++) {
      if (this._columns[i][optionName]) {
        return true;
      }
    }
  }
  isAllDataTypesDefined(checkSerializers) {
    const columns7 = this._columns;
    if (!columns7.length) {
      return false;
    }
    for (let i = 0; i < columns7.length; i++) {
      if (!columns7[i].dataField && columns7[i].calculateCellValue === columns7[i].defaultCalculateCellValue) {
        continue;
      }
      if (!columns7[i].dataType || checkSerializers && columns7[i].deserializeValue && void 0 === columns7[i].serializationFormat) {
        return false;
      }
    }
    return true;
  }
  getColumns() {
    return this._columns;
  }
  isBandColumnsUsed() {
    return this.getColumns().some(((column) => column.isBand));
  }
  getGroupColumns() {
    const result2 = [];
    each(this._columns, (function() {
      const column = this;
      if (isDefined(column.groupIndex)) {
        result2[column.groupIndex] = column;
      }
    }));
    return result2;
  }
  _shouldReturnVisibleColumns() {
    return true;
  }
  _compileVisibleColumns(rowIndex) {
    this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
    return this._visibleColumns[rowIndex] || [];
  }
  getVisibleColumns(rowIndex, isBase) {
    if (!this._shouldReturnVisibleColumns()) {
      return [];
    }
    return this._compileVisibleColumns.apply(this, arguments);
  }
  getFixedColumns(rowIndex) {
    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
    return this._fixedColumns[rowIndex] || [];
  }
  getFilteringColumns() {
    return this.getColumns().filter(((item) => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering))).map(((item) => {
      const field = extend(true, {}, item);
      if (!isDefined(field.dataField)) {
        field.dataField = field.name;
      }
      field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;
      return field;
    }));
  }
  getColumnIndexOffset() {
    return 0;
  }
  getStickyColumns(rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex, true);
    return visibleColumns.filter(((column) => column.fixed));
  }
  _getFixedColumnsCore() {
    const that = this;
    const result2 = [];
    const rowCount = that.getRowCount();
    const isColumnFixing = that._isColumnFixing();
    const transparentColumn = {
      command: "transparent"
    };
    let transparentColspan = 0;
    let notFixedColumnCount;
    let transparentColumnIndex;
    let lastFixedPosition;
    if (isColumnFixing) {
      for (let i = 0; i <= rowCount; i++) {
        notFixedColumnCount = 0;
        lastFixedPosition = null;
        transparentColumnIndex = null;
        const visibleColumns = that.getVisibleColumns(i, true);
        for (let j = 0; j < visibleColumns.length; j++) {
          const prevColumn = visibleColumns[j - 1];
          const column = visibleColumns[j];
          if (!column.fixed || column.fixedPosition === StickyPosition.Sticky) {
            if (0 === i) {
              if (column.isBand && column.colspan) {
                transparentColspan += column.colspan;
              } else {
                transparentColspan++;
              }
            }
            notFixedColumnCount++;
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else {
            lastFixedPosition = column.fixedPosition;
          }
        }
        if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
          return [];
        }
        if (!isDefined(transparentColumnIndex)) {
          transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length;
        }
        result2[i] = visibleColumns.slice(0);
        if (!transparentColumn.colspan) {
          transparentColumn.colspan = transparentColspan;
        }
        result2[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);
      }
    }
    return result2.map(((columns7) => columns7.map(((column) => {
      const newColumn = _extends({}, column);
      if (newColumn.headerId) {
        newColumn.headerId += "-fixed";
      }
      return newColumn;
    }))));
  }
  _isColumnFixing() {
    let isColumnFixing = this.option("columnFixing.enabled");
    !isColumnFixing && each(this._columns, ((_, column) => {
      if (column.fixed) {
        isColumnFixing = true;
        return false;
      }
    }));
    return isColumnFixing;
  }
  _getExpandColumnsCore() {
    return this.getGroupColumns();
  }
  getExpandColumns() {
    let expandColumns = this._getExpandColumnsCore();
    let expandColumn;
    const firstGroupColumn = expandColumns.filter(((column) => 0 === column.groupIndex))[0];
    const isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;
    const isColumnFixing = this._isColumnFixing();
    const rtlEnabled = this.option("rtlEnabled");
    if (expandColumns.length) {
      expandColumn = this.columnOption("command:expand");
    }
    expandColumns = map(expandColumns, ((column) => extend({}, _extends({}, column, {
      ownerBand: void 0
    }), {
      visibleWidth: null,
      minWidth: null,
      cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,
      headerCellTemplate: null,
      fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,
      fixedPosition: rtlEnabled ? "right" : "left"
    }, expandColumn, {
      index: column.index,
      type: column.type || GROUP_COMMAND_COLUMN_NAME
    })));
    return expandColumns;
  }
  getBandColumnsCache() {
    if (!this._bandColumnsCache) {
      const columns7 = this._columns;
      const columnChildrenByIndex = {};
      const columnParentByIndex = {};
      let isPlain = true;
      columns7.forEach(((column) => {
        const {
          ownerBand
        } = column;
        let parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;
        const parent = columns7[parentIndex];
        if (column.hasColumns) {
          isPlain = false;
        }
        if (column.colspan) {
          column.colspan = void 0;
        }
        if (column.rowspan) {
          column.rowspan = void 0;
        }
        if (parent) {
          columnParentByIndex[column.index] = parent;
        } else {
          parentIndex = -1;
        }
        columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
        columnChildrenByIndex[parentIndex].push(column);
      }));
      this._bandColumnsCache = {
        isPlain,
        columnChildrenByIndex,
        columnParentByIndex
      };
    }
    return this._bandColumnsCache;
  }
  _isColumnVisible(column) {
    return column.visible && this.isParentColumnVisible(column.index);
  }
  _isColumnInGroupPanel(column) {
    return isDefined(column.groupIndex) && !column.showWhenGrouped;
  }
  hasVisibleDataColumns() {
    const columns7 = this._columns;
    return columns7.some(((column) => {
      const isVisible = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      const isCommand = !!column.command;
      return isVisible && !isInGroupPanel && !isCommand;
    }));
  }
  _compileVisibleColumnsCore() {
    const bandColumnsCache = this.getBandColumnsCache();
    const columns7 = mergeColumns(this, this._columns, this._commandColumns, true);
    processBandColumns(this, columns7, bandColumnsCache);
    const indexedColumns = this._getIndexedColumns(columns7);
    const visibleColumns = this._getVisibleColumnsFromIndexed(indexedColumns);
    const isDataColumnsInvisible = !this.hasVisibleDataColumns();
    if (isDataColumnsInvisible && this._columns.length) {
      visibleColumns[visibleColumns.length - 1].push({
        command: "empty"
      });
    }
    return visibleColumns;
  }
  _getIndexedColumns(columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const rowCount = this.getRowCount();
    const columnDigitsCount = digitsCount(columns7.length);
    const bandColumnsCache = this.getBandColumnsCache();
    const positiveIndexedColumns = [];
    const negativeIndexedColumns = [];
    for (let i = 0; i < rowCount; i += 1) {
      negativeIndexedColumns[i] = [{}];
      positiveIndexedColumns[i] = [{}, {}, {}];
    }
    columns7.forEach(((column) => {
      let {
        visibleIndex
      } = column;
      let indexedColumns;
      const parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
      const isVisible = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      if (isVisible && !isInGroupPanel) {
        const rowIndex = parentBandColumns.length;
        if (visibleIndex < 0) {
          visibleIndex = -visibleIndex;
          indexedColumns = negativeIndexedColumns[rowIndex];
        } else {
          var _parentBandColumns$, _parentBandColumns$2;
          column.fixed = (null === (_parentBandColumns$ = parentBandColumns[0]) || void 0 === _parentBandColumns$ ? void 0 : _parentBandColumns$.fixed) ?? column.fixed;
          column.fixedPosition = (null === (_parentBandColumns$2 = parentBandColumns[0]) || void 0 === _parentBandColumns$2 ? void 0 : _parentBandColumns$2.fixedPosition) ?? column.fixedPosition;
          if (column.fixed && column.fixedPosition !== StickyPosition.Sticky) {
            const isDefaultCommandColumn = !!column.command && !m_utils_default.isCustomCommandColumn(this._columns, column);
            let isFixedToEnd = "right" === column.fixedPosition;
            if (rtlEnabled && !isDefaultCommandColumn) {
              isFixedToEnd = !isFixedToEnd;
            }
            indexedColumns = isFixedToEnd ? positiveIndexedColumns[rowIndex][2] : positiveIndexedColumns[rowIndex][0];
          } else {
            indexedColumns = positiveIndexedColumns[rowIndex][1];
          }
        }
        if (parentBandColumns.length) {
          visibleIndex = numberToString(visibleIndex, columnDigitsCount);
          for (let i = parentBandColumns.length - 1; i >= 0; i -= 1) {
            visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;
          }
        }
        indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
        indexedColumns[visibleIndex].push(column);
      }
    }));
    return {
      positiveIndexedColumns,
      negativeIndexedColumns
    };
  }
  _getVisibleColumnsFromIndexed(_ref) {
    let {
      positiveIndexedColumns,
      negativeIndexedColumns
    } = _ref;
    const result2 = [];
    const rowCount = this.getRowCount();
    const expandColumns = mergeColumns(this, this.getExpandColumns(), this._columns);
    let rowspanGroupColumns = 0;
    let rowspanExpandColumns = 0;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      result2.push([]);
      orderEach(negativeIndexedColumns[rowIndex], ((_, columns7) => {
        result2[rowIndex].unshift.apply(result2[rowIndex], columns7);
      }));
      const firstPositiveIndexColumn = result2[rowIndex].length;
      const positiveIndexedRowColumns = positiveIndexedColumns[rowIndex];
      positiveIndexedRowColumns.forEach(((columnsByFixing) => {
        orderEach(columnsByFixing, ((_, columnsByVisibleIndex) => {
          result2[rowIndex].push.apply(result2[rowIndex], columnsByVisibleIndex);
        }));
      }));
      if (rowspanExpandColumns <= rowIndex) {
        rowspanExpandColumns += processExpandColumns.call(this, result2[rowIndex], expandColumns, DETAIL_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
      if (rowspanGroupColumns <= rowIndex) {
        rowspanGroupColumns += processExpandColumns.call(this, result2[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
    }
    result2.push(getDataColumns(result2));
    return result2;
  }
  getInvisibleColumns(columns7, bandColumnIndex) {
    const that = this;
    let result2 = [];
    let hiddenColumnsByBand;
    columns7 = columns7 || that._columns;
    each(columns7, ((_, column) => {
      if (column.ownerBand !== bandColumnIndex) {
        return;
      }
      if (column.isBand) {
        if (!column.visible) {
          hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);
        } else {
          hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);
        }
        if (hiddenColumnsByBand.length) {
          result2.push(column);
          result2 = result2.concat(hiddenColumnsByBand);
        }
        return;
      }
      if (!column.visible) {
        result2.push(column);
      }
    }));
    return result2;
  }
  getChooserColumns(getAllColumns) {
    const columns7 = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
    const columnChooserColumns = columns7.filter(((column) => column.showInColumnChooser));
    const sortOrder = this.option("columnChooser.sortOrder");
    return sortColumns(columnChooserColumns, sortOrder);
  }
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);
    const sourceColumn = this._columns[columnIndex];
    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
      if (sourceLocation === targetLocation) {
        if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
          return false;
        }
        fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
        toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
        return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;
      }
      if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
        return sourceColumn && sourceColumn.allowGrouping;
      }
      if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
        return sourceColumn && sourceColumn.allowHiding;
      }
      return true;
    }
    return false;
  }
  moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const that = this;
    const options2 = {};
    let prevGroupIndex;
    const fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
    const toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
    let targetGroupIndex;
    if (fromIndex >= 0) {
      const column = that._columns[fromIndex];
      toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
      targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
      if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
        if (targetGroupIndex > column.groupIndex) {
          targetGroupIndex--;
        }
        if (targetLocation !== GROUP_LOCATION) {
          options2.groupIndex = void 0;
        } else {
          prevGroupIndex = column.groupIndex;
          delete column.groupIndex;
          updateColumnGroupIndexes(that);
        }
      }
      if (targetLocation === GROUP_LOCATION) {
        options2.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);
        column.groupIndex = prevGroupIndex;
      } else if (toVisibleIndex >= 0) {
        const targetColumn = that._columns[toIndex];
        if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
          options2.visibleIndex = MAX_SAFE_INTEGER;
        } else if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {
          options2.visibleIndex = MAX_SAFE_INTEGER;
        } else {
          options2.visibleIndex = targetColumn.visibleIndex;
        }
      }
      const isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;
      if (column.visible !== isVisible) {
        options2.visible = isVisible;
      }
      that.columnOption(column.index, options2);
    }
  }
  changeSortOrder(columnIndex, sortOrder) {
    const that = this;
    const options2 = {};
    const sortingOptions = that.option("sorting");
    const sortingMode = sortingOptions && sortingOptions.mode;
    const needResetSorting = "single" === sortingMode || !sortOrder;
    const allowSorting = "single" === sortingMode || "multiple" === sortingMode;
    const column = that._columns[columnIndex];
    if (allowSorting && column && column.allowSorting) {
      if (needResetSorting && !isDefined(column.groupIndex)) {
        each(that._columns, (function(index) {
          if (index !== columnIndex && this.sortOrder) {
            if (!isDefined(this.groupIndex)) {
              delete this.sortOrder;
            }
            delete this.sortIndex;
          }
        }));
      }
      if (isSortOrderValid(sortOrder)) {
        if (column.sortOrder !== sortOrder) {
          options2.sortOrder = sortOrder;
        }
      } else if ("none" === sortOrder) {
        if (column.sortOrder) {
          options2.sortIndex = void 0;
          options2.sortOrder = void 0;
        }
      } else {
        !(function(column2) {
          if ("ctrl" === sortOrder) {
            if (!("sortOrder" in column2 && "sortIndex" in column2)) {
              return false;
            }
            options2.sortOrder = void 0;
            options2.sortIndex = void 0;
          } else if (isDefined(column2.groupIndex) || isDefined(column2.sortIndex)) {
            options2.sortOrder = "desc" === column2.sortOrder ? "asc" : "desc";
          } else {
            options2.sortOrder = "asc";
          }
          return true;
        })(column);
      }
    }
    that.columnOption(column.index, options2);
  }
  getSortDataSourceParameters(useLocalSelector) {
    const sortColumns2 = [];
    const sort = [];
    each(this._columns, (function() {
      if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
        sortColumns2[this.sortIndex] = this;
      }
    }));
    each(sortColumns2, (function() {
      const sortOrder = this && this.sortOrder;
      if (isSortOrderValid(sortOrder)) {
        const sortItem = {
          selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
          desc: "desc" === this.sortOrder
        };
        if (this.sortingMethod) {
          sortItem.compare = this.sortingMethod.bind(this);
        }
        sort.push(sortItem);
      }
    }));
    return sort.length > 0 ? sort : null;
  }
  getGroupDataSourceParameters(useLocalSelector) {
    const group = [];
    each(this.getGroupColumns(), (function() {
      const selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
      if (selector) {
        const groupItem = {
          selector,
          desc: "desc" === this.sortOrder,
          isExpanded: !!this.autoExpandGroup
        };
        if (this.sortingMethod) {
          groupItem.compare = this.sortingMethod.bind(this);
        }
        group.push(groupItem);
      }
    }));
    return group.length > 0 ? group : null;
  }
  refresh(updateNewLookupsOnly) {
    const deferreds = [];
    each(this._columns, (function() {
      const {
        lookup
      } = this;
      if (lookup && !this.calculateDisplayValue) {
        if (updateNewLookupsOnly && lookup.valueMap) {
          return;
        }
        if (lookup.update) {
          deferreds.push(lookup.update());
        }
      }
    }));
    return when.apply(renderer_default, deferreds).done(resetColumnsCache.bind(null, this));
  }
  _updateColumnOptions(column, columnIndex) {
    var _this$_previousColumn, _this$_previousColumn2;
    const shouldTakeOriginalCallbackFromPrevious = this._reinitAfterLookupChanges && (null === (_this$_previousColumn = this._previousColumns) || void 0 === _this$_previousColumn ? void 0 : _this$_previousColumn[columnIndex]);
    column.selector = column.selector ?? ((data17) => column.calculateCellValue(data17));
    column.selector.columnIndex = columnIndex;
    column.selector.originalCallback = shouldTakeOriginalCallbackFromPrevious ? (null === (_this$_previousColumn2 = this._previousColumns[columnIndex].selector) || void 0 === _this$_previousColumn2 ? void 0 : _this$_previousColumn2.originalCallback) ?? column.selector : column.selector;
    each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], ((_, calculateCallbackName) => {
      const calculateCallback = column[calculateCallbackName];
      if (isFunction(calculateCallback)) {
        if (!calculateCallback.originalCallback) {
          const context = {
            column
          };
          column[calculateCallbackName] = function(data17) {
            return calculateCallback.call(context.column, data17);
          };
          column[calculateCallbackName].originalCallback = calculateCallback;
          column[calculateCallbackName].columnIndex = columnIndex;
          column[calculateCallbackName].context = context;
        } else {
          column[calculateCallbackName].context.column = column;
        }
      }
    }));
    if (isString(column.calculateDisplayValue)) {
      column.displayField = column.calculateDisplayValue;
      column.calculateDisplayValue = compileGetter(column.displayField);
    }
    if (column.calculateDisplayValue) {
      column.displayValueMap = column.displayValueMap || {};
    }
    updateSerializers(column, column.dataType);
    const {
      lookup
    } = column;
    if (lookup) {
      updateSerializers(lookup, lookup.dataType);
    }
    const dataType = lookup ? lookup.dataType : column.dataType;
    if (dataType) {
      column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
      column.format = column.format || m_utils_default.getFormatByDataType(dataType);
      column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
      column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];
      if (!isDefined(column.filterOperations)) {
        setFilterOperationsAsDefaultValues(column);
      }
      column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
      column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate && !column.lookup;
    }
  }
  updateColumnDataTypes(dataSource) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const firstItems = that._getFirstItems(dataSource);
    let isColumnDataTypesUpdated = false;
    each(that._columns, ((index, column) => {
      let i;
      let value2;
      let dataType;
      let lookupDataType;
      let valueDataType;
      const {
        lookup
      } = column;
      if (m_utils_default.isDateType(column.dataType) && void 0 === column.serializationFormat) {
        column.serializationFormat = dateSerializationFormat;
      }
      if (lookup && m_utils_default.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {
        lookup.serializationFormat = dateSerializationFormat;
      }
      if (column.calculateCellValue && firstItems.length) {
        if (!column.dataType || lookup && !lookup.dataType) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i]);
            if (!column.dataType) {
              valueDataType = getValueDataType(value2);
              dataType = dataType || valueDataType;
              if (dataType && valueDataType && dataType !== valueDataType) {
                dataType = "string";
              }
            }
            if (lookup && !lookup.dataType) {
              valueDataType = getValueDataType(m_utils_default.getDisplayValue(column, value2, firstItems[i]));
              lookupDataType = lookupDataType || valueDataType;
              if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                lookupDataType = "string";
              }
            }
          }
          if (dataType || lookupDataType) {
            if (dataType) {
              column.dataType = dataType;
            }
            if (lookup && lookupDataType) {
              lookup.dataType = lookupDataType;
            }
            isColumnDataTypesUpdated = true;
          }
        }
        if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i], true);
            if (void 0 === column.serializationFormat) {
              column.serializationFormat = getSerializationFormat(column.dataType, value2);
            }
            if (lookup && void 0 === lookup.serializationFormat) {
              lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value2, true));
            }
          }
        }
      }
      that._updateColumnOptions(column, index);
    }));
    return isColumnDataTypesUpdated;
  }
  _customizeColumns(columns7) {
    const that = this;
    const customizeColumns = that.option("customizeColumns");
    if (customizeColumns) {
      const hasOwnerBand = columns7.some(((column) => isObject(column.ownerBand)));
      if (hasOwnerBand) {
        updateIndexes(that);
      }
      customizeColumns(columns7);
      assignColumns(that, createColumnsFromOptions(that, columns7));
    }
  }
  updateColumns(dataSource, forceApplying, isApplyingUserState) {
    if (!forceApplying) {
      this.updateSortingGrouping(dataSource);
    }
    if (!dataSource || dataSource.isLoaded()) {
      const sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();
      const groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();
      const filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;
      if (!isApplyingUserState) {
        this._customizeColumns(this._columns);
      }
      updateIndexes(this);
      const columns7 = this._columns;
      return when(this.refresh(true)).always((() => {
        if (this._columns !== columns7) {
          return;
        }
        this._updateChanges(dataSource, {
          sorting: sortParameters,
          grouping: groupParameters,
          filtering: filterParameters
        });
        fireColumnsChanged(this);
      }));
    }
  }
  _updateChanges(dataSource, parameters) {
    var _dataSource$loadOptio;
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (dataSource) {
      this.updateColumnDataTypes(dataSource);
      this._dataSourceApplied = true;
    }
    if (!m_utils_default.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {
      updateColumnChanges(this, "sorting");
    }
    if (!m_utils_default.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {
      updateColumnChanges(this, "grouping");
    }
    if (this._dataController && !m_utils_default.equalFilterParameters(parameters.filtering, this._dataController.getCombinedFilter(), langParams)) {
      updateColumnChanges(this, "filtering");
    }
    updateColumnChanges(this, "columns");
  }
  updateSortingGrouping(dataSource, fromDataSource) {
    const that = this;
    let isColumnsChanged;
    const updateSortGroupParameterIndexes = function(columns7, sortParameters, indexParameterName) {
      each(columns7, ((index, column) => {
        delete column[indexParameterName];
        if (sortParameters) {
          for (let i = 0; i < sortParameters.length; i++) {
            const {
              selector
            } = sortParameters[i];
            const {
              isExpanded
            } = sortParameters[i];
            if (selector === column.dataField || selector === column.name || selector === column.displayField || m_utils_default.isEqualSelectors(selector, column.selector) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateCellValue) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateGroupValue) || m_utils_default.isSelectorEqualWithCallback(selector, column.calculateDisplayValue)) {
              if (fromDataSource) {
                column.sortOrder = "sortOrder" in column ? column.sortOrder : sortParameters[i].desc ? "desc" : "asc";
              } else {
                column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
              }
              if (void 0 !== isExpanded) {
                column.autoExpandGroup = isExpanded;
              }
              column[indexParameterName] = i;
              break;
            }
          }
        }
      }));
    };
    if (dataSource) {
      var _this$_columnChanges;
      const sortParameters = m_utils_default.normalizeSortingInfo(dataSource.sort());
      const groupParameters = m_utils_default.normalizeSortingInfo(dataSource.group());
      const columnsGroupParameters = that.getGroupDataSourceParameters();
      const columnsSortParameters = that.getSortDataSourceParameters();
      const changeTypes = null === (_this$_columnChanges = this._columnChanges) || void 0 === _this$_columnChanges ? void 0 : _this$_columnChanges.changeTypes;
      const sortingChanged = !m_utils_default.equalSortParameters(sortParameters, columnsSortParameters);
      const needToApplySortingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.sorting);
      const needToApplyGroupingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.grouping);
      const groupingChanged = !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters, true);
      const groupExpandingChanged = !groupingChanged && !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters);
      if (!that._columns.length) {
        each(groupParameters, ((index, group) => {
          that._columns.push(group.selector);
        }));
        each(sortParameters, ((index, sort) => {
          if (!isFunction(sort.selector)) {
            that._columns.push(sort.selector);
          }
        }));
        assignColumns(that, createColumnsFromOptions(that, that._columns));
      }
      if ((needToApplyGroupingFromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {
        updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
        if (fromDataSource) {
          groupingChanged && updateColumnChanges(that, "grouping");
          groupExpandingChanged && updateColumnChanges(that, "groupExpanding");
          isColumnsChanged = true;
        }
      }
      if ((needToApplySortingFromDataSource || !columnsSortParameters && !that._hasUserState) && sortingChanged) {
        updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
        if (fromDataSource) {
          updateColumnChanges(that, "sorting");
          isColumnsChanged = true;
        }
      }
      if (isColumnsChanged) {
        fireColumnsChanged(that);
      }
    }
  }
  updateFilter(filter, remoteFiltering, columnIndex, filterValue) {
    const that = this;
    if (!Array.isArray(filter)) {
      return filter;
    }
    filter = extend([], filter);
    columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;
    filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;
    if (isString(filter[0]) && "!" !== filter[0]) {
      const column = that.columnOption(filter[0]);
      if (remoteFiltering) {
        if (config_default2().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
          filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], "filter");
        }
      } else if (column && column.selector) {
        filter[0] = column.selector;
        filter[0].columnIndex = column.index;
      }
    } else if (isFunction(filter[0])) {
      filter[0].columnIndex = columnIndex;
      filter[0].filterValue = filterValue;
      filter[0].selectedFilterOperation = filter.selectedFilterOperation;
    }
    for (let i = 0; i < filter.length; i++) {
      filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);
    }
    return filter;
  }
  columnCount() {
    return this._columns ? this._columns.length : 0;
  }
  columnOption(identifier, option, value2, notFireEvent) {
    const that = this;
    const columns7 = that._columns.concat(that._commandColumns);
    const column = findColumn(columns7, identifier);
    if (column) {
      if (1 === arguments.length) {
        return extend({}, column);
      }
      if (isString(option)) {
        if (2 === arguments.length) {
          return columnOptionCore(that, column, option);
        }
        columnOptionCore(that, column, option, value2, notFireEvent);
      } else if (isObject(option)) {
        each(option, ((optionName, value3) => {
          columnOptionCore(that, column, optionName, value3, notFireEvent);
        }));
      }
      fireColumnsChanged(that);
    }
  }
  clearSorting() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "sortOrder", void 0);
      delete findColumn(that._columns, i).sortOrder;
    }
    that.endUpdate();
  }
  clearGrouping() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "groupIndex", void 0);
    }
    that.endUpdate();
  }
  getVisibleIndex(index, rowIndex) {
    const columns7 = this.getVisibleColumns(rowIndex);
    for (let i = columns7.length - 1; i >= 0; i--) {
      if (columns7[i].index === index) {
        return i;
      }
    }
    return -1;
  }
  getVisibleIndexByColumn(column, rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex);
    const visibleColumn = visibleColumns.filter(((col) => col.index === column.index && col.command === column.command))[0];
    return visibleColumns.indexOf(visibleColumn);
  }
  getVisibleColumnIndex(id, rowIndex) {
    const index = this.columnOption(id, "index");
    return this.getVisibleIndex(index, rowIndex);
  }
  addColumn(options2) {
    const that = this;
    let column = createColumn(that, options2);
    const index = that._columns.length;
    that._columns.push(column);
    if (column.isBand) {
      that._columns = createColumnsFromOptions(that, that._columns);
      column = that._columns[index];
    }
    column.added = options2;
    updateIndexes(that, column);
    that.updateColumns(that._dataSource);
    that._checkColumns();
  }
  deleteColumn(id) {
    const that = this;
    const column = that.columnOption(id);
    if (column && column.index >= 0) {
      convertOwnerBandToColumnReference(that._columns);
      that._columns.splice(column.index, 1);
      if (column.isBand) {
        const childIndexes = that.getChildrenByBandColumn(column.index).map(((column2) => column2.index));
        that._columns = that._columns.filter(((column2) => childIndexes.indexOf(column2.index) < 0));
      }
      updateIndexes(that);
      that.updateColumns(that._dataSource);
    }
  }
  addCommandColumn(options2) {
    let commandColumn = this._commandColumns.filter(((column) => column.command === options2.command))[0];
    if (!commandColumn) {
      commandColumn = options2;
      this._commandColumns.push(commandColumn);
    }
  }
  getUserState() {
    const columns7 = this._columns;
    const result2 = [];
    let i;
    function handleStateField(index, value2) {
      if (void 0 !== columns7[i][value2]) {
        result2[i][value2] = columns7[i][value2];
      }
    }
    for (i = 0; i < columns7.length; i++) {
      result2[i] = {};
      each(USER_STATE_FIELD_NAMES, handleStateField);
    }
    return result2;
  }
  setName(column) {
    column.name = column.name || column.dataField || column.type;
  }
  setUserState(state) {
    const that = this;
    const dataSource = that._dataSource;
    let ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
    null === state || void 0 === state || state.forEach(this.setName);
    if (!ignoreColumnOptionNames) {
      ignoreColumnOptionNames = [];
      const commonColumnSettings = that.getCommonSettings();
      if (!that.option("columnChooser.enabled")) {
        ignoreColumnOptionNames.push("visible");
      }
      if ("none" === that.option("sorting.mode")) {
        ignoreColumnOptionNames.push("sortIndex", "sortOrder");
      }
      if (!commonColumnSettings.allowGrouping) {
        ignoreColumnOptionNames.push("groupIndex");
      }
      if (!commonColumnSettings.allowFixing) {
        ignoreColumnOptionNames.push("fixed", "fixedPosition");
      }
      if (!commonColumnSettings.allowResizing) {
        ignoreColumnOptionNames.push("width", "visibleWidth");
      }
      const isFilterPanelHidden = !that.option("filterPanel.visible");
      if (!that.option("filterRow.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
      }
      if (!that.option("headerFilter.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValues", "filterType");
      }
    }
    that._columnsUserState = state;
    that._ignoreColumnOptionNames = ignoreColumnOptionNames;
    that._hasUserState = !!state;
    updateColumnChanges(that, "filtering");
    that.init(true);
    if (dataSource) {
      dataSource.sort(that.getSortDataSourceParameters());
      dataSource.group(that.getGroupDataSourceParameters());
    }
  }
  _checkColumns() {
    const usedNames = {};
    let hasEditableColumnWithoutName = false;
    const duplicatedNames = [];
    this._columns.forEach(((column) => {
      var _column$columns;
      const {
        name: name2
      } = column;
      const isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;
      const isEditable2 = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;
      if (name2) {
        if (usedNames[name2]) {
          duplicatedNames.push(`"${name2}"`);
        }
        usedNames[name2] = true;
      } else if (isEditable2) {
        hasEditableColumnWithoutName = true;
      }
    }));
    if (duplicatedNames.length) {
      ui_errors_default.log("E1059", duplicatedNames.join(", "));
    }
    if (hasEditableColumnWithoutName) {
      ui_errors_default.log("E1060");
    }
  }
  _createCalculatedColumnOptions(columnOptions, bandColumn) {
    let calculatedColumnOptions = {};
    let {
      dataField
    } = columnOptions;
    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
      calculatedColumnOptions.isBand = true;
      dataField = null;
    }
    if (dataField) {
      if (isString(dataField)) {
        const getter = compileGetter(dataField);
        calculatedColumnOptions = {
          caption: m_inflector_default.captionize(dataField),
          calculateCellValue(data17, skipDeserialization) {
            const value2 = getter(data17);
            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
          },
          setCellValue: defaultSetCellValue,
          parseValue(text) {
            const column = this;
            let result2;
            let parsedValue;
            if ("number" === column.dataType) {
              if (isString(text) && column.format) {
                result2 = strictParseNumber(text.trim(), column.format);
              } else if (isDefined(text) && isNumeric(text)) {
                result2 = Number(text);
              }
            } else if ("boolean" === column.dataType) {
              if (text === column.trueText) {
                result2 = true;
              } else if (text === column.falseText) {
                result2 = false;
              }
            } else if (m_utils_default.isDateType(column.dataType)) {
              parsedValue = date_default.parse(text, column.format);
              if (parsedValue) {
                result2 = parsedValue;
              }
            } else {
              result2 = text;
            }
            return result2;
          }
        };
      }
      calculatedColumnOptions.allowFiltering = true;
    } else {
      calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
    }
    calculatedColumnOptions.calculateFilterExpression = function() {
      return filtering_default.defaultCalculateFilterExpression.apply(this, arguments);
    };
    calculatedColumnOptions.defaultFilterOperation = "=";
    calculatedColumnOptions.createFilterExpression = function(filterValue, selectedFilterOperation) {
      let result2;
      if (this.calculateFilterExpression) {
        result2 = this.calculateFilterExpression.apply(this, arguments);
      }
      if (isFunction(result2)) {
        result2 = [result2, "=", true];
      }
      if (result2) {
        result2.columnIndex = this.index;
        result2.filterValue = filterValue;
        result2.selectedFilterOperation = selectedFilterOperation;
      }
      return result2;
    };
    if (!dataField || !isString(dataField)) {
      extend(true, calculatedColumnOptions, {
        allowSorting: false,
        allowGrouping: false,
        calculateCellValue: () => null
      });
    }
    if (bandColumn) {
      calculatedColumnOptions.allowFixing = false;
    }
    if (columnOptions.dataType) {
      calculatedColumnOptions.userDataType = columnOptions.dataType;
    }
    if (columnOptions.selectedFilterOperation && !("defaultSelectedFilterOperation" in calculatedColumnOptions)) {
      calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;
    }
    if (columnOptions.lookup) {
      calculatedColumnOptions.lookup = {
        calculateCellValue(value2, skipDeserialization) {
          if (this.valueExpr) {
            value2 = this.valueMap && this.valueMap[value2];
          }
          return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
        },
        updateValueMap() {
          this.valueMap = {};
          if (this.items) {
            const calculateValue = compileGetter(this.valueExpr);
            const calculateDisplayValue = compileGetter(this.displayExpr);
            for (let i = 0; i < this.items.length; i++) {
              const item = this.items[i];
              const displayValue = calculateDisplayValue(item);
              this.valueMap[calculateValue(item)] = displayValue;
              this.dataType = this.dataType || getValueDataType(displayValue);
            }
          }
        },
        update() {
          const that = this;
          let {
            dataSource
          } = that;
          if (dataSource) {
            if (isFunction(dataSource) && !variable_wrapper_default.isWrapped(dataSource)) {
              dataSource = dataSource({});
            }
            if (isPlainObject(dataSource) || dataSource instanceof m_abstract_store_default || Array.isArray(dataSource)) {
              if (that.valueExpr) {
                const dataSourceOptions = normalizeDataSourceOptions(dataSource);
                dataSourceOptions.paginate = false;
                dataSource = new DataSource(dataSourceOptions);
                return dataSource.load().done(((data17) => {
                  that.items = data17;
                  that.updateValueMap && that.updateValueMap();
                }));
              }
            } else {
              ui_errors_default.log("E1016");
            }
          } else {
            that.updateValueMap && that.updateValueMap();
          }
        }
      };
    }
    calculatedColumnOptions.resizedCallbacks = callbacks_default();
    if (columnOptions.resized) {
      calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));
    }
    each(calculatedColumnOptions, ((optionName) => {
      if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
        const defaultOptionName = `default${optionName.charAt(0).toUpperCase()}${optionName.substr(1)}`;
        calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];
      }
    }));
    return calculatedColumnOptions;
  }
  getRowCount() {
    this._rowCount = this._rowCount || getRowCount(this);
    return this._rowCount;
  }
  getRowIndex(columnIndex, alwaysGetRowIndex) {
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;
  }
  getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result2 = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
    if (onlyVisibleDirectChildren) {
      return result2.filter(((column) => column.visible && !column.command)).sort(((column1, column2) => column1.visibleIndex - column2.visibleIndex));
    }
    return result2;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result2 = this.getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex);
    return result2.filter(((column) => !column.isBand && column.visible));
  }
  isParentBandColumn(columnIndex, bandColumnIndex) {
    let result2 = false;
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    const parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns) {
      each(parentBandColumns, ((_, bandColumn) => {
        if (bandColumn.index === bandColumnIndex) {
          result2 = true;
          return false;
        }
      }));
    }
    return result2;
  }
  isParentColumnVisible(columnIndex) {
    let result2 = true;
    const bandColumnsCache = this.getBandColumnsCache();
    const bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    bandColumns && each(bandColumns, ((_, bandColumn) => {
      result2 = result2 && bandColumn.visible;
      return result2;
    }));
    return result2;
  }
  getParentColumn(column) {
    const bandColumnsCache = this.getBandColumnsCache();
    const bandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
    return bandColumns[0];
  }
  isFirstColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
  }
  isLastColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
  }
  getColumnId(column) {
    if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (m_utils_default.isCustomCommandColumn(this._columns, column)) {
        return `type:${column.type}`;
      }
      return `command:${column.command}`;
    }
    return column.index;
  }
  getCustomizeTextByDataType(dataType) {
    return getCustomizeTextByDataType(dataType);
  }
  getHeaderContentAlignment(columnAlignment) {
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      return "left" === columnAlignment ? "right" : "left";
    }
    return columnAlignment;
  }
  isVirtualMode() {
    return false;
  }
};
var columnsControllerModule = {
  defaultOptions: () => ({
    commonColumnSettings: {
      allowFiltering: true,
      allowHiding: true,
      allowSorting: true,
      allowEditing: true,
      encodeHtml: true,
      trueText: message_default.format("dxDataGrid-trueText"),
      falseText: message_default.format("dxDataGrid-falseText")
    },
    allowColumnReordering: false,
    allowColumnResizing: false,
    columnResizingMode: "nextColumn",
    columnMinWidth: void 0,
    columnWidth: void 0,
    adaptColumnWidthByRatio: true,
    columns: void 0,
    regenerateColumnsByVisibleItems: false,
    customizeColumns: null,
    dateSerializationFormat: void 0
  }),
  controllers: {
    columns: ColumnsController
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_columns_controller.js
m_core_default.registerModule("columns", {
  defaultOptions: () => extend(true, {}, columnsControllerModule.defaultOptions(), {
    commonColumnSettings: {
      allowExporting: true
    }
  }),
  controllers: columnsControllerModule.controllers
});

// node_modules/devextreme/esm/__internal/core/utils/m_array_compare.js
var getKeyWrapper = function(item, getKey) {
  const key = getKey(item);
  if (isObject(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
  const key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (let i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
  const oldIndexByKey = {};
  const newIndexByKey = {};
  let addedCount = 0;
  let removeCount = 0;
  const result2 = [];
  oldItems.forEach((function(item, index) {
    const key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index;
  }));
  newItems.forEach((function(item, index) {
    const key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index;
  }));
  const itemCount = Math.max(oldItems.length, newItems.length);
  for (let index = 0; index < itemCount + addedCount; index++) {
    const newItem = newItems[index];
    const oldNextIndex = index - addedCount + removeCount;
    const nextOldItem = oldItems[oldNextIndex];
    const isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result2.push({
          type: "remove",
          key: getKey(nextOldItem),
          index,
          oldItem: nextOldItem
        });
        removeCount++;
        index--;
      }
    } else {
      const key = getKeyWrapper(newItem, getKey);
      const oldIndex = oldIndexByKey[key];
      const oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result2.push({
          type: "insert",
          data: newItem,
          index
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result2.push({
            type: "update",
            data: newItem,
            key: getKey(newItem),
            index,
            oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result2;
};

// node_modules/devextreme/esm/__internal/ui/collection/m_data_controller.js
var DataControllerMock = {
  load: () => Deferred().reject(),
  loadSingle: () => Deferred().reject(),
  loadFromStore: () => Deferred().reject(),
  loadNextPage: () => Deferred().reject(),
  loadOptions: noop,
  userData: noop,
  cancel: noop,
  cancelAll: noop,
  filter: noop,
  addSearchFilter: noop,
  group: noop,
  paginate: noop,
  pageSize: noop,
  pageIndex: noop,
  resetDataSourcePageIndex: noop,
  totalCount: noop,
  isLastPage: noop,
  isLoading: noop,
  isLoaded: noop,
  searchValue: noop,
  searchOperation: noop,
  searchExpr: noop,
  select: noop,
  key: noop,
  keyOf: noop,
  store: noop,
  items: noop,
  applyMapFunction: noop,
  getDataSource: noop,
  reload: noop,
  on: noop,
  off: noop
};
var DataController = class {
  constructor(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data17) {
    return this._dataSource._applyMapFunction(data17);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var m_data_controller_default = DataController;

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_helper_mixin.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = (Base) => class extends Base {
  postCtor() {
    this.on("disposing", (() => {
      this._disposeDataSource();
    }));
  }
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  }
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  }
  _initDataController() {
    var _this$option;
    const dataController2 = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController2) {
      this._dataController = dataController2;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  }
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  }
  _addReadyWatcher() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  }
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  }
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  }
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  }
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  }
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  }
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  }
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_controller.js
var changePaging = function(that, optionName, value2) {
  const dataSource = that._dataSource;
  if (dataSource) {
    if (void 0 !== value2) {
      const oldValue = that._getPagingOptionValue(optionName);
      if (oldValue !== value2) {
        if ("pageSize" === optionName) {
          dataSource.pageIndex(0);
        }
        dataSource[optionName](value2);
        that._skipProcessingPagingChange = true;
        that.option(`paging.${optionName}`, value2);
        that._skipProcessingPagingChange = false;
        const pageIndex = dataSource.pageIndex();
        that._isPaging = "pageIndex" === optionName;
        return dataSource["pageIndex" === optionName ? "load" : "reload"]().done((() => {
          that._isPaging = false;
          that.pageChanged.fire(pageIndex);
        }));
      }
      return Deferred().resolve().promise();
    }
    return dataSource[optionName]();
  }
  if ("pageIndex" === optionName && void 0 !== value2) {
    return Deferred().resolve().promise();
  }
  return 0;
};
var DataController2 = class extends DataHelperMixin(m_modules_default.Controller) {
  init() {
    this._items = [];
    this._cachedProcessedItems = null;
    this._columnsController = this.getController("columns");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._errorHandlingController = this.getController("errorHandling");
    this._filterSyncController = this.getController("filterSync");
    this._applyFilterController = this.getController("applyFilter");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._focusController = this.getController("focus");
    this._headerFilterController = this.getController("headerFilter");
    this._selectionController = this.getController("selection");
    this._stateStoringController = this.getController("stateStoring");
    this._validatingController = this.getController("validating");
    this._isPaging = false;
    this._currentOperationTypes = null;
    this._dataChangedHandler = (e) => {
      this._currentOperationTypes = this._dataSource.operationTypes();
      this._handleDataChanged(e);
      this._currentOperationTypes = null;
    };
    this._columnsChangedHandler = this._handleColumnsChanged.bind(this);
    this._loadingChangedHandler = this._handleLoadingChanged.bind(this);
    this._loadErrorHandler = this._handleLoadError.bind(this);
    this._customizeStoreLoadOptionsHandler = this._handleCustomizeStoreLoadOptions.bind(this);
    this._changingHandler = this._handleChanging.bind(this);
    this._dataPushedHandler = this._handleDataPushed.bind(this);
    this._columnsController.columnsChanged.add(this._columnsChangedHandler);
    this._isLoading = false;
    this._isCustomLoading = false;
    this._repaintChangesOnly = void 0;
    this._changes = [];
    this.createAction("onDataErrorOccurred");
    this.dataErrorOccurred.add(((error) => this.executeAction("onDataErrorOccurred", {
      error
    })));
    this._refreshDataSource();
    this.postCtor();
  }
  _getPagingOptionValue(optionName) {
    return this._dataSource[optionName]();
  }
  callbackNames() {
    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged", "pushed"];
  }
  callbackFlags(name2) {
    if ("dataErrorOccurred" === name2) {
      return {
        stopOnFalse: true
      };
    }
    return;
  }
  publicMethods() {
    return ["_disposeDataSource", "beginCustomLoading", "byKey", "clearFilter", "endCustomLoading", "filter", "getCombinedFilter", "getDataByKeys", "getDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getVisibleRows", "keyOf", "pageCount", "pageIndex", "pageSize", "refresh", "repaintRows", "totalCount"];
  }
  reset() {
    this._columnsController.reset();
    this._items = [];
    this._refreshDataSource();
  }
  _handleDataSourceChange(args) {
    if (args.value === args.previousValue || this.option("columns") && Array.isArray(args.value) && Array.isArray(args.previousValue)) {
      const isValueChanged = args.value !== args.previousValue;
      if (isValueChanged) {
        const store = this.store();
        if (store) {
          store._array = args.value;
        }
      }
      if (this.needToRefreshOnDataSourceChange(args)) {
        this.refresh(this.option("repaintChangesOnly"));
      }
      return true;
    }
    return false;
  }
  needToRefreshOnDataSourceChange(args) {
    return true;
  }
  optionChanged(args) {
    const that = this;
    let dataSource;
    let changedPagingOptions;
    function handled() {
      args.handled = true;
    }
    if ("dataSource" === args.name && args.name === args.fullName && this._handleDataSourceChange(args)) {
      handled();
      return;
    }
    switch (args.name) {
      case "cacheEnabled":
      case "repaintChangesOnly":
      case "highlightChanges":
      case "loadingTimeout":
        handled();
        break;
      case "remoteOperations":
      case "keyExpr":
      case "dataSource":
      case "scrolling":
        handled();
        that.reset();
        break;
      case "paging":
        dataSource = that.dataSource();
        if (dataSource) {
          changedPagingOptions = that._setPagingOptions(dataSource);
          if (changedPagingOptions) {
            const pageIndex = dataSource.pageIndex();
            this._isPaging = changedPagingOptions.isPageIndexChanged;
            dataSource.load().done((() => {
              this._isPaging = false;
              that.pageChanged.fire(pageIndex);
            }));
          }
        }
        handled();
        break;
      case "rtlEnabled":
        that.reset();
        break;
      case "columns":
        dataSource = that.dataSource();
        if (dataSource && dataSource.isLoading() && args.name === args.fullName) {
          this._useSortingGroupingFromColumns = true;
          dataSource.load();
        }
        break;
      default:
        super.optionChanged(args);
    }
  }
  isReady() {
    return !this._isLoading;
  }
  getDataSource() {
    return this._dataSource && this._dataSource._dataSource;
  }
  getCombinedFilter(returnDataField) {
    return this.combinedFilter(void 0, returnDataField);
  }
  combinedFilter(filter, returnDataField) {
    if (!this._dataSource) {
      return filter;
    }
    let combined = filter ?? this._dataSource.filter();
    const isColumnsTypesDefined = this._columnsController.isDataSourceApplied() || this._columnsController.isAllDataTypesDefined();
    if (isColumnsTypesDefined) {
      const additionalFilter = this._calculateAdditionalFilter();
      combined = additionalFilter ? m_utils_default.combineFilters([additionalFilter, combined]) : combined;
    }
    const isRemoteFiltering = this._dataSource.remoteOperations().filtering || returnDataField;
    combined = this._columnsController.updateFilter(combined, isRemoteFiltering);
    return combined;
  }
  waitReady() {
    if (this._updateLockCount) {
      this._readyDeferred = new Deferred();
      return this._readyDeferred;
    }
    return when();
  }
  _endUpdateCore() {
    const changes = this._changes;
    if (changes.length) {
      this._changes = [];
      const repaintChangesOnly = changes.every(((change) => change.repaintChangesOnly));
      this.updateItems(1 === changes.length ? changes[0] : {
        repaintChangesOnly
      });
    }
    if (this._readyDeferred) {
      this._readyDeferred.resolve();
      this._readyDeferred = null;
    }
  }
  _handleCustomizeStoreLoadOptions(e) {
    var _storeLoadOptions$fil;
    const columnsController = this._columnsController;
    const dataSource = this._dataSource;
    const {
      storeLoadOptions
    } = e;
    if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
      return;
    }
    storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
    if (1 === (null === (_storeLoadOptions$fil = storeLoadOptions.filter) || void 0 === _storeLoadOptions$fil ? void 0 : _storeLoadOptions$fil.length) && "!" === storeLoadOptions.filter[0]) {
      e.data = [];
      e.extra = e.extra || {};
      e.extra.totalCount = 0;
    }
    if (!columnsController.isDataSourceApplied()) {
      columnsController.updateColumnDataTypes(dataSource);
    }
    this._columnsUpdating = true;
    columnsController.updateSortingGrouping(dataSource, !this._useSortingGroupingFromColumns);
    this._columnsUpdating = false;
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
    storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
    dataSource.sort(storeLoadOptions.sort);
    dataSource.group(storeLoadOptions.group);
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
    e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
  }
  _handleColumnsChanged(e) {
    const that = this;
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    let filterValue;
    let filterValues;
    let filterApplied;
    const updateItemsHandler = function(change) {
      var _change$changeTypes, _change$changeTypes2;
      that._columnsController.columnsChanged.remove(updateItemsHandler);
      that.updateItems({
        repaintChangesOnly: false,
        event: null === change || void 0 === change || null === (_change$changeTypes = change.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes.event,
        virtualColumnsScrolling: null === change || void 0 === change || null === (_change$changeTypes2 = change.changeTypes) || void 0 === _change$changeTypes2 ? void 0 : _change$changeTypes2.virtualColumnsScrolling
      });
    };
    if (changeTypes.sorting || changeTypes.grouping) {
      if (that._dataSource && !that._columnsUpdating) {
        that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
        that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
        that.reload();
      }
    } else if (changeTypes.columns) {
      filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
      if (optionNames.filterValues || optionNames.filterType && Array.isArray(filterValues) || optionNames.filterValue || optionNames.selectedFilterOperation || optionNames.allowFiltering) {
        filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
        if (Array.isArray(filterValues) || void 0 === e.columnIndex || isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
          that._applyFilter();
          filterApplied = true;
        }
      }
      if (!that._needApplyFilter && !m_utils_default.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
        that._columnsController.columnsChanged.add(updateItemsHandler);
      }
      if (isDefined(optionNames.visible)) {
        const column = that._columnsController.columnOption(e.columnIndex);
        if (column && (isDefined(column.filterValue) || isDefined(column.filterValues))) {
          that._applyFilter();
          filterApplied = true;
        }
      }
    }
    if (!filterApplied && changeTypes.filtering && !this._needApplyFilter) {
      that.reload();
    }
  }
  _handleDataChanged(e) {
    const that = this;
    const dataSource = that._dataSource;
    const columnsController = that._columnsController;
    let isAsyncDataSourceApplying = false;
    this._useSortingGroupingFromColumns = false;
    if (dataSource && !that._isDataSourceApplying) {
      that._isDataSourceApplying = true;
      when(that._columnsController.applyDataSource(dataSource)).done((() => {
        if (that._isLoading) {
          that._handleLoadingChanged(false);
        }
        if (isAsyncDataSourceApplying && e && e.isDelayed) {
          e.isDelayed = false;
        }
        that._isDataSourceApplying = false;
        const needApplyFilter = that._needApplyFilter;
        that._needApplyFilter = false;
        if (needApplyFilter && !that._isAllDataTypesDefined && (() => {
          const additionalFilter = that._calculateAdditionalFilter();
          return additionalFilter && additionalFilter.length;
        })()) {
          ui_errors_default.log("W1005", that.component.NAME);
          that._applyFilter();
        } else {
          that.updateItems(e, true);
        }
      })).fail((() => {
        that._isDataSourceApplying = false;
      }));
      if (that._isDataSourceApplying) {
        isAsyncDataSourceApplying = true;
        that._handleLoadingChanged(true);
      }
      that._needApplyFilter = !that._columnsController.isDataSourceApplied();
      that._isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
    }
  }
  _handleLoadingChanged(isLoading) {
    this._isLoading = isLoading;
    this._fireLoadingChanged();
  }
  _handleLoadError(e) {
    this.dataErrorOccurred.fire(e);
  }
  _handleDataPushed(changes) {
    this.pushed.fire(changes);
  }
  fireError() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.dataErrorOccurred.fire(ui_errors_default.Error.apply(ui_errors_default, args));
  }
  _setPagingOptions(dataSource) {
    const pageIndex = this.option("paging.pageIndex");
    const pageSize = this.option("paging.pageSize");
    const pagingEnabled = this.option("paging.enabled");
    const scrollingMode = this.option("scrolling.mode");
    const appendMode = "infinite" === scrollingMode;
    const virtualMode = "virtual" === scrollingMode;
    const paginate = pagingEnabled || virtualMode || appendMode;
    let isPaginateChanged = false;
    let isPageSizeChanged = false;
    let isPageIndexChanged = false;
    dataSource.requireTotalCount(!appendMode);
    if (void 0 !== pagingEnabled && dataSource.paginate() !== paginate) {
      dataSource.paginate(paginate);
      isPaginateChanged = true;
    }
    if (void 0 !== pageSize && dataSource.pageSize() !== pageSize) {
      dataSource.pageSize(pageSize);
      isPageSizeChanged = true;
    }
    if (void 0 !== pageIndex && dataSource.pageIndex() !== pageIndex) {
      dataSource.pageIndex(pageIndex);
      isPageIndexChanged = true;
    }
    if (isPaginateChanged || isPageSizeChanged || isPageIndexChanged) {
      return {
        isPaginateChanged,
        isPageSizeChanged,
        isPageIndexChanged
      };
    }
    return false;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (Array.isArray(dataSource)) {
      return {
        store: {
          type: "array",
          data: dataSource,
          key: this.option("keyExpr")
        }
      };
    }
    return dataSource;
  }
  _initDataSource() {
    const that = this;
    const oldDataSource = this._dataSource;
    super._initDataSource();
    const dataSource = that._dataSource;
    that._useSortingGroupingFromColumns = true;
    that._cachedProcessedItems = null;
    if (dataSource) {
      const changedPagingOptions = that._setPagingOptions(dataSource);
      this._isPaging = null === changedPagingOptions || void 0 === changedPagingOptions ? void 0 : changedPagingOptions.isPageIndexChanged;
      that.setDataSource(dataSource);
    } else if (oldDataSource) {
      that.updateItems();
    }
  }
  _loadDataSource() {
    const that = this;
    const dataSource = that._dataSource;
    const result2 = new Deferred();
    when(this._columnsController.refresh(true)).always((() => {
      if (dataSource) {
        dataSource.load().done((function() {
          that._isPaging = false;
          result2.resolve.apply(result2, arguments);
        })).fail(result2.reject);
      } else {
        result2.resolve();
      }
    }));
    return result2.promise();
  }
  _beforeProcessItems(items) {
    return items.slice(0);
  }
  getRowIndexDelta() {
    return 0;
  }
  getDataIndex(change) {
    const visibleItems = this._items;
    const lastVisibleItem = "append" === change.changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1] : null;
    return isDefined(null === lastVisibleItem || void 0 === lastVisibleItem ? void 0 : lastVisibleItem.dataIndex) ? lastVisibleItem.dataIndex + 1 : 0;
  }
  _processItems(items, change) {
    const that = this;
    const rowIndexDelta = that.getRowIndexDelta();
    const {
      changeType
    } = change;
    const visibleColumns = that._columnsController.getVisibleColumns(null, "loadingAll" === changeType);
    const dataIndex = this.getDataIndex(change);
    const options2 = {
      visibleColumns,
      dataIndex
    };
    const result2 = [];
    each(items, ((index, item) => {
      if (isDefined(item)) {
        options2.rowIndex = index - rowIndexDelta;
        item = that._processItem(item, options2);
        result2.push(item);
      }
    }));
    return result2;
  }
  _processItem(item, options2) {
    item = this._generateDataItem(item, options2);
    item = this._processDataItem(item, options2);
    item.dataIndex = options2.dataIndex++;
    return item;
  }
  _generateDataItem(data17, options2) {
    return {
      rowType: "data",
      data: data17,
      key: this.keyOf(data17)
    };
  }
  _processDataItem(dataItem, options2) {
    dataItem.values = this.generateDataValues(dataItem.data, options2.visibleColumns);
    return dataItem;
  }
  generateDataValues(data17, columns7, isModified) {
    const values = [];
    let value2;
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      value2 = isModified ? void 0 : null;
      if (!column.command) {
        if (column.calculateCellValue) {
          value2 = column.calculateCellValue(data17);
        } else if (column.dataField) {
          value2 = data17[column.dataField];
        }
      }
      values.push(value2);
    }
    return values;
  }
  _applyChange(change) {
    const that = this;
    if ("update" === change.changeType) {
      that._applyChangeUpdate(change);
    } else if (that.items().length && change.repaintChangesOnly && "refresh" === change.changeType) {
      that._applyChangesOnly(change);
    } else if ("refresh" === change.changeType) {
      that._applyChangeFull(change);
    }
  }
  _applyChangeFull(change) {
    this._items = change.items.slice(0);
  }
  _getRowIndices(change) {
    const rowIndices = change.rowIndices.slice(0);
    const rowIndexDelta = this.getRowIndexDelta();
    rowIndices.sort(((a, b) => a - b));
    for (let i = 0; i < rowIndices.length; i++) {
      let correctedRowIndex = rowIndices[i];
      if (change.allowInvisibleRowIndices) {
        correctedRowIndex += rowIndexDelta;
      }
      if (correctedRowIndex < 0) {
        rowIndices.splice(i, 1);
        i--;
      }
    }
    return rowIndices;
  }
  _applyChangeUpdate(change) {
    const that = this;
    const {
      items
    } = change;
    const rowIndices = that._getRowIndices(change);
    const rowIndexDelta = that.getRowIndexDelta();
    const repaintChangesOnly = that.option("repaintChangesOnly");
    let prevIndex = -1;
    let rowIndexCorrection = 0;
    let changeType;
    change.items = [];
    change.rowIndices = [];
    change.columnIndices = [];
    change.changeTypes = [];
    const equalItems = function(item1, item2, strict) {
      let result2 = item1 && item2 && equalByValue(item1.key, item2.key);
      if (result2 && strict) {
        result2 = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing);
      }
      return result2;
    };
    each(rowIndices, ((index, rowIndex) => {
      let columnIndices;
      rowIndex += rowIndexCorrection + rowIndexDelta;
      if (prevIndex === rowIndex) {
        return;
      }
      prevIndex = rowIndex;
      const oldItem = that._items[rowIndex];
      const oldNextItem = that._items[rowIndex + 1];
      const newItem = items[rowIndex];
      const newNextItem = items[rowIndex + 1];
      const strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
      if (newItem) {
        newItem.rowIndex = rowIndex;
        change.items.push(newItem);
      }
      if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
        changeType = "update";
        that._items[rowIndex] = newItem;
        if (oldItem.visible !== newItem.visible) {
          change.items.splice(-1, 1, {
            visible: newItem.visible
          });
        } else if (repaintChangesOnly && !change.isFullUpdate) {
          columnIndices = that._partialUpdateRow(oldItem, newItem, rowIndex - rowIndexDelta);
        }
      } else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
        changeType = "insert";
        that._items.splice(rowIndex, 0, newItem);
        rowIndexCorrection++;
      } else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
        changeType = "remove";
        that._items.splice(rowIndex, 1);
        rowIndexCorrection--;
        prevIndex = -1;
      } else if (newItem) {
        changeType = "update";
        that._items[rowIndex] = newItem;
      } else {
        return;
      }
      change.rowIndices.push(rowIndex - rowIndexDelta);
      change.changeTypes.push(changeType);
      change.columnIndices.push(columnIndices);
    }));
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    if (JSON.stringify(oldRow.values[columnIndex]) !== JSON.stringify(newRow.values[columnIndex])) {
      return true;
    }
    function isCellModified(row, columnIndex2) {
      return row.modifiedValues ? void 0 !== row.modifiedValues[columnIndex2] : false;
    }
    if (isCellModified(oldRow, columnIndex) !== isCellModified(newRow, columnIndex)) {
      return true;
    }
    return false;
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    let columnIndices;
    if (oldItem.rowType === newItem.rowType) {
      if ("group" !== newItem.rowType && "groupFooter" !== newItem.rowType) {
        columnIndices = [];
        if ("detail" !== newItem.rowType) {
          for (let columnIndex = 0; columnIndex < oldItem.values.length; columnIndex++) {
            if (this._isCellChanged(oldItem, newItem, visibleRowIndex, columnIndex, isLiveUpdate)) {
              columnIndices.push(columnIndex);
            }
          }
        }
      }
      if ("group" === newItem.rowType && oldItem.cells) {
        const isRowStateEquals = newItem.isExpanded === oldItem.isExpanded && newItem.data.isContinuation === oldItem.data.isContinuation && newItem.data.isContinuationOnNextPage === oldItem.data.isContinuationOnNextPage;
        if (isRowStateEquals) {
          columnIndices = oldItem.cells.map(((cell, index) => {
            var _cell$column;
            return "groupExpand" !== (null === (_cell$column = cell.column) || void 0 === _cell$column ? void 0 : _cell$column.type) ? index : -1;
          })).filter(((index) => index >= 0));
        }
      }
    }
    return columnIndices;
  }
  _partialUpdateRow(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    var _changedColumnIndices;
    let changedColumnIndices = this._getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate);
    if (null !== (_changedColumnIndices = changedColumnIndices) && void 0 !== _changedColumnIndices && _changedColumnIndices.length && this.option("dataRowTemplate")) {
      changedColumnIndices = void 0;
    }
    if (changedColumnIndices) {
      oldItem.cells && oldItem.cells.forEach(((cell, columnIndex) => {
        const isCellChanged = changedColumnIndices.indexOf(columnIndex) >= 0;
        if (!isCellChanged && cell && cell.update) {
          cell.update(newItem);
        }
      }));
      newItem.update = oldItem.update;
      newItem.watch = oldItem.watch;
      newItem.cells = oldItem.cells;
      if (isLiveUpdate) {
        newItem.oldValues = oldItem.values;
      }
      oldItem.update && oldItem.update(newItem);
    }
    return changedColumnIndices;
  }
  _isItemEquals(item1, item2) {
    if (JSON.stringify(item1.values) !== JSON.stringify(item2.values)) {
      return false;
    }
    if (["modified", "isNewRow", "removed", "isEditing"].some(((field) => item1[field] !== item2[field]))) {
      return false;
    }
    if ("group" === item1.rowType || "groupFooter" === item1.rowType) {
      var _item1$data, _item2$data, _item1$data2, _item2$data2;
      const expandedMatch = item1.isExpanded === item2.isExpanded;
      const summaryCellsMatch = JSON.stringify(item1.summaryCells) === JSON.stringify(item2.summaryCells);
      const continuationMatch = (null === (_item1$data = item1.data) || void 0 === _item1$data ? void 0 : _item1$data.isContinuation) === (null === (_item2$data = item2.data) || void 0 === _item2$data ? void 0 : _item2$data.isContinuation) && (null === (_item1$data2 = item1.data) || void 0 === _item1$data2 ? void 0 : _item1$data2.isContinuationOnNextPage) === (null === (_item2$data2 = item2.data) || void 0 === _item2$data2 ? void 0 : _item2$data2.isContinuationOnNextPage);
      if (!expandedMatch || !summaryCellsMatch || !continuationMatch) {
        return false;
      }
    }
    return true;
  }
  _applyChangesOnly(change) {
    const rowIndices = [];
    const columnIndices = [];
    const changeTypes = [];
    const items = [];
    const newIndexByKey = {};
    const isLiveUpdate = (null === change || void 0 === change ? void 0 : change.isLiveUpdate) ?? true;
    function getRowKey(row) {
      if (row) {
        return `${row.rowType},${JSON.stringify(row.key)}`;
      }
      return;
    }
    const currentItems = this._items;
    const oldItems = currentItems.slice();
    change.items.forEach(((item, index) => {
      const key = getRowKey(item);
      newIndexByKey[key] = index;
      item.rowIndex = index;
    }));
    const result2 = findChanges(oldItems, change.items, getRowKey, ((item1, item2) => {
      if (!this._isItemEquals(item1, item2)) {
        return false;
      }
      if (item1.cells) {
        item1.update && item1.update(item2);
        item1.cells.forEach(((cell) => {
          if (cell && cell.update) {
            cell.update(item2, true);
          }
        }));
      }
      return true;
    }));
    if (!result2) {
      this._applyChangeFull(change);
      return;
    }
    result2.forEach(((change2) => {
      switch (change2.type) {
        case "update": {
          const {
            index
          } = change2;
          const newItem = change2.data;
          const {
            oldItem
          } = change2;
          const changedColumnIndices = this._partialUpdateRow(oldItem, newItem, index, isLiveUpdate);
          rowIndices.push(index);
          changeTypes.push("update");
          items.push(newItem);
          currentItems[index] = newItem;
          columnIndices.push(changedColumnIndices);
          break;
        }
        case "insert":
          rowIndices.push(change2.index);
          changeTypes.push("insert");
          items.push(change2.data);
          columnIndices.push(void 0);
          currentItems.splice(change2.index, 0, change2.data);
          break;
        case "remove":
          rowIndices.push(change2.index);
          changeTypes.push("remove");
          currentItems.splice(change2.index, 1);
          items.push(change2.oldItem);
          columnIndices.push(void 0);
      }
    }));
    change.repaintChangesOnly = true;
    change.changeType = "update";
    change.rowIndices = rowIndices;
    change.columnIndices = columnIndices;
    change.changeTypes = changeTypes;
    change.items = items;
    if (oldItems.length) {
      change.isLiveUpdate = true;
    }
    this._correctRowIndices(((rowIndex) => {
      const oldRowIndexOffset = this._rowIndexOffset || 0;
      const rowIndexOffset = this.getRowIndexOffset();
      const oldItem = oldItems[rowIndex - oldRowIndexOffset];
      const key = getRowKey(oldItem);
      const newVisibleRowIndex = newIndexByKey[key];
      return newVisibleRowIndex >= 0 ? newVisibleRowIndex + rowIndexOffset - rowIndex : 0;
    }));
  }
  _correctRowIndices(rowIndex) {
  }
  _afterProcessItems(items, change) {
    return items;
  }
  _updateItemsCore(change) {
    let items;
    const dataSource = this._dataSource;
    const changeType = change.changeType || "refresh";
    change.changeType = changeType;
    if (dataSource) {
      const cachedProcessedItems = this._cachedProcessedItems;
      if (change.useProcessedItemsCache && cachedProcessedItems) {
        items = cachedProcessedItems;
      } else {
        items = change.items || dataSource.items();
        items = this._beforeProcessItems(items);
        items = this._processItems(items, change);
        this._cachedProcessedItems = items;
      }
      items = this._afterProcessItems(items, change);
      change.items = items;
      const oldItems = this._items.length === items.length && this._items;
      this._applyChange(change);
      const rowIndexDelta = this.getRowIndexDelta();
      each(this._items, ((index, item) => {
        item.rowIndex = index - rowIndexDelta;
        if (oldItems) {
          item.cells = oldItems[index].cells ?? [];
        }
        const newItem = items[index];
        if (newItem) {
          item.loadIndex = newItem.loadIndex;
        }
      }));
      this._rowIndexOffset = this.getRowIndexOffset();
    } else {
      this._items = [];
    }
  }
  _handleChanging(e) {
    const rows = this.getVisibleRows();
    const dataSource = this.dataSource();
    if (dataSource) {
      e.changes.forEach(((change) => {
        if ("insert" === change.type && change.index >= 0) {
          let dataIndex = 0;
          for (let i = 0; i < change.index; i++) {
            const row = rows[i];
            if (row && ("data" === row.rowType || "group" === row.rowType)) {
              dataIndex++;
            }
          }
          change.index = dataIndex;
        }
      }));
    }
  }
  updateItems(change, isDataChanged) {
    change = change || {};
    const that = this;
    change.isFirstRender = !that.changed.fired();
    if (void 0 !== that._repaintChangesOnly) {
      change.repaintChangesOnly = change.repaintChangesOnly ?? that._repaintChangesOnly;
      change.needUpdateDimensions = change.needUpdateDimensions || that._needUpdateDimensions;
    } else if (change.changes) {
      change.repaintChangesOnly = that.option("repaintChangesOnly");
    } else if (isDataChanged) {
      const operationTypes = that.dataSource().operationTypes();
      change.repaintChangesOnly = operationTypes && !operationTypes.grouping && !operationTypes.filtering && that.option("repaintChangesOnly");
      change.isDataChanged = true;
      if (operationTypes && (operationTypes.reload || operationTypes.paging || operationTypes.groupExpanding)) {
        change.needUpdateDimensions = true;
      }
    }
    if (that._updateLockCount && !change.cancel) {
      that._changes.push(change);
      return;
    }
    that._updateItemsCore(change);
    if (change.cancel) {
      return;
    }
    that._fireChanged(change);
  }
  loadingOperationTypes() {
    const dataSource = this.dataSource();
    return dataSource && dataSource.loadingOperationTypes() || {};
  }
  _fireChanged(change) {
    if (this._currentOperationTypes) {
      change.operationTypes = this._currentOperationTypes;
      this._currentOperationTypes = null;
    }
    deferRender((() => {
      this.changed.fire(change);
    }));
  }
  isLoading() {
    return this._isLoading || this._isCustomLoading;
  }
  _fireLoadingChanged() {
    this.loadingChanged.fire(this.isLoading(), this._loadingText);
  }
  _calculateAdditionalFilter() {
    return null;
  }
  _applyFilter() {
    const dataSource = this._dataSource;
    if (dataSource) {
      dataSource.pageIndex(0);
      this._isFilterApplying = true;
      return this.reload().done((() => {
        if (this._isFilterApplying) {
          this.pageChanged.fire();
        }
      }));
    }
    return new Deferred().resolve();
  }
  resetFilterApplying() {
    this._isFilterApplying = false;
  }
  filter(filterExpr) {
    var _dataSource$loadOptio;
    const dataSource = this._dataSource;
    const filter = null === dataSource || void 0 === dataSource ? void 0 : dataSource.filter();
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (0 === arguments.length) {
      return filter;
    }
    filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
    if (m_utils_default.equalFilterParameters(filter, filterExpr, langParams)) {
      return;
    }
    if (dataSource) {
      dataSource.filter(filterExpr);
    }
    this._applyFilter();
  }
  clearFilter(filterName) {
    const that = this;
    const columnsController = that._columnsController;
    const clearColumnOption = function(optionName) {
      const columnCount = columnsController.columnCount();
      for (let index = 0; index < columnCount; index++) {
        columnsController.columnOption(index, optionName, void 0);
      }
    };
    that.component.beginUpdate();
    if (arguments.length > 0) {
      switch (filterName) {
        case "dataSource":
          that.filter(null);
          break;
        case "search":
          that.searchByText("");
          break;
        case "header":
          clearColumnOption("filterValues");
          break;
        case "row":
          clearColumnOption("filterValue");
      }
    } else {
      that.filter(null);
      that.searchByText("");
      clearColumnOption("filterValue");
      clearColumnOption("bufferedFilterValue");
      clearColumnOption("filterValues");
    }
    that.component.endUpdate();
  }
  _fireDataSourceChanged() {
    const that = this;
    const changedHandler = function() {
      that.changed.remove(changedHandler);
      that.dataSourceChanged.fire();
    };
    that.changed.add(changedHandler);
  }
  _getDataSourceAdapter() {
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const dataSourceAdapterProvider = this._getDataSourceAdapter();
    const dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
    dataSourceAdapter.init(dataSource, remoteOperations);
    return dataSourceAdapter;
  }
  isLocalStore() {
    let store = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.store();
    return store instanceof m_array_store_default;
  }
  isCustomStore(store) {
    store = store || this.store();
    return store instanceof m_custom_store_default;
  }
  _createDataSourceAdapter(dataSource) {
    let remoteOperations = this.option("remoteOperations");
    const store = dataSource.store();
    const enabledRemoteOperations = {
      filtering: true,
      sorting: true,
      paging: true,
      grouping: true,
      summary: true
    };
    if (isObject(remoteOperations) && remoteOperations.groupPaging) {
      remoteOperations = extend({}, enabledRemoteOperations, remoteOperations);
    }
    if ("auto" === remoteOperations) {
      remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
        filtering: true,
        sorting: true,
        paging: true
      };
    }
    if (true === remoteOperations) {
      remoteOperations = enabledRemoteOperations;
    }
    return this._createDataSourceAdapterCore(dataSource, remoteOperations);
  }
  setDataSource(dataSource) {
    const that = this;
    const oldDataSource = that._dataSource;
    if (!dataSource && oldDataSource) {
      oldDataSource.cancelAll();
      oldDataSource.changed.remove(that._dataChangedHandler);
      oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
      oldDataSource.loadError.remove(that._loadErrorHandler);
      oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
      oldDataSource.changing.remove(that._changingHandler);
      oldDataSource.pushed.remove(that._dataPushedHandler);
      oldDataSource.dispose(that._isSharedDataSource);
    }
    if (dataSource) {
      dataSource = that._createDataSourceAdapter(dataSource);
    }
    that._dataSource = dataSource;
    if (dataSource) {
      that._fireDataSourceChanged();
      that._isLoading = !dataSource.isLoaded();
      that._needApplyFilter = true;
      that._isAllDataTypesDefined = that._columnsController.isAllDataTypesDefined();
      dataSource.changed.add(that._dataChangedHandler);
      dataSource.loadingChanged.add(that._loadingChangedHandler);
      dataSource.loadError.add(that._loadErrorHandler);
      dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler);
      dataSource.changing.add(that._changingHandler);
      dataSource.pushed.add(that._dataPushedHandler);
    }
  }
  items(byLoaded) {
    return this._items;
  }
  isEmpty() {
    return !this.items().length;
  }
  pageCount() {
    return this._dataSource ? this._dataSource.pageCount() : 1;
  }
  dataSource() {
    return this._dataSource;
  }
  store() {
    const dataSource = this._dataSource;
    return dataSource && dataSource.store();
  }
  loadAll(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const dataSource = that._dataSource;
    if (dataSource) {
      if (data17) {
        const options2 = {
          data: data17,
          isCustomLoading: true,
          storeLoadOptions: {
            isLoadingAll: true
          },
          loadOptions: {
            filter: skipFilter ? null : that.getCombinedFilter(),
            group: dataSource.group(),
            sort: dataSource.sort()
          }
        };
        dataSource._handleDataLoaded(options2);
        when(options2.data).done(((data18) => {
          var _options$extra;
          data18 = that._beforeProcessItems(data18);
          d.resolve(that._processItems(data18, {
            changeType: "loadingAll"
          }), null === (_options$extra = options2.extra) || void 0 === _options$extra ? void 0 : _options$extra.summary);
        })).fail(d.reject);
      } else if (!dataSource.isLoading()) {
        const loadOptions = extend({}, dataSource.loadOptions(), {
          isLoadingAll: true,
          requireTotalCount: false
        });
        dataSource.load(loadOptions).done(((items, extra) => {
          items = that._beforeProcessItems(items);
          items = that._processItems(items, {
            changeType: "loadingAll"
          });
          d.resolve(items, extra && extra.summary);
        })).fail(d.reject);
      } else {
        d.reject();
      }
    } else {
      d.resolve([]);
    }
    return d;
  }
  getKeyByRowIndex(rowIndex, byLoaded) {
    const item = this.items(byLoaded)[rowIndex];
    if (item) {
      return item.key;
    }
  }
  getRowIndexByKey(key, byLoaded) {
    return m_utils_default.getIndexByKey(key, this.items(byLoaded));
  }
  getRowByKey(key) {
    var _this$items;
    return null === (_this$items = this.items()) || void 0 === _this$items ? void 0 : _this$items[this.getRowIndexByKey(key)];
  }
  keyOf(data17) {
    const store = this.store();
    if (store) {
      return store.keyOf(data17);
    }
  }
  byKey(key) {
    const store = this.store();
    const rowIndex = this.getRowIndexByKey(key);
    let result2;
    if (!store) {
      return;
    }
    if (rowIndex >= 0) {
      result2 = new Deferred().resolve(this.items()[rowIndex].data);
    }
    return result2 || store.byKey(key);
  }
  key() {
    const store = this.store();
    if (store) {
      return store.key();
    }
  }
  getRowIndexOffset(byLoadedRows) {
    return 0;
  }
  getDataByKeys(rowKeys) {
    const that = this;
    const result2 = new Deferred();
    const deferreds = [];
    const data17 = [];
    each(rowKeys, ((index, key) => {
      deferreds.push(that.byKey(key).done(((keyData) => {
        data17[index] = keyData;
      })));
    }));
    when.apply(renderer_default, deferreds).always((() => {
      result2.resolve(data17);
    }));
    return result2;
  }
  pageIndex(value2) {
    return changePaging(this, "pageIndex", value2);
  }
  pageSize(value2) {
    return changePaging(this, "pageSize", value2);
  }
  beginCustomLoading(messageText) {
    this._isCustomLoading = true;
    this._loadingText = messageText || "";
    this._fireLoadingChanged();
  }
  endCustomLoading() {
    this._isCustomLoading = false;
    this._loadingText = void 0;
    this._fireLoadingChanged();
  }
  refresh(options2) {
    if (true === options2) {
      options2 = {
        reload: true,
        changesOnly: true
      };
    } else if (!options2) {
      options2 = {
        reload: true,
        lookup: true
      };
    }
    const that = this;
    const dataSource = that.getDataSource();
    const {
      changesOnly
    } = options2;
    const d = new Deferred();
    const customizeLoadResult = function() {
      that._repaintChangesOnly = !!changesOnly;
    };
    when(!options2.lookup || that._columnsController.refresh()).always((() => {
      if (options2.load || options2.reload) {
        dataSource && dataSource.on("customizeLoadResult", customizeLoadResult);
        when(that.reload(options2.reload, changesOnly)).always((() => {
          dataSource && dataSource.off("customizeLoadResult", customizeLoadResult);
          that._repaintChangesOnly = void 0;
        })).done(d.resolve).fail(d.reject);
      } else {
        that.updateItems({
          repaintChangesOnly: options2.changesOnly
        });
        d.resolve();
      }
    }));
    return d.promise();
  }
  getVisibleRows() {
    return this.items();
  }
  _disposeDataSource() {
    if (this._dataSource && this._dataSource._eventsStrategy) {
      this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
    }
    this.setDataSource(null);
  }
  dispose() {
    this._disposeDataSource();
    super.dispose();
  }
  repaintRows(rowIndexes, changesOnly) {
    rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
    if (rowIndexes.length > 1 || isDefined(rowIndexes[0])) {
      this.updateItems({
        changeType: "update",
        rowIndices: rowIndexes,
        isFullUpdate: !changesOnly
      });
    }
  }
  skipProcessingPagingChange(fullName) {
    return this._skipProcessingPagingChange && ("paging.pageIndex" === fullName || "paging.pageSize" === fullName);
  }
  getUserState() {
    return {
      searchText: this.option("searchPanel.text"),
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    };
  }
  getCachedStoreData() {
    return this._dataSource && this._dataSource.getCachedStoreData();
  }
  isLastPageLoaded() {
    const pageIndex = this.pageIndex();
    const pageCount = this.pageCount();
    return pageIndex === pageCount - 1;
  }
  load() {
    var _this$_dataSource;
    return null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.load();
  }
  reload(reload, changesOnly) {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.reload(reload, changesOnly);
  }
  push() {
    var _this$_dataSource3;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.push(...args);
  }
  itemsCount() {
    var _this$_dataSource4;
    return this._dataSource ? null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.itemsCount() : 0;
  }
  totalItemsCount() {
    var _this$_dataSource5;
    return this._dataSource ? null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.totalItemsCount() : 0;
  }
  hasKnownLastPage() {
    var _this$_dataSource6;
    return this._dataSource ? null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 ? void 0 : _this$_dataSource6.hasKnownLastPage() : true;
  }
  isLoaded() {
    var _this$_dataSource7;
    return this._dataSource ? null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.isLoaded() : true;
  }
  totalCount() {
    var _this$_dataSource8;
    return this._dataSource ? null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.totalCount() : 0;
  }
  hasLoadOperation() {
    var _this$_dataSource9;
    const operationTypes = (null === (_this$_dataSource9 = this._dataSource) || void 0 === _this$_dataSource9 ? void 0 : _this$_dataSource9.operationTypes()) ?? {};
    return Object.keys(operationTypes).some(((type2) => operationTypes[type2]));
  }
};
var dataControllerModule = {
  defaultOptions: () => ({
    loadingTimeout: 0,
    dataSource: null,
    cacheEnabled: true,
    repaintChangesOnly: false,
    highlightChanges: false,
    onDataErrorOccurred: null,
    remoteOperations: "auto",
    paging: {
      enabled: true,
      pageSize: void 0,
      pageIndex: void 0
    }
  }),
  controllers: {
    data: DataController2
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter_utils.js
var cloneItems = function(items, groupCount) {
  if (items) {
    items = items.slice(0);
    if (groupCount) {
      for (let i = 0; i < items.length; i++) {
        items[i] = extend({
          key: items[i].key
        }, items[i]);
        items[i].items = cloneItems(items[i].items, groupCount - 1);
      }
    }
  }
  return items;
};
var calculateOperationTypes = function(loadOptions, lastLoadOptions, isFullReload) {
  let operationTypes = {
    reload: true,
    fullReload: true
  };
  if (lastLoadOptions) {
    operationTypes = {
      sorting: !m_utils_default.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
      grouping: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
      groupExpanding: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group) || lastLoadOptions.groupExpand,
      filtering: !m_utils_default.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter, loadOptions.langParams),
      pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
      skip: loadOptions.skip !== lastLoadOptions.skip,
      take: loadOptions.take !== lastLoadOptions.take,
      pageSize: loadOptions.pageSize !== lastLoadOptions.pageSize,
      fullReload: isFullReload,
      reload: false,
      paging: false
    };
    operationTypes.reload = isFullReload || operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
    operationTypes.paging = operationTypes.pageIndex || operationTypes.pageSize || operationTypes.take;
  }
  return operationTypes;
};
var executeTask = function(action, timeout) {
  if (isDefined(timeout)) {
    m_common_default.executeAsync(action, timeout);
  } else {
    action();
  }
};
var createEmptyCachedData = function() {
  return {
    items: {}
  };
};
var getPageDataFromCache = function(options2, updatePaging) {
  const groupCount = m_utils_default.normalizeSortingInfo(options2.group || options2.storeLoadOptions.group || options2.loadOptions.group).length;
  const items = [];
  if (fillItemsFromCache(items, options2, groupCount)) {
    return items;
  }
  if (updatePaging) {
    updatePagingOptionsByCache(items, options2, groupCount);
  }
};
var fillItemsFromCache = function(items, options2, groupCount, fromEnd) {
  var _options$cachedData;
  const {
    storeLoadOptions
  } = options2;
  const take = options2.take ?? storeLoadOptions.take ?? 0;
  const cachedItems = null === (_options$cachedData = options2.cachedData) || void 0 === _options$cachedData ? void 0 : _options$cachedData.items;
  if (take && cachedItems) {
    const skip = options2.skip ?? storeLoadOptions.skip ?? 0;
    for (let i = 0; i < take; i += 1) {
      const localIndex = fromEnd ? take - 1 - i : i;
      const cacheItemIndex = localIndex + skip;
      const cacheItem = cachedItems[cacheItemIndex];
      if (void 0 === cacheItem && cacheItemIndex in cachedItems) {
        return true;
      }
      const item = getItemFromCache(options2, cacheItem, groupCount, localIndex, take);
      if (item) {
        items.push(item);
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
};
var getItemFromCache = function(options2, cacheItem, groupCount, index, take) {
  if (groupCount && cacheItem) {
    const skips = 0 === index && options2.skips || [];
    const takes = index === take - 1 && options2.takes || [];
    return getGroupItemFromCache(cacheItem, groupCount, skips, takes);
  }
  return cacheItem;
};
var getGroupItemFromCache = function(cacheItem, groupCount, skips, takes) {
  if (groupCount && cacheItem) {
    const result2 = _extends({}, cacheItem);
    const skip = skips[0] || 0;
    const take = takes[0];
    const {
      items
    } = cacheItem;
    if (items) {
      if (void 0 === take && !items[skip]) {
        return;
      }
      result2.items = [];
      if (skips.length) {
        result2.isContinuation = true;
      }
      if (take) {
        result2.isContinuationOnNextPage = cacheItem.count > take;
      }
      for (let i = 0; void 0 === take ? items[i + skip] : i < take; i += 1) {
        const childCacheItem = items[i + skip];
        const isLast = i + 1 === take;
        const item = getGroupItemFromCache(childCacheItem, groupCount - 1, 0 === i ? skips.slice(1) : [], isLast ? takes.slice(1) : []);
        if (void 0 !== item) {
          result2.items.push(item);
        } else {
          return;
        }
      }
    }
    return result2;
  }
  return cacheItem;
};
var updatePagingOptionsByCache = function(cacheItemsFromBegin, options2, groupCount) {
  const cacheItemBeginCount = cacheItemsFromBegin.length;
  const {
    storeLoadOptions
  } = options2;
  if (void 0 !== storeLoadOptions.skip && storeLoadOptions.take && !groupCount) {
    const cacheItemsFromEnd = [];
    fillItemsFromCache(cacheItemsFromEnd, options2, groupCount, true);
    const cacheItemEndCount = cacheItemsFromEnd.length;
    if (cacheItemBeginCount || cacheItemEndCount) {
      options2.skip = options2.skip ?? storeLoadOptions.skip;
      options2.take = options2.take ?? storeLoadOptions.take;
    }
    if (cacheItemBeginCount) {
      storeLoadOptions.skip += cacheItemBeginCount;
      storeLoadOptions.take -= cacheItemBeginCount;
      options2.cachedDataPartBegin = cacheItemsFromBegin;
    }
    if (cacheItemEndCount) {
      storeLoadOptions.take -= cacheItemEndCount;
      options2.cachedDataPartEnd = cacheItemsFromEnd.reverse();
    }
  }
};
var setPageDataToCache = function(options2, data17, groupCount) {
  const {
    storeLoadOptions
  } = options2;
  const skip = options2.skip ?? storeLoadOptions.skip ?? 0;
  const take = options2.take ?? storeLoadOptions.take ?? 0;
  for (let i = 0; i < take; i += 1) {
    const globalIndex = i + skip;
    const cacheItems = options2.cachedData.items;
    const skips = 0 === i && options2.skips || [];
    cacheItems[globalIndex] = getCacheItem(cacheItems[globalIndex], data17[i], groupCount, skips);
  }
};
var getCacheItem = function(cacheItem, loadedItem, groupCount, skips) {
  if (groupCount && loadedItem) {
    const result2 = _extends({}, loadedItem);
    delete result2.isContinuation;
    delete result2.isContinuationOnNextPage;
    const skip = skips[0] || 0;
    if (loadedItem.items) {
      result2.items = (null === cacheItem || void 0 === cacheItem ? void 0 : cacheItem.items) || {};
      loadedItem.items.forEach(((item, index) => {
        const globalIndex = index + skip;
        const childSkips = 0 === index ? skips.slice(1) : [];
        result2.items[globalIndex] = getCacheItem(result2.items[globalIndex], item, groupCount - 1, childSkips);
      }));
    }
    return result2;
  }
  return loadedItem;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter.js
var DataSourceAdapter = class extends m_modules_default.Controller {
  init(dataSource, remoteOperations) {
    const that = this;
    that._dataSource = dataSource;
    that._remoteOperations = remoteOperations || {};
    that._isLastPage = !dataSource.isLastPage();
    that._hasLastPage = false;
    that._currentTotalCount = 0;
    that._cachedData = createEmptyCachedData();
    that._lastOperationTypes = {};
    that._eventsStrategy = dataSource._eventsStrategy;
    that._totalCountCorrection = 0;
    that._isLoadingAll = false;
    that.changed = callbacks_default();
    that.loadingChanged = callbacks_default();
    that.loadError = callbacks_default();
    that.customizeStoreLoadOptions = callbacks_default();
    that.changing = callbacks_default();
    that.pushed = callbacks_default();
    that._dataChangedHandler = that._handleDataChanged.bind(that);
    that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
    that._dataLoadedHandler = that._handleDataLoaded.bind(that);
    that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
    that._loadErrorHandler = that._handleLoadError.bind(that);
    that._pushHandler = that._handlePush.bind(that);
    that._changingHandler = that._handleChanging.bind(that);
    dataSource.on("changed", that._dataChangedHandler);
    dataSource.on("customizeStoreLoadOptions", that._customizeStoreLoadOptionsHandler);
    dataSource.on("customizeLoadResult", that._dataLoadedHandler);
    dataSource.on("loadingChanged", that._loadingChangedHandler);
    dataSource.on("loadError", that._loadErrorHandler);
    dataSource.on("changing", that._changingHandler);
    dataSource.store().on("beforePush", that._pushHandler);
    each(dataSource, ((memberName, member) => {
      if (!that[memberName] && isFunction(member)) {
        that[memberName] = function() {
          return this._dataSource[memberName].apply(this._dataSource, arguments);
        };
      }
    }));
  }
  dispose(isSharedDataSource) {
    const dataSource = this._dataSource;
    const store = dataSource.store();
    dataSource.off("changed", this._dataChangedHandler);
    dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptionsHandler);
    dataSource.off("customizeLoadResult", this._dataLoadedHandler);
    dataSource.off("loadingChanged", this._loadingChangedHandler);
    dataSource.off("loadError", this._loadErrorHandler);
    dataSource.off("changing", this._changingHandler);
    store && store.off("beforePush", this._pushHandler);
    if (!isSharedDataSource) {
      dataSource.dispose();
    }
  }
  remoteOperations() {
    return this._remoteOperations;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    if (operationTypes.reload) {
      that.resetCurrentTotalCount();
      that._isLastPage = !dataSource.paginate();
      that._hasLastPage = that._isLastPage;
    }
  }
  resetCurrentTotalCount() {
    this._currentTotalCount = 0;
    this._totalCountCorrection = 0;
  }
  resetCache() {
    this._cachedStoreData = void 0;
    this._cachedPagingData = void 0;
  }
  resetPagesCache(isLiveUpdate) {
    this._cachedData = createEmptyCachedData();
  }
  _needClearStoreDataCache() {
    const remoteOperations = this.remoteOperations();
    const operationTypes = calculateOperationTypes(this._lastLoadOptions || {}, {});
    const isLocalOperations = Object.keys(remoteOperations).every(((operationName) => !operationTypes[operationName] || !remoteOperations[operationName]));
    return !isLocalOperations;
  }
  push(changes, fromStore) {
    const store = this.store();
    if (this._needClearStoreDataCache()) {
      this._cachedStoreData = void 0;
    }
    this._cachedPagingData = void 0;
    this.resetPagesCache(true);
    if (this._cachedStoreData) {
      applyBatch({
        keyInfo: store,
        data: this._cachedStoreData,
        changes
      });
    }
    if (!fromStore) {
      this._applyBatch(changes);
    }
    this.pushed.fire(changes);
  }
  getDataIndexGetter() {
    if (!this._dataIndexGetter) {
      let indexByKey2;
      let storeData;
      const store = this.store();
      this._dataIndexGetter = (data17) => {
        const isCacheUpdated = storeData && storeData !== this._cachedStoreData;
        if (!indexByKey2 || isCacheUpdated) {
          storeData = this._cachedStoreData || [];
          indexByKey2 = {};
          for (let i = 0; i < storeData.length; i++) {
            indexByKey2[getKeyHash(store.keyOf(storeData[i]))] = i;
          }
        }
        return indexByKey2[getKeyHash(store.keyOf(data17))];
      };
    }
    return this._dataIndexGetter;
  }
  _getKeyInfo() {
    return this.store();
  }
  _needToCopyDataObject() {
    return true;
  }
  _applyBatch(changes, fromStore) {
    const keyInfo = this._getKeyInfo();
    const dataSource = this._dataSource;
    const groupCount = m_utils_default.normalizeSortingInfo(this.group()).length;
    const isReshapeMode = "reshape" === this.option("editing.refreshMode");
    const isVirtualMode3 = "virtual" === this.option("scrolling.mode");
    changes = changes.filter(((change) => !dataSource.paginate() || "insert" !== change.type || void 0 !== change.index));
    const getItemCount2 = () => groupCount ? this.itemsCount() : this.items().length;
    const oldItemCount = getItemCount2();
    applyBatch({
      keyInfo,
      data: this._items,
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    applyBatch({
      keyInfo,
      data: dataSource.items(),
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    const needUpdateTotalCountCorrection = this._currentTotalCount > 0 || (fromStore || !isReshapeMode) && isVirtualMode3;
    if (needUpdateTotalCountCorrection) {
      this._totalCountCorrection += getItemCount2() - oldItemCount;
    }
    changes.splice(0, changes.length);
  }
  _handlePush(_ref) {
    let {
      changes
    } = _ref;
    this.push(changes, true);
  }
  _handleChanging(e) {
    this.changing.fire(e);
    this._applyBatch(e.changes, true);
  }
  _needCleanCacheByOperation(operationType, remoteOperations) {
    const operationTypesByOrder = ["filtering", "sorting", "paging"];
    const operationTypeIndex = operationTypesByOrder.indexOf(operationType);
    const currentOperationTypes = operationTypeIndex >= 0 ? operationTypesByOrder.slice(operationTypeIndex) : [operationType];
    return currentOperationTypes.some(((operationType2) => remoteOperations[operationType2]));
  }
  _customizeRemoteOperations(options2, operationTypes) {
    let cachedStoreData = this._cachedStoreData;
    let cachedPagingData = this._cachedPagingData;
    let cachedData = this._cachedData;
    if (options2.storeLoadOptions.filter && !options2.remoteOperations.filtering || options2.storeLoadOptions.sort && !options2.remoteOperations.sorting) {
      options2.remoteOperations = {
        filtering: options2.remoteOperations.filtering,
        summary: options2.remoteOperations.summary
      };
    }
    if (operationTypes.fullReload) {
      cachedStoreData = void 0;
      cachedPagingData = void 0;
      cachedData = createEmptyCachedData();
    } else {
      if (operationTypes.reload) {
        cachedPagingData = void 0;
        cachedData = createEmptyCachedData();
      } else if (operationTypes.groupExpanding) {
        cachedData = createEmptyCachedData();
      }
      each(operationTypes, ((operationType, value2) => {
        if (value2 && this._needCleanCacheByOperation(operationType, options2.remoteOperations)) {
          cachedStoreData = void 0;
          cachedPagingData = void 0;
        }
      }));
    }
    if (cachedPagingData) {
      options2.remoteOperations.paging = false;
    }
    options2.cachedStoreData = cachedStoreData;
    options2.cachedPagingData = cachedPagingData;
    options2.cachedData = cachedData;
    if (!options2.isCustomLoading) {
      this._cachedStoreData = cachedStoreData;
      this._cachedPagingData = cachedPagingData;
      this._cachedData = cachedData;
    }
  }
  _handleCustomizeStoreLoadOptions(options2) {
    var _options$data;
    this._handleDataLoading(options2);
    if (!(0 === (null === (_options$data = options2.data) || void 0 === _options$data ? void 0 : _options$data.length))) {
      options2.data = getPageDataFromCache(options2, true) || options2.cachedStoreData;
    }
  }
  _handleDataLoading(options2) {
    const dataSource = this._dataSource;
    const lastLoadOptions = this._lastLoadOptions;
    this.customizeStoreLoadOptions.fire(options2);
    options2.delay = this.option("loadingTimeout");
    options2.originalStoreLoadOptions = options2.storeLoadOptions;
    options2.remoteOperations = extend({}, this.remoteOperations());
    const isFullReload = !this.isLoaded() && !this._isRefreshing;
    if (this.option("integrationOptions.renderedOnServer") && !this.isLoaded()) {
      options2.delay = void 0;
    }
    const loadOptions = extend({
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    }, options2.storeLoadOptions);
    const operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload);
    this._customizeRemoteOperations(options2, operationTypes);
    if (!options2.isCustomLoading) {
      const isRefreshing = this._isRefreshing;
      options2.pageIndex = dataSource.pageIndex();
      options2.lastLoadOptions = loadOptions;
      options2.operationTypes = operationTypes;
      this._loadingOperationTypes = operationTypes;
      this._isRefreshing = true;
      when(isRefreshing || this._isRefreshed || this.refresh(options2, operationTypes)).done((() => {
        if (this._lastOperationId === options2.operationId) {
          this._isRefreshed = true;
          this.load().always((() => {
            this._isRefreshed = false;
          }));
        }
      })).fail((() => {
        dataSource.cancel(options2.operationId);
      })).always((() => {
        this._isRefreshing = false;
      }));
      dataSource.cancel(this._lastOperationId);
      this._lastOperationId = options2.operationId;
      if (this._isRefreshing) {
        dataSource.cancel(this._lastOperationId);
      }
    }
    this._handleDataLoadingCore(options2);
  }
  _handleDataLoadingCore(options2) {
    const {
      remoteOperations
    } = options2;
    options2.loadOptions = {};
    const cachedExtra = options2.cachedData.extra;
    const localLoadOptionNames = {
      filter: !remoteOperations.filtering,
      sort: !remoteOperations.sorting,
      group: !remoteOperations.grouping,
      summary: !remoteOperations.summary,
      skip: !remoteOperations.paging,
      take: !remoteOperations.paging,
      requireTotalCount: cachedExtra && "totalCount" in cachedExtra || !remoteOperations.paging,
      langParams: !remoteOperations.filtering || !remoteOperations.sorting
    };
    each(options2.storeLoadOptions, ((optionName, optionValue) => {
      if (localLoadOptionNames[optionName]) {
        options2.loadOptions[optionName] = optionValue;
        delete options2.storeLoadOptions[optionName];
      }
    }));
    if (cachedExtra) {
      options2.extra = cachedExtra;
    }
  }
  _handleDataLoaded(options2) {
    const {
      loadOptions
    } = options2;
    const localPaging = options2.remoteOperations && !options2.remoteOperations.paging;
    const {
      cachedData
    } = options2;
    const {
      storeLoadOptions
    } = options2;
    const needCache = false !== this.option("cacheEnabled") && storeLoadOptions;
    const needPageCache = needCache && !options2.isCustomLoading && cachedData && (!localPaging || storeLoadOptions.group);
    const needPagingCache = needCache && localPaging;
    const needStoreCache = needPagingCache && !options2.isCustomLoading;
    if (!loadOptions) {
      this._dataSource.cancel(options2.operationId);
      return;
    }
    if (localPaging) {
      options2.skip = loadOptions.skip;
      options2.take = loadOptions.take;
      delete loadOptions.skip;
      delete loadOptions.take;
    }
    if (loadOptions.group) {
      loadOptions.group = options2.group || loadOptions.group;
    }
    const groupCount = m_utils_default.normalizeSortingInfo(options2.group || storeLoadOptions.group || loadOptions.group).length;
    if (options2.cachedDataPartBegin) {
      options2.data = options2.cachedDataPartBegin.concat(options2.data);
    }
    if (options2.cachedDataPartEnd) {
      options2.data = options2.data.concat(options2.cachedDataPartEnd);
    }
    if (!needPageCache || !getPageDataFromCache(options2)) {
      var _options$extra;
      if (needPagingCache && options2.cachedPagingData) {
        options2.data = cloneItems(options2.cachedPagingData, groupCount);
      } else {
        if (needStoreCache) {
          if (!this._cachedStoreData) {
            this._cachedStoreData = cloneItems(options2.data, m_utils_default.normalizeSortingInfo(storeLoadOptions.group).length);
          } else if (options2.mergeStoreLoadData) {
            options2.data = this._cachedStoreData = this._cachedStoreData.concat(options2.data);
          }
        }
        new m_array_store_default(options2.data).load(loadOptions).done(((data17) => {
          options2.data = data17;
          if (needStoreCache) {
            this._cachedPagingData = cloneItems(options2.data, groupCount);
          }
        })).fail(((error) => {
          options2.data = new Deferred().reject(error);
        }));
      }
      if (loadOptions.requireTotalCount && localPaging) {
        options2.extra = isPlainObject(options2.extra) ? options2.extra : {};
        options2.extra.totalCount = options2.data.length;
      }
      if (options2.extra && options2.extra.totalCount >= 0 && (false === storeLoadOptions.requireTotalCount || false === loadOptions.requireTotalCount)) {
        options2.extra.totalCount = -1;
      }
      if (!loadOptions.data && (storeLoadOptions.requireTotalCount || ((null === (_options$extra = options2.extra) || void 0 === _options$extra ? void 0 : _options$extra.totalCount) ?? -1) >= 0)) {
        this._totalCountCorrection = 0;
      }
      this._handleDataLoadedCore(options2);
      if (needPageCache) {
        cachedData.extra = cachedData.extra || extend({}, options2.extra);
        when(options2.data).done(((data17) => {
          setPageDataToCache(options2, data17, groupCount);
        }));
      }
    }
    when(options2.data).done((() => {
      if (options2.lastLoadOptions) {
        this._lastLoadOptions = options2.lastLoadOptions;
        Object.keys(options2.operationTypes).forEach(((operationType) => {
          this._lastOperationTypes[operationType] = this._lastOperationTypes[operationType] || options2.operationTypes[operationType];
        }));
      }
    }));
    options2.storeLoadOptions = options2.originalStoreLoadOptions;
  }
  _handleDataLoadedCore(options2) {
    if (options2.remoteOperations && !options2.remoteOperations.paging && Array.isArray(options2.data)) {
      if (void 0 !== options2.skip) {
        options2.data = options2.data.slice(options2.skip);
      }
      if (void 0 !== options2.take) {
        options2.data = options2.data.slice(0, options2.take);
      }
    }
  }
  _handleLoadingChanged(isLoading) {
    this.loadingChanged.fire(isLoading);
  }
  _handleLoadError(error) {
    this.loadError.fire(error);
    this.changed.fire({
      changeType: "loadError",
      error
    });
  }
  _loadPageSize() {
    return this.pageSize();
  }
  _handleDataChanged(args) {
    let currentTotalCount;
    const dataSource = this._dataSource;
    let isLoading = false;
    const isDataLoading = !args || isDefined(args.changeType);
    const itemsCount = this.itemsCount();
    if (isDataLoading) {
      this._isLastPage = !itemsCount || !this._loadPageSize() || itemsCount < this._loadPageSize();
      if (this._isLastPage) {
        this._hasLastPage = true;
      }
    }
    if (dataSource.totalCount() >= 0) {
      if (dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        this.pageIndex(dataSource.pageIndex());
        this.resetPagesCache();
        dataSource.load();
        isLoading = true;
      }
    } else if (isDataLoading) {
      currentTotalCount = dataSource.pageIndex() * this.pageSize() + itemsCount;
      if (currentTotalCount > this._currentTotalCount) {
        this._currentTotalCount = currentTotalCount;
        if (0 === dataSource.pageIndex() || !this.option("scrolling.legacyMode")) {
          this._totalCountCorrection = 0;
        }
      }
      if (0 === itemsCount && dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        if ("infinite" !== this.option("scrolling.mode")) {
          dataSource.load();
          isLoading = true;
        }
      }
    }
    if (!isLoading) {
      this._operationTypes = this._lastOperationTypes;
      this._lastOperationTypes = {};
      this.component._optionCache = {};
      this.changed.fire(args);
      this.component._optionCache = void 0;
    }
  }
  _scheduleCustomLoadCallbacks(deferred) {
    const that = this;
    that._isCustomLoading = true;
    deferred.always((() => {
      that._isCustomLoading = false;
    }));
  }
  loadingOperationTypes() {
    return this._loadingOperationTypes;
  }
  operationTypes() {
    return this._operationTypes;
  }
  lastLoadOptions() {
    return this._lastLoadOptions || {};
  }
  isLastPage() {
    return this._isLastPage;
  }
  _dataSourceTotalCount() {
    return this._dataSource.totalCount();
  }
  _changeRowExpandCore(path) {
  }
  changeRowExpand(path) {
  }
  totalCount() {
    return parseInt((this._currentTotalCount || this._dataSourceTotalCount()) + this._totalCountCorrection);
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  items() {
  }
  itemsCount() {
    return this._dataSource.items().length;
  }
  totalItemsCount() {
    return this.totalCount();
  }
  pageSize() {
    const dataSource = this._dataSource;
    if (!arguments.length && !dataSource.paginate()) {
      return 0;
    }
    return dataSource.pageSize.apply(dataSource, arguments);
  }
  pageCount() {
    const count = this.totalItemsCount() - this._totalCountCorrection;
    const pageSize = this.pageSize();
    if (pageSize && count > 0) {
      return Math.max(1, Math.ceil(count / pageSize));
    }
    return 1;
  }
  hasKnownLastPage() {
    return this._hasLastPage || this._dataSource.totalCount() >= 0;
  }
  loadFromStore(loadOptions, store) {
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      return;
    }
    store = store || dataSource.store();
    store.load(loadOptions).done(((data17, extra) => {
      if (data17 && !Array.isArray(data17) && Array.isArray(data17.data)) {
        extra = data17;
        data17 = data17.data;
      }
      d.resolve(data17, extra);
    })).fail(d.reject);
    return d;
  }
  isCustomLoading() {
    return !!this._isCustomLoading;
  }
  load(options2) {
    const that = this;
    const dataSource = that._dataSource;
    const d = new Deferred();
    if (options2) {
      const store = dataSource.store();
      const dataSourceLoadOptions = dataSource.loadOptions();
      const loadResult = {
        storeLoadOptions: extend({}, options2, {
          langParams: null === dataSourceLoadOptions || void 0 === dataSourceLoadOptions ? void 0 : dataSourceLoadOptions.langParams
        }),
        isCustomLoading: true
      };
      each(store._customLoadOptions() || [], ((_, optionName) => {
        if (!(optionName in loadResult.storeLoadOptions)) {
          loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName];
        }
      }));
      this._isLoadingAll = options2.isLoadingAll;
      that._scheduleCustomLoadCallbacks(d);
      dataSource._scheduleLoadCallbacks(d);
      that._handleCustomizeStoreLoadOptions(loadResult);
      executeTask((() => {
        if (!dataSource.store()) {
          return d.reject("canceled");
        }
        when(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done(((data17, extra) => {
          loadResult.data = data17;
          loadResult.extra = extra || {};
          that._handleDataLoaded(loadResult);
          if (options2.requireTotalCount && void 0 === loadResult.extra.totalCount) {
            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions);
          }
          when(loadResult.data, loadResult.extra.totalCount).done(((data18, totalCount) => {
            loadResult.extra.totalCount = totalCount;
            d.resolve(data18, loadResult.extra);
          })).fail(d.reject);
        })).fail(d.reject);
      }), that.option("loadingTimeout"));
      return d.fail((function() {
        that._eventsStrategy.fireEvent("loadError", arguments);
      })).always((() => {
        this._isLoadingAll = false;
      })).promise();
    }
    return dataSource.load();
  }
  reload(full) {
    return full ? this._dataSource.reload() : this._dataSource.load();
  }
  getCachedStoreData() {
    return this._cachedStoreData;
  }
  isLoaded() {
  }
  pageIndex(pageIndex) {
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_source_adapter.js
var DataSourceAdapterType = DataSourceAdapter;
var m_data_source_adapter_default = {
  extend(extender) {
    DataSourceAdapterType = extender(DataSourceAdapterType);
  },
  create: (component) => new DataSourceAdapterType(component)
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_controller.js
var DataGridDataController = class extends DataController2 {
  _getDataSourceAdapter() {
    return m_data_source_adapter_default;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (dataSource && !Array.isArray(dataSource) && this.option("keyExpr")) {
      ui_errors_default.log("W1011");
    }
    return super._getSpecificDataSourceOption();
  }
};
m_core_default.registerModule("data", {
  defaultOptions: dataControllerModule.defaultOptions,
  controllers: {
    data: DataGridDataController
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting_mixin.js
var sortingMixin = (Base) => class extends Base {
  _applyColumnState(options2) {
    const that = this;
    let ariaSortState;
    let $sortIndicator;
    const sortingMode = that.option("sorting.mode");
    const {
      rootElement
    } = options2;
    const {
      column
    } = options2;
    const $indicatorsContainer = that._getIndicatorContainer(rootElement);
    if ("sort" === options2.name) {
      rootElement.find(".dx-sort").remove();
      !$indicatorsContainer.children().length && $indicatorsContainer.remove();
      const isSortingAllowed = "none" !== sortingMode && column.allowSorting;
      const hasSeveralSortIndexes = that.getController && !!that.getController("columns").columnOption("sortIndex:1");
      if (!isDefined(column.groupIndex) && (isSortingAllowed || isDefined(column.sortOrder))) {
        ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
        $sortIndicator = super._applyColumnState(options2).toggleClass("dx-sort-up", "asc" === column.sortOrder).toggleClass("dx-sort-down", "desc" === column.sortOrder);
        if (hasSeveralSortIndexes && that.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
          renderer_default("<span>").addClass("dx-sort-index-icon").text(column.sortIndex + 1).appendTo($sortIndicator);
          $sortIndicator.addClass("dx-sort-index");
        }
        if (isSortingAllowed) {
          options2.rootElement.addClass(that.addWidgetPrefix("action"));
        }
      }
      this._setAriaSortAttribute(column, ariaSortState, rootElement, hasSeveralSortIndexes);
      return $sortIndicator;
    }
    return super._applyColumnState(options2);
  }
  _setAriaSortAttribute(column, ariaSortState, $rootElement, hasSeveralSortIndexes) {
    $rootElement.removeAttr("aria-roledescription");
    if (column.isGrouped) {
      let description = this.localize("dxDataGrid-ariaNotSortedColumn");
      if (isDefined(column.sortOrder)) {
        description = "asc" === column.sortOrder ? this.localize("dxDataGrid-ariaSortedAscendingColumn") : this.localize("dxDataGrid-ariaSortedDescendingColumn");
      }
      this.setAria("roledescription", description, $rootElement);
    } else if (!isDefined(column.sortOrder)) {
      this.setAria("sort", "none", $rootElement);
    } else {
      this.setAria("sort", ariaSortState, $rootElement);
      if (hasSeveralSortIndexes && column.sortIndex >= 0) {
        const ariaColumnHeader = message_default.format("dxDataGrid-ariaColumnHeader");
        const ariaSortIndex = message_default.format("dxDataGrid-ariaSortIndex", column.sortIndex + 1);
        const description = `${ariaColumnHeader}, ${ariaSortIndex}`;
        this.setAria("roledescription", description, $rootElement);
      }
    }
  }
  _getIndicatorClassName(name2) {
    if ("sort" === name2) {
      return "dx-sort";
    }
    if ("sortIndex" === name2) {
      return "dx-sort-index-icon";
    }
    return super._getIndicatorClassName(name2);
  }
  _renderIndicator(options2) {
    const {
      column
    } = options2;
    const $container = options2.container;
    const $indicator = options2.indicator;
    if ("sort" === options2.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if (!isDefined(column.sortOrder)) {
        $indicator && $indicator.addClass("dx-sort-none");
      }
      if ($container.children().length && (!rtlEnabled && "left" === options2.columnAlignment || rtlEnabled && "right" === options2.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options2);
  }
  _updateIndicator($cell, column, indicatorName) {
    if ("sort" === indicatorName && isDefined(column.groupIndex)) {
      return;
    }
    return super._updateIndicator.apply(this, arguments);
  }
  _getIndicatorElements($cell, returnAll) {
    const $indicatorElements = super._getIndicatorElements($cell);
    return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not(".dx-sort-none");
  }
};
var m_sorting_mixin_default = sortingMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting.js
var columnHeadersView = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("header" === row.rowType) {
      m_events_engine_default.on($row, addNamespace(CLICK_EVENT_NAME, "dxDataGridColumnHeadersView"), "td", this.createAction(((e) => {
        this._processHeaderAction(e.event, $row);
      })));
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
    if (renderer_default(event.currentTarget).parent().get(0) !== $row.get(0)) {
      return;
    }
    const that = this;
    let keyName = null;
    const $cellElementFromEvent = renderer_default(event.currentTarget);
    const rowIndex = $cellElementFromEvent.parent().index();
    let columnIndex = -1;
    [].slice.call(that.getCellElements(rowIndex)).some((($cellElement, index) => {
      if ($cellElement === $cellElementFromEvent.get(0)) {
        columnIndex = index;
        return true;
      }
      return;
    }));
    const visibleColumns = that._columnsController.getVisibleColumns(rowIndex);
    const column = visibleColumns[columnIndex];
    const editingController = that.getController("editing");
    const editingMode = that.option("editing.mode");
    const isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
    if (isCellEditing || !that._isSortableElement(renderer_default(event.target))) {
      return;
    }
    if (column && !isDefined(column.groupIndex) && !column.command) {
      if (event.shiftKey) {
        keyName = "shift";
      } else if (isCommandKeyPressed(event)) {
        keyName = "ctrl";
      }
      setTimeout((() => {
        that._columnsController.changeSortOrder(column.index, keyName);
      }));
    }
  }
  _renderCellContent($cell, options2) {
    const that = this;
    const {
      column
    } = options2;
    if (!column.command && "header" === options2.rowType) {
      that._applyColumnState({
        name: "sort",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
    }
    super._renderCellContent.apply(this, arguments);
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    if (1 === changeTypes.length && changeTypes.sorting) {
      this._updateIndicators("sort");
      return;
    }
    super._columnOptionChanged(e);
  }
};
var headerPanel = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem(...arguments);
    m_events_engine_default.on($item, addNamespace(CLICK_EVENT_NAME, "dxDataGridHeaderPanel"), that.createAction((() => {
      that._processGroupItemAction(groupColumn.index);
    })));
    that._applyColumnState({
      name: "sort",
      rootElement: $item,
      column: {
        alignment: that.option("rtlEnabled") ? "right" : "left",
        allowSorting: groupColumn.allowSorting,
        sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc",
        isGrouped: true
      },
      showColumnLines: true
    });
    return $item;
  }
  _processGroupItemAction(groupColumnIndex) {
    setTimeout((() => this.getController("columns").changeSortOrder(groupColumnIndex)));
  }
};
var sortingModule = {
  defaultOptions: () => ({
    sorting: {
      mode: "single",
      ascendingText: message_default.format("dxDataGrid-sortingAscendingText"),
      descendingText: message_default.format("dxDataGrid-sortingDescendingText"),
      clearText: message_default.format("dxDataGrid-sortingClearText"),
      showSortIndexes: true
    }
  }),
  extenders: {
    views: {
      columnHeadersView,
      headerPanel
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sorting.js
m_core_default.registerModule("sorting", sortingModule);

// node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.scroll.js
var {
  abstract
} = class_default;
var realDevice = m_devices_default.real();
var Locker = class_default.inherit((function() {
  const NAMESPACED_SCROLL_EVENT = addNamespace("scroll", "dxScrollEmitter");
  return {
    ctor(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = (e) => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      m_events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract,
    check(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose() {
      this._disposed = true;
      m_events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
})());
var TimeoutLocker = Locker.inherit({
  ctor(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll() {
    this._prepare();
    this._forget();
  },
  _prepare() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget() {
    const that = this;
    this._timer = setTimeout((() => {
      that._clearTimer();
    }), this._timeout);
  },
  dispose() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    const direction = e.shiftKey || false;
    const directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
  }
});
!(function() {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll() {
      this._locked = true;
      const that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame((() => {
        that._locked = false;
      }));
    },
    check(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      const that = this;
      const {
        callBase
      } = this;
      this._checkFrame = requestAnimationFrame((() => {
        callBase.call(that, e, callback);
        that._locked = false;
      }));
    },
    dispose() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
})();
var ScrollEmitter = m_emitter_gesture_default.inherit((function() {
  const FRAME_DURATION2 = Math.round(1e3 / 60);
  return {
    ctor(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: () => true,
    configure(data17) {
      if (data17.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data17.scrollTarget);
        this._wheelLocker = new WheelLocker(data17.scrollTarget);
      }
      this.callBase(data17);
    },
    _init(e) {
      this._wheelLocker.check(e, (() => {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      }));
      this._pointerLocker.check(e, (() => {
        const skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      }));
      this._fireEvent("dxscrollinit", e);
      this._prevEventData = eventData(e);
    },
    move(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start(e) {
      this._savedEventData = eventData(e);
      this._fireEvent("dxscrollstart", e);
      this._prevEventData = eventData(e);
    },
    _move(e) {
      const currentEventData = eventData(e);
      this._fireEvent("dxscroll", e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      const delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end(e) {
      const endEventDelta = eventDelta(this._prevEventData, eventData(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        const delta = eventDelta(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION2 / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity
      });
    },
    _stop(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent("dxscrollcancel", e);
    },
    dispose() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
})());
m_emitter_registrator_default({
  emitter: ScrollEmitter,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
var m_emitter_gesture_scroll_default = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/consts.js
var DIRECTION_VERTICAL = "vertical";
var DIRECTION_HORIZONTAL = "horizontal";
var DIRECTION_BOTH = "both";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_relative_offset.js
function getRelativeOffset(targetElementClass, sourceElement) {
  const offset = {
    left: 0,
    top: 0
  };
  let element = sourceElement;
  while (null !== (_element = element) && void 0 !== _element && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    const parentElement = element.offsetParent;
    const elementRect = element.getBoundingClientRect();
    const parentElementRect = parentElement.getBoundingClientRect();
    offset.left += elementRect.left - parentElementRect.left;
    offset.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_element_location_internal.js
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset) {
  let scrollableContentClass = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : SCROLLABLE_CONTENT_CLASS;
  const additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset);
  const isVertical = direction === DIRECTION_VERTICAL;
  const prop = isVertical ? "top" : "left";
  const inverseProp = isVertical ? "bottom" : "right";
  const dimension = isVertical ? "height" : "width";
  const containerOffsetSize = containerElement[`offset${titleize(dimension)}`];
  const containerClientSize = containerElement[`client${titleize(dimension)}`];
  const containerSize = containerElement.getBoundingClientRect()[dimension];
  const elementSize = targetElement.getBoundingClientRect()[dimension];
  let scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  const relativeElementOffset = getRelativeOffset(scrollableContentClass, targetElement)[prop] / scale;
  const containerScrollOffset = scrollOffset[prop];
  const relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  const relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.device.js
var deviceDependentOptions = function() {
  return [{
    device: () => !m_support_default.nativeScrolling,
    options: {
      useNative: false
    }
  }, {
    device: (device) => !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: m_support_default.touch,
      showScrollbar: "onHover"
    }
  }];
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollbar.js
var SCROLLBAR = "dxScrollbar";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL = "horizontal";
var SCROLLBAR_VISIBLE = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
var activeScrollbar = null;
var Scrollbar = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  }
  _init() {
    super._init();
    this._isHovered = false;
  }
  _initMarkup() {
    this._renderThumb();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option("hoverStateEnabled", this._isHoverMode());
    const {
      hoverStateEnabled
    } = this.option();
    this.$element().toggleClass(HOVER_ENABLED_STATE, hoverStateEnabled);
  }
  _renderThumb() {
    this._$thumb = renderer_default("<div>").addClass("dx-scrollable-scroll");
    renderer_default("<div>").addClass("dx-scrollable-scroll-content").appendTo(this._$thumb);
    this.$element().addClass("dx-scrollable-scrollbar").append(this._$thumb);
  }
  isThumb($element) {
    return !!this.$element().find($element).length;
  }
  _isHoverMode() {
    const {
      visibilityMode,
      expandable
    } = this.option();
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && expandable;
  }
  _renderDirection() {
    const {
      direction
    } = this.option();
    this.$element().addClass(`dx-scrollbar-${direction}`);
    this._dimension = direction === HORIZONTAL ? "width" : "height";
    this._prop = direction === HORIZONTAL ? "left" : "top";
  }
  _attachPointerDownHandler() {
    m_events_engine_default.on(this._$thumb, addNamespace(m_pointer_default.down, SCROLLBAR), this.feedbackOn.bind(this));
  }
  feedbackOn(e) {
    null === e || void 0 === e || e.preventDefault();
    this.$element().addClass("dx-scrollable-scrollbar-active");
    activeScrollbar = this;
  }
  feedbackOff() {
    this.$element().removeClass("dx-scrollable-scrollbar-active");
    activeScrollbar = null;
  }
  cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option("visible", true);
    }
  }
  cursorLeave() {
    this._isHovered = false;
    this.option("visible", false);
  }
  _renderDimensions() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  }
  _toggleVisibility(visible) {
    const {
      visibilityMode
    } = this.option();
    if (visibilityMode === SCROLLBAR_VISIBLE.onScroll) {
      this._$thumb.css("opacity");
    }
    visible = this._adjustVisibility(visible);
    this.option().visible = visible;
    this._$thumb.toggleClass("dx-state-invisible", !visible);
  }
  _adjustVisibility(visible) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    const {
      visibilityMode
    } = this.option();
    switch (visibilityMode) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible = visible || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible = true;
    }
    return visible;
  }
  moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if (isPlainObject(location)) {
      location = location[this._prop] || 0;
    }
    const scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    move(this._$thumb, scrollBarLocation);
  }
  _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  }
  _update() {
    const containerSize = Math.round(this.option("containerSize"));
    const contentSize = Math.round(this.option("contentSize"));
    let baseContainerSize = Math.round(this.option("baseContainerSize"));
    let baseContentSize = Math.round(this.option("baseContentSize"));
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    const {
      scaleRatio
    } = this.option();
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    const thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), 15));
    this._thumbRatio = (containerSize - thumbSize) / (scaleRatio * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / scaleRatio);
    this.$element().css("display", this._needScrollbar() ? "" : "none");
  }
  _isHidden() {
    const {
      visibilityMode
    } = this.option();
    return visibilityMode === SCROLLBAR_VISIBLE.never;
  }
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  }
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  }
  _normalizeSize(size) {
    return isPlainObject(size) ? size[this._dimension] || 0 : size;
  }
  _clean() {
    super._clean();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    m_events_engine_default.off(this._$thumb, `.${SCROLLBAR}`);
  }
  _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case "containerSize":
      case "contentSize":
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case "baseContentSize":
      case "baseContainerSize":
      case "scaleRatio":
        this._update();
        break;
      case "visibilityMode":
      case "direction":
        this._invalidate();
        break;
      default:
        super._optionChanged.apply(this, arguments);
    }
  }
  update() {
    deferRenderer((() => {
      this._adjustVisibility() && this.option("visible", true);
    }))();
  }
};
ready_callbacks_default.add((() => {
  m_events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.up, SCROLLBAR), (() => {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  }));
}));
var m_scrollbar_default = Scrollbar;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.native.js
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL = "vertical";
var HORIZONTAL2 = "horizontal";
var NativeStrategy = class extends class_default.inherit({}) {
  ctor(scrollable) {
    this._init(scrollable);
  }
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$content = scrollable.$content();
    const {
      direction,
      useSimulatedScrollbar
    } = scrollable.option();
    this._direction = direction;
    this._useSimulatedScrollbar = useSimulatedScrollbar;
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  }
  render() {
    const device = devices_default.real();
    const deviceType = device.platform;
    this._$element.addClass("dx-scrollable-native").addClass(`dx-scrollable-native-${deviceType}`).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  }
  updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option("rtlEnabled")) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  }
  _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL2);
  }
  _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$element), {
      direction,
      expandable: this._component.option("scrollByThumb")
    });
  }
  handleInit(e) {
  }
  handleStart() {
  }
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  }
  handleEnd() {
  }
  handleCancel() {
  }
  handleStop() {
  }
  _eachScrollbar(callback) {
    callback = callback.bind(this);
    each(this._scrollbars || {}, ((direction, scrollbar) => {
      callback(scrollbar, direction);
    }));
  }
  createActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._updateAction = this._createActionByOption("onUpdated");
  }
  _createActionArgs() {
    const {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : void 0,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : void 0
    };
  }
  _getScrollOffset() {
    const {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  }
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  }
  _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(left) >= 0 : void 0;
  }
  _isReachedRight(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : void 0;
  }
  _isScrollbarVisible() {
    const {
      showScrollbar
    } = this.option();
    return "never" !== showScrollbar && false !== showScrollbar;
  }
  handleScroll(e) {
    var _this$_scrollAction;
    this._eventForUserAction = e;
    this._moveScrollbars();
    null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this, this._createActionArgs());
  }
  _moveScrollbars() {
    const {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar(((scrollbar) => {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option("visible", true);
    }));
    this._hideScrollbars();
  }
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout((() => {
      this._eachScrollbar(((scrollbar) => {
        scrollbar.option("visible", false);
      }));
    }), 500);
  }
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  }
  disabledChanged() {
  }
  update() {
    this._update();
    this._updateAction(this._createActionArgs());
  }
  _update() {
    this._updateDimensions();
    this._updateScrollbars();
  }
  _updateDimensions() {
    this._containerSize = {
      height: getHeight(this._$container),
      width: getWidth(this._$container)
    };
    this._componentContentSize = {
      height: getHeight(this._component.$content()),
      width: getWidth(this._component.$content())
    };
    this._contentSize = {
      height: getHeight(this._$content),
      width: getWidth(this._$content)
    };
  }
  _updateScrollbars() {
    this._eachScrollbar((function(scrollbar, direction) {
      const dimension = direction === VERTICAL ? "height" : "width";
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    }));
  }
  _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL2) && this._contentSize.width > this._containerSize.width
    };
  }
  dispose() {
    const {
      className
    } = this._$element.get(0);
    const scrollableNativeRegexp = new RegExp("dx-scrollable-native\\S*", "g");
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
    }
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_NATIVE}`);
    m_events_engine_default.off(this._$container, `.${SCROLLABLE_NATIVE}`);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  }
  _removeScrollbars() {
    this._eachScrollbar(((scrollbar) => {
      scrollbar.$element().remove();
    }));
  }
  scrollBy(distance) {
    const location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  }
  validate(e) {
    const {
      disabled
    } = this.option();
    if (disabled) {
      return false;
    }
    if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  }
  _isScrolledInMaxDirection(e) {
    const container = this._$container.get(0);
    let result2;
    if (e.delta > 0) {
      result2 = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result2 = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result2 = container.scrollTop >= this._getMaxOffset().top;
    }
    return result2;
  }
  getDirection() {
    return this._allowedDirection();
  }
};
var m_scrollable_native_default = NativeStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_animator.js
var Animator = class extends class_default.inherit({}) {
  ctor(strategy) {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  }
  start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  }
  stop() {
    this._stopped = true;
    cancelAnimationFrame(this._stepAnimationFrame);
  }
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
  }
  _step() {
    class_default.abstract();
  }
  _isFinished() {
  }
  _stop() {
  }
  _complete() {
  }
  _isStopped() {
    return this._stopped;
  }
  inProgress() {
    return !(this._stopped || this._finished);
  }
};
var m_animator_default = Animator;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.simulated.js
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = `${SCROLLABLE_SIMULATED}Cursor`;
var SCROLLABLE_SIMULATED_KEYBOARD = `${SCROLLABLE_SIMULATED}Keyboard`;
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var VERTICAL2 = "vertical";
var HORIZONTAL3 = "horizontal";
var FRAME_DURATION = Math.round(1e3 / 60);
var BOUNCE_FRAMES = 400 / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - 0.92 ** BOUNCE_FRAMES) / (1 - 0.92);
var KEY_CODES = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
var InertiaAnimator = class extends m_animator_default {
  constructor() {
    super(...arguments);
    this.VELOCITY_LIMIT = 1;
  }
  ctor(scroller) {
    super.ctor();
    this.scroller = scroller;
  }
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  }
  _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  }
  _acceleration() {
    return this.scroller._inBounds() ? 0.92 : 0.5;
  }
  _complete() {
    this.scroller._scrollComplete();
  }
};
var BounceAnimator = class extends InertiaAnimator {
  constructor() {
    super(...arguments);
    this.VELOCITY_LIMIT = 0.2;
  }
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || super._isFinished();
  }
  _acceleration() {
    return 0.92;
  }
  _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    super._complete();
  }
};
var Scroller = class extends class_default.inherit({}) {
  ctor(options2) {
    this._initOptions(options2);
    this._initAnimators();
    this._initScrollbar();
  }
  _initOptions(options2) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options2.direction === HORIZONTAL3 ? "x" : "y";
    this._prop = options2.direction === HORIZONTAL3 ? "left" : "top";
    this._dimension = options2.direction === HORIZONTAL3 ? "width" : "height";
    this._scrollProp = options2.direction === HORIZONTAL3 ? "scrollLeft" : "scrollTop";
    each(options2, ((optionName, optionValue) => {
      this[`_${optionName}`] = optionValue;
    }));
  }
  _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  }
  _initScrollbar() {
    this._scrollbar = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  }
  _visibilityModeNormalize(mode) {
    return true === mode ? "onScroll" : false === mode ? "never" : mode;
  }
  _scrollStep(delta) {
    const prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    m_events_engine_default.triggerHandler(this._$container, {
      type: "scroll"
    });
  }
  _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  }
  _boundLocation(location) {
    location = void 0 !== location ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  }
  _move(location) {
    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  }
  _moveContent() {
    const location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  }
  _getScaleRatio() {
    if (hasWindow() && !this._scaleRatio) {
      const element = this._$element.get(0);
      const realDimension = this._getRealDimension(element, this._dimension);
      const baseDimension = this._getBaseDimension(element, this._dimension);
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  }
  _getRealDimension(element, dimension) {
    return Math.round(getBoundingRect(element)[dimension]);
  }
  _getBaseDimension(element, dimension) {
    const dimensionName = `offset${titleize(dimension)}`;
    return element[dimensionName];
  }
  _moveContentByTranslator(location) {
    let translateOffset;
    const minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    }
    if (location <= minOffset) {
      translateOffset = location - minOffset;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    const targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (!translateOffset) {
      resetPosition(this._$content);
      return;
    }
    move(this._$content, targetLocation);
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  }
  _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  }
  _scrollToBounds() {
    var _this$_bounceAction;
    if (this._inBounds()) {
      return;
    }
    null === (_this$_bounceAction = this._bounceAction) || void 0 === _this$_bounceAction || _this$_bounceAction.call(this);
    this._setupBounce();
    this._bounceAnimator.start();
  }
  _setupBounce() {
    const boundLocation = this._bounceLocation = this._boundLocation();
    const bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  }
  _inBounds(location) {
    location = void 0 !== location ? location : this._location;
    return this._boundLocation(location) === location;
  }
  _crossBoundOnNextStep() {
    const location = this._location;
    const nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  }
  _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  }
  _stopScrolling() {
    deferRenderer((() => {
      this._hideScrollbar();
      this._inertiaAnimator.stop();
      this._bounceAnimator.stop();
    }))();
  }
  _prepareThumbScrolling(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      return;
    }
    const $target = renderer_default(e.originalEvent.target);
    const scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  }
  _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  }
  _moveToMouseLocation(e) {
    const mouseLocation = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop];
    const location = this._location + mouseLocation / this._containerToContentRatio() - getHeight(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  }
  _startHandler() {
    this._showScrollbar();
  }
  _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  }
  _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= 0.5;
    }
    this._scrollStep(delta);
  }
  _scrollByHandler(delta) {
    if (!delta.x && !delta.y) {
      return;
    }
    this._scrollBy(delta);
    this._scrollComplete();
  }
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  }
  _endHandler(velocity) {
    this._completeDeferred = Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  }
  _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  }
  _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  }
  _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  }
  _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  }
  _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  }
  _updateHandler() {
    this._update();
    this._moveToBounds();
  }
  _update() {
    this._stopScrolling();
    return deferUpdate((() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      deferRender((() => {
        this._moveScrollbar();
        this._scrollbar.update();
      }));
    }));
  }
  _resetScaleRatio() {
    this._scaleRatio = null;
  }
  _updateLocation() {
    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  }
  _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  }
  _getMaxOffset() {
    return 0;
  }
  _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  }
  _updateScrollbar() {
    deferUpdater((() => {
      const containerSize = this._containerSize();
      const contentSize = this._contentSize();
      const baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
      const baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
      deferRender((() => {
        this._scrollbar.option({
          containerSize,
          contentSize,
          baseContainerSize,
          baseContentSize,
          scaleRatio: this._getScaleRatio()
        });
      }));
    }))();
  }
  _moveToBounds() {
    deferRenderer(deferUpdater(deferRenderer((() => {
      const location = this._boundLocation();
      const locationChanged = location !== this._location;
      this._location = location;
      this._move();
      if (locationChanged) {
        var _this$_scrollAction;
        null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this);
      }
    }))))();
  }
  _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  }
  _showScrollbar() {
    this._scrollbar.option("visible", true);
  }
  _hideScrollbar() {
    this._scrollbar.option("visible", false);
  }
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  }
  _contentSize() {
    const isOverflowHidden = "hidden" === this._$content.css(`overflow${this._axis.toUpperCase()}`);
    let contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      const containerScrollSize = this._$content[0][`scroll${titleize(this._dimension)}`] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  }
  _validateEvent(e) {
    const $target = renderer_default(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  }
  _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  }
  _isScrollbar($element) {
    return this._scrollByThumb && (null === $element || void 0 === $element ? void 0 : $element.is(this._$scrollbar));
  }
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  }
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  }
  _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  }
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  }
  dispose() {
  }
};
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = class extends class_default.inherit({}) {
  ctor(scrollable) {
    this._init(scrollable);
  }
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  }
  render() {
    this._$element.addClass("dx-scrollable-simulated");
    this._createScrollers();
    if (this.option("useKeyboard")) {
      this._$container.prop("tabIndex", 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  }
  _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL3)) {
      this._createScroller(HORIZONTAL3);
    }
    if (this._isDirection(VERTICAL2)) {
      this._createScroller(VERTICAL2);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
  }
  _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  }
  _scrollerOptions(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  }
  _applyScaleRatio(targetLocation) {
    for (const direction in this._scrollers) {
      const prop = this._getPropByDirection(direction);
      if (isDefined(targetLocation[prop])) {
        const scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  }
  _isAnyThumbScrolling($target) {
    let result2 = false;
    this._eventHandler("isThumbScrolling", $target).done(((isThumbScrollingVertical, isThumbScrollingHorizontal) => {
      result2 = isThumbScrollingVertical || isThumbScrollingHorizontal;
    }));
    return result2;
  }
  handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler("init", e);
  }
  _suppressDirections(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller((function(scroller, direction) {
      const $target = renderer_default(e.originalEvent.target);
      const isValid = scroller._validateEvent(e) || this.option("scrollByContent") && this._isContent($target);
      this._validDirections[direction] = isValid;
    }));
  }
  _isContent($element) {
    return !!$element.closest(this._$element).length;
  }
  _prepareDirections(value2) {
    value2 = value2 || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL3] = value2;
    this._validDirections[VERTICAL2] = value2;
  }
  _eachScroller(callback) {
    callback = callback.bind(this);
    each(this._scrollers, ((direction, scroller) => {
      callback(scroller, direction);
    }));
  }
  handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler("start").done(this._startAction);
  }
  _saveActive() {
    activeScrollable = this;
  }
  _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  }
  handleMove(e) {
    var _e$preventDefault;
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    null === (_e$preventDefault = e.preventDefault) || void 0 === _e$preventDefault || _e$preventDefault.call(e);
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler("move", e.delta);
  }
  _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL3];
    distance.y *= this._validDirections[VERTICAL2];
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  }
  _tryGetDevicePixelRatio() {
    if (hasWindow()) {
      return getWindow().devicePixelRatio;
    }
  }
  handleEnd(e) {
    var _e$originalEvent;
    this._resetActive();
    this._refreshCursorState(null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler("end", e.velocity).done(this._endAction);
  }
  handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler("end", {
      x: 0,
      y: 0
    });
  }
  handleStop() {
    this._resetActive();
    this._eventHandler("stop");
  }
  handleScroll() {
    var _this$_scrollAction2;
    this._updateRtlConfig();
    null === (_this$_scrollAction2 = this._scrollAction) || void 0 === _this$_scrollAction2 || _this$_scrollAction2.call(this);
  }
  _attachKeyboardHandler() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
    if (!this.option("disabled") && this.option("useKeyboard")) {
      m_events_engine_default.on(this._$element, addNamespace("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  }
  _keyDownHandler(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout((() => {
      if (normalizeKeyName(e) === KEY_CODES.TAB) {
        this._eachScroller(((scroller) => {
          scroller._updateHandler();
        }));
      }
    }));
    if (!this._$container.is(dom_adapter_default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    let handled = true;
    switch (normalizeKeyName(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  _scrollByLine(lines) {
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    let scrollOffset = 40;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  }
  _scrollByPage(page) {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  }
  _dimensionByProp(prop) {
    return "left" === prop ? "width" : "height";
  }
  _getPropByDirection(direction) {
    return direction === HORIZONTAL3 ? "left" : "top";
  }
  _scrollToHome() {
    const prop = this._wheelProp();
    const distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  }
  _scrollToEnd() {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  }
  createActions() {
    this._startAction = this._createActionHandler("onStart");
    this._endAction = this._createActionHandler("onEnd");
    this._updateAction = this._createActionHandler("onUpdated");
    this._createScrollerActions();
  }
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler("onScroll");
    this._bounceAction = this._createActionHandler("onBounce");
    this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  }
  _createActionHandler(optionName) {
    const actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler(extend(this._createActionArgs(), arguments));
    };
  }
  _createActionArgs() {
    const {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    const offset = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset.top,
      left: scrollerX && offset.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: null === scrollerX || void 0 === scrollerX ? void 0 : scrollerX._reachedMax(),
      reachedRight: null === scrollerX || void 0 === scrollerX ? void 0 : scrollerX._reachedMin(),
      reachedTop: null === scrollerY || void 0 === scrollerY ? void 0 : scrollerY._reachedMax(),
      reachedBottom: null === scrollerY || void 0 === scrollerY ? void 0 : scrollerY._reachedMin()
    };
  }
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  }
  _eventHandler(eventName, location) {
    const args = [].slice.call(arguments).slice(1);
    const deferreds = map(this._scrollers, ((scroller) => scroller[`_${eventName}Handler`].apply(scroller, args)));
    return when.apply(renderer_default, deferreds).promise();
  }
  location() {
    const location = locate(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  }
  disabledChanged() {
    this._attachCursorHandlers();
  }
  _attachCursorHandlers() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    if (!this.option("disabled") && this._isHoverMode()) {
      m_events_engine_default.on(this._$element, addNamespace("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      m_events_engine_default.on(this._$element, addNamespace("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  }
  _isHoverMode() {
    return "onHover" === this.option("showScrollbar");
  }
  _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler("cursorEnter");
    e.originalEvent._hoverHandled = true;
  }
  _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler("cursorLeave");
    hoveredScrollable = null;
    this._refreshCursorState(null === e || void 0 === e ? void 0 : e.relatedTarget);
  }
  _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    const $target = renderer_default(target);
    const $scrollable = $target.closest(".dx-scrollable-simulated:not(.dx-state-disabled)");
    const targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  }
  update() {
    const result2 = this._eventHandler("update").done(this._updateAction);
    return when(result2, deferUpdate((() => {
      const allowedDirections = this._allowedDirections();
      deferRender((() => {
        let touchDirection = allowedDirections.vertical ? "pan-x" : "";
        touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
        this._$container.css("touchAction", touchDirection);
      }));
      return when().promise();
    })));
  }
  _allowedDirections() {
    const bounceEnabled = this.option("bounceEnabled");
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  }
  _updateBounds() {
    var _this$_scrollers$HORI;
    null === (_this$_scrollers$HORI = this._scrollers[HORIZONTAL3]) || void 0 === _this$_scrollers$HORI || _this$_scrollers$HORI._updateBounds();
  }
  _isHorizontalAndRtlEnabled() {
    return this.option("rtlEnabled") && this.option("direction") !== VERTICAL2;
  }
  updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      let scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  }
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      const windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  }
  _getWindowDevicePixelRatio() {
    return hasWindow() ? getWindow().devicePixelRatio : 1;
  }
  scrollBy(distance) {
    var _this$_startAction, _this$_endAction;
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    null === (_this$_startAction = this._startAction) || void 0 === _this$_startAction || _this$_startAction.call(this);
    this._eventHandler("scrollBy", {
      x: distance.left,
      y: distance.top
    });
    null === (_this$_endAction = this._endAction) || void 0 === _this$_endAction || _this$_endAction.call(this);
    this._updateRtlConfig();
  }
  validate(e) {
    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
      return false;
    }
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("bounceEnabled")) {
      return true;
    }
    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
  }
  _validateWheel(e) {
    const scroller = this._scrollers[this._wheelDirection(e)];
    const reachedMin = scroller._reachedMin();
    const reachedMax = scroller._reachedMax();
    const contentGreaterThanContainer = !reachedMin || !reachedMax;
    const locatedNotAtBound = !reachedMin && !reachedMax;
    const scrollFromMin = reachedMin && e.delta > 0;
    const scrollFromMax = reachedMax && e.delta < 0;
    let validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || void 0 !== this._validateWheelTimer;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout((() => {
        this._validateWheelTimer = void 0;
      }), 500);
    }
    return validated;
  }
  _validateMove(e) {
    if (!this.option("scrollByContent") && !renderer_default(e.target).closest(".dx-scrollable-scrollbar").length) {
      return false;
    }
    return this._allowedDirection();
  }
  getDirection(e) {
    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
  }
  _wheelProp() {
    return this._wheelDirection() === HORIZONTAL3 ? "left" : "top";
  }
  _wheelDirection(e) {
    switch (this.option("direction")) {
      case HORIZONTAL3:
        return HORIZONTAL3;
      case VERTICAL2:
        return VERTICAL2;
      default:
        return null !== e && void 0 !== e && e.shiftKey ? HORIZONTAL3 : VERTICAL2;
    }
  }
  dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler("dispose");
    this._detachEventHandlers();
    this._$element.removeClass("dx-scrollable-simulated");
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    m_events_engine_default.off(this._$container, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
  }
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.js
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY2 = "dxScrollableStrategy";
var VERTICAL3 = "vertical";
var HORIZONTAL4 = "horizontal";
var BOTH = "both";
var Scrollable = class _Scrollable extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL3,
      showScrollbar: "onScroll",
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false,
      _onVisibilityChanged: noop
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat(deviceDependentOptions(), [{
      device: () => m_support_default.nativeScrolling && "android" === devices_default.real().platform && !browser_default.mozilla,
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  }
  _initOptions(options2) {
    super._initOptions(options2);
    if (!("useSimulatedScrollbar" in options2)) {
      this._setUseSimulatedScrollbar();
    }
  }
  _setUseSimulatedScrollbar() {
    if (!this.initialOption("useSimulatedScrollbar")) {
      this.option("useSimulatedScrollbar", !this.option("useNative"));
    }
  }
  _init() {
    super._init();
    this._initScrollableMarkup();
    this._locked = false;
  }
  _visibilityChanged(visible) {
    if (visible) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
      const {
        _onVisibilityChanged: onVisibilityChanged
      } = this.option();
      null === onVisibilityChanged || void 0 === onVisibilityChanged || onVisibilityChanged(this);
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  }
  _initScrollableMarkup() {
    const $element = this.$element().addClass("dx-scrollable");
    const $container = renderer_default("<div>").addClass("dx-scrollable-container");
    const $wrapper = renderer_default("<div>").addClass("dx-scrollable-wrapper");
    const $content = renderer_default("<div>").addClass("dx-scrollable-content");
    this._$container = $container;
    this._$wrapper = $wrapper;
    this._$content = $content;
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  }
  _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  }
  _initMarkup() {
    super._initMarkup();
    this._renderDirection();
  }
  _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    super._render();
    this._updateRtlPosition(true);
  }
  _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  }
  _getMaxOffset() {
    const {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = renderer_default(this.container()).get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  }
  _attachEventHandlers() {
    const strategy = this._strategy;
    const initEventData = {
      getDirection: strategy.getDirection.bind(strategy),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    m_events_engine_default.off(this._$wrapper, `.${SCROLLABLE}`);
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.start, SCROLLABLE), strategy.handleStart.bind(strategy));
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.move, SCROLLABLE), strategy.handleMove.bind(strategy));
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.end, SCROLLABLE), strategy.handleEnd.bind(strategy));
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));
    m_events_engine_default.on(this._$wrapper, addNamespace(m_emitter_gesture_scroll_default.stop, SCROLLABLE), strategy.handleStop.bind(strategy));
    m_events_engine_default.off(this._$container, `.${SCROLLABLE}`);
    m_events_engine_default.on(this._$container, addNamespace("scroll", SCROLLABLE), strategy.handleScroll.bind(strategy));
  }
  _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  }
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  }
  handleMove(e) {
    this._strategy.handleMove(e);
  }
  _prepareDirections(value2) {
    this._strategy._prepareDirections(value2);
  }
  _initHandler() {
    const strategy = this._strategy;
    strategy.handleInit.apply(strategy, arguments);
  }
  _renderDisabledState() {
    const {
      disabled
    } = this.option();
    this.$element().toggleClass("dx-scrollable-disabled", disabled);
    if (this.option("disabled")) {
      this._lock();
    } else {
      this._unlock();
    }
  }
  _renderDirection() {
    const {
      direction
    } = this.option();
    this.$element().removeClass(`dx-scrollable-${HORIZONTAL4}`).removeClass(`dx-scrollable-${VERTICAL3}`).removeClass(`dx-scrollable-${BOTH}`).addClass(`dx-scrollable-${direction}`);
  }
  _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY2, this._strategy);
  }
  _createStrategy() {
    this._strategy = this.option("useNative") ? new m_scrollable_native_default(this) : new SimulatedStrategy(this);
  }
  _createActions() {
    var _this$_strategy;
    null === (_this$_strategy = this._strategy) || void 0 === _this$_strategy || _this$_strategy.createActions();
  }
  _clean() {
    var _this$_strategy2;
    null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 || _this$_strategy2.dispose();
  }
  _optionChanged(args) {
    var _this$_strategy3;
    switch (args.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState();
        null === (_this$_strategy3 = this._strategy) || void 0 === _this$_strategy3 || _this$_strategy3.disabledChanged();
        break;
      case "updateManually":
      case "scrollByContent":
      case "_onVisibilityChanged":
        break;
      case "width":
        super._optionChanged(args);
        this._updateRtlPosition();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _resetInactiveDirection() {
    const inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !hasWindow()) {
      return;
    }
    const scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  }
  _getInactiveProp() {
    const {
      direction
    } = this.option();
    if (direction === VERTICAL3) {
      return "left";
    }
    if (direction === HORIZONTAL4) {
      return "top";
    }
  }
  _location() {
    return this._strategy.location();
  }
  _normalizeLocation(location) {
    if (isPlainObject(location)) {
      const left = ensureDefined(location.left, location.x);
      const top = ensureDefined(location.top, location.y);
      return {
        left: isDefined(left) ? -left : void 0,
        top: isDefined(top) ? -top : void 0
      };
    }
    const {
      direction
    } = this.option();
    return {
      left: direction !== VERTICAL3 ? -location : void 0,
      top: direction !== HORIZONTAL4 ? -location : void 0
    };
  }
  _isLocked() {
    return this._locked;
  }
  _lock() {
    this._locked = true;
  }
  _unlock() {
    if (!this.option("disabled")) {
      this._locked = false;
    }
  }
  _isDirection(direction) {
    const {
      direction: current2
    } = this.option();
    if (direction === VERTICAL3) {
      return current2 !== HORIZONTAL4;
    }
    if (direction === HORIZONTAL4) {
      return current2 !== VERTICAL3;
    }
    return current2 === direction;
  }
  _updateAllowedDirection() {
    const allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL4) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL4;
    } else if (this._isDirection(VERTICAL3) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL3;
    } else {
      this._allowedDirectionValue = null;
    }
  }
  _allowedDirection() {
    return this._allowedDirectionValue;
  }
  $content() {
    return this._$content;
  }
  content() {
    return getPublicElement(this._$content);
  }
  container() {
    return getPublicElement(this._$container);
  }
  scrollOffset() {
    return this._strategy._getScrollOffset();
  }
  _isRtlNativeStrategy() {
    const {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  }
  scrollTop() {
    return this.scrollOffset().top;
  }
  scrollLeft() {
    return this.scrollOffset().left;
  }
  clientHeight() {
    return getHeight(this._$container);
  }
  scrollHeight() {
    return getOuterHeight(this.$content());
  }
  clientWidth() {
    return getWidth(this._$container);
  }
  scrollWidth() {
    return getOuterWidth(this.$content());
  }
  update() {
    if (!this._strategy) {
      return;
    }
    return when(this._strategy.update()).done((() => {
      this._updateAllowedDirection();
    }));
  }
  scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  }
  scrollTo(targetLocation) {
    if (!hasWindow()) {
      return;
    }
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    let location = this._location();
    const {
      useNative
    } = this.option();
    if (!useNative) {
      const strategy = this._strategy;
      targetLocation = strategy._applyScaleRatio(targetLocation);
      location = strategy._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left -= this._getMaxOffset().left;
    }
    const distance = this._normalizeLocation({
      left: location.left - ensureDefined(targetLocation.left, location.left),
      top: location.top - ensureDefined(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  }
  scrollToElement(element, offset) {
    const $element = renderer_default(element);
    const elementInsideContent = this.$content().find(element).length;
    const elementIsInsideContent = $element.parents(".dx-scrollable").length - $element.parents(".dx-scrollable-content").length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    const scrollPosition = {
      top: 0,
      left: 0
    };
    const {
      direction
    } = this.option();
    if (direction !== VERTICAL3) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL4, offset);
    }
    if (direction !== HORIZONTAL4) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL3, offset);
    }
    this.scrollTo(scrollPosition);
  }
  getScrollElementPosition($element, direction, offset) {
    const scrollOffset = this.scrollOffset();
    return getElementLocationInternal($element.get(0), direction, renderer_default(this.container()).get(0), scrollOffset, offset);
  }
  _updateIfNeed() {
    if (!this.option("updateManually")) {
      this.update();
    }
  }
  _useTemplates() {
    return false;
  }
  isRenovated() {
    return !!_Scrollable.IS_RENOVATED_WIDGET;
  }
};
component_registrator_default(SCROLLABLE, Scrollable);
var m_scrollable_default = Scrollable;

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var ui_scrollable_default = m_scrollable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_rows_view.js
var FREE_SPACE_CLASS = "dx-freespace-row";
var LAST_ROW_BORDER = "dx-last-row-border";
function getMaxHorizontalScrollOffset(scrollable) {
  return scrollable ? Math.round(scrollable.scrollWidth() - scrollable.clientWidth()) : 0;
}
function isGroupRow(_ref) {
  let {
    rowType,
    column
  } = _ref;
  return "group" === rowType && isDefined(column.groupIndex) && !column.showWhenGrouped && !column.command;
}
function setWatcher(_ref2) {
  let {
    element,
    watch,
    getter,
    callBack
  } = _ref2;
  if (watch) {
    const dispose = watch(getter, callBack);
    m_events_engine_default.on(element, removeEvent, dispose);
  }
}
var defaultCellTemplate = function($container, options2) {
  const isDataTextEmpty = isEmpty(options2.text) && "data" === options2.rowType;
  const {
    text
  } = options2;
  const container = $container.get(0);
  if (isDataTextEmpty) {
    m_utils_default.setEmptyText($container);
  } else if (options2.column.encodeHtml) {
    container.textContent = text;
  } else {
    container.innerHTML = text;
  }
};
var getScrollableBottomPadding = function(that) {
  const scrollable = that.getScrollable();
  return scrollable ? Math.ceil(parseFloat(renderer_default(scrollable.content()).css("paddingBottom"))) : 0;
};
var RowsView = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._resizingController = this.getController("resizing");
    this._columnsResizerController = this.getController("columnsResizer");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._validatingController = this.getController("validating");
    this._errorHandlingController = this.getController("errorHandling");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowHeight = 0;
    this._scrollTop = 0;
    this._scrollLeft = -1;
    this._scrollRight = 0;
    this._hasHeight = void 0;
    this._contentChanges = [];
    this._dataController.loadingChanged.add(((isLoading, messageText) => {
      this.setLoading(isLoading, messageText);
    }));
    this._dataController.dataSourceChanged.add((() => {
      if (this._scrollLeft >= 0 && !this._dataController.isLoading()) {
        this._handleScroll({
          component: this.getScrollable(),
          forceUpdateScrollPosition: true,
          scrollOffset: {
            top: this._scrollTop,
            left: this._scrollLeft
          }
        });
      }
    }));
  }
  _getDefaultTemplate(column) {
    if ("empty" === column.command) {
      return function(container) {
        container.html("&nbsp;");
      };
    } else {
      return defaultCellTemplate;
    }
  }
  renderFocusState(params) {
  }
  _getDefaultGroupTemplate(column) {
    const summaryTexts = this.option("summary.texts");
    return function($container, options2) {
      const {
        data: data17
      } = options2;
      let text = `${options2.column.caption}: ${options2.text}`;
      const container = $container.get(0);
      if (options2.summaryItems && options2.summaryItems.length) {
        text += ` ${m_utils_default.getGroupRowSummaryText(options2.summaryItems, summaryTexts)}`;
      }
      if (data17) {
        if (options2.groupContinuedMessage && options2.groupContinuesMessage) {
          text += ` (${options2.groupContinuedMessage}. ${options2.groupContinuesMessage})`;
        } else if (options2.groupContinuesMessage) {
          text += ` (${options2.groupContinuesMessage})`;
        } else if (options2.groupContinuedMessage) {
          text += ` (${options2.groupContinuedMessage})`;
        }
      }
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
    };
  }
  _update(change) {
  }
  _updateCell($cell, options2) {
    if (isGroupRow(options2)) {
      const isGroupContainer = $cell.is(`.${this.addWidgetPrefix(CLASSES3.groupRowContainer)}`);
      const $groupCell = isGroupContainer ? $cell.parent() : $cell;
      $groupCell.addClass("dx-group-cell");
    }
    super._updateCell.apply(this, arguments);
  }
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    let template;
    if (isGroupRow(options2)) {
      template = column.groupCellTemplate || {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultGroupTemplate(column)
      };
    } else if (("data" === options2.rowType || column.command) && column.cellTemplate) {
      template = column.cellTemplate;
    } else {
      template = {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultTemplate(column)
      };
    }
    return template;
  }
  _createRow(row, tag) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isGroup2 = "group" === row.rowType;
      const isDataRow2 = "data" === row.rowType;
      isDataRow2 && $row.addClass("dx-data-row");
      isDataRow2 && this.option("showRowLines") && $row.addClass("dx-row-lines");
      this.option("showColumnLines") && $row.addClass("dx-column-lines");
      if (false === row.visible) {
        $row.hide();
      }
      if (isGroup2) {
        $row.addClass("dx-group-row");
        this.setAriaExpandedAttribute($row, row);
      }
    }
    return $row;
  }
  _rowPrepared($row, rowOptions, row) {
    if ("data" === rowOptions.rowType) {
      if (this.option("rowAlternationEnabled")) {
        this._isAltRow(row) && $row.addClass("dx-row-alt");
        setWatcher({
          element: $row.get(0),
          watch: rowOptions.watch,
          getter: () => this._isAltRow(this._dataController.getRowByKey(row.key)),
          callBack: (value2) => {
            $row.toggleClass("dx-row-alt", value2);
          }
        });
      }
      this._setAriaRowIndex(rowOptions, $row);
      setWatcher({
        element: $row.get(0),
        watch: rowOptions.watch,
        getter: () => rowOptions.rowIndex,
        callBack: () => this._setAriaRowIndex(rowOptions, $row)
      });
    }
    super._rowPrepared.apply(this, arguments);
  }
  _setAriaRowIndex(row, $row) {
    if (!$row.is("tr")) {
      return;
    }
    const {
      component
    } = this;
    const isPagerMode = "standard" === component.option("scrolling.mode") && !m_utils_default.isVirtualRowRendering(component);
    let rowIndex = row.rowIndex + 1;
    if (isPagerMode) {
      rowIndex = component.pageIndex() * component.pageSize() + rowIndex;
    } else {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    this.setAria("rowindex", rowIndex, $row);
  }
  setAriaExpandedAttribute($row, row) {
    const description = row.isExpanded ? this.localize("dxDataGrid-ariaExpandedRow") : this.localize("dxDataGrid-ariaCollapsedRow");
    this.setAria("roledescription", description, $row);
  }
  _afterRowPrepared(e) {
    const arg = e.args[0];
    const dataController2 = this._dataController;
    const row = dataController2.getVisibleRows()[arg.rowIndex];
    const watch = this.option("integrationOptions.watchMethod");
    if (!arg.data || "data" !== arg.rowType || arg.isNewRow || !this.option("twoWayBindingEnabled") || !watch || !row) {
      return;
    }
    const dispose = watch((() => dataController2.generateDataValues(arg.data, arg.columns)), (() => {
      dataController2.repaintRows([row.rowIndex], this.option("repaintChangesOnly"));
    }), {
      deep: true,
      skipImmediate: true
    });
    m_events_engine_default.on(arg.rowElement, removeEvent, dispose);
  }
  _renderScrollable(force) {
    const that = this;
    const $element = that.element();
    if (!$element.children().length) {
      $element.append("<div>");
    }
    if (force || !that._loadPanel) {
      that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore());
    }
    if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
      const columns7 = that.getColumns();
      let allColumnsHasWidth = true;
      for (let i = 0; i < columns7.length; i++) {
        if (!columns7[i].width && !columns7[i].minWidth) {
          allColumnsHasWidth = false;
          break;
        }
      }
      if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
        that._renderScrollableCore($element);
      }
    }
  }
  _handleScroll(e) {
    const rtlEnabled = this.option("rtlEnabled");
    const isNativeScrolling = e.component.option("useNative");
    this._scrollTop = e.scrollOffset.top;
    this._scrollLeft = e.scrollOffset.left;
    let scrollLeft = e.scrollOffset.left;
    if (rtlEnabled) {
      this._scrollRight = getMaxHorizontalScrollOffset(e.component) - this._scrollLeft;
      if (isNativeScrolling) {
        scrollLeft = -this._scrollRight;
      }
      if (!this.isScrollbarVisible(true)) {
        this._scrollLeft = -1;
      }
    }
    this.scrollChanged.fire(_extends({}, e.scrollOffset, {
      left: scrollLeft
    }), this.name);
  }
  _renderScrollableCore($element) {
    const dxScrollableOptions = this._createScrollableOptions();
    const scrollHandler = this._handleScroll.bind(this);
    dxScrollableOptions.onScroll = scrollHandler;
    this._scrollable = this._createComponent($element, ui_scrollable_default, dxScrollableOptions);
    this._scrollableContainer = this._scrollable && renderer_default(this._scrollable.container());
  }
  _renderLoadPanel() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return m_utils_default.renderLoadPanel.apply(this, arguments);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    contentElement.empty().append(tableElement);
    return this._findContentElement();
  }
  _updateContent(newTableElement, change, isFixedTableRendering) {
    this._contentChanges.push({
      newTableElement,
      change,
      isFixedTableRendering
    });
    return this.waitAsyncTemplates().done((() => {
      const contentChanges = this._contentChanges;
      this._contentChanges = [];
      contentChanges.forEach(((_ref3) => {
        let {
          newTableElement: newTableElement2,
          change: change2,
          isFixedTableRendering: isFixedTableRendering2
        } = _ref3;
        const tableElement = this.getTableElement(isFixedTableRendering2);
        const contentElement = this._findContentElement(isFixedTableRendering2);
        const changeType = null === change2 || void 0 === change2 ? void 0 : change2.changeType;
        const executors = [];
        const highlightChanges = this.option("highlightChanges");
        const rowInsertedClass = this.addWidgetPrefix("row-inserted-animation");
        if ("update" === changeType) {
          each(change2.rowIndices, ((index, rowIndex) => {
            var _change$changeTypes;
            const $newRowElement = this._getRowElements(newTableElement2).eq(index);
            const dataChangeType = null === (_change$changeTypes = change2.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes[index];
            const item = change2.items && change2.items[index];
            executors.push((() => {
              const $rowElements = this._getRowElements(tableElement);
              const $rowElement = $rowElements.eq(rowIndex);
              switch (dataChangeType) {
                case "update":
                  if (item) {
                    var _change$columnIndices;
                    const columnIndices = null === (_change$columnIndices = change2.columnIndices) || void 0 === _change$columnIndices ? void 0 : _change$columnIndices[index];
                    if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
                      $rowElement.toggle(item.visible);
                    } else if (columnIndices) {
                      this._updateCells($rowElement, $newRowElement, columnIndices, item);
                    } else {
                      $rowElement.replaceWith($newRowElement);
                    }
                  }
                  break;
                case "insert":
                  if (!$rowElements.length) {
                    if (tableElement) {
                      const target = $newRowElement.is("tbody") ? tableElement : tableElement.children("tbody");
                      $newRowElement.prependTo(target);
                    }
                  } else if ($rowElement.length) {
                    $newRowElement.insertBefore($rowElement);
                  } else {
                    $newRowElement.insertAfter($rowElements.last());
                  }
                  if (highlightChanges && change2.isLiveUpdate) {
                    $newRowElement.addClass(rowInsertedClass);
                  }
                  break;
                case "remove":
                  $rowElement.remove();
              }
            }));
          }));
          each(executors, (function() {
            this();
          }));
          newTableElement2.remove();
        } else {
          this.setTableElement(newTableElement2, isFixedTableRendering2);
          contentElement.addClass(this.addWidgetPrefix("content"));
          this._setGridRole(contentElement);
          this._renderContent(contentElement, newTableElement2, isFixedTableRendering2);
        }
      }));
    })).fail((() => {
      this._contentChanges = [];
    }));
  }
  _getGridRoleName() {
    return "grid";
  }
  _setGridRole($element) {
    var _this$_dataController;
    const hasData = !(null !== (_this$_dataController = this._dataController) && void 0 !== _this$_dataController && _this$_dataController.isEmpty());
    const gridRoleName = this._getGridRoleName();
    if (null !== $element && void 0 !== $element && $element.length && hasData) {
      this.setAria("role", gridRoleName, $element);
    }
  }
  _createEmptyRow(className, isFixed, height) {
    const that = this;
    let $cell;
    const $row = that._createRow();
    const columns7 = isFixed ? this.getFixedColumns() : this.getColumns();
    $row.addClass(className).toggleClass("dx-column-lines", that.option("showColumnLines"));
    for (let i = 0; i < columns7.length; i++) {
      $cell = that._createCell({
        column: columns7[i],
        rowType: "freeSpace",
        columnIndex: i,
        columns: columns7
      });
      isNumeric(height) && $cell.css("height", height);
      $row.append($cell);
    }
    that.setAria("role", "presentation", $row);
    return $row;
  }
  getFixedColumns() {
    throw new Error("Method not implemented.");
  }
  _appendEmptyRow($table, $emptyRow, location) {
    const $tBodies = this._getBodies($table);
    const isTableContainer = !$tBodies.length || $emptyRow.is("tbody");
    const $container = isTableContainer ? $table : $tBodies;
    if ("top" === location) {
      $container.first().prepend($emptyRow);
      if (isTableContainer) {
        const $colgroup = $container.children("colgroup");
        $container.prepend($colgroup);
      }
    } else {
      $container.last().append($emptyRow);
    }
  }
  _renderFreeSpaceRow($tableElement, change) {
    let $freeSpaceRowElement = this._createEmptyRow(FREE_SPACE_CLASS);
    $freeSpaceRowElement = this._wrapRowIfNeed($tableElement, $freeSpaceRowElement, "refresh" === (null === change || void 0 === change ? void 0 : change.changeType));
    this._appendEmptyRow($tableElement, $freeSpaceRowElement);
  }
  _checkRowKeys(options2) {
    const that = this;
    const rows = that._getRows(options2);
    const keyExpr = that._dataController.store() && that._dataController.store().key();
    keyExpr && rows.some(((row) => {
      if ("data" === row.rowType && void 0 === row.key) {
        that._dataController.fireError("E1046", keyExpr);
        return true;
      }
      return;
    }));
  }
  _needUpdateRowHeight(itemsCount) {
    return itemsCount > 0 && !this._rowHeight;
  }
  _getRowsHeight($tableElement) {
    $tableElement = $tableElement || this._tableElement;
    const $rowElements = $tableElement.children("tbody").children().not(".dx-virtual-row").not(`.${FREE_SPACE_CLASS}`);
    return $rowElements.toArray().reduce(((sum, row) => sum + getBoundingRect(row).height), 0);
  }
  _updateRowHeight() {
    const that = this;
    const $tableElement = that.getTableElement();
    const itemsCount = that._dataController.items().length;
    if ($tableElement && that._needUpdateRowHeight(itemsCount)) {
      const rowsHeight = that._getRowsHeight($tableElement);
      that._rowHeight = rowsHeight / itemsCount;
    }
  }
  _findContentElement(isFixedTableRendering) {
    let $content = this.element();
    const scrollable = this.getScrollable();
    if ($content) {
      if (scrollable) {
        $content = renderer_default(scrollable.content());
      }
      return $content.children().first();
    }
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return $rows && $rows.not(`.${FREE_SPACE_CLASS}`);
  }
  _getFreeSpaceRowElements($table) {
    const tableElements = $table || this.getTableElements();
    return tableElements && tableElements.children("tbody").children(`.${FREE_SPACE_CLASS}`);
  }
  _getNoDataText() {
    return this.option("noDataText");
  }
  _rowClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({
      evaluate(expr) {
        const getter = compileGetter(expr);
        return getter(item.data);
      }
    }, e, item));
  }
  _rowDblClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowDblClick", extend({}, e, item));
  }
  _getColumnsCountBeforeGroups(columns7) {
    for (let i = 0; i < columns7.length; i++) {
      if ("groupExpand" === columns7[i].type) {
        return i;
      }
    }
    return 0;
  }
  _getGroupCellOptions(options2) {
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(options2.columns);
    const columnIndex = (options2.row.groupIndex || 0) + columnsCountBeforeGroups;
    return {
      columnIndex,
      colspan: options2.columns.length - columnIndex - 1
    };
  }
  _needWrapRow() {
    return super._needWrapRow.apply(this, arguments) || !!this.option("dataRowTemplate");
  }
  _renderCells($row, options2) {
    if ("group" === options2.row.rowType) {
      this._renderGroupedCells($row, options2);
    } else if (options2.row.values) {
      super._renderCells($row, options2);
    }
  }
  _renderGroupedCells($row, options2) {
    const {
      row
    } = options2;
    let expandColumn;
    const {
      columns: columns7
    } = options2;
    const {
      rowIndex
    } = row;
    let isExpanded;
    const groupCellOptions = this._getGroupCellOptions(options2);
    for (let i = 0; i <= groupCellOptions.columnIndex; i++) {
      if (i === groupCellOptions.columnIndex && columns7[i].allowCollapsing && "infinite" !== options2.scrollingMode) {
        isExpanded = !!row.isExpanded;
        expandColumn = columns7[i];
      } else {
        isExpanded = null;
        expandColumn = {
          command: "expand",
          cssClass: columns7[i].cssClass,
          fixed: columns7[i].fixed
        };
      }
      if (this._needRenderCell(i, options2.columnIndices)) {
        this._renderCell($row, {
          value: isExpanded,
          row,
          rowIndex,
          column: expandColumn,
          columnIndex: i,
          columnIndices: options2.columnIndices,
          change: options2.change
        });
      }
    }
    const groupColumnAlignment = getDefaultAlignment(this.option("rtlEnabled"));
    const groupColumn = extend({}, columns7[groupCellOptions.columnIndex], {
      command: null,
      type: null,
      cssClass: null,
      width: null,
      showWhenGrouped: false,
      alignment: groupColumnAlignment
    });
    if (groupCellOptions.colspan > 1) {
      groupColumn.colspan = groupCellOptions.colspan;
    }
    if (this._needRenderCell(groupCellOptions.columnIndex + 1, options2.columnIndices)) {
      this._renderCell($row, {
        value: row.values[row.groupIndex],
        row,
        rowIndex,
        column: groupColumn,
        columnIndex: groupCellOptions.columnIndex + 1,
        columnIndices: options2.columnIndices,
        change: options2.change
      });
    }
  }
  _renderRows($table, options2) {
    const that = this;
    const scrollingMode = that.option("scrolling.mode");
    super._renderRows($table, extend({
      scrollingMode
    }, options2));
    that._checkRowKeys(options2.change);
    that._renderFreeSpaceRow($table, options2.change);
    if (!that._hasHeight) {
      that.updateFreeSpaceRowHeight($table);
    }
  }
  _renderDataRowByTemplate($table, options2, dataRowTemplate) {
    const {
      row
    } = options2;
    const rowOptions = extend({
      columns: options2.columns
    }, row);
    const $tbody = this._createRow(row, "tbody");
    $tbody.appendTo($table);
    this.renderTemplate($tbody, dataRowTemplate, rowOptions, true, options2.change);
    this._rowPrepared($tbody, rowOptions, options2.row);
  }
  _renderRow($table, options2) {
    const {
      row
    } = options2;
    const {
      rowTemplate
    } = this.option();
    const dataRowTemplate = this.option("dataRowTemplate");
    if ("data" === row.rowType && dataRowTemplate) {
      this._renderDataRowByTemplate($table, options2, dataRowTemplate);
    } else if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
      this.renderTemplate($table, rowTemplate, extend({
        columns: options2.columns
      }, row), true);
    } else {
      super._renderRow($table, options2);
    }
  }
  _renderTable(options2) {
    const that = this;
    const $table = super._renderTable(options2);
    const resizeCompletedHandler = function() {
      const scrollableInstance = that.getScrollable();
      if (scrollableInstance && that.element().closest(getWindow().document).length) {
        that.resizeCompleted.remove(resizeCompletedHandler);
        scrollableInstance._visibilityChanged(true);
      }
    };
    if (!isDefined(that.getTableElement())) {
      that.setTableElement($table);
      that._renderScrollable(true);
      that.resizeCompleted.add(resizeCompletedHandler);
    } else {
      that._renderScrollable();
    }
    return $table;
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    if (this.option().rowTemplate || this.option().dataRowTemplate) {
      $table.appendTo(this.component.$element());
    }
    return $table;
  }
  _renderCore(change) {
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("rowsview")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    $element.toggleClass("dx-empty", this._dataController.isEmpty());
    this.setAria("role", "presentation", $element);
    const $table = this._renderTable({
      change
    });
    const deferred = this._updateContent($table, change);
    super._renderCore(change);
    this._lastColumnWidths = null;
    return deferred;
  }
  _getRows(change) {
    return change && change.items || this._dataController.items();
  }
  _getCellOptions(options2) {
    const that = this;
    const {
      column
    } = options2;
    const {
      row
    } = options2;
    const {
      data: data17
    } = row;
    const summaryCells = row && row.summaryCells;
    const {
      value: value2
    } = options2;
    const displayValue = m_utils_default.getDisplayValue(column, value2, data17, row.rowType);
    const parameters = super._getCellOptions(options2);
    parameters.value = value2;
    parameters.oldValue = options2.oldValue;
    parameters.displayValue = displayValue;
    parameters.row = row;
    parameters.key = row.key;
    parameters.data = data17;
    parameters.rowType = row.rowType;
    parameters.values = row.values;
    parameters.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    parameters.rowIndex = row.rowIndex;
    parameters.summaryItems = summaryCells && summaryCells[options2.columnIndex];
    parameters.resized = column.resizedCallbacks;
    if (isDefined(column.groupIndex) && !column.command) {
      const groupingTextsOptions = that.option("grouping.texts");
      const scrollingMode = that.option("scrolling.mode");
      if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
        parameters.groupContinuesMessage = data17 && data17.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
        parameters.groupContinuedMessage = data17 && data17.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage;
      }
    }
    return parameters;
  }
  _toggleDraggableSourceColumnClass($rows, visibleColumns, columnIndex, value2) {
    const columnsController = this._columnsController;
    const columns7 = columnsController.getColumns();
    const column = columns7 && columns7[columnIndex];
    const columnID = column && column.isBand && column.index;
    each($rows, ((rowIndex, row) => {
      if (!renderer_default(row).hasClass("dx-group-row")) {
        for (let i = 0; i < visibleColumns.length; i++) {
          if (isNumeric(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
            $rows.eq(rowIndex).children().eq(i).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
            if (!isNumeric(columnID)) {
              break;
            }
          }
        }
      }
    }));
  }
  _getDevicePixelRatio() {
    return getWindow().devicePixelRatio;
  }
  renderNoDataText() {
    return m_utils_default.renderNoDataText.apply(this, arguments);
  }
  getCellOptions(rowIndex, columnIdentifier) {
    const rowOptions = this._dataController.items()[rowIndex];
    let cellOptions;
    let column;
    if (rowOptions) {
      if (isString(columnIdentifier)) {
        column = this._columnsController.columnOption(columnIdentifier);
      } else {
        column = this._columnsController.getVisibleColumns()[columnIdentifier];
      }
      if (column) {
        cellOptions = this._getCellOptions({
          value: column.calculateCellValue(rowOptions.data),
          rowIndex: rowOptions.rowIndex,
          row: rowOptions,
          column
        });
      }
    }
    return cellOptions;
  }
  getRow(index) {
    if (index >= 0) {
      const rows = this._getRowElements();
      if (rows.length > index) {
        return renderer_default(rows[index]);
      }
    }
    return;
  }
  updateFreeSpaceRowHeight($table) {
    const dataController2 = this._dataController;
    const itemCount = dataController2.items(true).length;
    const contentElement = this._findContentElement();
    const freeSpaceRowElements = this._getFreeSpaceRowElements($table);
    if (freeSpaceRowElements && contentElement && dataController2.totalCount() >= 0) {
      let isFreeSpaceRowVisible = false;
      if (itemCount > 0) {
        if (!this._hasHeight) {
          const freeSpaceRowCount = dataController2.pageSize() - itemCount;
          const scrollingMode = this.option("scrolling.mode");
          if (freeSpaceRowCount > 0 && dataController2.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
            setHeight2(freeSpaceRowElements, freeSpaceRowCount * this._rowHeight);
            isFreeSpaceRowVisible = true;
          }
          if (!isFreeSpaceRowVisible && $table) {
            setHeight2(freeSpaceRowElements, 0);
          } else {
            freeSpaceRowElements.toggle(isFreeSpaceRowVisible);
          }
          this._updateLastRowBorder(isFreeSpaceRowVisible);
        } else {
          freeSpaceRowElements.hide();
          deferUpdate((() => {
            const scrollbarWidth = this.getScrollbarWidth(true);
            const elementHeightWithoutScrollbar = getHeight(this.element()) - scrollbarWidth;
            const contentHeight = getOuterHeight(contentElement);
            const showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0;
            const rowsHeight = this._getRowsHeight(contentElement.children().first());
            const $tableElement = $table || this.getTableElements();
            const borderTopWidth = Math.ceil(parseFloat($tableElement.css("borderTopWidth")));
            const heightCorrection = this._getHeightCorrection();
            const resultHeight = elementHeightWithoutScrollbar - rowsHeight - borderTopWidth - heightCorrection;
            if (showFreeSpaceRow) {
              deferRender((() => {
                freeSpaceRowElements.css("height", resultHeight);
                isFreeSpaceRowVisible = true;
                freeSpaceRowElements.show();
              }));
            }
            deferRender((() => this._updateLastRowBorder(isFreeSpaceRowVisible)));
          }));
        }
      } else {
        freeSpaceRowElements.css("height", 0);
        freeSpaceRowElements.show();
        this._updateLastRowBorder(true);
      }
    }
  }
  _getHeightCorrection() {
    const isZoomedWebkit = browser_default.webkit && this._getDevicePixelRatio() >= 2;
    const isChromeLatest = browser_default.chrome && browser_default.version >= 91;
    const hasExtraBorderTop = browser_default.mozilla && browser_default.version >= 70 && !this.option("showRowLines");
    return isZoomedWebkit || hasExtraBorderTop || isChromeLatest ? 1 : 0;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
      this._fireColumnResizedCallbacks();
    }
  }
  getScrollable() {
    return this._scrollable;
  }
  _handleDataChanged(change) {
    const that = this;
    switch (change.changeType) {
      case "refresh":
      case "prepend":
      case "append":
      case "update":
        that.render(null, change);
        break;
      default:
        that._update(change);
    }
  }
  publicMethods() {
    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"];
  }
  contentWidth() {
    return getWidth(this.element()) - this.getScrollbarWidth();
  }
  getScrollbarWidth(isHorizontal) {
    const scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0);
    let scrollbarWidth = 0;
    if (scrollableContainer) {
      if (!isHorizontal) {
        scrollbarWidth = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0;
      } else {
        scrollbarWidth = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0;
        scrollbarWidth += getScrollableBottomPadding(this);
      }
    }
    return scrollbarWidth > 0 ? scrollbarWidth : 0;
  }
  _fireColumnResizedCallbacks() {
    const lastColumnWidths = this._lastColumnWidths || [];
    const columnWidths = [];
    const columns7 = this.getColumns();
    for (let i = 0; i < columns7.length; i++) {
      columnWidths[i] = columns7[i].visibleWidth;
      if (columns7[i].resizedCallbacks && !isDefined(columns7[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
        columns7[i].resizedCallbacks.fire(columnWidths[i]);
      }
    }
    this._lastColumnWidths = columnWidths;
  }
  _updateLastRowBorder(isFreeSpaceRowVisible) {
    if (this.option("showBorders") && !isFreeSpaceRowVisible) {
      this.element().addClass(LAST_ROW_BORDER);
    } else {
      this.element().removeClass(LAST_ROW_BORDER);
    }
  }
  _updateScrollable() {
    const scrollable = ui_scrollable_default.getInstance(this.element());
    if (scrollable) {
      scrollable.update();
      if (scrollable.option("useNative") || !(null !== scrollable && void 0 !== scrollable && scrollable.isRenovated())) {
        this._updateHorizontalScrollPosition();
      }
    }
  }
  _updateHorizontalScrollPosition() {
    const scrollable = this.getScrollable();
    const scrollLeft = scrollable && scrollable.scrollOffset().left;
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      const maxHorizontalScrollOffset = getMaxHorizontalScrollOffset(scrollable);
      const scrollRight = maxHorizontalScrollOffset - scrollLeft;
      if (scrollRight !== this._scrollRight) {
        this._scrollLeft = maxHorizontalScrollOffset - this._scrollRight;
      }
    }
    if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
      scrollable.scrollTo({
        x: this._scrollLeft
      });
    }
  }
  _resizeCore() {
    const that = this;
    that._fireColumnResizedCallbacks();
    that._updateRowHeight();
    deferRender((() => {
      that._renderScrollable();
      that.renderNoDataText();
      that.updateFreeSpaceRowHeight();
      deferUpdate((() => {
        that._updateScrollable();
      }));
    }));
  }
  scrollTo(location) {
    const $element = this.element();
    const dxScrollable = $element && ui_scrollable_default.getInstance($element);
    if (dxScrollable) {
      dxScrollable.scrollTo(location);
    }
  }
  height(height) {
    const that = this;
    const $element = this.element();
    if (0 === arguments.length) {
      return $element ? getOuterHeight($element, true) : 0;
    }
    if (isDefined(height) && $element) {
      that.hasHeight("auto" !== height);
      setHeight2($element, height);
    }
  }
  hasHeight(hasHeight) {
    if (0 === arguments.length) {
      return !!this._hasHeight;
    }
    this._hasHeight = hasHeight;
    return;
  }
  setLoading(isLoading, messageText) {
    const that = this;
    let loadPanel = that._loadPanel;
    const dataController2 = that._dataController;
    const loadPanelOptions = that.option("loadPanel") || {};
    const animation2 = dataController2.isLoaded() ? loadPanelOptions.animation : null;
    const $element = that.element();
    if (!hasWindow()) {
      return;
    }
    if (!loadPanel && void 0 !== messageText && dataController2.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
      that._renderLoadPanel($element, $element.parent());
      loadPanel = that._loadPanel;
    }
    if (loadPanel) {
      const visibilityOptions = {
        message: messageText || loadPanelOptions.text,
        animation: animation2,
        visible: isLoading
      };
      if (isLoading) {
        visibilityOptions.position = m_utils_default.calculateLoadPanelPosition($element);
      }
      clearTimeout(that._hideLoadingTimeoutID);
      if (loadPanel.option("visible") && !isLoading) {
        that._hideLoadingTimeoutID = setTimeout((() => {
          loadPanel.option(visibilityOptions);
        }), 200);
      } else {
        loadPanel.option(visibilityOptions);
      }
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    const $rows = this._getRowElements().not(".dx-group-row") || [];
    this._toggleDraggableSourceColumnClass($rows, this.getColumns(), columnIndex, value2);
  }
  _getCellElementsCore(rowIndex) {
    const $cells = super._getCellElementsCore.apply(this, arguments);
    if ($cells) {
      const groupCellIndex = $cells.filter(".dx-group-cell").index();
      if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
        return $cells.slice(0, groupCellIndex + 1);
      }
    }
    return $cells;
  }
  _getBoundaryVisibleItemIndex(isTop, isFloor) {
    const that = this;
    let itemIndex = 0;
    let prevOffset = 0;
    let offset = 0;
    let viewportBoundary = that._scrollTop;
    const $contentElement = that._findContentElement();
    const contentElementOffsetTop = $contentElement && $contentElement.offset().top;
    const items = this._dataController.items();
    const tableElement = that.getTableElement();
    if (items.length && tableElement) {
      const rowElements = that._getRowElements(tableElement).filter(":visible");
      if (!isTop) {
        const height = getOuterHeight(this._hasHeight ? this.element() : getWindow());
        viewportBoundary += height;
      }
      for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
        prevOffset = offset;
        const $rowElement = renderer_default(rowElements).eq(itemIndex);
        if ($rowElement.length) {
          offset = $rowElement.offset();
          offset = (isTop ? offset.top : offset.top + getOuterHeight($rowElement)) - contentElementOffsetTop;
          if (offset > viewportBoundary) {
            if (itemIndex) {
              if (isFloor || 2 * viewportBoundary < Math.round(offset + prevOffset)) {
                itemIndex--;
              }
            }
            break;
          }
        }
      }
      if (itemIndex && itemIndex === items.length) {
        itemIndex--;
      }
    }
    return itemIndex;
  }
  getTopVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(true, isFloor);
  }
  getBottomVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(false, isFloor);
  }
  getTopVisibleRowData() {
    const itemIndex = this.getTopVisibleItemIndex();
    const items = this._dataController.items();
    if (items[itemIndex]) {
      return items[itemIndex].data;
    }
    return;
  }
  _scrollToElement($element, offset) {
    const scrollable = this.getScrollable();
    scrollable && scrollable.scrollToElement($element, offset);
  }
  optionChanged(args) {
    const that = this;
    super.optionChanged(args);
    switch (args.name) {
      case "wordWrapEnabled":
      case "showColumnLines":
      case "showRowLines":
      case "rowAlternationEnabled":
      case "rowTemplate":
      case "dataRowTemplate":
      case "twoWayBindingEnabled":
        that._invalidate(true, true);
        args.handled = true;
        break;
      case "scrolling":
        that._rowHeight = null;
        that._tableElement = null;
        args.handled = true;
        break;
      case "rtlEnabled":
        that._rowHeight = null;
        that._tableElement = null;
        break;
      case "loadPanel":
        that._tableElement = null;
        that._invalidate(true, "loadPanel.enabled" !== args.fullName);
        args.handled = true;
        break;
      case "noDataText":
        that.renderNoDataText();
        args.handled = true;
    }
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    const $contentElement = this._findContentElement();
    const $tableElement = this.getTableElement();
    if (null !== $tableElement && void 0 !== $tableElement && $tableElement.length) {
      this.setAria("owns", `${headerTableId ?? ""} ${$tableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentElement);
    }
  }
  dispose() {
    super.dispose();
    clearTimeout(this._hideLoadingTimeoutID);
    this._scrollable && this._scrollable.dispose();
  }
  setScrollerSpacing(vScrollbarWidth, hScrollbarWidth) {
  }
  getFixedContentElement() {
    var _this$element;
    const fixedContentClass = this.addWidgetPrefix("content-fixed");
    return null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${fixedContentClass}`);
  }
  _restoreErrorRow(contentTable) {
  }
  isElementInside($element) {
    const $rowsViewElement = $element.closest(`.${this.addWidgetPrefix("rowsview")}`);
    return $rowsViewElement.is(this.element());
  }
  _renderIcons($iconContainer, options2) {
    return $iconContainer;
  }
};
var rowsModule = {
  defaultOptions: () => ({
    hoverStateEnabled: false,
    scrolling: {
      useNative: "auto"
    },
    loadPanel: {
      enabled: "auto",
      text: message_default.format("Loading"),
      width: 200,
      height: 90,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true
    },
    dataRowTemplate: null,
    columnAutoWidth: false,
    noDataText: message_default.format("dxDataGrid-noDataText"),
    wordWrapEnabled: false,
    showColumnLines: true,
    showRowLines: false,
    rowAlternationEnabled: false,
    activeStateEnabled: false,
    twoWayBindingEnabled: true
  }),
  views: {
    rowsView: RowsView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/rows.js
var RowsView2 = rowsModule.views.rowsView;
m_core_default.registerModule("rows", rowsModule);

// node_modules/devextreme/esm/__internal/events/m_hold.js
var {
  abs
} = Math;
var HoldEmitter = m_emitter_default.inherit({
  start(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer(e) {
    const holdTimeout = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout((() => {
      this._requestAccept(e);
      this._fireEvent("dxhold", e, {
        target: e.target
      });
      this._forgetAccept();
    }), holdTimeout);
  },
  move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved(e) {
    const delta = eventDelta(this._startEventData, eventData(e));
    return abs(delta.x) > 5 || abs(delta.y) > 5;
  },
  end() {
    this._stopTimer();
  },
  _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel() {
    this._stopTimer();
  },
  dispose() {
    this._stopTimer();
  }
});
m_emitter_registrator_default({
  emitter: HoldEmitter,
  bubble: true,
  events: ["dxhold"]
});
var m_hold_default = {
  name: "dxhold"
};

// node_modules/devextreme/esm/__internal/events/m_contextmenu.js
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace("contextmenu", "dxContexMenu");
var HOLD_NAMESPACED_EVENT_NAME = addNamespace(m_hold_default.name, "dxContexMenu");
var ContextMenu = class_default.inherit({
  setup(element) {
    const $element = renderer_default(element);
    m_events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (m_support_default.touch || m_devices_default.isSimulator()) {
      m_events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler(e) {
    if (isMouseEvent(e) && !m_devices_default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: (e) => fireEvent({
    type: "dxcontextmenu",
    originalEvent: e
  }),
  teardown(element) {
    m_events_engine_default.off(element, ".dxContexMenu");
  }
});
m_event_registrator_default("dxcontextmenu", new ContextMenu());
var name = "dxcontextmenu";

// node_modules/devextreme/esm/ui/overlay/ui.overlay.js
var ui_overlay_default = m_overlay_default;

// node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
var initConfig = function() {
  let config2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config2;
  return {
    waveSizeCoefficient: waveSizeCoefficient || 2,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation ?? true)
  };
};
var render = function(args) {
  const config2 = initConfig(args);
  return {
    showWave: showWave.bind(this, config2),
    hideWave: hideWave.bind(this, config2)
  };
};
var getInkRipple = function(element) {
  let result2 = element.children(".dx-inkripple");
  if (0 === result2.length) {
    result2 = renderer_default("<div>").addClass("dx-inkripple").appendTo(element);
  }
  return result2;
};
var getWaves = function(element, wavesNumber) {
  const inkRipple = getInkRipple(renderer_default(element));
  const result2 = inkRipple.children(".dx-inkripple-wave").toArray();
  for (let i = result2.length; i < wavesNumber; i++) {
    const $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass("dx-inkripple-wave");
    result2.push($currentWave[0]);
  }
  return renderer_default(result2);
};
var getWaveStyleConfig = function(args, config2) {
  const element = renderer_default(config2.element);
  const elementWidth = getOuterWidth(element);
  const elementHeight = getOuterHeight(element);
  const elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  const waveSize = Math.min(4e3, parseInt(elementDiagonal * args.waveSizeCoefficient));
  let left;
  let top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    const event = config2.event;
    const position2 = element.offset();
    const x = event.pageX - position2.left;
    const y = event.pageY - position2.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config2) {
  const $wave = getWaves(config2.element, args.wavesNumber).eq(config2.wave || 0);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config2));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  const durationCss = args.durations.showingScale + "ms";
  $wave.addClass("dx-inkripple-showing").css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass("dx-inkripple-hiding").css("transitionDuration", "");
}
function hideWave(args, config2) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  const $wave = getWaves(config2.element, config2.wavesNumber).eq(config2.wave || 0);
  const durations = args.durations;
  const durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass("dx-inkripple-hiding").removeClass("dx-inkripple-showing").css("transitionDuration", durationCss);
  const animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}

// node_modules/devextreme/esm/__internal/ui/collection/item.js
var forcibleWatcher = (watchMethod, fn, callback) => {
  const filteredCallback = /* @__PURE__ */ (() => {
    let oldValue;
    return (value2) => {
      if (oldValue !== value2) {
        callback(value2, oldValue);
        oldValue = value2;
      }
    };
  })();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = class extends class_default.inherit({}) {
  ctor($element, options2, rawData) {
    this._$element = $element;
    this._options = options2;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  }
  _render() {
    const $placeholder = renderer_default("<div>").addClass("dx-item-content-placeholder");
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  }
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  }
  _startWatcher(field, render4) {
    const rawData = this._rawData;
    const exprGetter = this._options.fieldGetter(field);
    const watcher = forcibleWatcher(this._options.watchMethod(), (() => exprGetter(rawData)), ((value2, oldValue) => {
      this._dirty = true;
      render4(value2, oldValue);
    }));
    this._watchers.push(watcher);
  }
  setDataField() {
    this._dirty = false;
    each(this._watchers, ((_, watcher) => {
      watcher.force();
    }));
    return this._dirty;
  }
  _renderDisabled(value2, oldValue) {
    this._$element.toggleClass("dx-state-disabled", !!value2);
    this._$element.attr("aria-disabled", !!value2);
    this._updateOwnerFocus(value2);
  }
  _updateOwnerFocus(isDisabled) {
    const ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  }
  _renderVisible(value2, oldValue) {
    this._$element.toggleClass("dx-state-invisible", void 0 !== value2 && !value2);
  }
  _dispose() {
    each(this._watchers, ((_, watcher) => {
      watcher.dispose();
    }));
  }
  static getInstance($element) {
    return getInstanceByElement($element, this);
  }
};
var item_default = CollectionItem;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.js
var EditStrategy = class extends class_default.inherit({}) {
  constructor(collectionWidget) {
    super();
    this._collectionWidget = collectionWidget;
  }
  getIndexByItemData(value2) {
    return class_default.abstract();
  }
  getItemDataByIndex(index) {
    class_default.abstract();
  }
  getKeysByItems(items) {
    class_default.abstract();
  }
  getItemsByKeys(keys, items) {
    class_default.abstract();
  }
  itemsGetter() {
    class_default.abstract();
  }
  getKeyByIndex(index) {
    const resultIndex = this._denormalizeItemIndex(index);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  }
  _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    }
    return key1 === key2;
  }
  beginCache() {
    this._cache = {};
  }
  endCache() {
    this._cache = null;
  }
  getIndexByKey(key) {
    return class_default.abstract();
  }
  getNormalizedIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  }
  getIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  }
  getItemElement(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return renderer_default(value2);
    }
    const normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  }
  _isNode(el) {
    return dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el);
  }
  deleteItemAtIndex(index) {
    class_default.abstract();
  }
  itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    class_default.abstract();
  }
  _isNormalizedItemIndex(index) {
    return "number" === typeof index && Math.round(index) === index;
  }
  _isItemIndex(index) {
    return class_default.abstract();
  }
  _getNormalizedItemIndex(value2) {
    return class_default.abstract();
  }
  _normalizeItemIndex(index) {
    return class_default.abstract();
  }
  _denormalizeItemIndex(index) {
    return class_default.abstract();
  }
  _getItemByNormalizedIndex(value2) {
    return class_default.abstract();
  }
  _itemsFromSameParent(movingIndex, destinationIndex) {
    return class_default.abstract();
  }
};
var m_collection_widget_edit_strategy_default = EditStrategy;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.plain.js
var PlainEditStrategy = class extends m_collection_widget_edit_strategy_default {
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  }
  getIndexByItemData(itemData) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    }
    return this._getPlainItems().indexOf(itemData);
  }
  getItemDataByIndex(index) {
    return this._getPlainItems()[index];
  }
  deleteItemAtIndex(index) {
    this._getPlainItems().splice(index, 1);
  }
  itemsGetter() {
    return this._getPlainItems();
  }
  getKeysByItems(items) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let result2 = items;
    if (keyOf) {
      result2 = [];
      for (let i = 0; i < items.length; i++) {
        result2.push(keyOf(items[i]));
      }
    }
    return result2;
  }
  getIndexByKey(key) {
    const cache = this._cache;
    const keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if ("object" === typeof key) {
      for (let i = 0, {
        length
      } = keys; i < length; i++) {
        if (this._equalKeys(key, keys[i])) {
          return i;
        }
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  }
  getItemsByKeys(keys, items) {
    return (items || keys).slice();
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._getPlainItems();
    const movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  }
  _isItemIndex(index) {
    return "number" === typeof index && Math.round(index) === index;
  }
  _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  }
  _normalizeItemIndex(index) {
    return index;
  }
  _denormalizeItemIndex(index) {
    return index;
  }
  _getItemByNormalizedIndex(index) {
    return index > -1 ? this._collectionWidget._itemElements().eq(index) : null;
  }
  _itemsFromSameParent(firstIndex, secondIndex) {
    return true;
  }
};
var m_collection_widget_edit_strategy_plain_default = PlainEditStrategy;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_menu_base.edit.strategy.js
var MenuBaseEditStrategy = class extends m_collection_widget_edit_strategy_plain_default {
  _getPlainItems() {
    return map(this._collectionWidget.option("items"), (function getMenuItems(item) {
      return item.items ? [item].concat(map(item.items, getMenuItems)) : item;
    }));
  }
  _stringifyItem(item) {
    return JSON.stringify(item, ((key, value2) => {
      if ("template" === key) {
        return this._getTemplateString(value2);
      }
      return value2;
    }));
  }
  _getTemplateString(template) {
    let result2;
    if ("object" === typeof template) {
      result2 = renderer_default(template).text();
    } else {
      result2 = template.toString();
    }
    return result2;
  }
};
var m_menu_base_edit_strategy_default = MenuBaseEditStrategy;

// node_modules/devextreme/esm/__internal/core/templates/m_bindable_template.js
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  let fieldsDispose;
  const globalDispose = ((data17, watchMethod2, callback2) => watchMethod2((() => data17), callback2))(rawData, watchMethod, ((dataWithRawFields) => {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = (function(data17, watchMethod2, fields2, fieldsMap2, callback2) {
      const resolvedData = {};
      const missedFields = fields2.slice();
      const watchHandlers = fields2.map(((name2) => {
        const fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data17) : () => data17[name2], ((value2) => {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            const index = missedFields.indexOf(name2);
            if (index >= 0) {
              missedFields.splice(index, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        }));
      }));
      return function() {
        watchHandlers.forEach(((dispose) => dispose()));
      };
    })(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  }));
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
var BindableTemplate = class extends TemplateBase {
  constructor(render4, fields, watchMethod, fieldsMap) {
    super();
    this._render = render4;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options2) {
    const $container = renderer_default(options2.container);
    const dispose = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, ((data17) => {
      $container.empty();
      this._render($container, data17, options2.model);
    }));
    m_events_engine_default.on($container, removeEvent, dispose);
    return $container.contents();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_icon.js
var getImageSourceType = (source) => {
  if (!source || "string" !== typeof source) {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};
var getImageContainer = (source) => {
  switch (getImageSourceType(source)) {
    case "image":
      return renderer_default("<img>").attr("src", source).addClass("dx-icon");
    case "fontIcon":
      return renderer_default("<i>").addClass(`dx-icon ${source}`);
    case "dxIcon":
      return renderer_default("<i>").addClass(`dx-icon dx-icon-${source}`);
    case "svg":
      return renderer_default("<i>").addClass("dx-icon dx-svg-icon").append(source);
    default:
      return null;
  }
};

// node_modules/devextreme/esm/__internal/data/m_data_helper.js
var DATA_SOURCE_CHANGED_METHOD2 = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION2 = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE2 = "_normalizeDataSource";
var DataHelperMixin2 = {
  postCtor() {
    this.on("disposing", (() => {
      this._disposeDataSource();
    }));
  },
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION2 in this ? this[SPECIFIC_DATA_SOURCE_OPTION2]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE2 in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE2](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController() {
    var _this$option;
    const dataController2 = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController2) {
      this._dataController = dataController2;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  },
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD2 in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher() {
    this.readyWatcher = (function(isLoading) {
      this._ready && this._ready(!isLoading);
    }).bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = (function(e) {
      this[DATA_SOURCE_CHANGED_METHOD2](dataSource.items(), e);
    }).bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/data_helper.js
var data_helper_default = DataHelperMixin2;

// node_modules/devextreme/esm/__internal/ui/collection/collection_widget.base.js
var ITEM_CLASS = "dx-item";
var EMPTY_COLLECTION = "dx-empty-collection";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var CollectionWidget = class extends widget_default {
  _supportedKeys() {
    const move2 = (location, e) => {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return _extends({}, super._supportedKeys(), {
      space: (e) => {
        e.preventDefault();
        this._enterKeyHandler(e);
      },
      enter: this._enterKeyHandler,
      leftArrow: move2.bind(this, "left"),
      rightArrow: move2.bind(this, "right"),
      upArrow: move2.bind(this, "up"),
      downArrow: move2.bind(this, "down"),
      pageUp: move2.bind(this, "up"),
      pageDown: move2.bind(this, "down"),
      home: move2.bind(this, "first"),
      end: move2.bind(this, "last")
    });
  }
  _getHandlerExtendedParams(e, $target) {
    const params = extend({}, e, {
      target: $target.get(0),
      currentTarget: $target.get(0)
    });
    return params;
  }
  _enterKeyHandler(e) {
    const {
      focusedElement
    } = this.option();
    const $itemElement = renderer_default(focusedElement);
    if (!$itemElement.length) {
      return;
    }
    const itemData = this._getItemData($itemElement);
    if (null !== itemData && void 0 !== itemData && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler(this._getHandlerExtendedParams(e, $itemElement));
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (data17) => data17 ? data17.disabled : void 0,
      visibleExpr: (data17) => data17 ? data17.visible : void 0
    });
  }
  _init() {
    this._compileDisplayGetter();
    this._initDataController();
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS}`;
    this._cleanRenderedItems();
    this._refreshDataSource();
  }
  _compileDisplayGetter() {
    const {
      displayExpr
    } = this.option();
    this._displayGetter = displayExpr ? compileGetter(displayExpr) : void 0;
  }
  _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    super._initTemplates();
  }
  _getAnonymousTemplateName() {
    return "item";
  }
  _initDefaultItemTemplate() {
    const fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate((($container, data17) => {
        if (isPlainObject(data17)) {
          this._prepareDefaultItemTemplate(data17, $container);
        } else {
          if (fieldsMap && isFunction(fieldsMap.text)) {
            data17 = fieldsMap.text(data17);
          }
          $container.text(String(ensureDefined(data17, "")));
        }
      }), this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  }
  _getBindableFields() {
    return ["text", "html"];
  }
  _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
    return;
  }
  _prepareDefaultItemTemplate(data17, $container) {
    const {
      text,
      html
    } = data17;
    if (isDefined(text)) {
      $container.text(text);
    }
    if (isDefined(html)) {
      $container.html(html);
    }
  }
  _initItemsFromMarkup() {
    const rawItems = findTemplates(this.$element(), "dxItem");
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    const items = rawItems.map(((_ref) => {
      let {
        element,
        options: options2
      } = _ref;
      const isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
      if (isTemplateRequired) {
        options2.template = this._prepareItemTemplate(element);
      } else {
        renderer_default(element).remove();
      }
      return options2;
    }));
    this.option("items", items);
  }
  _prepareItemTemplate(item) {
    const templateId = `tmpl-${new guid_default()}`;
    const $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    this._saveTemplate(templateId, $template);
    return templateId;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  }
  _focusTarget() {
    return this.$element();
  }
  _focusInHandler(e) {
    super._focusInHandler(e);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._shouldSkipSelectOnFocus = true;
      this._setFocusedItem($focusedElement);
      this._shouldSkipSelectOnFocus = false;
    } else {
      const $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  }
  _focusOutHandler(e) {
    super._focusOutHandler(e);
    const {
      focusedElement
    } = this.option();
    const $target = renderer_default(focusedElement);
    this._updateFocusedItemState($target, false);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  }
  _getActiveItem(last) {
    const {
      focusedElement
    } = this.option();
    const $focusedElement = renderer_default(focusedElement);
    if ($focusedElement.length) {
      return $focusedElement;
    }
    return this._determineFocusedElement(last);
  }
  _determineFocusedElement(last) {
    let index = this._getFocusedElementIndex();
    const activeElements = this._getActiveElement();
    const lastIndex = activeElements.length - 1;
    if (index < 0) {
      index = last ? lastIndex : 0;
    }
    return activeElements.eq(index);
  }
  _getFocusedElementIndex() {
    return 0;
  }
  _moveFocus(location, e) {
    const $items = this._getAvailableItems();
    let $newTarget = renderer_default();
    switch (location) {
      case "pageup":
      case "up":
        $newTarget = this._prevItem($items);
        break;
      case "pagedown":
      case "down":
        $newTarget = this._nextItem($items);
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case "first":
        $newTarget = $items.first();
        break;
      case "last":
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if (0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getVisibleItems($itemElements) {
    const $items = $itemElements ?? this._itemElements();
    return $items.filter(":visible");
  }
  _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  }
  _prevItem($items) {
    const $target = this._getActiveItem();
    const targetIndex = $items.index($target);
    const $last = $items.last();
    let $item = renderer_default($items[targetIndex - 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $last;
    }
    return $item;
  }
  _nextItem($items) {
    const $target = this._getActiveItem(true);
    const targetIndex = $items.index($target);
    const $first = $items.first();
    let $item = renderer_default($items[targetIndex + 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $first;
    }
    return $item;
  }
  _selectFocusedItem($target) {
    this.selectItem($target);
  }
  _updateFocusedItemState(target, isFocused, needCleanItemId) {
    const $target = renderer_default(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  }
  _getElementClassToSkipRefreshId() {
    return "";
  }
  _shouldSkipRefreshId(target) {
    const elementClass = this._getElementClassToSkipRefreshId();
    const shouldSkipRefreshId = renderer_default(target).hasClass(elementClass);
    return shouldSkipRefreshId;
  }
  _refreshActiveDescendant($target) {
    const {
      focusedElement
    } = this.option();
    if (isDefined(focusedElement)) {
      const shouldSetExistingId = this._shouldSkipRefreshId(focusedElement);
      const id = shouldSetExistingId ? renderer_default(focusedElement).attr("id") : this.getFocusedItemId();
      this.setAria("activedescendant", id, $target);
      return;
    }
    this.setAria("activedescendant", null, $target);
  }
  _refreshItemId($target, needCleanItemId) {
    const {
      focusedElement
    } = this.option();
    const shouldSkipRefreshId = this._shouldSkipRefreshId($target);
    if (shouldSkipRefreshId) {
      return;
    }
    if (!needCleanItemId && focusedElement) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  }
  _isDisabled($element) {
    return $element && "true" === renderer_default($element).attr("aria-disabled");
  }
  _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus
    } = this.option();
    const isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled && !this._shouldSkipSelectOnFocus) {
      this._selectFocusedItem($target);
    }
  }
  _findItemElementByItem(item) {
    let result2 = renderer_default();
    const itemDataKey = this._itemDataKey();
    this.itemElements().each(((index, itemElement) => {
      const $item = renderer_default(itemElement);
      if ($item.data(itemDataKey) === item) {
        result2 = $item;
        return false;
      }
      return true;
    }));
    return result2;
  }
  _getIndexByItem(item) {
    const {
      items
    } = this.option();
    return items.indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    const isDisabling = "disabled" === property && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  }
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this._resetFocusedElement();
    }
  }
  _resetFocusedElement() {
    this.option("focusedElement", null);
  }
  _refreshItem($item, item) {
    const itemData = this._getItemData($item);
    const index = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index, itemData, null, $item);
  }
  _updateParentActiveDescendant() {
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue,
      fullName
    } = args;
    if ("items" === name2) {
      const matches = fullName.match(ITEM_PATH_REGEX);
      if (null !== matches && void 0 !== matches && matches.length) {
        const property = matches[matches.length - 1];
        const itemPath = fullName.replace(`.${property}`, "");
        const item = this.option(itemPath);
        this._itemOptionChanged(item, property, value2, previousValue);
        return;
      }
    }
    switch (name2) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(previousValue, false, true);
        this._setFocusedItem(renderer_default(value2));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _invalidate() {
    this._resetFocusedElement();
    super._invalidate();
  }
  _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  }
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  }
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  }
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  }
  _dataSourceChangedHandler(newItems, e) {
    const items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  }
  _shouldAppendItems() {
    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
  }
  _allowDynamicItemsAppend() {
    return false;
  }
  _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    if (this._inkRipple) {
      delete this._inkRipple;
    }
    this._resetActiveState();
  }
  _cleanItemContainer() {
    renderer_default(this._itemContainer()).empty();
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._itemFocusTimeout);
  }
  _refresh() {
    this._cleanRenderedItems();
    super._refresh();
  }
  _itemContainer(searchEnabled, previousSelectAllEnabled) {
    return this.$element();
  }
  _itemClass() {
    return ITEM_CLASS;
  }
  _itemContentClass() {
    return `${this._itemClass()}-content`;
  }
  _itemResponseWaitClass() {
    return "dx-item-response-wait";
  }
  _itemSelector() {
    return `.${this._itemClass()}`;
  }
  _itemDataKey() {
    return "dxItemData";
  }
  _itemIndexKey() {
    return "dxItemIndex";
  }
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  }
  _initMarkup() {
    super._initMarkup();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass("dx-collection");
    this._prepareContent();
  }
  _prepareContent() {
    deferRenderer((() => {
      this._renderContentImpl();
    }))();
  }
  _renderContent() {
    this._fireContentReadyAction();
  }
  _render() {
    super._render();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  }
  _getPointerEvent() {
    return m_pointer_default.down;
  }
  _attachClickEvent() {
    const itemSelector = this._itemSelector();
    const pointerDownEvent = m_pointer_default.down;
    const pointerUpEvent = m_pointer_default.up;
    const clickEventNamespace = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const pointerDownEventNamespace = addNamespace(pointerDownEvent, this.NAME);
    const pointerUpEventNamespace = addNamespace(pointerUpEvent, this.NAME);
    const pointerDownAction = new action_default(((args) => {
      const {
        event
      } = args;
      this._itemPointerHandler(event);
    }));
    const pointerUpAction = new action_default(((args) => {
      const {
        event
      } = args;
      this._itemPointerUpHandler(event);
    }));
    m_events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    m_events_engine_default.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);
    m_events_engine_default.off(this._itemContainer(), pointerUpEventNamespace, itemSelector);
    m_events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, ((e) => this._itemClickHandler(e)));
    m_events_engine_default.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, ((e) => {
      pointerDownAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    }));
    m_events_engine_default.on(this._itemContainer(), pointerUpEventNamespace, itemSelector, ((e) => {
      pointerUpAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    }));
  }
  _itemClickHandler(e, args, config2) {
    this._itemDXEventHandler(e, "onItemClick", args, config2);
  }
  _handleItemFocus(e) {
    if (e.isDefaultPrevented()) {
      return;
    }
    const $target = renderer_default(e.target);
    const $closestItem = $target.closest(this._itemElements());
    const $closestFocusable = this._closestFocusable($target);
    if ($closestItem.length && this._isFocusTarget(null === $closestFocusable || void 0 === $closestFocusable ? void 0 : $closestFocusable.get(0))) {
      this._shouldSkipSelectOnFocus = true;
      this.option("focusedElement", getPublicElement($closestItem));
      this._shouldSkipSelectOnFocus = false;
    }
  }
  _itemPointerHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = () => {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = void 0;
      this._handleItemFocus(e);
    };
    this._itemFocusTimeout = setTimeout((() => {
      this._forcePointerDownFocus();
    }));
  }
  _itemPointerUpHandler(e) {
  }
  _closestFocusable($target) {
    if ($target.is(focusable)) {
      return $target;
    }
    let $nextTarget = $target.parent();
    while ($nextTarget.length && !dom_adapter_default.isDocument($nextTarget.get(0)) && !dom_adapter_default.isDocumentFragment($nextTarget.get(0))) {
      if ($nextTarget.is(focusable)) {
        return $nextTarget;
      }
      $nextTarget = $nextTarget.parent();
    }
    return;
  }
  _forcePointerDownFocus() {
    if (this._itemFocusHandler) {
      this._itemFocusHandler();
    }
  }
  _updateFocusState(e, isFocused) {
    super._updateFocusState(e, isFocused);
    this._forcePointerDownFocus();
  }
  _attachHoldEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace(m_hold_default.name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  }
  _getHoldTimeout() {
    const {
      itemHoldTimeout
    } = this.option();
    return itemHoldTimeout;
  }
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  }
  _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  }
  _attachContextMenuEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace(name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  }
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  }
  _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  }
  _renderContentImpl() {
    const {
      items
    } = this.option();
    const itemsToRender = items ?? [];
    if (this._renderedItemsCount) {
      this._renderItems(itemsToRender.slice(this._renderedItemsCount));
    } else {
      this._renderItems(itemsToRender);
    }
  }
  _renderItems(items) {
    if (items.length) {
      each(items, ((index, itemData) => {
        this._renderItem(this._renderedItemsCount + index, itemData);
      }));
    }
    this._renderEmptyMessage();
  }
  _getItemsContainer() {
    return this._itemContainer();
  }
  _setAttributes($element) {
    const attributes = _extends({}, this.option("_itemAttributes"));
    const {
      class: customClassValue
    } = attributes;
    if (customClassValue) {
      const currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(" ");
    }
    $element.attr(attributes);
  }
  _renderItem(index, itemData, $container, $itemToReplace) {
    const itemIndex = (null === index || void 0 === index ? void 0 : index.item) ?? index;
    const $containerToRender = $container ?? this._getItemsContainer();
    const $itemFrame = this._renderItemFrame(itemIndex, itemData, $containerToRender, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    const $itemContent = this._getItemContent($itemFrame);
    const {
      itemTemplate
    } = this.option();
    const renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: itemTemplate
    });
    when(renderContentPromise).done((($content) => {
      this._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $content,
        itemData,
        itemIndex
      });
      this._executeItemRenderAction(index, itemData, getPublicElement($itemFrame));
    }));
    return $itemFrame;
  }
  _getItemContent($itemFrame) {
    const $itemContent = $itemFrame.find(".dx-item-content-placeholder");
    $itemContent.removeClass("dx-item-content-placeholder");
    return $itemContent;
  }
  _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    m_events_engine_default.on($itemElement, CLICK_EVENT_NAME, ((e) => {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }));
  }
  _renderItemContent(args) {
    const itemTemplateName = this._getItemTemplateName(args);
    const itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    const $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass("dx-template-wrapper")) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  }
  _renderItemContentByNode(args, $node) {
    renderer_default(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  }
  _addItemContentClasses(args) {
    const classes = [ITEM_CLASS + "-content", args.contentClass];
    renderer_default(args.container).addClass(classes.join(" "));
  }
  _appendItemToContainer($container, $itemFrame, index) {
    $itemFrame.appendTo($container);
  }
  _renderItemFrame(index, itemData, $container, $itemToReplace) {
    const $itemFrame = renderer_default("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if (null !== $itemToReplace && void 0 !== $itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index);
    }
    if (this.option("useItemTextAsTitle")) {
      const displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  }
  _itemOptions() {
    return {
      watchMethod: () => this.option("integrationOptions.watchMethod"),
      owner: this,
      fieldGetter: (field) => {
        const expr = this.option(`${field}Expr`);
        const getter = compileGetter(expr);
        return getter;
      }
    };
  }
  _postprocessRenderItem(args) {
  }
  _executeItemRenderAction(index, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index,
      itemData
    });
  }
  _setElementData(element, data17, index) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data17).data(this._itemIndexKey(), index);
  }
  _createItemRenderAction() {
    this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    return this._itemRenderAction;
  }
  _getItemRenderAction() {
    return this._itemRenderAction ?? this._createItemRenderAction();
  }
  _getItemTemplateName(args) {
    const data17 = args.itemData;
    const templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    const template = data17 && data17[templateProperty];
    return template || args.defaultTemplateName;
  }
  _createItemByTemplate(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index
    } = renderArgs;
    return itemTemplate.render({
      model: itemData,
      container,
      index,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
    };
  }
  _emptyMessageContainer() {
    return this._itemContainer();
  }
  _renderEmptyMessage(rootNodes) {
    const items = rootNodes ?? this.option("items");
    const noDataText = this.option("noDataText");
    const hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData ?? renderer_default("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option("encodeNoDataText")) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  }
  _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  }
  _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    const action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    const action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = this._closestItemElement(renderer_default(initiator));
    const args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  }
  _extendActionArgs($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  }
  _closestItemElement($element) {
    return renderer_default($element).closest(this._itemSelector());
  }
  _getItemData(itemElement) {
    return renderer_default(itemElement).data(this._itemDataKey());
  }
  _getSummaryItemsSize(dimension, items, includeMargin) {
    let result2 = 0;
    if (items) {
      each(items, ((_, item) => {
        if ("width" === dimension) {
          result2 += getOuterWidth(item, includeMargin ?? false);
        } else if ("height" === dimension) {
          result2 += getOuterHeight(item, includeMargin ?? false);
        }
      }));
    }
    return result2;
  }
  getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = `dx-${new guid_default()}`;
    }
    return this._focusedItemId;
  }
  itemElements() {
    return this._itemElements();
  }
  itemsContainer() {
    return this._itemContainer();
  }
};
CollectionWidget.include(data_helper_default);
CollectionWidget.ItemClass = item_default;
var collection_widget_base_default = CollectionWidget;

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.js
var SelectionStrategy = class {
  constructor(options2) {
    this._lastSelectAllPageDeferred = Deferred().reject();
    this.options = options2;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(name2, value2) {
    this.options[name2] = value2;
  }
  onSelectionChanging() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanging = noop
    } = this.options;
    const selectionChangingArgs = {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      cancel: false
    };
    onSelectionChanging(selectionChangingArgs);
    return selectionChangingArgs.cancel;
  }
  _callCallbackIfNotCanceled(callback, cancelCallback) {
    const cancelResult = this.onSelectionChanging();
    if (isPromise(cancelResult)) {
      cancelResult.then(((cancel) => {
        if (!cancel) {
          callback();
        } else {
          cancelCallback();
        }
      })).catch((() => {
        callback();
      }));
    } else if (!cancelResult) {
      callback();
    } else {
      cancelCallback();
    }
  }
  onSelectionChanged() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanged = noop
    } = this.options;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  }
  equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject(key1) && isObject(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  }
  getSelectableItems(items) {
    return items.filter(((item) => !(null !== item && void 0 !== item && item.disabled)));
  }
  _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  }
  _removeTemplateProperty(remoteFilter) {
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map(((f) => this._removeTemplateProperty(f)));
    }
    if (isObject(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  }
  _getQueryParams() {
    const {
      sensitivity
    } = this.options;
    if (!sensitivity) {
      return;
    }
    return {
      langParams: {
        collatorOptions: {
          sensitivity
        }
      }
    };
  }
  _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    const filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    const needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    const deferred = Deferred();
    const queryParams = this._getQueryParams();
    const loadOptions = _extends({
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    }, queryParams);
    if (remoteFilter && 0 === remoteFilter.length) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done(((items) => {
        let filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = m_query_default(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      })).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  }
  updateSelectedItemKeyHash(keys) {
    for (let i = 0; i < keys.length; i++) {
      const keyHash = getKeyHash(keys[i]);
      if (!isObject(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        const keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  }
  _isAnyItemSelected(items) {
    for (let i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  }
  _getFullSelectAllState() {
    const items = this.options.plainItems();
    const dataFilter = this.options.filter();
    let selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter(((item) => !(null !== item && void 0 !== item && item.disabled)));
    if (dataFilter) {
      selectedItems = m_query_default(selectedItems).filter(dataFilter).toArray();
    }
    const selectedItemsLength = selectedItems.length;
    const disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return;
  }
  _getVisibleSelectAllState() {
    const items = this.getSelectableItems(this.options.plainItems());
    let hasSelectedItems = false;
    let hasUnselectedItems = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemData = this.options.getItemData(item);
      const key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    }
    return false;
  }
  isItemKeySelected(itemKey) {
    throw new Error("isItemKeySelected method should be overriden");
  }
  addSelectedItem(itemKey, itemData) {
    throw new Error("addSelectedItem method should be overriden");
  }
  removeSelectedItem(itemKey) {
    throw new Error("removeSelectedItem method should be overriden");
  }
  _selectAllPlainItems(isDeselect) {
    const items = this.getSelectableItems(this.options.plainItems());
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.options.isSelectableItem(item)) {
        const itemData = this.options.getItemData(item);
        const itemKey = this.options.keyOf(itemData);
        const isSelected = this.isItemKeySelected(itemKey);
        if (!isSelected && !isDeselect) {
          this.addSelectedItem(itemKey, itemData);
        }
        if (isSelected && isDeselect) {
          this.removeSelectedItem(itemKey);
        }
      }
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.deferred.js
var DeferredStrategy = class extends SelectionStrategy {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const d = Deferred();
    const that = this;
    const key = this.options.key();
    const select = isString(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done(((items) => {
      const keys = items.map(((item) => that.options.keyOf(item)));
      d.resolve(keys);
    })).fail(d.reject);
    return d.promise();
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      const filter = this.options.filter();
      const needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (let i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  setSelectedItems(keys) {
    this._setOption("selectionFilter", null);
    for (let i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  }
  isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  }
  isItemKeySelected(itemData) {
    const {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    const queryParams = this._getQueryParams();
    return !!m_query_default([itemData], queryParams).filter(selectionFilter).toArray().length;
  }
  _getKeyExpr() {
    const keyField = this.options.key();
    if (Array.isArray(keyField) && 1 === keyField.length) {
      return keyField[0];
    }
    return keyField;
  }
  _normalizeKey(key) {
    const keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
      return key[keyExpr[0]];
    }
    return key;
  }
  _getFilterByKey(key) {
    const keyField = this._getKeyExpr();
    let filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (let i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  }
  addSelectedItem(key, isSelectAll, skipFilter) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  }
  removeSelectedItem(key) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  }
  validate() {
    const {
      key
    } = this.options;
    if (key && void 0 === key()) {
      throw ui_errors_default.Error("E1042", "Deferred selection");
    }
  }
  _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    const filterString = JSON.stringify(filter);
    for (let index = 0; index < selectionFilter.length; index++) {
      const subFilter = selectionFilter[index];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index;
      }
    }
    return -1;
  }
  _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
    }
    return false;
  }
  _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  }
  _denormalizeFilter(filter) {
    if (filter && isString(filter[0])) {
      filter = [filter];
    }
    return filter;
  }
  _isOnlyNegativeFiltersLeft(filters) {
    return filters.every(((filterItem, i) => {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && "!" === filterItem[0];
      }
      return "and" === filterItem;
    }));
  }
  _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    const that = this;
    const currentFilter = isDeselect ? ["!", filter] : filter;
    const currentOperation = isDeselect ? "and" : "or";
    let needAddFilter = true;
    let selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if (null !== (_selectionFilter = selectionFilter) && void 0 !== _selectionFilter && _selectionFilter.length && !skipFilter) {
      const removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      const filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      const shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      const isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  }
  _normalizeFilter(filter) {
    if (filter && 1 === filter.length) {
      filter = filter[0];
    }
    return filter;
  }
  _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    const operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && "and" === operation) {
      filter.splice(0, filter.length);
    }
  }
  _isSimpleKeyFilter(filter, key) {
    return 3 === filter.length && filter[0] === key && "=" === filter[1];
  }
  _isKeyFilter(filter) {
    if (2 === filter.length && "!" === filter[0]) {
      return this._isKeyFilter(filter[1]);
    }
    const keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (let i = 0; i < keyField.length; i++) {
        if (i > 0 && "and" !== filter[2 * i - 1]) {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  }
  _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (let i = filterIndex; i < selectionFilter.length; i++) {
        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    const filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    }
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
        const filterIndex2 = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
        if (filterIndex2 >= 0) {
          if (!selectionFilter[i].length) {
            this._removeFilterByIndex(selectionFilter, i, isSelectAll);
          } else if (1 === selectionFilter[i].length) {
            selectionFilter[i] = selectionFilter[i][0];
          }
          return filterIndex2;
        }
      }
    }
    return -1;
  }
  getSelectAllState() {
    const filter = this.options.filter();
    let {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
  loadSelectedItemsWithFilter() {
    const componentFilter = this.options.filter();
    const {
      selectionFilter
    } = this.options;
    const filter = componentFilter ? [componentFilter, "and", selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  }
  _onePageSelectAll(isDeselect) {
    this._selectAllPlainItems(isDeselect);
    this.onSelectionChanged();
    return Deferred().resolve();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_selection_filter.js
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    let filterExpr;
    selectedItemKeys.forEach((function(key, index) {
      filterExpr = filterExpr || [];
      let filterExprPart;
      if (index > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString(keyExpr) || isFunction(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = (function(keyExpr2, itemKeyValue) {
          const filterExpr2 = [];
          for (let i = 0, {
            length
          } = keyExpr2; i < length; i++) {
            const currentKeyExpr = keyExpr2[i];
            const keyValueGetter = compileGetter(currentKeyExpr);
            const currentKeyValue = itemKeyValue && keyValueGetter(itemKeyValue);
            const filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        })(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    }));
    if (filterExpr && 1 === filterExpr.length) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    let forceCombinedFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const filterExpr = this.getExpr(keyExpr);
    let combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  let selectedItemKeyHashesMap;
  const getSelectedItemKeyHashesMap = function(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      const normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (let i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  const normalizeKeys = function(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map(((key) => keyOf(key))) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    const key = keyOf(item);
    let keyHash;
    let i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject(keyHash)) {
        const selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (void 0 === keyValue) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.standard.js
var StandardStrategy = class extends SelectionStrategy {
  constructor(options2) {
    super(options2);
    this._lastSelectAllPageDeferred = Deferred().reject();
    this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(items, isDeselect) {
    const {
      keyOf
    } = this.options;
    let keyIndicesToRemoveMap;
    let keyIndex;
    let i;
    if (!keyOf) {
      return;
    }
    const isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  }
  _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    const selectedItemKeys = this.options.selectedItemKeys.slice(0);
    const selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (let i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let deferred = Deferred();
    const key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    let deselectedItems = [];
    if (isDeselect) {
      const {
        selectedItems
      } = this.options;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? m_query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    let filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  }
  _replaceSelectionUpdate(items) {
    const internalKeys = [];
    const {
      keyOf
    } = this.options;
    if (!keyOf) {
      return;
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  }
  _warnOnIncorrectKeys(keys) {
    const {
      allowNullValue
    } = this.options;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
        ui_errors_default.log("W1002", key);
      }
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode
    } = this.options;
    return "all" === mode || "multiple" === mode;
  }
  _requestInProgress() {
    var _this$_lastLoadDeferr;
    return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
  }
  _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    let selectedItems;
    const deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys
    };
  }
  _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    const isDeselectAll = isDeselect && isSelectAll;
    const oldRequestItems = {
      added: [],
      removed: []
    };
    const multiSelectEnabled = this._isMultiSelectEnabled();
    let lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  }
  _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    let currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = getUniqueValues(currentKeys);
    }
    return currentKeys;
  }
  _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const that = this;
    const deferred = Deferred();
    const filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always((() => {
      const currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    }));
    that._lastLoadDeferred = deferred;
    return deferred;
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    if (this._isCancelingInProgress) {
      return Deferred().reject();
    }
    const loadingDeferred = this._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    const selectionDeferred = Deferred();
    loadingDeferred.done(((items) => {
      this._storeSelectionState();
      if (preserve) {
        this._preserveSelectionUpdate(items, isDeselect);
      } else {
        this._replaceSelectionUpdate(items);
      }
      this._isCancelingInProgress = true;
      this._callCallbackIfNotCanceled((() => {
        this._isCancelingInProgress = false;
        this.onSelectionChanged();
        selectionDeferred.resolve(items);
      }), (() => {
        this._isCancelingInProgress = false;
        this._restoreSelectionState();
        selectionDeferred.reject();
      }));
    }));
    return selectionDeferred;
  }
  addSelectedItem(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (-1 === this.options.disabledItemKeys.indexOf(key)) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    const keyHash = this._getKeyHash(key);
    if (-1 === this._indexOfSelectedItemKey(keyHash)) {
      if (!isObject(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  }
  _getSelectedIndexByKey(key, ignoreIndicesMap) {
    const {
      selectedItemKeys
    } = this.options;
    for (let index = 0; index < selectedItemKeys.length; index++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
        return index;
      }
    }
    return -1;
  }
  _getSelectedIndexByHash(key, ignoreIndicesMap) {
    let indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter(((index) => !ignoreIndicesMap[index]));
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  }
  _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    let selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  }
  _shiftSelectedKeyIndices(keyIndex) {
    for (let currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      const currentKey = this.options.selectedItemKeys[currentKeyIndex];
      const currentKeyHash = getKeyHash(currentKey);
      const currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (let i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  }
  removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    const keyHash = this._getKeyHash(key);
    const isBatchDeselect = !!keyIndicesToRemoveMap;
    const keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    const keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  }
  _updateAddedItemKeys(keys, items) {
    for (let i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  }
  _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (let i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  }
  _isItemSelectionInProgress(key, checkPending) {
    const shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      const addedItems = this._lastRequestData.addedItems ?? [];
      return addedItems.includes(key);
    }
    return false;
  }
  _getKeyHash(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  }
  setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    const oldSelectedKeys = this.options.selectedItemKeys;
    const oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption("selectedItemKeys", keys);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  }
  isItemDataSelected(itemData) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options2);
  }
  isItemKeySelected(key) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    let result2 = this._isItemSelectionInProgress(key, options2.checkPending);
    if (!result2) {
      const keyHash = this._getKeyHash(key);
      const index = this._indexOfSelectedItemKey(keyHash);
      result2 = -1 !== index;
    }
    return result2;
  }
  getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    }
    return this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const keyExpr = this.options.key();
    const keys = this.getSelectedItemKeys();
    const filter = this.options.filter();
    if (!keys.length) {
      return Deferred().resolve([]);
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  }
  _storeSelectionState() {
    const {
      selectedItems,
      selectedItemKeys,
      keyHashIndices
    } = this.options;
    this._storedSelectionState = {
      keyHashIndices: JSON.stringify(keyHashIndices),
      selectedItems: [...selectedItems],
      selectedItemKeys: [...selectedItemKeys]
    };
  }
  _restoreSelectionState() {
    this._clearItemKeys();
    const {
      selectedItemKeys,
      selectedItems,
      keyHashIndices
    } = this._storedSelectionState;
    this._setOption("selectedItemKeys", selectedItemKeys);
    this._setOption("selectedItems", selectedItems);
    this._setOption("keyHashIndices", JSON.parse(keyHashIndices));
  }
  _onePageSelectAll(isDeselect) {
    if ("pending" === this._lastSelectAllPageDeferred.state()) {
      return Deferred().reject();
    }
    this._storeSelectionState();
    this._selectAllPlainItems(isDeselect);
    this._lastSelectAllPageDeferred = Deferred();
    this._callCallbackIfNotCanceled((() => {
      this.onSelectionChanged();
      this._lastSelectAllPageDeferred.resolve();
    }), (() => {
      this._restoreSelectionState();
      this._lastSelectAllPageDeferred.reject();
    }));
    return this._lastSelectAllPageDeferred;
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.js
var Selection = class {
  constructor(options2) {
    this.options = extend(this._getDefaultOptions(), options2, {
      selectedItemKeys: options2.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new DeferredStrategy(this.options) : new StandardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop,
      key: noop,
      keyOf: (item) => item,
      load: () => Deferred().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => true,
      isItemSelected: () => false,
      getItemData: (item) => item,
      dataFields: noop,
      filter: noop
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(value2) {
    if (void 0 === value2) {
      return this.options.selectionFilter;
    }
    const filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  }
  setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  }
  select(keys) {
    return this.selectedItemKeys(keys, true);
  }
  deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    keys = keys ?? [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  }
  _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  }
  _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo, _this$options;
    let isSelectedItemsChanged;
    const items = this.options.plainItems();
    const item = items[itemIndex];
    let deferred;
    const {
      isVirtualPaging: isVirtualPaging2
    } = this.options;
    const allowLoadByRange = null === (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) || void 0 === _this$options$allowLo ? void 0 : _this$options$allowLo.call(_this$options);
    const {
      alwaysSelectByShift
    } = this.options;
    let indexOffset;
    let focusedItemNotInLoadedRange = false;
    let shiftFocusedItemNotInLoadedRange = false;
    const itemIsNotInLoadedRange = (index) => index >= 0 && !items.filter(((it) => it.loadIndex === index)).length;
    if (isVirtualPaging2 && isDefined(item)) {
      if (allowLoadByRange) {
        indexOffset = item.loadIndex - itemIndex;
        itemIndex = item.loadIndex;
      }
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if (isDefined(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    const itemData = this.options.getItemData(item);
    const itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    let allowSelectByShift = keys.shift;
    if (false === alwaysSelectByShift && allowSelectByShift) {
      allowSelectByShift = false !== allowLoadByRange || !focusedItemNotInLoadedRange && !shiftFocusedItemNotInLoadedRange;
    }
    if (allowSelectByShift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
      if (allowLoadByRange && (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange)) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        const isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if ("single" === this.options.mode) {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      when(deferred).done((() => {
        this._focusedItemIndex = itemIndex;
        !setFocusOnly && this.onSelectionChanged();
      }));
      return true;
    }
  }
  isDataItem(item) {
    return this.options.isSelectableItem(item);
  }
  isSelectable() {
    return "single" === this.options.mode || "multiple" === this.options.mode;
  }
  isItemDataSelected(data17) {
    return this._selectionStrategy.isItemDataSelected(data17, {
      checkPending: true
    });
  }
  isItemSelected(arg, options2) {
    return this._selectionStrategy.isItemKeySelected(arg, options2);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    const loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    const deferred = Deferred();
    const indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done(((items) => {
      this.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    }));
    return deferred.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    let isSelectedItemsChanged = false;
    let itemIndexStep;
    const indexOffsetDefined = isDefined(indexOffset);
    let index = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    const {
      keyOf
    } = this.options;
    const focusedItem = items[index];
    const focusedData = this.options.getItemData(focusedItem);
    const focusedKey = keyOf(focusedData);
    const isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    let data17;
    let itemKey;
    let startIndex;
    let endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index = startIndex; index !== endIndex; index += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index])) {
          itemKey = keyOf(this.options.getItemData(items[index]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index = startIndex; index !== endIndex; index += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index])) {
          data17 = this.options.getItemData(items[index]);
          itemKey = keyOf(data17);
          this._addSelectedItem(data17, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(false);
    }
    return this.selectedItemKeys([], true, false, true);
  }
  deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(true);
    }
    return this.selectedItemKeys([], true, true, true);
  }
  getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
};

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.js
var NOT_EXISTING_INDEX = -1;
var indexExists = (index) => index !== NOT_EXISTING_INDEX;
var CollectionWidget2 = class extends collection_widget_base_default {
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectionMode: "none",
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      focusOnSelectedItem: true,
      selectedItem: null,
      onSelectionChanging: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  }
  ctor(element, options2) {
    this._userOptions = options2 || {};
    super.ctor(element, options2);
  }
  _init() {
    this._initEditStrategy();
    super._init();
    this._initKeyGetter();
    this._initActions();
    this._initSelectionModule();
  }
  _initKeyGetter() {
    const {
      keyExpr
    } = this.option();
    this._keyGetter = compileGetter(keyExpr);
  }
  _selectedItemClass() {
    return "dx-item-selected";
  }
  _getActionsList() {
    return ["onSelectionChanging", "onSelectionChanged"];
  }
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    actions.forEach(((action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) ?? noop;
    }));
  }
  _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  }
  _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  }
  _getKeyByIndex(index) {
    return this._editStrategy.getKeyByIndex(index);
  }
  _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  }
  _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  }
  _isKeySpecified() {
    return !!this._dataController.key();
  }
  _getCombinedFilter() {
    return this._dataController.filter();
  }
  key() {
    const {
      keyExpr
    } = this.option();
    if (keyExpr) {
      return keyExpr;
    }
    return this._dataController.key();
  }
  keyOf(item) {
    if (this.option("keyExpr")) {
      return this._keyGetter(item);
    }
    if (this._dataController.store()) {
      return this._dataController.keyOf(item);
    }
    return item;
  }
  _nullValueSelectionSupported() {
    return false;
  }
  _initSelectionModule() {
    const that = this;
    const {
      itemsGetter
    } = this._editStrategy;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanging: (args) => {
        var _this$_actions$onSele, _this$_actions;
        const isSelectionChanged = args.addedItemKeys.length || args.removedItemKeys.length;
        if (!this._rendered || !isSelectionChanged) {
          return;
        }
        const selectionChangingArgs = {
          removedItems: args.removedItems,
          addedItems: args.addedItems,
          cancel: false
        };
        null === (_this$_actions$onSele = (_this$_actions = this._actions).onSelectionChanging) || void 0 === _this$_actions$onSele || _this$_actions$onSele.call(_this$_actions, selectionChangingArgs);
        args.cancel = selectionChangingArgs.cancel;
      },
      onSelectionChanged: (args) => {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          this.option("selectedItems", this._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          this._updateSelectedItems(args);
        }
      },
      filter: this._getCombinedFilter.bind(this),
      totalCount: () => {
        const {
          items = []
        } = this.option();
        const totalCount = this._dataController.totalCount();
        return totalCount >= 0 ? totalCount : this._getItemsCount(items);
      },
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this),
      load(options2) {
        var _dataController$loadO;
        const dataController2 = that._dataController;
        options2.customQueryParams = null === (_dataController$loadO = dataController2.loadOptions()) || void 0 === _dataController$loadO ? void 0 : _dataController$loadO.customQueryParams;
        options2.userData = dataController2.userData();
        if (dataController2.store()) {
          return dataController2.loadFromStore(options2).done(((loadResult) => {
            if (that._disposed) {
              return;
            }
            const items = normalizeLoadResult(loadResult).data;
            dataController2.applyMapFunction(items);
          }));
        }
        return Deferred().resolve(this.plainItems());
      },
      dataFields: () => this._dataController.select(),
      plainItems: itemsGetter.bind(this._editStrategy)
    });
  }
  _getItemsCount(items) {
    return items.reduce(((itemsCount, item) => {
      const subItemsCount = item.items ? this._getItemsCount(item.items) : 1;
      return itemsCount + subItemsCount;
    }), 0);
  }
  _initEditStrategy() {
    this._editStrategy = new m_collection_widget_edit_strategy_plain_default(this);
  }
  _getSelectedItemIndices(keys) {
    const indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    this._editStrategy.beginCache();
    each(keys, ((_, key) => {
      const selectedIndex = this._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    }));
    this._editStrategy.endCache();
    return indices;
  }
  _initMarkup() {
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done((() => this._normalizeSelectedItems()));
    }
    super._initMarkup();
  }
  _render() {
    super._render();
    this._rendering = false;
  }
  _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    super._fireContentReadyAction();
  }
  _syncSelectionOptions(byOption) {
    byOption = byOption ?? this._chooseSelectOption();
    let selectedItem;
    let selectedIndex;
    let selectedItemKeys;
    let selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          const selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return Deferred().resolve().promise();
  }
  _chooseSelectOption() {
    let optionName = "selectedIndex";
    const isOptionDefined = (name2) => {
      const optionValue = this.option(name2);
      const length = isDefined(optionValue) && optionValue.length;
      return length || name2 in this._userOptions;
    };
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  }
  _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (let i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  }
  _normalizeSelectedItems() {
    const {
      selectionMode,
      selectedItems = [],
      items
    } = this.option();
    if ("none" === selectionMode) {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if ("single" === selectionMode) {
      const newSelection = selectedItems ?? [];
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && items && items.length) {
        const currentSelection = this._selection.getSelectedItems();
        let normalizedSelection = newSelection[0] ?? currentSelection[0];
        if (void 0 === normalizedSelection) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(newSelection));
    } else {
      const newKeys = this._getKeysByItems(selectedItems);
      const oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return Deferred().resolve().promise();
  }
  _itemClickHandler(e, args, config2) {
    let itemSelectPromise = Deferred().resolve();
    this._createAction(((e2) => {
      itemSelectPromise = this._itemSelectHandler(e2.event) ?? itemSelectPromise;
    }), {
      validatingTargetName: "itemElement"
    })({
      itemElement: renderer_default(e.currentTarget),
      event: e
    });
    itemSelectPromise.always((() => {
      super._itemClickHandler(e, args, config2);
    }));
  }
  _itemSelectHandler(e, shouldIgnoreSelectByClick) {
    if (!shouldIgnoreSelectByClick && !this.option("selectByClick")) {
      return;
    }
    const $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      const itemSelectPromise = this.selectItem(e.currentTarget);
      return null === itemSelectPromise || void 0 === itemSelectPromise ? void 0 : itemSelectPromise.promise();
    }
  }
  _selectedItemElement(index) {
    return this._itemElements().eq(index);
  }
  _postprocessRenderItem(args) {
    const {
      selectionMode
    } = this.option();
    if ("none" !== selectionMode) {
      const $itemElement = renderer_default(args.itemElement);
      const normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      const isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  }
  _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  }
  _updateSelectedItems(args) {
    const {
      addedItemKeys,
      removedItemKeys
    } = args;
    if (this._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      if (!this._rendering) {
        const addedSelection = [];
        const removedSelection = [];
        this._editStrategy.beginCache();
        for (let i = 0; i < addedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          this._addSelection(normalizedIndex);
        }
        for (let i = 0; i < removedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(removedItemKeys[i]);
          removedSelection.push(normalizedIndex);
          this._removeSelection(normalizedIndex);
        }
        this._editStrategy.endCache();
        this._updateSelection(addedSelection, removedSelection);
      }
      this._actions.onSelectionChanged({
        addedItems: args.addedItems,
        removedItems: args.removedItems
      });
    }
  }
  _updateSelection(addedSelection, removedSelection) {
  }
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("selected", value2, $target);
  }
  _getFocusedElementIndex() {
    const {
      focusOnSelectedItem
    } = this.option();
    return focusOnSelectedItem ? this._getFlatIndex() : super._getFocusedElementIndex();
  }
  _getFlatIndex() {
    const {
      selectedIndex = NOT_EXISTING_INDEX
    } = this.option();
    return selectedIndex;
  }
  _removeSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", false);
    }
  }
  _addSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", true);
    }
  }
  _isItemSelected(index) {
    const key = this._getKeyByIndex(index);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        super._optionChanged(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done((() => this._normalizeSelectedItems()));
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "onSelectionChanging":
      case "onSelectionChanged":
        this._initActions();
        break;
      case "selectByClick":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
      case "focusOnSelectedItem":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  }
  _waitDeletingPrepare($itemElement) {
    if ($itemElement.data("dxItemDeleting")) {
      return Deferred().resolve().promise();
    }
    $itemElement.data("dxItemDeleting", true);
    const deferred = Deferred();
    const deletingActionArgs = {
      cancel: false
    };
    const deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always((function(value2) {
      const deletePromiseExists = !deletePromise;
      const deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
      const argumentsSpecified = !!arguments.length;
      const shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always((() => {
        $itemElement.data("dxItemDeleting", false);
      })).done(((cancel) => {
        if (shouldDelete && !cancel) {
          deferred.resolve();
        } else {
          deferred.reject();
        }
      })).fail(deferred.reject);
    }));
    return deferred.promise();
  }
  _deleteItemFromDS($item) {
    const dataController2 = this._dataController;
    const deferred = Deferred();
    const disabledState = this.option("disabled");
    const dataStore = dataController2.store();
    if (!dataStore) {
      return Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw ui_errors_default.Error("E1011");
    }
    this.option("disabled", true);
    dataStore.remove(dataController2.keyOf(this._getItemData($item))).done(((key) => {
      if (void 0 !== key) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    })).fail((() => {
      deferred.reject();
    }));
    deferred.always((() => {
      this.option("disabled", disabledState);
    }));
    return deferred;
  }
  _tryRefreshLastPage() {
    const deferred = Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done((() => {
        deferred.resolve();
      }));
    }
    return deferred.promise();
  }
  _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  }
  _updateSelectionAfterDelete(index) {
    const key = this._getKeyByIndex(index);
    this._selection.deselect([key]);
  }
  _updateIndicesAfterIndex(index) {
    const itemElements = this._itemElements();
    for (let i = index + 1; i < itemElements.length; i += 1) {
      renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  }
  _simulateOptionChange(optionName) {
    var _this$_optionChangedA;
    const optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    null === (_this$_optionChangedA = this._optionChangedAction) || void 0 === _this$_optionChangedA || _this$_optionChangedA.call(this, {
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  }
  isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  }
  selectItem(itemElement) {
    const {
      selectionMode
    } = this.option();
    if ("none" === selectionMode) {
      return Deferred().resolve();
    }
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return Deferred().resolve();
    }
    const key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return Deferred().resolve();
    }
    if ("single" === selectionMode) {
      return this._selection.setSelection([key]);
    }
    const {
      selectedItemKeys
    } = this.option();
    return this._selection.setSelection([...selectedItemKeys ?? [], key], [key]);
  }
  unselectItem(itemElement) {
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  }
  _deleteItemElementByIndex(index) {
    this._updateSelectionAfterDelete(index);
    this._updateIndicesAfterIndex(index);
    this._editStrategy.deleteItemAtIndex(index);
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  }
  deleteItem(itemElement) {
    const deferred = Deferred();
    const $item = this._editStrategy.getItemElement(itemElement);
    const index = this._editStrategy.getNormalizedIndex(itemElement);
    const itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index)) {
      this._waitDeletingPrepare($item).done((() => {
        $item.addClass(itemResponseWaitClass);
        const deletedActionArgs = this._extendActionArgs($item);
        this._deleteItemFromDS($item).done((() => {
          this._deleteItemElementByIndex(index);
          this._afterItemElementDeleted($item, deletedActionArgs);
          this._tryRefreshLastPage().done((() => {
            deferred.resolveWith(this);
          }));
        })).fail((() => {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(this);
        }));
      })).fail((() => {
        deferred.rejectWith(this);
      }));
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise();
  }
  reorderItem(itemElement, toItemElement) {
    const deferred = Deferred();
    const strategy = this._editStrategy;
    const $movingItem = strategy.getItemElement(itemElement);
    const $destinationItem = strategy.getItemElement(toItemElement);
    const movingIndex = strategy.getNormalizedIndex(itemElement);
    const destinationIndex = strategy.getNormalizedIndex(toItemElement);
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    const canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done((() => {
      $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      this.option("selectedItems", this._getItemsByKeys(this._selection.getSelectedItemKeys(), this._selection.getSelectedItems()));
      if ("items" === changingOption) {
        this._simulateOptionChange(changingOption);
      }
      this._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy.getIndex(movingIndex),
        toIndex: strategy.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    }));
  }
};
var m_collection_widget_edit_default = CollectionWidget2;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.async.js
var CollectionWidgetAsync = class extends m_collection_widget_edit_default {
  _initMarkup() {
    this._asyncTemplateItemsMap = {};
    super._initMarkup();
  }
  _render() {
    super._render();
    this._planPostRenderActions();
  }
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const itemDeferred = Deferred();
    const uniqueKey = `dx${new guid_default()}`;
    this._asyncTemplateItemsMap[uniqueKey] = itemDeferred;
    const $itemContent = super._renderItemContent(_extends({}, args, {
      uniqueKey
    }));
    itemDeferred.done((() => {
      renderContentDeferred.resolve($itemContent);
    }));
    return renderContentDeferred.promise();
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
      const {
        uniqueKey
      } = renderArgs;
      if (uniqueKey) {
        var _this$_asyncTemplateI;
        null === (_this$_asyncTemplateI = this._asyncTemplateItemsMap[uniqueKey]) || void 0 === _this$_asyncTemplateI || _this$_asyncTemplateI.resolve();
      }
    };
  }
  _postProcessRenderItems() {
  }
  _planPostRenderActions() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const d = Deferred();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    when.apply(this, asyncTemplateItems).done((() => {
      this._postProcessRenderItems(...args);
      d.resolve().done((() => {
        this._asyncTemplateItemsMap = {};
      }));
    }));
    return d.promise();
  }
  _clean() {
    super._clean();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    asyncTemplateItems.forEach(((item) => {
      item.reject();
    }));
    this._asyncTemplateItemsMap = {};
  }
};
var m_collection_widget_async_default = CollectionWidgetAsync;

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js
var ui_collection_widget_async_default = m_collection_widget_async_default;

// node_modules/devextreme/esm/__internal/core/m_resize_observer.js
var window2 = m_window_default.getWindow();
var ResizeObserverMock = {
  observe: noop,
  unobserve: noop,
  disconnect: noop
};
var ResizeObserverSingleton = class {
  constructor() {
    if (!m_window_default.hasWindow() || !window2.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = /* @__PURE__ */ new Map();
    this._observer = new window2.ResizeObserver(((entries) => {
      entries.forEach(((entry) => {
        var _this$_callbacksMap$g;
        null === (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) || void 0 === _this$_callbacksMap$g || _this$_callbacksMap$g(entry);
      }));
    }));
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
};
var resizeObserverSingleton = new ResizeObserverSingleton();

// node_modules/devextreme/esm/core/resize_observer.js
var resize_observer_default = resizeObserverSingleton;

// node_modules/devextreme/esm/__internal/ui/m_validation_engine.js
var EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var BaseRuleValidator = class {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}`)(value2);
  }
  defaultFormattedMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}-formatted`)(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    let result2 = true;
    if (valueArray.length) {
      valueArray.every(((itemValue) => {
        result2 = this._validate(itemValue, rule);
        return result2;
      }));
    } else {
      result2 = this._validate(null, rule);
    }
    return result2;
  }
};
var RequiredRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (false === value2) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return "" !== value2;
  }
};
var NumericRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString(value2)) {
      return !isNaN(number_default.parse(value2));
    }
    return isNumeric(value2);
  }
};
var RangeRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value2, rule);
    const validValue = isDefined(value2) && "" !== value2;
    const number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if (isDefined(max)) {
      return number <= max;
    }
    throw errors_default.Error("E0101");
  }
};
var StringLengthRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    value2 = String(value2 ?? "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
};
var CustomRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
};
var AsyncRuleValidator = class extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!isPromise(callbackResult)) {
      throw errors_default.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = Deferred();
    promise.then(((res) => {
      deferred.resolve(res);
    }), ((err) => {
      const res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString(err)) {
          res.message = err;
        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    }));
    return deferred.promise();
  }
};
var CompareRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors_default.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
};
var PatternRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if (isString(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
};
var EmailRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
};
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = class extends class_default.inherit({}) {
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  }
  validate() {
    const result2 = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, ((_, validator) => {
      const validatorResult = validator.validate();
      result2.isValid = result2.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
      }
      result2.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    }));
    if (this._pendingValidators.length) {
      result2.status = STATUS.pending;
    } else {
      result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result2);
    }
    this._updateValidationInfo(result2);
    return extend({}, this._validationInfo.result);
  }
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, ((_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    }));
  }
  _updateValidationInfo(result2) {
    this._validationInfo.result = result2;
    if (result2.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  }
  _addPendingValidator(validator) {
    const foundValidator = grep(this._pendingValidators, ((val) => val === validator))[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  }
  _removePendingValidator(validator) {
    const index = this._pendingValidators.indexOf(validator);
    if (index >= 0) {
      this._pendingValidators.splice(index, 1);
    }
  }
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    each(this.validators, ((_, validator) => {
      const foundRules = grep(brokenRules, ((rule) => rule.validator === validator));
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    }));
    return orderedRules;
  }
  _updateBrokenRules(result2) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = grep(brokenRules, ((rule) => rule.validator !== result2.validator));
    if (result2.brokenRules) {
      brokenRules = rules.concat(result2.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  }
  _onValidatorStatusChanged(result2) {
    if (result2.status === STATUS.pending) {
      this._addPendingValidator(result2.validator);
      return;
    }
    this._resolveIfComplete(result2);
  }
  _resolveIfComplete(result2) {
    this._removePendingValidator(result2.validator);
    this._updateBrokenRules(result2);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = extend({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout((() => {
        deferred.resolve(res);
      }));
    }
  }
  _raiseValidatedEvent(result2) {
    this._eventsStrategy.fireEvent("validated", [result2]);
  }
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  }
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  }
  removeRegisteredValidator(validator) {
    const index = this.validators.indexOf(validator);
    if (index > -1) {
      this.validators.splice(index, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  }
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  }
  reset() {
    each(this.validators, ((_, validator) => {
      validator.reset();
    }));
    this._pendingValidators = [];
    this._resetValidationInfo();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result2 = grep(this.groups, ((config2) => config2.group === group));
    if (result2.length) {
      return result2[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes("dxValidationGroup");
    const validationGroup = hasValidationGroup && $element.dxValidationGroup("instance");
    if (validationGroup) {
      return validationGroup;
    }
    const $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(void 0, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    let config2 = this.getGroupConfig(group);
    if (!config2) {
      config2 = new GroupConfig(group, isRemovable);
      this.groups.push(config2);
    }
    return config2;
  },
  removeGroup(group) {
    const config2 = this.getGroupConfig(group);
    const index = this.groups.indexOf(config2);
    if (index > -1) {
      this.groups.splice(index, 1);
    }
    return config2;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result: result2,
      rule
    } = info;
    if (!result2.brokenRule) {
      result2.brokenRule = rule;
    }
    if (!result2.brokenRules) {
      result2.brokenRules = [];
    }
    result2.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    let result2 = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    each(rules || [], ((_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result2.isValid = false;
            this._addBrokenRule({
              result: result2,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if ("async" === rule.type) {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result2.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result: result2,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors_default.Error("E0100");
      }
    }));
    if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
      result2 = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result: result2,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result2);
    result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  _synchronizeGroupValidationInfo(validator, result2) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result2.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result: result2,
      value: value2,
      items,
      name: name2
    } = _ref;
    const asyncResults = [];
    each(items, ((_, item) => {
      const validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result2.pendingRules) {
          result2.pendingRules = [];
        }
        result2.pendingRules.push(item.rule);
        const asyncResult = validateResult.then(((res) => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        }));
        asyncResults.push(asyncResult);
      }
    }));
    if (asyncResults.length) {
      result2.complete = Promise.all(asyncResults).then(((values) => this._getAsyncRulesResult({
        result: result2,
        values
      })));
    }
    return result2;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result2;
    if (isObject(ruleResult)) {
      result2 = extend({}, ruleResult);
      if (!isDefined(result2.isValid)) {
        result2.isValid = true;
      }
    } else {
      result2 = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result2;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result: result2
    } = _ref3;
    each(values, ((index, val) => {
      if (false === val.isValid) {
        result2.isValid = val.isValid;
        const rule = result2.pendingRules[index];
        this._addBrokenRule({
          result: result2,
          rule
        });
      }
    }));
    result2.pendingRules = null;
    result2.complete = null;
    result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config2 = ValidationEngine.getGroupConfig(group);
    if (config2) {
      config2.removeRegisteredValidator.call(config2, validator);
      const validatorsInGroup = config2.validators;
      const isRemovable = config2._isRemovable;
      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options2) {
    const initedOptions = {};
    if (options2) {
      const syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
      syncOptions.forEach(((prop) => {
        if (prop in options2) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options2[prop]
          }, options2));
        }
      }));
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options2) {
    let {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus": {
        const isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options2.isValid !== isValid ? {
          isValid
        } : {};
      }
      case "isValid": {
        const {
          validationStatus
        } = options2;
        let newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      }
      case "validationErrors": {
        const validationError = !(null !== value2 && void 0 !== value2 && value2.length) ? null : value2[0];
        return options2.validationError !== validationError ? {
          validationError
        } : {};
      }
      case "validationError": {
        const {
          validationErrors
        } = options2;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        }
        if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        }
        if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
      }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var m_validation_engine_default = ValidationEngine;

// node_modules/devextreme/esm/ui/validation_engine.js
var validation_engine_default = m_validation_engine_default;

// node_modules/devextreme/esm/__internal/ui/m_validation_message.js
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var ValidationMessage = class extends m_overlay_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: "auto",
      height: "auto",
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      container: this.$element(),
      mode: "auto",
      preventScrollEvents: false,
      positionSide: "top",
      offset: {
        h: 0,
        v: 0
      }
    });
  }
  _init() {
    super._init();
    this.updateMaxWidth();
    this._updatePosition();
  }
  _initMarkup() {
    super._initMarkup();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  }
  _updatePositionByTarget() {
    const {
      target
    } = this.option();
    this.option("position.of", target);
  }
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const shouldShowMessage = this.option("visible") && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  }
  _toggleVisibilityClasses(visible) {
    if (visible) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  }
  _updateContentId() {
    const {
      container,
      contentId
    } = this.option();
    const id = contentId ?? renderer_default(container).attr("aria-describedby");
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", id);
  }
  _renderInnerHtml(element) {
    const $element = element && renderer_default(element);
    null === $element || void 0 === $element || $element.html(this._textMarkup);
  }
  _getTextMarkup() {
    const validationErrors = this.option("validationErrors") ?? [];
    let validationErrorMessage = "";
    validationErrors.forEach(((err) => {
      const separator = validationErrorMessage ? "<br />" : "";
      validationErrorMessage += separator + encodeHtml((null === err || void 0 === err ? void 0 : err.message) ?? "");
    }));
    return validationErrorMessage;
  }
  _toggleModeClass() {
    const {
      mode
    } = this.option();
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode);
  }
  updateMaxWidth() {
    const target = this.option("target");
    const targetWidth = getOuterWidth(target);
    let maxWidth = "100%";
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, 100);
    }
    this.option({
      maxWidth
    });
  }
  _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case "top":
        return [`${rtlSide} bottom`, `${rtlSide} top`];
      case "left":
        return ["right", "left"];
      case "right":
        return ["left", "right"];
      default:
        return [`${rtlSide} top`, `${rtlSide} bottom`];
    }
  }
  _updatePosition() {
    const {
      positionSide,
      rtlEnabled,
      offset: componentOffset,
      boundary
    } = this.option();
    const rtlSide = getDefaultAlignment(rtlEnabled);
    const positions = this._getPositionsArray(positionSide, rtlSide);
    const offset = _extends({}, componentOffset);
    this.$element().addClass(`dx-invalid-message-${positionSide}`);
    if (rtlEnabled && "left" !== positionSide && "right" !== positionSide) {
      offset.h = -offset.h;
    }
    if ("top" === positionSide) {
      offset.v = -offset.v;
    }
    if ("left" === positionSide) {
      offset.h = -offset.h;
    }
    this.option("position", {
      offset,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: "none flip"
    });
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "target":
        this._updatePositionByTarget();
        this.updateMaxWidth();
        super._optionChanged(args);
        break;
      case "boundary":
        this.option("position.boundary", value2);
        break;
      case "mode":
        this._toggleModeClass();
        break;
      case "rtlEnabled":
      case "offset":
      case "positionSide":
        this.$element().removeClass(`dx-invalid-message-${previousValue}`);
        this._updatePosition();
        break;
      case "container":
        this._updateContentId();
        super._optionChanged(args);
        break;
      case "contentId":
        this._updateContentId();
        break;
      case "validationErrors":
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxValidationMessage", ValidationMessage);
var m_validation_message_default = ValidationMessage;

// node_modules/devextreme/esm/ui/validation_message.js
var validation_message_default = m_validation_message_default;

// node_modules/devextreme/esm/__internal/ui/editor/editor.js
var INVALID_MESSAGE_AUTO2 = "dx-invalid-message-auto";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: "mode",
  validationMessagePosition: "positionSide",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
var Editor = class extends widget_default {
  ctor(element, options2) {
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    super.ctor(element, options2);
  }
  _createElement(element) {
    super._createElement(element);
    const $element = this.$element();
    if ($element) {
      data($element[0], VALIDATION_TARGET, this);
    }
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _init() {
    this._initialValue = this.option("value");
    super._init();
    const {
      validationTooltipOptions
    } = this.option();
    this._options.cache("validationTooltipOptions", validationTooltipOptions);
    const $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: "valid",
      validationMessageMode: "auto",
      validationMessagePosition: "bottom",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  }
  _attachKeyboardEvents() {
    if (!this.option("readOnly")) {
      super._attachKeyboardEvents();
    }
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationError: true
    });
  }
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  }
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  }
  _initMarkup() {
    this._toggleReadOnlyState();
    const {
      name: name2,
      _onMarkupRendered: markupRendered
    } = this.option();
    this._setSubmitElementName(name2);
    super._initMarkup();
    this._renderValidationState();
    null === markupRendered || void 0 === markupRendered || markupRendered();
  }
  _raiseValueChangeAction(value2, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
  }
  _valueChangeArgs(value2, previousValue) {
    return {
      value: value2,
      previousValue,
      event: this._valueChangeEventInstance
    };
  }
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  }
  _focusInHandler(e) {
    const {
      validationMessageMode
    } = this.option();
    const isValidationMessageShownOnFocus = "auto" === validationMessageMode;
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      const $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
      null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO2);
      clearTimeout(this.showValidationMessageTimeout);
      this.showValidationMessageTimeout = setTimeout((() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO2)), 150);
    }
    super._focusInHandler(e);
  }
  _canValueBeChangedByClick() {
    return false;
  }
  _getStylingModePrefix() {
    return "dx-editor-";
  }
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    const prefix = this._getStylingModePrefix();
    const allowedStylingClasses = ALLOWED_STYLING_MODES.map(((mode) => prefix + mode));
    allowedStylingClasses.forEach(((className) => this.$element().removeClass(className)));
    let stylingModeClass = prefix + String(stylingMode);
    if (!allowedStylingClasses.includes(stylingModeClass)) {
      const optionName = "stylingMode";
      const defaultOptionValue = this._getDefaultOptions()[optionName];
      const platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];
      stylingModeClass = prefix + (platformOptionValue ?? defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  }
  _getValidationErrors() {
    let {
      validationErrors
    } = this.option();
    const {
      validationError
    } = this.option();
    if (!validationErrors && validationError) {
      validationErrors = [validationError];
    }
    return validationErrors;
  }
  _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria("describedby", null);
      this._$validationMessage = void 0;
      this._validationMessage = void 0;
    }
  }
  _toggleValidationClasses(isInvalid3) {
    this.$element().toggleClass("dx-invalid", isInvalid3);
    this.setAria("invalid", isInvalid3 || void 0);
  }
  _renderValidationState() {
    const {
      validationStatus,
      _showValidationMessage: showValidationMessage
    } = this.option();
    const isValid = this.option("isValid") && "invalid" !== validationStatus;
    const validationErrors = this._getValidationErrors();
    const $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!hasWindow() || !showValidationMessage) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      const {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = renderer_default("<div>").appendTo($element);
      const validationMessageContentId = `dx-${new guid_default()}`;
      this.setAria("describedby", validationMessageContentId);
      this._validationMessage = new validation_message_default(this._$validationMessage, extend({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache("validationTooltipOptions")));
      this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  }
  _getValidationMessagePosition() {
    const {
      validationMessagePosition
    } = this.option();
    return validationMessagePosition;
  }
  _getValidationMessageTarget() {
    return this.$element();
  }
  _toggleReadOnlyState() {
    const {
      readOnly
    } = this.option();
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass("dx-state-readonly", !!readOnly);
    this._setAriaReadonly(readOnly);
  }
  _setAriaReadonly(readOnly) {
    this.setAria("readonly", readOnly || void 0);
  }
  _toggleBackspaceHandler(isReadOnly) {
    const $eventTarget = this._keyboardEventBindingTarget();
    const eventName = addNamespace("keydown", "editorReadOnly");
    m_events_engine_default.off($eventTarget, eventName);
    if (isReadOnly) {
      m_events_engine_default.on($eventTarget, eventName, ((e) => {
        if ("backspace" === normalizeKeyName(e)) {
          e.preventDefault();
        }
      }));
    }
  }
  _dispose() {
    const element = this.$element()[0];
    data(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    super._dispose();
  }
  _setSubmitElementName(name2) {
    const $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name2 && name2.length > 0) {
      $submitElement.attr("name", name2);
    } else {
      $submitElement.removeAttr("name");
    }
  }
  _getSubmitElement() {
    return null;
  }
  _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    let {
      name: name2,
      value: value2
    } = _ref;
    const optionKey = VALIDATION_MESSAGE_KEYS_MAP[String(name2)] ? VALIDATION_MESSAGE_KEYS_MAP[String(name2)] : name2;
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option(optionKey, value2);
  }
  _hasActiveElement() {
    return false;
  }
  _optionChanged(args) {
    var _this$_validationMess3;
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case "value":
        if (value2 != previousValue) {
          this.option("isDirty", this._initialValue !== value2);
          this.validationRequest.fire({
            value: value2,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(value2, previousValue);
          this._saveValueChangeEvent(void 0);
        }
        break;
      case "width":
        super._optionChanged(args);
        null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 || _this$_validationMess3.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(value2);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessagePosition":
      case "validationMessageOffset":
        this._setValidationMessageOption(args);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(args);
        super._optionChanged(args);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case "_showValidationMessage":
      case "isDirty":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _resetToInitialValue() {
    this.option("value", this._initialValue);
  }
  blur() {
    if (this._hasActiveElement()) {
      m_dom_default.resetActiveElement();
    }
  }
  clear() {
    const defaultOptions3 = this._getDefaultOptions();
    this.option("value", defaultOptions3.value);
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this._resetToInitialValue();
    this.option("isDirty", false);
    this.option("isValid", true);
  }
};
Editor.isEditor = (instance) => instance instanceof Editor;
var editor_default = Editor;

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_button.js
var TextEditorButton = class {
  constructor(name2, editor, options2) {
    this.instance = null;
    this.$container = null;
    this.$placeMarker = null;
    this.editor = editor;
    this.name = name2;
    this.options = options2 || {};
  }
  _addPlaceMarker($container) {
    this.$placeMarker = renderer_default("<div>").appendTo($container);
  }
  _addToContainer($element) {
    const {
      $placeMarker,
      $container
    } = this;
    if ($placeMarker) {
      $placeMarker.replaceWith($element);
    } else {
      $element.appendTo($container);
    }
  }
  _attachEvents(instance, $element) {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    const {
      editor,
      options: options2
    } = this;
    return options2.visible || !editor.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    const {
      instance,
      $placeMarker
    } = this;
    if (instance) {
      if (instance.dispose) {
        instance.dispose();
      } else {
        instance.remove();
      }
      this.instance = null;
    }
    $placeMarker && $placeMarker.remove();
  }
  render() {
    let $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
    this.$container = $container;
    if (this._isVisible()) {
      const {
        instance,
        $element
      } = this._create();
      this.instance = instance;
      this._attachEvents(instance, $element);
    } else {
      this._addPlaceMarker($container);
    }
  }
  update() {
    if (this._shouldRender()) {
      this.render();
    }
    return !!this.instance;
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.clear.js
var pointerDown = m_pointer_default.down;
var ClearButton = class extends TextEditorButton {
  _create() {
    const $element = renderer_default("<span>").addClass("dx-clear-button-area").append(renderer_default("<span>").addClass("dx-icon").addClass("dx-icon-clear"));
    this._addToContainer($element);
    this.update(true);
    return {
      instance: $element,
      $element
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor._isClearButtonVisible();
  }
  _attachEvents(instance, $button) {
    const {
      editor
    } = this;
    const editorName = editor.NAME;
    m_events_engine_default.on($button, addNamespace(pointerDown, editorName), ((e) => {
      e.preventDefault();
      if ("mouse" !== e.pointerType) {
        editor._clearValueHandler(e);
      }
    }));
    m_events_engine_default.on($button, addNamespace(CLICK_EVENT_NAME, editorName), ((e) => editor._clearValueHandler(e)));
  }
  _legacyRender($editor, isVisible) {
    $editor.toggleClass("dx-show-clear-button", isVisible);
  }
  update() {
    let rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!rendered) {
      super.update();
    }
    const {
      editor,
      instance
    } = this;
    const $editor = editor.$element();
    const isVisible = this._isVisible();
    if (instance) {
      instance.toggleClass("dx-state-invisible", !isVisible);
    }
    this._legacyRender($editor, isVisible);
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.label.js
var TextEditorLabel = class {
  constructor(props) {
    this.NAME = "dxLabel";
    this._props = props;
    this._id = `dx-texteditor-label-${new guid_default()}`;
    this._render();
    this._toggleMarkupVisibility();
  }
  _isVisible() {
    return !!this._props.text && "hidden" !== this._props.mode;
  }
  _render() {
    this._$before = renderer_default("<div>").addClass("dx-label-before");
    this._$labelSpan = renderer_default("<span>");
    this._$label = renderer_default("<div>").addClass("dx-label").append(this._$labelSpan);
    this._$after = renderer_default("<div>").addClass("dx-label-after");
    this._$root = renderer_default("<div>").addClass("dx-texteditor-label").attr("id", this._id).append(this._$before).append(this._$label).append(this._$after);
    this._updateMark();
    this._updateText();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  _toggleMarkupVisibility() {
    const visible = this._isVisible();
    this._updateEditorBeforeButtonsClass(visible);
    this._updateEditorLabelClass(visible);
    visible ? this._$root.appendTo(this._props.$editor) : this._$root.detach();
    this._attachEvents();
  }
  _attachEvents() {
    const clickEventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const hoverStartEventName = addNamespace(HOVERSTART, this.NAME);
    const activeEventName = addNamespace(ACTIVE_EVENT_NAME, this.NAME);
    m_events_engine_default.off(this._$labelSpan, clickEventName);
    m_events_engine_default.off(this._$labelSpan, hoverStartEventName);
    m_events_engine_default.off(this._$labelSpan, activeEventName);
    if (this._isVisible() && this._isOutsideMode()) {
      m_events_engine_default.on(this._$labelSpan, clickEventName, ((e) => {
        const selectedText = getWindow().getSelection().toString();
        if ("" === selectedText) {
          this._props.onClickHandler();
          e.preventDefault();
        }
      }));
      m_events_engine_default.on(this._$labelSpan, hoverStartEventName, ((e) => {
        this._props.onHoverHandler(e);
      }));
      m_events_engine_default.on(this._$labelSpan, activeEventName, ((e) => {
        this._props.onActiveHandler(e);
      }));
    }
  }
  _updateEditorLabelClass(visible) {
    this._props.$editor.removeClass("dx-texteditor-with-floating-label").removeClass("dx-texteditor-label-outside").removeClass("dx-texteditor-with-label");
    if (visible) {
      const labelClass = "floating" === this._props.mode ? "dx-texteditor-with-floating-label" : "dx-texteditor-with-label";
      this._props.$editor.addClass(labelClass);
      if (this._isOutsideMode()) {
        this._props.$editor.addClass("dx-texteditor-label-outside");
      }
    }
  }
  _isOutsideMode() {
    return "outside" === this._props.mode;
  }
  _updateEditorBeforeButtonsClass() {
    let visible = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible();
    this._props.$editor.removeClass("dx-texteditor-with-before-buttons");
    if (visible) {
      const beforeButtonsClass = this._props.containsButtonsBefore ? "dx-texteditor-with-before-buttons" : "";
      this._props.$editor.addClass(beforeButtonsClass);
    }
  }
  _updateMark() {
    this._$labelSpan.attr("data-mark", this._props.mark);
  }
  _updateText() {
    this._$labelSpan.text(this._props.text);
  }
  _updateBeforeWidth() {
    if (this._isVisible()) {
      const width = this._props.beforeWidth ?? this._props.getBeforeWidth();
      this._$before.css({
        width
      });
      this._updateLabelTransform();
    }
  }
  _updateLabelTransform() {
    let offset = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    this._$labelSpan.css("transform", "");
    if (this._isVisible() && this._isOutsideMode()) {
      const sign2 = this._props.rtlEnabled ? 1 : -1;
      const labelTranslateX = sign2 * (getWidth(this._$before) + offset);
      this._$labelSpan.css("transform", `translateX(${labelTranslateX}px)`);
    }
  }
  _updateMaxWidth() {
    if (this._isVisible() && !this._isOutsideMode()) {
      const maxWidth = this._props.containerWidth ?? this._props.getContainerWidth();
      this._$label.css({
        maxWidth
      });
    }
  }
  $element() {
    return this._$root;
  }
  isVisible() {
    return this._isVisible();
  }
  getId() {
    if (this._isVisible()) {
      return this._id;
    }
  }
  updateMode(mode) {
    this._props.mode = mode;
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateText(text) {
    this._props.text = text;
    this._updateText();
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateMark(mark) {
    this._props.mark = mark;
    this._updateMark();
  }
  updateContainsButtonsBefore(containsButtonsBefore) {
    this._props.containsButtonsBefore = containsButtonsBefore;
    this._updateEditorBeforeButtonsClass();
  }
  updateBeforeWidth(beforeWidth) {
    this._props.beforeWidth = beforeWidth;
    this._updateBeforeWidth();
  }
  updateMaxWidth(containerWidth) {
    this._props.containerWidth = containerWidth;
    this._updateMaxWidth();
  }
};

// node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString2(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var key$1 in second) {
      out[key$1] = second[key$1];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
var EMPTY_OBJ = {};
var Fragment = "$F";
function normalizeEventName(name2) {
  return name2.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMfromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function removeVNodeDOM(vNode, parentDOM) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      removeChild(parentDOM, vNode.dom);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          removeVNodeDOM(children[i], parentDOM);
        }
        return;
      }
    }
  } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
  do {
    var flags = vNode.flags;
    if (flags & 2033) {
      insertOrAppend(parentDOM, vNode.dom, nextNode);
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(children[i], parentDOM, nextNode);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
var renderCheck = {
  v: false
};
var options = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
var keyPrefix = "$";
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index, currentKey) {
  for (var len = nodes.length; index < len; index++) {
    var n = nodes[index];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index;
      if (isArray(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString2(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString2(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var namespaces = {
  "xlink:actuate": xlinkNS,
  "xlink:arcrole": xlinkNS,
  "xlink:href": xlinkNS,
  "xlink:role": xlinkNS,
  "xlink:show": xlinkNS,
  "xlink:title": xlinkNS,
  "xlink:type": xlinkNS,
  "xml:base": xmlNS,
  "xml:lang": xmlNS,
  "xml:space": xmlNS
};
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    if (isString2(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
var onTextInputChange = createWrappedFunction("onInput", applyValueInput);
var wrappedOnChange = createWrappedFunction(["onClick", "onChange"], applyValueInput);
function emptywrapper(event) {
  event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent(dom, "change", wrappedOnChange);
    attachEvent(dom, "click", emptywrapper);
  } else {
    attachEvent(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
var onSelectChange = createWrappedFunction("onChange", applyValueSelect);
function selectEvents(dom) {
  attachEvent(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index = nextPropsOrEmpty.selectedIndex;
  if (index === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index) && index > -1 && dom.options[index]) {
      value2 = dom.options[index].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
var onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction("onChange");
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent(dom, "change", wrappedOnChange$1);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove2(vNode, parentDOM) {
  unmount(vNode);
  removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children);
    } else if (childFlags === 2) {
      unmount(children);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI);
    } else if (flags & 8) {
      ref = vNode.ref;
      if (!isNullOrUndef(ref) && isFunction2(ref.onComponentWillUnmount)) {
        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
      }
      unmount(children);
    } else if (flags & 1024) {
      remove2(children, vNode.ref);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children);
      }
    }
  }
}
function unmountAllChildren(children) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i]);
  }
}
function clearDOM(dom) {
  dom.textContent = "";
}
function removeAllChildren(dom, vNode, children) {
  unmountAllChildren(children);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom);
  } else {
    clearDOM(dom);
  }
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString2(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString2(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context));
  var childContext = context;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component3, props, context, isSVG, lifecycle) {
  var instance = new Component3(props, context);
  var usesNewAPI = instance.$N = Boolean(Component3.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context;
  if (instance.props === EMPTY_OBJ) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context);
  return instance;
}
function renderFunctionalComponent(vNode, context) {
  var props = vNode.props || EMPTY_OBJ;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);
}
function mount2(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  } else if (flags & 512 || flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
  } else if (flags & 1024) {
    mountPortal(vNode, context, parentDOM, nextNode, lifecycle);
  } else ;
}
function mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {
  mount2(vNode.children, vNode.ref, context, false, null, lifecycle);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount2(children, parentDOM, context, isSVG, nextNode, lifecycle);
  } else {
    mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount2(children, dom, context, childrenIsSVG, null, lifecycle);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount2(child, dom, context, isSVG, nextNode, lifecycle);
  }
}
function mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);
  mount2(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  mount2(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context)), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
  unmount(lastVNode);
  if ((nextVNode.flags & lastVNode.flags & 2033) !== 0) {
    mount2(nextVNode, null, context, isSVG, null, lifecycle);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount2(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
    removeVNodeDOM(lastVNode, parentDOM);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    } else {
      mount2(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 512) {
    nextVNode.dom = lastVNode.dom;
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
  } else {
    patchPortal(lastVNode, nextVNode, context, lifecycle);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context, lifecycle) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ;
    if (nextPropsOrEmpty !== EMPTY_OBJ) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ) {
      for (var prop$1 in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
  unmount(lastChildren);
  mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
  removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
        case 1:
          remove2(lastChildren, parentDOM);
          break;
        case 16:
          unmount(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM);
          mount2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
        case 1:
          clearDOM(parentDOM);
          break;
        default:
          clearDOM(parentDOM);
          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          mount2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));
    patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount2(nextChild, dom, context, isSVG, nextNode, lifecycle);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove2(lastChildren[i], dom);
    }
  }
}
function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount2(bNode, dom, context, isSVG, nextNode, lifecycle);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove2(a[j++], dom);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
  }
}
function patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
  var aNode;
  var bNode;
  var nextPos;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove2(a[aStart++], dom);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove2(a[aStart++], dom);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove2(aNode, dom);
        }
      } else if (!canRemoveWholeContent) {
        remove2(aNode, dom);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a);
    mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount2(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
      } else {
        j--;
      }
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount2(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
      }
    }
  }
}
var result;
var p;
var maxLen = 0;
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
var hasDocumentAvailable = typeof document !== "undefined";
if (hasDocumentAvailable) {
  if (window.Node) {
    Node.prototype.$EV = null;
    Node.prototype.$V = null;
  }
}
function __render(input, parentDOM, callback, context) {
  var lifecycle = [];
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount2(input, parentDOM, context, false, null, lifecycle);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove2(rootInput, parentDOM);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context, false, null, lifecycle);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render2(input, parentDOM, callback, context) {
  if (callback === void 0) callback = null;
  if (context === void 0) context = EMPTY_OBJ;
  __render(input, parentDOM, callback, context);
}
var QUEUE = [];
var nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
  window.setTimeout(a, 0);
};
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (QUEUE.indexOf(component) === -1) {
      QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
    callAll(lifecycle);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var Component = function Component2(props, context) {
  this.state = null;
  this.$BR = false;
  this.$BS = true;
  this.$PS = null;
  this.$LI = null;
  this.$UN = false;
  this.$CX = null;
  this.$QU = null;
  this.$N = false;
  this.$L = null;
  this.$SVG = false;
  this.$F = false;
  this.props = props || EMPTY_OBJ;
  this.context = context || EMPTY_OBJ;
};
Component.prototype.forceUpdate = function forceUpdate(callback) {
  if (this.$UN) {
    return;
  }
  queueStateChanges(this, {}, callback, true);
};
Component.prototype.setState = function setState(newState, callback) {
  if (this.$UN) {
    return;
  }
  if (!this.$BS) {
    queueStateChanges(this, newState, callback, false);
  }
};
Component.prototype.render = function render3(_nextProps, _nextState, _nextContext) {
  return null;
};

// node_modules/inferno/index.esm.js
if (true) {
  console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
}

// node_modules/@devextreme/runtime/esm/inferno/effect_host.js
var InfernoEffectHost = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    this.lockCount--;
    if (this.lockCount < 0) {
      throw new Error("Unexpected Effect Call");
    }
    if (this.lockCount === 0) {
      const effects = this.callbacks;
      this.callbacks = [];
      effects.forEach((callback) => callback());
    }
  }
};

// node_modules/@devextreme/runtime/esm/inferno/base_component.js
var areObjectsEqual = (firstObject, secondObject) => {
  const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
  if (!bothAreObjects) {
    return firstObject === secondObject;
  }
  const firstObjectKeys = Object.keys(firstObject);
  const secondObjectKeys = Object.keys(secondObject);
  if (firstObjectKeys.length !== secondObjectKeys.length) {
    return false;
  }
  const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
  return !hasDifferentElement;
};
var BaseInfernoComponent = class extends Component {
  constructor() {
    super(...arguments);
    this._pendingContext = this.context;
  }
  componentWillReceiveProps(_, context) {
    this._pendingContext = context !== null && context !== void 0 ? context : {};
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
  }
};
var InfernoComponent = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    InfernoEffectHost.lock();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  componentWillUpdate(_nextProps, _nextState, _context) {
    InfernoEffectHost.lock();
  }
  componentDidMount() {
    InfernoEffectHost.callbacks.push(() => {
      this._effects = this.createEffects();
    });
    InfernoEffectHost.callEffects();
  }
  componentDidUpdate() {
    InfernoEffectHost.callbacks.push(() => this.updateEffects());
    InfernoEffectHost.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
};
var InfernoWrapperComponent = class extends InfernoComponent {
  constructor() {
    super(...arguments);
    this.vDomElement = null;
  }
  vDomUpdateClasses() {
    const el = this.vDomElement;
    const currentClasses = el.className.length ? el.className.split(" ") : [];
    const addedClasses = currentClasses.filter((className) => el.dxClasses.previous.indexOf(className) < 0);
    const removedClasses = el.dxClasses.previous.filter((className) => currentClasses.indexOf(className) < 0);
    addedClasses.forEach((value2) => {
      const indexInRemoved = el.dxClasses.removed.indexOf(value2);
      if (indexInRemoved > -1) {
        el.dxClasses.removed.splice(indexInRemoved, 1);
      } else if (!el.dxClasses.added.includes(value2)) {
        el.dxClasses.added.push(value2);
      }
    });
    removedClasses.forEach((value2) => {
      const indexInAdded = el.dxClasses.added.indexOf(value2);
      if (indexInAdded > -1) {
        el.dxClasses.added.splice(indexInAdded, 1);
      } else if (!el.dxClasses.removed.includes(value2)) {
        el.dxClasses.removed.push(value2);
      }
    });
  }
  componentDidMount() {
    const el = findDOMfromVNode(this.$LI, true);
    this.vDomElement = el;
    super.componentDidMount();
    el.dxClasses = el.dxClasses || {
      removed: [],
      added: [],
      previous: []
    };
    el.dxClasses.previous = (el === null || el === void 0 ? void 0 : el.className.length) ? el.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const el = this.vDomElement;
    if (el !== null) {
      el.dxClasses.added.forEach((className) => el.classList.add(className));
      el.dxClasses.removed.forEach((className) => el.classList.remove(className));
      el.dxClasses.previous = el.className.length ? el.className.split(" ") : [];
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
    if (shouldUpdate) {
      this.vDomUpdateClasses();
    }
    return shouldUpdate;
  }
};

// node_modules/@devextreme/runtime/esm/inferno/create_context.js
var contextId = 0;
var createContext = function(defaultValue) {
  const id = contextId++;
  return {
    id,
    defaultValue,
    Provider: class extends Component {
      getChildContext() {
        return Object.assign(Object.assign({}, this.context), { [id]: this.props.value || defaultValue });
      }
      render() {
        return this.props.children;
      }
    }
  };
};

// node_modules/@devextreme/runtime/esm/inferno/effect.js
var InfernoEffect = class {
  constructor(effect, dependency) {
    this.dependency = dependency;
    this.effect = effect;
    this.destroy = effect();
  }
  update(dependency) {
    const currentDependency = this.dependency;
    if (dependency) {
      this.dependency = dependency;
    }
    if (!dependency || dependency.some((d, i) => currentDependency[i] !== d)) {
      this.dispose();
      this.destroy = this.effect();
    }
  }
  dispose() {
    if (this.destroy) {
      this.destroy();
    }
  }
};

// node_modules/@devextreme/runtime/esm/inferno/re_render_effect.js
var createReRenderEffect = () => new InfernoEffect(() => {
  rerender();
}, []);

// node_modules/@devextreme/runtime/esm/inferno/mocked/shared.js
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef2(o) {
  return o === void 0 || o === null;
}
function isInvalid2(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction3(o) {
  return typeof o === "function";
}
function isNull2(o) {
  return o === null;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error(`Inferno Error: ${message}`);
}

// node_modules/@devextreme/runtime/esm/inferno/mocked/hydrate.js
function isSameInnerHTML2(dom, innerHTML) {
  const tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  let flags;
  let children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 2033) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & 8192) {
      vNode = vNode.childFlags === 2 ? children : children[children.length - 1];
    } else if (flags & 4) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context, isSVG, isClass, lifecycle) {
  const type2 = vNode.type;
  const ref = vNode.ref;
  const props = vNode.props || EMPTY_OBJ;
  let currentNode;
  if (isClass) {
    const instance = createClassComponentInstance(vNode, type2, props, context, isSVG, lifecycle);
    const input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
    mountClassComponentCallbacks(ref, instance, lifecycle);
  } else {
    const input = normalizeRoot(renderFunctionalComponent(vNode, context));
    currentNode = hydrateVNode(input, parentDOM, dom, context, isSVG, lifecycle);
    vNode.children = input;
    mountFunctionalComponentCallbacks(vNode, lifecycle);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context, isSVG, lifecycle) {
  const childFlags = parentVNode.childFlags;
  const children = parentVNode.children;
  const props = parentVNode.props;
  const flags = parentVNode.flags;
  if (childFlags !== 1) {
    if (childFlags === 2) {
      if (isNull2(currentNode)) {
        mount2(children, parentNode, context, isSVG, null, lifecycle);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context, isSVG, lifecycle);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === 16) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
        parentNode.textContent = children;
      } else if (currentNode.nodeValue !== children) {
        currentNode.nodeValue = children;
      }
      currentNode = null;
    } else if (childFlags & 12) {
      let prevVNodeIsTextNode = false;
      for (let i = 0, len = children.length; i < len; ++i) {
        const child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & 16) > 0) {
          mount2(child, parentNode, context, isSVG, currentNode, lifecycle);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context, isSVG, lifecycle);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & 16) > 0;
      }
    }
    if ((flags & 8192) === 0) {
      let nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & 448) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context, isSVG, lifecycle) {
  const props = vNode.props;
  const className = vNode.className;
  const flags = vNode.flags;
  const ref = vNode.ref;
  isSVG = isSVG || (flags & 32) > 0;
  if (dom.nodeType !== 1) {
    mountElement(vNode, null, context, isSVG, null, lifecycle);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context, isSVG, lifecycle);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG);
    }
    if (isNullOrUndef2(className)) {
      if (dom.className !== "") {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (dom.nodeType !== 3) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    const text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context, isSVG, lifecycle) {
  const children = vNode.children;
  if (vNode.childFlags === 2) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context, isSVG, lifecycle);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context, isSVG, lifecycle) {
  const flags = vNode.flags |= 16384;
  if (flags & 14) {
    return hydrateComponent(vNode, parentDOM, currentDom, context, isSVG, (flags & 4) > 0, lifecycle);
  }
  if (flags & 481) {
    return hydrateElement(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
  }
  if (flags & 16) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & 512) {
    return vNode.dom = currentDom;
  }
  if (flags & 8192) {
    return hydrateFragment(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  let dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render2(input, parentDOM, callback);
  } else {
    const lifecycle = [];
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      let listener;
      while ((listener = lifecycle.shift()) !== void 0) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}

// node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isString3(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
var componentHooks = {
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function createElement(type2, props, _children) {
  var arguments$1 = arguments;
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags = 0;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments$1[childLen + 2];
    }
  }
  if (isString3(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop$1 in props) {
        if (prop$1 === "key") {
          key = props.key;
        } else if (prop$1 === "ref") {
          ref = props.ref;
        } else if (componentHooks[prop$1] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[prop$1] = props[prop$1];
        } else {
          newProps[prop$1] = props[prop$1];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}

// node_modules/@devextreme/runtime/esm/inferno/render_template.js
var getContainer = (props) => {
  var _a, _b;
  return ((_a = props.container) === null || _a === void 0 ? void 0 : _a.get(0)) || ((_b = props.item) === null || _b === void 0 ? void 0 : _b.get(0));
};
function renderTemplate(template, props, _component) {
  setTimeout(() => {
    render2(createElement(template, props), getContainer(props));
  }, 0);
}
var hasTemplate2 = (name2, properties, _component) => {
  const value2 = properties[name2];
  return !!value2 && typeof value2 !== "string";
};

// node_modules/@devextreme/runtime/esm/inferno/normalize_styles.js
var NUMBER_STYLES = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "borderImageOutset",
  "borderImageSlice",
  "border-imageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "fillOpacity",
  "flex",
  "flexGrow",
  "flexNegative",
  "flexOrder",
  "flexPositive",
  "flexShrink",
  "floodOpacity",
  "fontWeight",
  "gridColumn",
  "gridRow",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "stopOpacity",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "tabSize",
  "widows",
  "zIndex",
  "zoom"
]);
var isNumeric2 = (value2) => {
  if (typeof value2 === "number")
    return true;
  return !Number.isNaN(Number(value2));
};
var getNumberStyleValue = (style, value2) => NUMBER_STYLES.has(style) ? value2 : `${value2}px`;
var uppercasePattern = /[A-Z]/g;
var kebabCase = (str) => str.replace(uppercasePattern, "-$&").toLowerCase();
function normalizeStyles(styles) {
  if (!(styles instanceof Object)) {
    return void 0;
  }
  return Object.entries(styles).reduce((acc, [key, value2]) => {
    acc[kebabCase(key)] = isNumeric2(value2) ? getNumberStyleValue(key, value2) : value2;
    return acc;
  }, {});
}

// node_modules/devextreme/esm/__internal/core/r1/utils/get_template.js
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);

// node_modules/devextreme/esm/__internal/core/r1/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.entries(firstObject).every(((_ref) => {
    let [key, firstValue] = _ref;
    const secondValue = secondObject[key];
    if (firstValue instanceof Date && secondValue instanceof Date) {
      return firstValue.getTime() === secondValue.getTime();
    }
    return firstValue === secondValue;
  }));
};

// node_modules/devextreme/esm/__internal/core/r1/utils/update_props_immutable.js
var cloneObjectValue = (value2) => Array.isArray(value2) ? [...value2] : _extends({}, value2);
var cloneObjectProp = (value2, prevValue, fullNameParts) => {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
};
var updatePropsImmutable = (props, option, name2, fullName) => {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/config_context.js
var ConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/core/r1/config_provider.js
var ConfigProviderDefaultProps = {};
var ConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.__getterCache = {};
  }
  get config() {
    if (void 0 !== this.__getterCache.config) {
      return this.__getterCache.config;
    }
    return this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  componentWillUpdate(nextProps) {
    if (this.props.rtlEnabled !== nextProps.rtlEnabled) {
      this.__getterCache.config = void 0;
    }
  }
  getChildContext() {
    return _extends({}, this.context, {
      [ConfigContext.id]: this.config || ConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
ConfigProvider.defaultProps = ConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/core/r1/utils/render_utils.js
var combineClasses = (classesMap) => Object.keys(classesMap).filter(((cssClass) => !!cssClass && classesMap[cssClass])).join(" ");

// node_modules/devextreme/esm/__internal/core/r1/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config2) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled)) {
    return config2.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config2) {
  const isPropDefined = isDefined(rtlProp);
  const onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config2 || void 0 === config2 ? void 0 : config2.rtlEnabled) || onlyGlobalDefined;
}

// node_modules/devextreme/esm/__internal/core/r1/base_props.js
var BaseWidgetDefaultProps = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true
};

// node_modules/devextreme/esm/__internal/core/r1/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler, eventData2, namespace) => {
    const event = namespace ? addNamespace(eventName, namespace) : eventName;
    if (handler) {
      m_events_engine_default.on(element, event, eventData2, handler);
      return () => {
        m_events_engine_default.off(element, event, handler);
      };
    }
    return;
  };
}
var subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
var subscribeToScrollEvent = subscribeToEvent(m_emitter_gesture_scroll_default.scroll);
var subscribeToScrollInitEvent = subscribeToEvent(m_emitter_gesture_scroll_default.init);
var subscribeToDXScrollStartEvent = subscribeToEvent(m_emitter_gesture_scroll_default.start);
var subscribeToDXScrollMoveEvent = subscribeToEvent(m_emitter_gesture_scroll_default.move);
var subscribeToDXScrollEndEvent = subscribeToEvent(m_emitter_gesture_scroll_default.end);
var subscribeToDXScrollStopEvent = subscribeToEvent(m_emitter_gesture_scroll_default.stop);
var subscribeToDXScrollCancelEvent = subscribeToEvent(m_emitter_gesture_scroll_default.cancel);
var subscribeToDXPointerDownEvent = subscribeToEvent(m_pointer_default.down);
var subscribeToDXPointerUpEvent = subscribeToEvent(m_pointer_default.up);
var subscribeToDXPointerMoveEvent = subscribeToEvent(m_pointer_default.move);
var subscribeToMouseEnterEvent = subscribeToEvent("mouseenter");
var subscribeToMouseLeaveEvent = subscribeToEvent("mouseleave");
var subscribeToKeyDownEvent = subscribeToEvent("keydown");
var subscribeToDxActiveEvent = subscribeToEvent("dxactive");
var subscribeToDxInactiveEvent = subscribeToEvent("dxinactive");
var subscribeToDxHoverStartEvent = subscribeToEvent("dxhoverstart");
var subscribeToDxHoverEndEvent = subscribeToEvent("dxhoverend");
var subscribeToDxFocusInEvent = subscribeToEvent("focusin");
var subscribeToDxFocusOutEvent = subscribeToEvent("focusout");

// node_modules/devextreme/esm/__internal/core/r1/widget.js
var getAria = (args) => Object.keys(args).reduce(((r, key) => {
  if (args[key]) {
    return _extends({}, r, {
      ["role" === key || "id" === key ? key : `aria-${key}`]: String(args[key])
    });
  }
  return r;
}), {});
var WidgetDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});
var Widget = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {
      active: false,
      focused: false,
      hovered: false
    };
    this.refs = null;
    this.rootElementRef = createRef();
    this.widgetElementRef = createRef();
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.activeEffect = this.activeEffect.bind(this);
    this.inactiveEffect = this.inactiveEffect.bind(this);
    this.clickEffect = this.clickEffect.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.focusInEffect = this.focusInEffect.bind(this);
    this.focusOutEffect = this.focusOutEffect.bind(this);
    this.hoverStartEffect = this.hoverStartEffect.bind(this);
    this.hoverEndEffect = this.hoverEndEffect.bind(this);
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.resizeEffect = this.resizeEffect.bind(this);
    this.windowResizeEffect = this.windowResizeEffect.bind(this);
    this.visibilityEffect = this.visibilityEffect.bind(this);
    this.checkDeprecation = this.checkDeprecation.bind(this);
    this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new InfernoEffect(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new InfernoEffect(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new InfernoEffect(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new InfernoEffect(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new InfernoEffect(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new InfernoEffect(this.checkDeprecation, [this.props.height, this.props.width]), new InfernoEffect(this.applyCssTextEffect, [this.props.cssText]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8, _this$_effects$9, _this$_effects$10, _this$_effects$11, _this$_effects$12, _this$_effects$13;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]);
    null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]);
    null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 || _this$_effects$3.update([this.props.disabled, this.props.name, this.props.onClick]);
    null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 || _this$_effects$4.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]);
    null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 || _this$_effects$5.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]);
    null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 || _this$_effects$6.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]);
    null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 || _this$_effects$7.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]);
    null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 || _this$_effects$8.update([this.props.focusStateEnabled, this.props.onKeyDown]);
    null === (_this$_effects$9 = this._effects[9]) || void 0 === _this$_effects$9 || _this$_effects$9.update([this.props.name, this.props.onDimensionChanged]);
    null === (_this$_effects$10 = this._effects[10]) || void 0 === _this$_effects$10 || _this$_effects$10.update([this.props.onDimensionChanged]);
    null === (_this$_effects$11 = this._effects[11]) || void 0 === _this$_effects$11 || _this$_effects$11.update([this.props.name, this.props.onVisibilityChange]);
    null === (_this$_effects$12 = this._effects[12]) || void 0 === _this$_effects$12 || _this$_effects$12.update([this.props.height, this.props.width]);
    null === (_this$_effects$13 = this._effects[13]) || void 0 === _this$_effects$13 || _this$_effects$13.update([this.props.cssText]);
  }
  setRootElementRef() {
    var _this$widgetElementRe;
    const {
      rootElementRef,
      onRootElementRendered
    } = this.props;
    if (rootElementRef && this.widgetElementRef) {
      rootElementRef.current = this.widgetElementRef.current;
    }
    if (null !== this && void 0 !== this && null !== (_this$widgetElementRe = this.widgetElementRef) && void 0 !== _this$widgetElementRe && _this$widgetElementRe.current) {
      null === onRootElementRendered || void 0 === onRootElementRendered || onRootElementRendered(this.widgetElementRef.current);
    }
  }
  activeEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      disabled,
      _feedbackShowTimeout,
      onActive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe2;
        return subscribeToDxActiveEvent(null === (_this$widgetElementRe2 = this.widgetElementRef) || void 0 === _this$widgetElementRe2 ? void 0 : _this$widgetElementRe2.current, ((event) => {
          this.setState({
            active: true
          });
          null === onActive || void 0 === onActive || onActive(event);
        }), {
          timeout: _feedbackShowTimeout,
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  inactiveEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      _feedbackHideTimeout,
      onInactive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      var _this$widgetElementRe3;
      return subscribeToDxInactiveEvent(null === (_this$widgetElementRe3 = this.widgetElementRef) || void 0 === _this$widgetElementRe3 ? void 0 : _this$widgetElementRe3.current, ((event) => {
        if (this.state.active) {
          this.setState({
            active: false
          });
          null === onInactive || void 0 === onInactive || onInactive(event);
        }
      }), {
        timeout: _feedbackHideTimeout,
        selector
      }, "UIFeedback");
    }
    return;
  }
  clickEffect() {
    const {
      name: name2,
      onClick,
      disabled
    } = this.props;
    const namespace = name2;
    if (onClick && !disabled) {
      var _this$widgetElementRe4;
      dxClick.on(null === (_this$widgetElementRe4 = this.widgetElementRef) || void 0 === _this$widgetElementRe4 ? void 0 : _this$widgetElementRe4.current, onClick, {
        namespace
      });
      return () => {
        var _this$widgetElementRe5;
        return dxClick.off(null === (_this$widgetElementRe5 = this.widgetElementRef) || void 0 === _this$widgetElementRe5 ? void 0 : _this$widgetElementRe5.current, {
          namespace
        });
      };
    }
    return;
  }
  focusInEffect() {
    const {
      disabled,
      focusStateEnabled,
      name: name2,
      onFocusIn
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe6;
        return subscribeToDxFocusInEvent(null === (_this$widgetElementRe6 = this.widgetElementRef) || void 0 === _this$widgetElementRe6 ? void 0 : _this$widgetElementRe6.current, ((event) => {
          if (!event.isDefaultPrevented()) {
            this.setState({
              focused: true
            });
            null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
          }
        }), null, namespace);
      }
    }
    return;
  }
  focusOutEffect() {
    const {
      focusStateEnabled,
      name: name2,
      onFocusOut
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      var _this$widgetElementRe7;
      return subscribeToDxFocusOutEvent(null === (_this$widgetElementRe7 = this.widgetElementRef) || void 0 === _this$widgetElementRe7 ? void 0 : _this$widgetElementRe7.current, ((event) => {
        if (!event.isDefaultPrevented() && this.state.focused) {
          this.setState({
            focused: false
          });
          null === onFocusOut || void 0 === onFocusOut || onFocusOut(event);
        }
      }), null, namespace);
    }
    return;
  }
  hoverStartEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      disabled,
      onHoverStart
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe8;
        return subscribeToDxHoverStartEvent(null === (_this$widgetElementRe8 = this.widgetElementRef) || void 0 === _this$widgetElementRe8 ? void 0 : _this$widgetElementRe8.current, ((event) => {
          if (!this.state.active) {
            this.setState({
              hovered: true
            });
          }
          null === onHoverStart || void 0 === onHoverStart || onHoverStart(event);
        }), {
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  hoverEndEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      onHoverEnd
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      var _this$widgetElementRe9;
      return subscribeToDxHoverEndEvent(null === (_this$widgetElementRe9 = this.widgetElementRef) || void 0 === _this$widgetElementRe9 ? void 0 : _this$widgetElementRe9.current, ((event) => {
        if (this.state.hovered) {
          this.setState({
            hovered: false
          });
          null === onHoverEnd || void 0 === onHoverEnd || onHoverEnd(event);
        }
      }), {
        selector
      }, "UIFeedback");
    }
    return;
  }
  keyboardEffect() {
    const {
      onKeyDown,
      focusStateEnabled
    } = this.props;
    if (focusStateEnabled && onKeyDown) {
      var _this$widgetElementRe10, _this$widgetElementRe11;
      const id = keyboard.on(null === (_this$widgetElementRe10 = this.widgetElementRef) || void 0 === _this$widgetElementRe10 ? void 0 : _this$widgetElementRe10.current, null === (_this$widgetElementRe11 = this.widgetElementRef) || void 0 === _this$widgetElementRe11 ? void 0 : _this$widgetElementRe11.current, ((e) => onKeyDown(e)));
      return () => keyboard.off(id);
    }
    return;
  }
  resizeEffect() {
    const namespace = `${this.props.name}VisibilityChange`;
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      var _this$widgetElementRe12;
      resize.on(null === (_this$widgetElementRe12 = this.widgetElementRef) || void 0 === _this$widgetElementRe12 ? void 0 : _this$widgetElementRe12.current, onDimensionChanged, {
        namespace
      });
      return () => {
        var _this$widgetElementRe13;
        return resize.off(null === (_this$widgetElementRe13 = this.widgetElementRef) || void 0 === _this$widgetElementRe13 ? void 0 : _this$widgetElementRe13.current, {
          namespace
        });
      };
    }
    return;
  }
  windowResizeEffect() {
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize_callbacks_default.add(onDimensionChanged);
      return () => {
        resize_callbacks_default.remove(onDimensionChanged);
      };
    }
    return;
  }
  visibilityEffect() {
    const {
      name: name2,
      onVisibilityChange
    } = this.props;
    const namespace = `${name2}VisibilityChange`;
    if (onVisibilityChange) {
      var _this$widgetElementRe14;
      visibility.on(null === (_this$widgetElementRe14 = this.widgetElementRef) || void 0 === _this$widgetElementRe14 ? void 0 : _this$widgetElementRe14.current, (() => onVisibilityChange(true)), (() => onVisibilityChange(false)), {
        namespace
      });
      return () => {
        var _this$widgetElementRe15;
        return visibility.off(null === (_this$widgetElementRe15 = this.widgetElementRef) || void 0 === _this$widgetElementRe15 ? void 0 : _this$widgetElementRe15.current, {
          namespace
        });
      };
    }
    return;
  }
  checkDeprecation() {
    const {
      width,
      height
    } = this.props;
    if (isFunction(width)) {
      errors_default.log("W0017", "width");
    }
    if (isFunction(height)) {
      errors_default.log("W0017", "height");
    }
  }
  applyCssTextEffect() {
    var _this$widgetElementRe16;
    const {
      cssText
    } = this.props;
    if (void 0 !== cssText && "" !== cssText && null !== (_this$widgetElementRe16 = this.widgetElementRef) && void 0 !== _this$widgetElementRe16 && _this$widgetElementRe16.current) {
      this.widgetElementRef.current.style.cssText = cssText;
    }
  }
  getShouldRenderConfigProvider() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabledDefinition(rtlEnabled, this.config);
  }
  getRtlEnabled() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabled(rtlEnabled, this.config);
  }
  getAttributes() {
    const {
      aria,
      disabled,
      focusStateEnabled,
      visible
    } = this.props;
    const accessKey = focusStateEnabled && !disabled && this.props.accessKey;
    const props = _extends({}, extend({}, accessKey && {
      accessKey
    }), getAria(_extends({}, aria, {
      disabled,
      hidden: !visible
    })), extend({}, this.getRestAttributes(this.props)));
    return props;
  }
  getRestAttributes(props) {
    const result2 = _extends({}, props);
    ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"].forEach(((exclude) => {
      delete result2[exclude];
    }));
    return result2;
  }
  getStyles() {
    const {
      width,
      height
    } = this.props;
    const style = this.props.style || {};
    const computedWidth = normalizeStyleProp("width", isFunction(width) ? width() : width);
    const computedHeight = normalizeStyleProp("height", isFunction(height) ? height() : height);
    return _extends({}, style, {
      height: computedHeight ?? style.height,
      width: computedWidth ?? style.width
    });
  }
  getCssClasses() {
    const {
      classes,
      addWidgetClass,
      className,
      disabled,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled,
      onVisibilityChange,
      visible
    } = this.props;
    const isFocusable = !!focusStateEnabled && !disabled;
    const isHoverable = !!hoverStateEnabled && !disabled;
    const canBeActive = !!activeStateEnabled && !disabled;
    const classesMap = {
      "dx-widget": !!addWidgetClass,
      [String(classes)]: !!classes,
      [String(className)]: !!className,
      "dx-state-disabled": !!disabled,
      "dx-state-invisible": !visible,
      "dx-state-focused": !!this.state.focused && isFocusable,
      "dx-state-active": !!this.state.active && canBeActive,
      "dx-state-hover": !!this.state.hovered && isHoverable && !this.state.active,
      "dx-rtl": !!this.props.rtlEnabled,
      "dx-visibility-change-handler": !!onVisibilityChange
    };
    return combineClasses(classesMap);
  }
  getTabIndex() {
    const {
      focusStateEnabled,
      disabled,
      tabIndex
    } = this.props;
    const isFocusable = focusStateEnabled && !disabled;
    return isFocusable ? tabIndex : void 0;
  }
  focus() {
    var _this$widgetElementRe17;
    focus.trigger(null === (_this$widgetElementRe17 = this.widgetElementRef) || void 0 === _this$widgetElementRe17 ? void 0 : _this$widgetElementRe17.current);
  }
  blur() {
    var _this$widgetElementRe18, _this$widgetElementRe19;
    const activeElement = dom_adapter_default.getActiveElement(null === (_this$widgetElementRe18 = this.widgetElementRef) || void 0 === _this$widgetElementRe18 ? void 0 : _this$widgetElementRe18.current);
    if ((null === (_this$widgetElementRe19 = this.widgetElementRef) || void 0 === _this$widgetElementRe19 ? void 0 : _this$widgetElementRe19.current) === activeElement) {
      activeElement.blur();
    }
  }
  activate() {
    this.setState({
      active: true
    });
  }
  deactivate() {
    this.setState({
      active: false
    });
  }
  render() {
    const {
      hint,
      children
    } = this.props;
    const widget = normalizeProps(createVNode(1, "div", this.getCssClasses(), children, 0, _extends({}, this.getAttributes(), {
      tabIndex: this.getTabIndex(),
      title: hint,
      style: this.getStyles()
    }), null, this.widgetElementRef));
    return this.getShouldRenderConfigProvider() ? createComponentVNode(2, ConfigProvider, {
      rtlEnabled: this.getRtlEnabled(),
      children: widget
    }) : widget;
  }
};
Widget.defaultProps = WidgetDefaultProps;

// node_modules/devextreme/esm/__internal/core/utils/combine_classes.js
function combineClasses2(classesMap) {
  return Object.keys(classesMap).filter(((p2) => classesMap[p2])).join(" ");
}

// node_modules/devextreme/esm/__internal/ui/button/icon.js
var defaultIconProps = {
  position: "left",
  source: ""
};
var Icon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get sourceType() {
    return getImageSourceType(this.props.source);
  }
  get cssClass() {
    return "left" !== this.props.position ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const generalClasses = {
      "dx-icon": true,
      [this.cssClass]: !!this.cssClass
    };
    const {
      source
    } = this.props;
    if ("dxIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [`dx-icon-${source}`]: true
      }));
    }
    if ("fontIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [String(source)]: !!source
      }));
    }
    if ("image" === this.sourceType) {
      return combineClasses2(generalClasses);
    }
    if ("svg" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        "dx-svg-icon": true
      }));
    }
    return "";
  }
  get restAttributes() {
    const restProps = _extends({}, this.props);
    ["iconTemplate", "position", "source"].forEach(((excluded) => {
      delete restProps[excluded];
    }));
    return restProps;
  }
  render() {
    const {
      iconClassName,
      props: {
        source
      },
      sourceType
    } = this;
    const IconTemplate = getTemplate(this.props.iconTemplate);
    return createFragment(["dxIcon" === sourceType && createVNode(1, "i", iconClassName), "fontIcon" === sourceType && createVNode(1, "i", iconClassName), "image" === sourceType && createVNode(1, "img", iconClassName, null, 1, {
      alt: "",
      src: source
    }), IconTemplate && createVNode(1, "i", iconClassName, IconTemplate({}), 0)], 0);
  }
};
Icon.defaultProps = defaultIconProps;

// node_modules/devextreme/esm/__internal/ui/button/ink_ripple.js
var InkRipple = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.state = {};
    this.hideWave = this.hideWave.bind(this);
    this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    if (void 0 !== this.__getterCache.getConfig) {
      return this.__getterCache.getConfig;
    }
    return this.__getterCache.getConfig = (() => {
      const {
        config: config2
      } = this.props;
      return initConfig(config2);
    })();
  }
  get restAttributes() {
    const restProps = _extends({}, this.props);
    delete restProps.config;
    return restProps;
  }
  hideWave(opts) {
    hideWave(this.getConfig, opts);
  }
  showWave(opts) {
    showWave(this.getConfig, opts);
  }
  componentWillUpdate(nextProps) {
    if (this.props.config !== nextProps.config) {
      this.__getterCache.getConfig = void 0;
    }
  }
  render() {
    return normalizeProps(createVNode(1, "div", "dx-inkripple", null, 1, _extends({}, this.restAttributes)));
  }
};
InkRipple.defaultProps = {
  config: {}
};

// node_modules/devextreme/esm/__internal/ui/button/props.js
var defaultButtonProps = _extends({}, BaseWidgetDefaultProps, {
  activeStateEnabled: true,
  hoverStateEnabled: true,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: false,
  useSubmitBehavior: false,
  templateData: {}
});

// node_modules/devextreme/esm/__internal/ui/button/button.js
var stylingModes = ["outlined", "text", "contained"];
var getCssClasses = (model) => {
  const {
    icon,
    iconPosition,
    stylingMode,
    text,
    type: type2
  } = model;
  const isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);
  const classesMap = {
    "dx-button": true,
    [`dx-button-mode-${isValidStylingMode ? stylingMode : "contained"}`]: true,
    [`dx-button-${type2 ?? "normal"}`]: true,
    "dx-button-has-text": !!text,
    "dx-button-has-icon": !!icon,
    "dx-button-icon-right": "left" !== iconPosition
  };
  return combineClasses2(classesMap);
};
var defaultOptionRules = createDefaultOptionRules([{
  device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
  options: {
    focusStateEnabled: true
  }
}, {
  device: () => isMaterial(current()),
  options: {
    useInkRipple: true
  }
}]);
var Button = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.contentRef = createRef();
    this.inkRippleRef = createRef();
    this.submitInputRef = createRef();
    this.widgetRef = createRef();
    this.__getterCache = {};
    this.state = {};
    this.focus = this.focus.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.submitEffect = this.submitEffect.bind(this);
    this.onActive = this.onActive.bind(this);
    this.onInactive = this.onInactive.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit,
      useSubmitBehavior
    } = this.props;
    if (useSubmitBehavior && onSubmit) {
      click.on(this.submitInputRef.current, ((event) => onSubmit({
        event,
        submitInput: this.submitInputRef.current
      })), {
        namespace: "UIFeedback"
      });
      return () => click.off(this.submitInputRef.current, {
        namespace: "UIFeedback"
      });
    }
    return;
  }
  onActive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.showWave({
      element: this.contentRef.current,
      event
    });
  }
  onInactive(event) {
    const {
      useInkRipple
    } = this.props;
    useInkRipple && this.inkRippleRef.current.hideWave({
      element: this.contentRef.current,
      event
    });
  }
  onWidgetClick(event) {
    const {
      onClick,
      useSubmitBehavior
    } = this.props;
    null === onClick || void 0 === onClick || onClick({
      event
    });
    if (useSubmitBehavior) {
      this.submitInputRef.current.click();
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which || "enter" === keyName || "enter" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get aria() {
    const {
      icon,
      text
    } = this.props;
    let label = text ?? "";
    if (!text && icon) {
      const iconSource = getImageSourceType(icon);
      switch (iconSource) {
        case "image": {
          const notURLRegexp = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          const isPathToImage = !icon.includes("base64") && notURLRegexp.test(icon);
          label = isPathToImage ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          label = message_default.format(camelize(icon, true)) || icon;
          break;
        case "fontIcon":
          label = icon;
          break;
        case "svg": {
          var _titleRegexp$exec;
          const titleRegexp = /<title>(.*?)<\/title>/;
          const title = (null === (_titleRegexp$exec = titleRegexp.exec(icon)) || void 0 === _titleRegexp$exec ? void 0 : _titleRegexp$exec[1]) ?? "";
          label = title;
          break;
        }
      }
    }
    return _extends({
      role: "button"
    }, label ? {
      label
    } : {});
  }
  get cssClasses() {
    return getCssClasses(this.props);
  }
  get iconSource() {
    const {
      icon
    } = this.props;
    return icon ?? "";
  }
  get inkRippleConfig() {
    if (void 0 !== this.__getterCache.inkRippleConfig) {
      return this.__getterCache.inkRippleConfig;
    }
    return this.__getterCache.inkRippleConfig = (() => {
      const {
        icon,
        text
      } = this.props;
      return !text && icon ? {
        isCentered: true,
        useHoldAnimation: false,
        waveSizeCoefficient: 1
      } : {};
    })();
  }
  get buttonTemplateData() {
    const {
      icon,
      text,
      templateData
    } = this.props;
    return _extends({
      icon,
      text
    }, templateData);
  }
  get restAttributes() {
    const restProps = _extends({}, this.props);
    ["accessKey", "activeStateEnabled", "children", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"].forEach(((excluded) => {
      delete restProps[excluded];
    }));
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  activate() {
    this.widgetRef.current.activate();
  }
  deactivate() {
    this.widgetRef.current.deactivate();
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text) {
      this.__getterCache.inkRippleConfig = void 0;
    }
  }
  render() {
    const {
      children,
      iconPosition,
      text
    } = this.props;
    const ButtonTemplate = getTemplate(this.props.template);
    const IconTemplate = getTemplate(this.props.iconTemplate);
    const renderText = !this.props.template && !children && "" !== text;
    const isIconLeft = "left" === iconPosition;
    const iconComponent = !ButtonTemplate && !children && (this.iconSource || IconTemplate) && createComponentVNode(2, Icon, {
      source: this.iconSource,
      position: iconPosition,
      iconTemplate: IconTemplate
    });
    return normalizeProps(createComponentVNode(2, Widget, _extends({
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      aria: this.aria,
      className: this.props.className,
      classes: this.cssClasses,
      disabled: this.props.disabled,
      focusStateEnabled: this.props.focusStateEnabled,
      height: this.props.height,
      hint: this.props.hint,
      hoverStateEnabled: this.props.hoverStateEnabled,
      onActive: this.onActive,
      onClick: this.onWidgetClick,
      onInactive: this.onInactive,
      onKeyDown: this.keyDown,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      width: this.props.width
    }, this.restAttributes, {
      children: createVNode(1, "div", "dx-button-content", [ButtonTemplate && ButtonTemplate({
        data: this.buttonTemplateData
      }), !ButtonTemplate && children, isIconLeft && iconComponent, renderText && createVNode(1, "span", "dx-button-text", text, 0), !isIconLeft && iconComponent, this.props.useSubmitBehavior && createVNode(64, "input", "dx-button-submit-input", null, 1, {
        type: "submit",
        tabIndex: -1
      }, null, this.submitInputRef), this.props.useInkRipple && createComponentVNode(2, InkRipple, {
        config: this.inkRippleConfig
      }, null, this.inkRippleRef)], 0, null, null, this.contentRef)
    }), null, this.widgetRef));
  }
};
Button.defaultProps = _extends({}, defaultButtonProps, convertRulesToOptions(defaultOptionRules));
var __defaultOptionRules = [];
function defaultOptions(rule) {
  __defaultOptionRules.push(rule);
  Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));
}

// node_modules/devextreme/esm/core/dom_component.js
var dom_component_default2 = dom_component_default;

// node_modules/devextreme/esm/__internal/core/m_inferno_renderer.js
var remove3 = (element) => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const {
      nextSibling
    } = element;
    cleanDataRecursive(element);
    parentNode.$V = element.$V;
    render2(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = "";
    delete parentNode.$V;
  }
  delete element.$V;
};
var infernoRenderer = dependency_injector_default({
  createElement: (component, props) => createElement(component, props),
  remove: remove3,
  onAfterRender: () => {
    InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = null === container || void 0 === container ? void 0 : container.nextSibling;
      const rootNode = dom_adapter_default.createElement("div");
      rootNode.appendChild(container);
      const mountNode = dom_adapter_default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove3(container);
      hydrate(createElement(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      render2(createElement(component, props), container);
    }
  }
});

// node_modules/devextreme/esm/core/inferno_renderer.js
var inferno_renderer_default = infernoRenderer;

// node_modules/devextreme/esm/__internal/core/r1/template_wrapper.js
var _excluded2 = ["isEqual"];
var isDxElementWrapper = (element) => !!element.toArray;
var buildTemplateArgs = (model, template) => {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual: isEqual2
  } = _ref, data17 = _objectWithoutPropertiesLoose(_ref, _excluded2);
  if (isEqual2) {
    args.model.data = data17;
    args.isEqual = isEqual2;
  }
  return args;
};
var renderTemplateContent = (props, container) => {
  const {
    data: data17,
    index
  } = props.model ?? {
    data: {}
  };
  if (data17) {
    Object.keys(data17).forEach(((name2) => {
      if (data17[name2] && dom_adapter_default.isNode(data17[name2])) {
        data17[name2] = getPublicElement(renderer_default(data17[name2]));
      }
    }));
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data17
  } : {}, !props.transclude && Number.isFinite(index) ? {
    index
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
};
var removeDifferentElements = (oldChildren, newChildren) => {
  newChildren.forEach(((newElement) => {
    const hasOldChild = !!oldChildren.find(((oldElement) => newElement === oldElement));
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  }));
};
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMfromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      template,
      model
    } = this.props;
    const {
      template: nextTemplate,
      model: nextModel,
      isEqual: isEqual2
    } = nextProps;
    const equalityComparer = isEqual2 ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data17,
      index
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index !== nextIndex) {
      return true;
    }
    if (!isDefined(data17) || !isDefined(nextData)) {
      return model !== nextModel;
    }
    return !equalityComparer(data17, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/component_wrapper.js
var setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default2 {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce(((options2, name2) => {
      options2[name2] = true;
      return options2;
    }), {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce(((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }), {}), this._propsInfo.templates.reduce(((options2, name2) => _extends({}, options2, {
      [name2]: null
    })), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach(((key) => {
      unwrappedProps[key] = this.option(key);
    }));
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach(((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    }));
    Object.keys(this._getActionConfigsFull()).forEach(((name2) => this._addAction(name2)));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter(((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      })).reduce(((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }), {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      twoWay,
      elements,
      props
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions3 = this._getDefaultOptions();
    const {
      ref,
      children,
      onKeyboardHandled
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach(((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    }));
    allowNull.forEach(setDefaultOptionValue(widgetProps, (() => null)));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, ((name2) => defaultOptions3[name2])));
    twoWay.forEach(((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, (() => defaultOptions3[defaultName]))(name2);
    }));
    elements.forEach(((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    }));
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach(((template) => {
      options2[template] = this._componentTemplates[template];
    }));
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter(((c, i, a) => c && a.indexOf(c) === i)).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach(((template) => {
      result2[template] = "dx-renovation-template-mock";
    }));
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce(((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }), {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach(((key) => {
      result2[key] = (e) => this.viewRef.keyDown(m_keyboard_processor_default.createKeyDownOptions(e));
    }));
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach(((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        }));
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      name: name2,
      fullName,
      value: value2,
      previousValue
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _validateOptions(options2) {
    return super._validateOptions(options2);
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error) {
      return value2;
    }
  }
  focus() {
    const $root = this.$element();
    const hasFocus = $root.is(":focus") || $root.find(":focus").length > 0;
    if (hasFocus) {
      return;
    }
    if (this.option("focusStateEnabled")) {
      $root.focus();
    } else {
      var _focusableElements$;
      const focusableElements = $root.find("[tabindex]");
      null === (_focusableElements$ = focusableElements[0]) || void 0 === _focusableElements$ || _focusableElements$.focus();
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// node_modules/devextreme/esm/__internal/ui/button/wrapper.js
var ButtonWrapper = class extends ComponentWrapper {
  get _validationGroupConfig() {
    return validation_engine_default.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const props = super.getProps();
    props.onClick = (_ref) => {
      let {
        event
      } = _ref;
      this._clickAction({
        event,
        validationGroup: this._validationGroupConfig
      });
    };
    const iconType = getImageSourceType(props.icon);
    if ("svg" === iconType) {
      props.iconTemplate = this._createTemplateComponent((() => props.icon));
    }
    return props;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(_, value2) {
    const button = this.viewRef;
    value2 ? button.activate() : button.deactivate();
  }
  _getSubmitAction() {
    let needValidate = true;
    let validationStatus = "valid";
    return this._createAction(((_ref2) => {
      let {
        event,
        submitInput
      } = _ref2;
      if (needValidate) {
        const validationGroup = this._validationGroupConfig;
        if (void 0 !== validationGroup && "" !== validationGroup) {
          const validationResult = validationGroup.validate();
          validationStatus = validationResult.status;
          if ("pending" === validationResult.status) {
            needValidate = false;
            this.option("disabled", true);
            validationResult.complete.then(((_ref3) => {
              let {
                status
              } = _ref3;
              this.option("disabled", false);
              validationStatus = status;
              "valid" === validationStatus && submitInput.click();
              needValidate = true;
            }));
          }
        }
      }
      "valid" !== validationStatus && event.preventDefault();
      event.stopPropagation();
    }));
  }
  _initializeComponent() {
    super._initializeComponent();
    this._addAction("onSubmit", this._getSubmitAction());
    this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const $content = this.$element().find(".dx-button-content").first();
    const $template = $content.children().filter(".dx-template-wrapper");
    const $input = $content.children().filter(".dx-button-submit-input");
    if ($template.length) {
      $template.addClass("dx-button-content");
      $template.append($input);
      $content.replaceWith($template);
    }
  }
  _patchOptionValues(options2) {
    return super._patchOptionValues(_extends({}, options2, {
      templateData: options2._templateData
    }));
  }
  _findGroup() {
    const $element = this.$element();
    const validationGroup = this.option("validationGroup");
    return void 0 !== validationGroup && "" !== validationGroup ? validationGroup : validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(option) {
    if ("onClick" === option.name) {
      this._clickAction = this._createClickAction();
    }
    super._optionChanged(option);
  }
};

// node_modules/devextreme/esm/__internal/ui/button/generated_wrapper.js
var Button2 = class extends ButtonWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    let _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  activate() {
    let _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.activate(...arguments);
  }
  deactivate() {
    let _this$viewRef3;
    return null === (_this$viewRef3 = this.viewRef) || void 0 === _this$viewRef3 ? void 0 : _this$viewRef3.deactivate(...arguments);
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: ["activeStateEnabled", "hoverStateEnabled", "icon", "iconPosition", "onClick", "onSubmit", "pressed", "stylingMode", "template", "iconTemplate", "text", "type", "useInkRipple", "useSubmitBehavior", "templateData", "className", "accessKey", "disabled", "focusStateEnabled", "height", "hint", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width"]
    };
  }
  get _viewComponent() {
    return Button;
  }
};
component_registrator_default("dxButton", Button2);
Button2.defaultOptions = defaultOptions;

// node_modules/devextreme/esm/__internal/ui/button/index.js
var button_default = Button2;

// node_modules/devextreme/esm/ui/button.js
var button_default2 = button_default;

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_custom.js
var CustomButton = class extends TextEditorButton {
  _attachEvents(instance, $element) {
    const {
      editor
    } = this;
    m_events_engine_default.on($element, HOVERSTART, (() => {
      editor.$element().addClass("dx-custom-button-hovered");
    }));
    m_events_engine_default.on($element, HOVEREND, (() => {
      editor.$element().removeClass("dx-custom-button-hovered");
    }));
    m_events_engine_default.on($element, CLICK_EVENT_NAME, ((e) => {
      e.stopPropagation();
    }));
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default2, _extends({}, this.options, {
      ignoreParentReadOnly: true,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(editor)
    }));
    return {
      $element,
      instance
    };
  }
  _prepareIntegrationOptions(editor) {
    return _extends({}, editor.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    const isUpdated = super.update();
    if (this.instance) {
      this.instance.option("disabled", this._isDisabled());
    }
    return isUpdated;
  }
  _isVisible() {
    const {
      visible
    } = this.editor.option();
    return !!visible;
  }
  _isDisabled() {
    const isDefinedByUser = void 0 !== this.options.disabled;
    if (isDefinedByUser) {
      if (this.instance) {
        return this.instance.option("disabled");
      }
      return this.options.disabled;
    }
    const {
      readOnly
    } = this.editor.option();
    return readOnly;
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_index.js
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || "object" !== typeof buttonInfo || Array.isArray(buttonInfo)) {
      throw ui_errors_default.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw ui_errors_default.Error("E1054");
    }
  })();
  (() => {
    const {
      name: name2
    } = buttonInfo;
    if ("string" !== typeof name2) {
      throw ui_errors_default.Error("E1055");
    }
  })();
  (() => {
    const {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && "after" !== location && "before" !== location) {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (existingNames.includes(newName)) {
    throw ui_errors_default.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!predefinedButtonsInfo.find(((info) => info.name === name2));
}
var TextEditorButtonCollection = class {
  constructor(editor, defaultButtonsInfo) {
    this.buttons = [];
    this.defaultButtonsInfo = defaultButtonsInfo;
    this.editor = editor;
  }
  _compileButtonInfo(buttons) {
    const names = [];
    return buttons.map(((button) => {
      const isStringButton = "string" === typeof button;
      if (!isStringButton) {
        checkButtonInfo(button);
      }
      const isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
      if (isDefaultButton) {
        const defaultButtonInfo = this.defaultButtonsInfo.find(((_ref) => {
          let {
            name: name3
          } = _ref;
          return name3 === button || name3 === button.name;
        }));
        if (!defaultButtonInfo) {
          throw ui_errors_default.Error("E1056", this.editor.NAME, button);
        }
        checkNamesUniqueness(names, button);
        return defaultButtonInfo;
      }
      const {
        name: name2
      } = button;
      checkNamesUniqueness(names, name2);
      return _extends({}, button, {
        Ctor: CustomButton
      });
    }));
  }
  _createButton(buttonsInfo) {
    const {
      Ctor,
      options: options2,
      name: name2
    } = buttonsInfo;
    const button = new Ctor(name2, this.editor, options2);
    this.buttons.push(button);
    return button;
  }
  _renderButtons(buttons, $container, targetLocation) {
    let $buttonsContainer = null;
    const buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
    buttonsInfo.forEach(((buttonInfo) => {
      const {
        location = "after"
      } = buttonInfo;
      if (location === targetLocation) {
        this._createButton(buttonInfo).render((() => {
          $buttonsContainer = $buttonsContainer ?? renderer_default("<div>").addClass("dx-texteditor-buttons-container");
          if ("before" === targetLocation) {
            $container.prepend($buttonsContainer);
          } else {
            $container.append($buttonsContainer);
          }
          return $buttonsContainer;
        })());
      }
    }));
    return $buttonsContainer;
  }
  clean() {
    this.buttons.forEach(((button) => button.dispose()));
    this.buttons = [];
  }
  getButton(buttonName) {
    const button = this.buttons.find(((_ref2) => {
      let {
        name: name2
      } = _ref2;
      return name2 === buttonName;
    }));
    return null === button || void 0 === button ? void 0 : button.instance;
  }
  renderAfterButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "after");
  }
  renderBeforeButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "before");
  }
  updateButtons(names) {
    this.buttons.forEach(((button) => {
      if (!names || names.includes(button.name)) {
        button.update();
      }
    }));
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.base.js
var TEXTEDITOR_CLASS = "dx-texteditor";
var TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
var TextEditorLabelCreator = TextEditorLabel;
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw ui_errors_default.Error("E1053");
  }
}
var TextEditorBase = class extends editor_default {
  ctor(element, options2) {
    if (options2) {
      checkButtonsOptionType(options2.buttons);
    }
    this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._labelContainerElement = null;
    super.ctor(element, options2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      buttons: void 0,
      value: "",
      spellcheck: false,
      showClearButton: false,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: true,
      focusStateEnabled: true,
      text: void 0,
      displayValueFormatter: (value2) => isDefined(value2) && false !== value2 ? value2 : "",
      stylingMode: config_default2().editorStylingMode || "outlined",
      showValidationMark: true,
      label: "",
      labelMode: "static",
      labelMark: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const themeName = current();
        return isMaterial(themeName);
      },
      options: {
        labelMode: "floating",
        stylingMode: config_default2().editorStylingMode || "filled"
      }
    }, {
      device() {
        const themeName = current();
        return isFluent(themeName);
      },
      options: {
        labelMode: "outside"
      }
    }]);
  }
  _getDefaultButtons() {
    return [{
      name: "clear",
      Ctor: ClearButton
    }];
  }
  _isClearButtonVisible() {
    return this.option("showClearButton") && !this.option("readOnly");
  }
  _input() {
    return this.$element().find(".dx-texteditor-input").first();
  }
  _isFocused() {
    return focused(this._input()) || super._isFocused();
  }
  _inputWrapper() {
    return this.$element();
  }
  _buttonsContainer() {
    return this._inputWrapper().find(".dx-texteditor-buttons-container").eq(0);
  }
  _isControlKey(key) {
    return CONTROL_KEYS.includes(key);
  }
  _renderStylingMode() {
    super._renderStylingMode();
    const {
      stylingMode
    } = this.option();
    this._updateButtonsStyling(stylingMode);
  }
  _initMarkup() {
    this.$element().addClass("dx-texteditor");
    this._renderInput();
    this._renderButtonContainers();
    this._renderStylingMode();
    this._renderInputType();
    this._renderPlaceholder();
    this._renderProps();
    super._initMarkup();
    this._renderValue();
    this._renderLabel();
  }
  _render() {
    super._render();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._renderEnterKeyAction();
    this._renderEmptinessEvent();
  }
  _renderInput() {
    this._$textEditorContainer = renderer_default("<div>").addClass("dx-texteditor-container").appendTo(this.$element());
    this._$textEditorInputContainer = renderer_default("<div>").addClass("dx-texteditor-input-container").appendTo(this._$textEditorContainer);
    this._$textEditorInputContainer.append(this._createInput());
  }
  _getInputContainer() {
    return this._$textEditorInputContainer;
  }
  _renderPendingIndicator() {
    this.$element().addClass("dx-validation-pending");
    const $inputContainer = this._getInputContainer();
    const $indicatorElement = renderer_default("<div>").addClass("dx-pending-indicator").appendTo($inputContainer);
    this._pendingIndicator = this._createComponent($indicatorElement, load_indicator_default);
  }
  _disposePendingIndicator() {
    if (!this._pendingIndicator) {
      return;
    }
    this._pendingIndicator.dispose();
    this._pendingIndicator.$element().remove();
    this._pendingIndicator = null;
    this.$element().removeClass("dx-validation-pending");
  }
  _renderValidationState() {
    super._renderValidationState();
    const isPending = "pending" === this.option("validationStatus");
    if (isPending) {
      if (!this._pendingIndicator) {
        this._renderPendingIndicator();
      }
      this._showValidMark = false;
    } else {
      if ("invalid" === this.option("validationStatus")) {
        this._showValidMark = false;
      }
      if (!this._showValidMark && true === this.option("showValidationMark")) {
        this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator;
      }
      this._disposePendingIndicator();
    }
    this._toggleValidMark();
  }
  _getButtonsContainer() {
    return this._$textEditorContainer;
  }
  _renderButtonContainers() {
    const {
      buttons
    } = this.option();
    const $buttonsContainer = this._getButtonsContainer();
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, $buttonsContainer);
    this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, $buttonsContainer);
  }
  _cleanButtonContainers() {
    var _this$_$beforeButtons, _this$_$afterButtonsC;
    null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons || _this$_$beforeButtons.remove();
    null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC || _this$_$afterButtonsC.remove();
    this._buttonCollection.clean();
  }
  _clean() {
    this._buttonCollection.clean();
    this._disposePendingIndicator();
    this._unobserveLabelContainerResize();
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._$textEditorContainer = null;
    super._clean();
  }
  _createInput() {
    const $input = renderer_default("<input>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    return $input;
  }
  _setSubmitElementName(name2) {
    const {
      inputAttr
    } = this.option();
    super._setSubmitElementName(name2 || (null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr.name) || "");
  }
  _applyInputAttributes($input) {
    let customAttributes = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const inputAttributes = extend(this._getDefaultAttributes(), customAttributes);
    $input.attr(inputAttributes).addClass("dx-texteditor-input");
    this._setInputMinHeight($input);
  }
  _setInputMinHeight($input) {
    $input.css("minHeight", this.option("height") ? "0" : "");
  }
  _getPlaceholderAttr() {
    const {
      ios: ios2,
      mac: mac2
    } = devices_default.real();
    const {
      placeholder
    } = this.option();
    const value2 = placeholder || (ios2 || mac2 ? " " : null);
    return value2;
  }
  _getDefaultAttributes() {
    const defaultAttributes = {
      autocomplete: "off",
      placeholder: this._getPlaceholderAttr()
    };
    return defaultAttributes;
  }
  _updateButtons(names) {
    this._buttonCollection.updateButtons(names);
  }
  _updateButtonsStyling(editorStylingMode) {
    each(this.option("buttons"), ((_, _ref) => {
      let {
        options: options2,
        name: buttonName
      } = _ref;
      if (options2 && !options2.stylingMode && this.option("visible")) {
        const buttonInstance = this.getButton(buttonName);
        if (null !== buttonInstance && void 0 !== buttonInstance && buttonInstance.option) {
          buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained");
        }
      }
    }));
  }
  _renderValue() {
    const renderInputPromise = this._renderInputValue();
    return renderInputPromise.promise();
  }
  _renderInputValue(value2) {
    value2 = value2 ?? this.option("value");
    const {
      text,
      displayValue,
      displayValueFormatter
    } = this.option();
    let textValue = text;
    if (void 0 !== displayValue && null !== value2) {
      textValue = null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(displayValue);
    } else if (!isDefined(textValue)) {
      textValue = null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(value2);
    }
    this.option("text", textValue);
    if (this._input().val() !== (isDefined(textValue) ? textValue : "")) {
      this._renderDisplayText(textValue);
    } else {
      this._toggleEmptinessEventHandler();
    }
    return Deferred().resolve();
  }
  _renderDisplayText(text) {
    this._input().val(text);
    this._toggleEmptinessEventHandler();
  }
  _isValueValid() {
    if (this._input().length) {
      const {
        validity
      } = this._input().get(0);
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  _toggleEmptiness(isEmpty3) {
    this.$element().toggleClass("dx-texteditor-empty", isEmpty3);
    this._togglePlaceholder(isEmpty3);
  }
  _togglePlaceholder(isEmpty3) {
    this.$element().find(".dx-placeholder").eq(0).toggleClass("dx-state-invisible", !isEmpty3);
  }
  _renderProps() {
    this._toggleReadOnlyState();
    this._toggleSpellcheckState();
    this._toggleTabIndex();
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(value2);
    const $input = this._input();
    $input.prop("disabled", value2);
  }
  _toggleTabIndex() {
    const $input = this._input();
    const disabled = this.option("disabled");
    const focusStateEnabled = this.option("focusStateEnabled");
    if (disabled || !focusStateEnabled) {
      $input.attr("tabIndex", -1);
    } else {
      $input.removeAttr("tabIndex");
    }
  }
  _toggleReadOnlyState() {
    this._input().prop("readOnly", this._readOnlyPropValue());
    super._toggleReadOnlyState();
  }
  _readOnlyPropValue() {
    const {
      readOnly
    } = this.option();
    return !!readOnly;
  }
  _toggleSpellcheckState() {
    const {
      spellcheck
    } = this.option();
    this._input().prop("spellcheck", spellcheck);
  }
  _unobserveLabelContainerResize() {
    if (this._labelContainerElement) {
      resize_observer_default.unobserve(this._labelContainerElement);
      this._labelContainerElement = null;
    }
  }
  _getLabelContainer() {
    return this._input();
  }
  _getLabelContainerWidth() {
    return getWidth(this._getLabelContainer());
  }
  _getLabelBeforeWidth() {
    const buttonsBeforeWidth = this._$beforeButtonsContainer && getWidth(this._$beforeButtonsContainer);
    return buttonsBeforeWidth ?? 0;
  }
  _updateLabelWidth() {
    this._label.updateBeforeWidth(this._getLabelBeforeWidth());
    this._label.updateMaxWidth(this._getLabelContainerWidth());
  }
  _getFieldElement() {
    return this._getLabelContainer();
  }
  _setFieldAria(force) {
    var _this$_label;
    const inputAttr = this.option("inputAttr");
    const ariaLabel = null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr["aria-label"];
    const labelId = null === (_this$_label = this._label) || void 0 === _this$_label ? void 0 : _this$_label.getId();
    const value2 = ariaLabel ? void 0 : labelId;
    if (value2 || force) {
      const aria = {
        labelledby: value2,
        label: ariaLabel
      };
      this.setAria(aria, this._getFieldElement());
    }
  }
  _renderLabel() {
    this._unobserveLabelContainerResize();
    this._labelContainerElement = renderer_default(this._getLabelContainer()).get(0);
    const {
      label,
      labelMode,
      labelMark,
      rtlEnabled
    } = this.option();
    const labelConfig = {
      onClickHandler: () => {
        this.focus();
      },
      onHoverHandler: (e) => {
        e.stopPropagation();
      },
      onActiveHandler: (e) => {
        e.stopPropagation();
      },
      $editor: this.$element(),
      text: label,
      mark: labelMark,
      mode: labelMode,
      rtlEnabled,
      containsButtonsBefore: !!this._$beforeButtonsContainer,
      getContainerWidth: () => this._getLabelContainerWidth(),
      getBeforeWidth: () => this._getLabelBeforeWidth()
    };
    this._label = new TextEditorLabelCreator(labelConfig);
    this._setFieldAria();
    if (this._labelContainerElement) {
      resize_observer_default.observe(this._labelContainerElement, this._updateLabelWidth.bind(this));
    }
  }
  _renderPlaceholder() {
    this._renderPlaceholderMarkup();
    this._attachPlaceholderEvents();
  }
  _renderPlaceholderMarkup() {
    if (this._$placeholder) {
      this._$placeholder.remove();
      this._$placeholder = null;
    }
    const $input = this._input();
    const placeholder = this.option("placeholder");
    const placeholderAttributes = {
      id: placeholder ? `dx-${new guid_default()}` : void 0,
      "data-dx_placeholder": placeholder
    };
    const $placeholder = this._$placeholder = renderer_default("<div>").attr(placeholderAttributes);
    $placeholder.insertAfter($input);
    $placeholder.addClass("dx-placeholder");
  }
  _attachPlaceholderEvents() {
    const startEvent = addNamespace(m_pointer_default.up, this.NAME);
    m_events_engine_default.on(this._$placeholder, startEvent, (() => {
      m_events_engine_default.trigger(this._input(), "focus");
    }));
    this._toggleEmptinessEventHandler();
  }
  _placeholder() {
    return this._$placeholder ?? renderer_default();
  }
  _clearValueHandler(e) {
    const $input = this._input();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    this._clearValue();
    if (!this._isFocused()) {
      m_events_engine_default.trigger($input, "focus");
    }
    m_events_engine_default.trigger($input, "input");
  }
  _clearValue() {
    this.clear();
  }
  _renderEvents() {
    const $input = this._input();
    each(EVENTS_LIST, ((_, event) => {
      if (this.hasActionSubscription(`on${event}`)) {
        const action = this._createActionByOption(`on${event}`, {
          excludeValidators: ["readOnly"]
        });
        m_events_engine_default.on($input, addNamespace(event.toLowerCase(), this.NAME), ((e) => {
          if (this._disposed) {
            return;
          }
          action({
            event: e
          });
        }));
      }
    }));
  }
  _refreshEvents() {
    const $input = this._input();
    each(EVENTS_LIST, ((_, event) => {
      m_events_engine_default.off($input, addNamespace(event.toLowerCase(), this.NAME));
    }));
    this._renderEvents();
  }
  _keyPressHandler(e) {
    this.option("text", this._input().val());
  }
  _keyDownHandler(e) {
    const $input = this._input();
    const isCtrlEnter = e.ctrlKey && "enter" === normalizeKeyName(e);
    const {
      value: value2
    } = this.option();
    const isNewValue = $input.val() !== value2;
    if (isCtrlEnter && isNewValue) {
      m_events_engine_default.trigger($input, "change");
    }
  }
  _getValueChangeEventOptionName() {
    return "valueChangeEvent";
  }
  _renderValueChangeEvent() {
    const keyPressEvent = addNamespace(this._renderValueEventName(), `${this.NAME}TextChange`);
    const valueChangeEvent = addNamespace(this.option(this._getValueChangeEventOptionName()), `${this.NAME}ValueChange`);
    const keyDownEvent = addNamespace("keydown", `${this.NAME}TextChange`);
    const $input = this._input();
    m_events_engine_default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
    m_events_engine_default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
    m_events_engine_default.on($input, keyDownEvent, this._keyDownHandler.bind(this));
  }
  _cleanValueChangeEvent() {
    const valueChangeNamespace = `.${this.NAME}ValueChange`;
    const textChangeNamespace = `.${this.NAME}TextChange`;
    m_events_engine_default.off(this._input(), valueChangeNamespace);
    m_events_engine_default.off(this._input(), textChangeNamespace);
  }
  _refreshValueChangeEvent() {
    this._cleanValueChangeEvent();
    this._renderValueChangeEvent();
  }
  _renderValueEventName() {
    return "input change keypress";
  }
  _focusTarget() {
    return this._input();
  }
  _focusEventTarget() {
    return this.element();
  }
  _isInput(element) {
    return element === this._input().get(0);
  }
  _preventNestedFocusEvent(event) {
    if (event.isDefaultPrevented()) {
      return true;
    }
    let shouldPrevent = this._isNestedTarget(event.relatedTarget);
    if ("focusin" === event.type) {
      shouldPrevent = shouldPrevent && this._isNestedTarget(event.target) && !this._isInput(event.target);
    } else if (!shouldPrevent) {
      this._toggleFocusClass(false, this.$element());
    }
    if (shouldPrevent) {
      event.preventDefault();
    }
    return shouldPrevent;
  }
  _isNestedTarget(target) {
    return !!this.$element().find(target).length;
  }
  _focusClassTarget($element) {
    return this.$element();
  }
  _focusInHandler(event) {
    this._preventNestedFocusEvent(event);
    super._focusInHandler(event);
  }
  _focusOutHandler(event) {
    this._preventNestedFocusEvent(event);
    super._focusOutHandler(event);
  }
  _toggleFocusClass(isFocused, $element) {
    super._toggleFocusClass(isFocused, this._focusClassTarget($element));
  }
  _hasFocusClass(element) {
    return super._hasFocusClass(renderer_default(element || this.$element()));
  }
  _renderEmptinessEvent() {
    const $input = this._input();
    m_events_engine_default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
  }
  _toggleEmptinessEventHandler() {
    const text = this._input().val();
    const isEmpty3 = ("" === text || null === text) && this._isValueValid();
    this._toggleEmptiness(isEmpty3);
  }
  _valueChangeEventHandler(e, formattedValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
    this._saveValueChangeEvent(void 0);
  }
  _renderEnterKeyAction() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    });
    m_events_engine_default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
    m_events_engine_default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  }
  _enterKeyHandlerUp(e) {
    if (this._disposed) {
      return;
    }
    if ("enter" === normalizeKeyName(e)) {
      var _this$_enterKeyAction;
      null === (_this$_enterKeyAction = this._enterKeyAction) || void 0 === _this$_enterKeyAction || _this$_enterKeyAction.call(this, {
        event: e
      });
    }
  }
  _updateValue() {
    this._options.silent("text", null);
    this._renderValue();
  }
  _dispose() {
    this._enterKeyAction = void 0;
    super._dispose();
  }
  _getSubmitElement() {
    return this._input();
  }
  _hasActiveElement() {
    return this._input().is(dom_adapter_default.getActiveElement(this._input()[0]));
  }
  _optionChanged(args) {
    const {
      name: name2,
      fullName,
      value: value2
    } = args;
    const eventName = name2.replace("on", "");
    if (EVENTS_LIST.includes(eventName)) {
      this._refreshEvents();
      return;
    }
    switch (name2) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        super._optionChanged(args);
        this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder();
        this._setFieldAria(true);
        this._input().attr({
          placeholder: this._getPlaceholderAttr()
        });
        break;
      case "label":
        this._label.updateText(value2);
        this._setFieldAria(true);
        break;
      case "labelMark":
        this._label.updateMark(value2);
        break;
      case "labelMode":
        this._label.updateMode(value2);
        this._setFieldAria();
        break;
      case "width":
        super._optionChanged(args);
        this._label.updateMaxWidth(this._getLabelContainerWidth());
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons();
        super._optionChanged(args);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
      case "showValidationMark":
        break;
      case "value":
        this._updateValue();
        super._optionChanged(args);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(name2));
        break;
      case "stylingMode":
        this._renderStylingMode();
        this._updateLabelWidth();
        break;
      case "buttons": {
        if (fullName === name2) {
          checkButtonsOptionType(value2);
        }
        this._cleanButtonContainers();
        this._renderButtonContainers();
        const {
          stylingMode
        } = this.option();
        this._updateButtonsStyling(stylingMode);
        this._updateLabelWidth();
        this._label.updateContainsButtonsBefore(!!this._$beforeButtonsContainer);
        break;
      }
      case "visible":
        super._optionChanged(args);
        if (value2 && this.option("buttons")) {
          this._cleanButtonContainers();
          this._renderButtonContainers();
          const {
            stylingMode
          } = this.option();
          this._updateButtonsStyling(stylingMode);
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderInputType() {
    this._setInputType(this.option("mode"));
  }
  _setInputType(type2) {
    const input = this._input();
    if ("search" === type2) {
      type2 = "text";
    }
    try {
      input.prop("type", type2);
    } catch (e) {
      input.prop("type", "text");
    }
  }
  getButton(name2) {
    return this._buttonCollection.getButton(name2);
  }
  focus() {
    m_events_engine_default.trigger(this._input(), "focus");
  }
  clear() {
    if (this._showValidMark) {
      this._showValidMark = false;
      this._renderValidationState();
    }
    const defaultOptions3 = this._getDefaultOptions();
    if (this.option("value") === defaultOptions3.value) {
      this._options.silent("text", "");
      this._renderValue();
    } else {
      this.option("value", defaultOptions3.value);
    }
  }
  _resetInputText() {
    this._options.silent("text", this._initialValue);
    this._renderValue();
  }
  _isValueEqualToInitial() {
    const {
      value: value2
    } = this.option();
    const initialValue = this._initialValue;
    return value2 === initialValue;
  }
  _resetToInitialValue() {
    const shouldResetInputText = this._isValueEqualToInitial();
    if (shouldResetInputText) {
      this._resetInputText();
    } else {
      super._resetToInitialValue();
    }
    this._disposePendingIndicator();
    this._showValidMark = false;
    this._toggleValidMark();
  }
  _toggleValidMark() {
    this.$element().toggleClass("dx-valid", !!this._showValidMark);
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      super.reset(value2);
    } else {
      super.reset();
    }
  }
  on(eventName, eventHandler) {
    const result2 = super.on(eventName, eventHandler);
    const event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
    if (EVENTS_LIST.includes(event)) {
      this._refreshEvents();
    }
    return result2;
  }
};
var m_text_editor_base_default = TextEditorBase;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.rule.js
var BaseMaskRule = class {
  constructor(config2) {
    this._value = " ";
    extend(this, config2);
  }
  next(rule) {
    if (!arguments.length) {
      return this._next;
    }
    this._next = rule;
  }
  _prepareHandlingArgs(args, config2) {
    config2 = config2 || {};
    const handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
    args[handlingProperty] = config2.str ?? args[handlingProperty];
    args.start = config2.start ?? args.start;
    args.length = config2.length ?? args.length;
    args.index += 1;
    return args;
  }
  first(index) {
    index = index || 0;
    return this.next().first(index + 1);
  }
  isAccepted(caret3) {
    return false;
  }
  adjustedCaret(caret3, isForwardDirection, char) {
    return isForwardDirection ? this._adjustedForward(caret3, 0, char) : this._adjustedBackward(caret3, 0, char);
  }
  _adjustedForward(caret3, index, char) {
  }
  _adjustedBackward(caret3, index, char) {
  }
  isValid(args) {
  }
  reset() {
  }
  clear(args) {
  }
  text() {
  }
  value() {
  }
  rawValue() {
  }
  handle(args) {
  }
};
var EmptyMaskRule = class extends BaseMaskRule {
  next() {
  }
  handle() {
    return 0;
  }
  text() {
    return "";
  }
  value() {
    return "";
  }
  first() {
    return 0;
  }
  rawValue() {
    return "";
  }
  adjustedCaret() {
    return 0;
  }
  isValid() {
    return true;
  }
};
var MaskRule = class extends BaseMaskRule {
  text() {
    return (" " !== this._value ? this._value : this.maskChar) + this.next().text();
  }
  value() {
    return this._value + this.next().value();
  }
  rawValue() {
    return this._value + this.next().rawValue();
  }
  handle(args) {
    const str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
    if (!str || !str.length || !args.length) {
      return 0;
    }
    if (args.start) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char, args);
    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }));
  }
  clear(args) {
    this._tryAcceptChar(" ", args);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  reset() {
    this._accepted(false);
    this.next().reset();
  }
  _tryAcceptChar(char, args) {
    this._accepted(false);
    if (!this._isAllowed(char, args)) {
      return;
    }
    const acceptedChar = " " === char ? this.maskChar : char;
    args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
    this._accepted(true);
    this._value = char;
  }
  _accepted(value2) {
    if (!arguments.length) {
      return !!this._isAccepted;
    }
    this._isAccepted = !!value2;
  }
  first(index) {
    return " " === this._value ? index || 0 : super.first(index);
  }
  _isAllowed(char, args) {
    if (" " === char) {
      return true;
    }
    return this._isValid(char, args);
  }
  _isValid(char, args) {
    const {
      allowedChars
    } = this;
    if (allowedChars instanceof RegExp) {
      return allowedChars.test(char);
    }
    if (isFunction(allowedChars)) {
      return allowedChars(char, args.index, args.fullText);
    }
    if (Array.isArray(allowedChars)) {
      return allowedChars.includes(char);
    }
    return allowedChars === char;
  }
  isAccepted(caret3) {
    return 0 === caret3 ? this._accepted() : this.next().isAccepted(caret3 - 1);
  }
  _adjustedForward(caret3, index, char) {
    if (index >= caret3) {
      return index;
    }
    return this.next()._adjustedForward(caret3, index + 1, char) || index + 1;
  }
  _adjustedBackward(caret3, index) {
    if (index >= caret3 - 1) {
      return caret3;
    }
    return this.next()._adjustedBackward(caret3, index + 1) || index + 1;
  }
  isValid(args) {
    return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
  }
};
var StubMaskRule = class extends MaskRule {
  value() {
    return this.next().value();
  }
  handle(args) {
    const hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
    const str = hasValueProperty ? args.value : args.text;
    if (!str.length || !args.length) {
      return 0;
    }
    if (args.start || hasValueProperty) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start && args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char);
    const nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }) : args;
    return this.next().handle(nextArgs) + 1;
  }
  clear(args) {
    this._accepted(false);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  _tryAcceptChar(char) {
    this._accepted(this._isValid(char));
  }
  _isValid(char) {
    return char === this.maskChar;
  }
  first(index) {
    index = index || 0;
    return this.next().first(index + 1);
  }
  _adjustedForward(caret3, index, char) {
    if (index >= caret3 && char === this.maskChar) {
      return index;
    }
    if (caret3 === index + 1 && this._accepted()) {
      return caret3;
    }
    return this.next()._adjustedForward(caret3, index + 1, char);
  }
  _adjustedBackward(caret3, index) {
    if (index >= caret3 - 1) {
      return 0;
    }
    return this.next()._adjustedBackward(caret3, index + 1);
  }
  isValid(args) {
    return this.next().isValid(this._prepareHandlingArgs(args));
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.strategy.js
var BLUR_EVENT = "blur beforedeactivate";
var DELETE_INPUT_TYPES = ["deleteContentBackward", "deleteSoftLineBackward", "deleteContent", "deleteHardLineBackward"];
var HISTORY_INPUT_TYPES = ["historyUndo", "historyRedo"];
var EVENT_NAMES = ["focusIn", "focusOut", "input", "paste", "cut", "drop", "beforeInput"];
function getEmptyString(length) {
  return " ".repeat(length);
}
var MaskStrategy = class {
  constructor(editor) {
    this.editor = editor;
  }
  _editorOption() {
    return this.editor.option(...arguments);
  }
  _editorInput() {
    return this.editor._input();
  }
  _editorCaret(newCaret) {
    if (!newCaret) {
      return this.editor._caret();
    }
    this.editor._caret(newCaret);
  }
  _attachChangeEventHandler() {
    if (!this._editorOption("valueChangeEvent").split(" ").includes("change")) {
      return;
    }
    const $input = this._editorInput();
    const namespace = addNamespace(BLUR_EVENT, "dxMask");
    m_events_engine_default.on($input, namespace, ((e) => {
      this.editor._changeHandler(e);
    }));
  }
  _beforeInputHandler() {
    this._previousText = this._editorOption("text");
    this._prevCaret = this._editorCaret();
  }
  _inputHandler(event) {
    const {
      originalEvent
    } = event;
    if (!originalEvent) {
      return;
    }
    const {
      inputType: inputType2
    } = originalEvent;
    if (HISTORY_INPUT_TYPES.includes(inputType2)) {
      this._handleHistoryInputEvent();
    } else if (DELETE_INPUT_TYPES.includes(inputType2)) {
      this._handleBackwardDeleteInputEvent();
    } else {
      const currentCaret = this._editorCaret();
      if (!currentCaret.end) {
        return;
      }
      this._clearSelectedText();
      this._autoFillHandler(originalEvent);
      this._editorCaret(currentCaret);
      this._handleInsertTextInputEvent(originalEvent.data);
    }
    if (this._editorOption("text") === this._previousText) {
      event.stopImmediatePropagation();
    }
  }
  _handleHistoryInputEvent() {
    const caret3 = this._editorCaret();
    this._updateEditorMask({
      start: caret3.start,
      length: caret3.end - caret3.start,
      text: ""
    });
    this._editorCaret(this._prevCaret);
  }
  _handleBackwardDeleteInputEvent() {
    this._clearSelectedText(true);
    const caret3 = this._editorCaret();
    this.editor.setForwardDirection();
    this.editor._adjustCaret();
    const adjustedForwardCaret = this._editorCaret();
    if (adjustedForwardCaret.start !== caret3.start) {
      this.editor.setBackwardDirection();
      this.editor._adjustCaret();
    }
  }
  _clearSelectedText(isDeleteInputEvent) {
    const selectionLength = this._prevCaret && this._prevCaret.end - this._prevCaret.start;
    const length = selectionLength || Number(isDeleteInputEvent);
    const caret3 = this._editorCaret();
    if (!this._isAutoFill()) {
      this.editor.setBackwardDirection();
      this._updateEditorMask({
        start: caret3.start,
        length,
        text: getEmptyString(length)
      });
    }
  }
  _handleInsertTextInputEvent(data17) {
    var _this$_prevCaret;
    const text = data17 ?? "";
    this.editor.setForwardDirection();
    const hasValidChars = this._updateEditorMask({
      start: (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.start) ?? 0,
      length: text.length || 1,
      text
    });
    if (!hasValidChars) {
      this._editorCaret(this._prevCaret);
    }
  }
  _updateEditorMask(args) {
    const textLength = args.text.length;
    const processedCharsCount = this.editor._handleChain(args);
    this.editor._displayMask();
    if (this.editor.isForwardDirection()) {
      const {
        start,
        end
      } = this._editorCaret();
      const correction = processedCharsCount - textLength;
      const hasSkippedStub = processedCharsCount > 1;
      if (hasSkippedStub && 1 === textLength) {
        this._editorCaret({
          start: start + correction,
          end: end + correction
        });
      }
      this.editor._adjustCaret();
    }
    return !!processedCharsCount;
  }
  _focusInHandler() {
    this.editor._showMaskPlaceholder();
    this.editor.setForwardDirection();
    if (!this.editor._isValueEmpty() && this._editorOption("isValid")) {
      this.editor._adjustCaret();
    } else {
      const caret3 = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout((() => {
        this._editorCaret({
          start: caret3,
          end: caret3
        });
      }), 0);
    }
  }
  _focusOutHandler(event) {
    this.editor._changeHandler(event);
    if ("onFocus" === this._editorOption("showMaskMode") && this.editor._isValueEmpty()) {
      this._editorOption("text", "");
      this.editor._renderDisplayText("");
    }
  }
  _delHandler(event) {
    const {
      editor
    } = this;
    editor._maskKeyHandler(event, (() => {
      if (!editor._hasSelection()) {
        editor._handleKey(" ");
      }
    }));
  }
  _cutHandler(event) {
    const caret3 = this._editorCaret();
    const selectedText = this._editorInput().val().substring(caret3.start, caret3.end);
    this.editor._maskKeyHandler(event, (() => clipboardText(event, selectedText)));
  }
  _dropHandler() {
    this._clearDragTimer();
    this._dragTimer = setTimeout((() => {
      const value2 = this.editor._convertToValue(this._editorInput().val());
      this._editorOption("value", value2);
    }));
  }
  _pasteHandler(event) {
    const {
      editor
    } = this;
    if (this._editorOption("disabled")) {
      return;
    }
    const caret3 = this._editorCaret();
    editor._maskKeyHandler(event, (() => {
      const pastedText = clipboardText(event);
      const restText = editor._maskRulesChain.text().substring(caret3.end);
      const accepted = editor._handleChain({
        text: pastedText,
        start: caret3.start,
        length: pastedText.length
      });
      const newCaret = caret3.start + accepted;
      editor._handleChain({
        text: restText,
        start: newCaret,
        length: restText.length
      });
      editor._caret({
        start: newCaret,
        end: newCaret
      });
    }));
  }
  _autoFillHandler(event) {
    const {
      editor
    } = this;
    const inputVal = this._editorInput().val();
    this._inputHandlerTimer = setTimeout((() => {
      if (this._isAutoFill()) {
        editor._maskKeyHandler(event, (() => {
          editor._handleChain({
            text: inputVal,
            start: 0,
            length: inputVal.length
          });
        }));
        editor._validateMask();
      }
    }));
  }
  _isAutoFill() {
    const $input = this._editorInput();
    if (browser_default.webkit) {
      const input = $input.get(0);
      return (null === input || void 0 === input ? void 0 : input.matches(":-webkit-autofill")) ?? false;
    }
    return false;
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _clearTimers() {
    this._clearDragTimer();
    clearTimeout(this._caretTimeout);
    clearTimeout(this._inputHandlerTimer);
  }
  getHandler(handlerName) {
    return (args) => {
      var _this;
      null === (_this = this[`_${handlerName}Handler`]) || void 0 === _this || _this.call(this, args);
    };
  }
  attachEvents() {
    const $input = this._editorInput();
    EVENT_NAMES.forEach(((eventName) => {
      const namespace = addNamespace(eventName.toLowerCase(), "dxMask");
      m_events_engine_default.on($input, namespace, this.getHandler(eventName));
    }));
    this._attachChangeEventHandler();
  }
  detachEvents() {
    this._clearTimers();
    m_events_engine_default.off(this._editorInput(), ".dxMask");
  }
  clean() {
    this._clearTimers();
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_utils.caret.js
var {
  ios,
  mac
} = devices_default.real();
var isFocusingOnCaretChange = ios || mac;
var getCaret = (input) => {
  let range;
  try {
    range = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } catch (e) {
    range = {
      start: 0,
      end: 0
    };
  }
  return range;
};
var setCaret = (input, position2) => {
  const body = dom_adapter_default.getBody();
  if (!body.contains(input) && !body.contains(input.getRootNode().host)) {
    return;
  }
  try {
    input.selectionStart = position2.start;
    input.selectionEnd = position2.end;
  } catch (e) {
  }
};
var caret = function(input, position2) {
  let force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  input = renderer_default(input).get(0);
  if (!isDefined(position2)) {
    return getCaret(input);
  }
  if (!force && isFocusingOnCaretChange && dom_adapter_default.getActiveElement(input) !== input) {
    return;
  }
  setCaret(input, position2);
};
var m_utils_caret_default = caret;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.js
var caret2 = m_utils_caret_default;
var buildInMaskRules = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: (char) => isLiteralChar(char),
  l: (char) => isLiteralChar(char) || isSpaceChar(char),
  C: /\S/,
  c: /./,
  A: (char) => isLiteralChar(char) || isNumericChar(char),
  a: (char) => isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
};
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  const code = char.charCodeAt();
  return code > 64 && code < 91 || code > 96 && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return " " === char;
}
var TextEditorMask = class extends m_text_editor_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: message_default.format("validation-mask"),
      useMaskedValue: false,
      showMaskMode: "always"
    });
  }
  _supportedKeys() {
    const that = this;
    const keyHandlerMap = {
      del: that._maskStrategy.getHandler("del"),
      enter: that._changeHandler
    };
    const result2 = super._supportedKeys();
    each(keyHandlerMap, ((key, callback) => {
      const parentHandler = result2[key];
      result2[key] = function(e) {
        that.option("mask") && callback.call(that, e);
        parentHandler && parentHandler(e);
      };
    }));
    return result2;
  }
  _getSubmitElement() {
    return !this.option("mask") ? super._getSubmitElement() : this._$hiddenElement;
  }
  _init() {
    super._init();
    this._initMaskStrategy();
  }
  _initMaskStrategy() {
    this._maskStrategy = new MaskStrategy(this);
  }
  _initMarkup() {
    this._renderHiddenElement();
    super._initMarkup();
  }
  _attachMouseWheelEventHandlers() {
    if (!this._hasMouseWheelHandler()) {
      return;
    }
    const input = this._input();
    const eventName = addNamespace(EVENT_NAME, this.NAME);
    const mouseWheelAction = this._createAction(((e) => {
      const {
        event
      } = e;
      if (focused(input) && !isCommandKeyPressed(event)) {
        this._onMouseWheel(event);
        event.preventDefault();
        event.stopPropagation();
      }
    }));
    m_events_engine_default.off(input, eventName);
    m_events_engine_default.on(input, eventName, ((e) => {
      mouseWheelAction({
        event: e
      });
    }));
  }
  _hasMouseWheelHandler() {
    return false;
  }
  _onMouseWheel(e) {
  }
  _useMaskBehavior() {
    return Boolean(this.option("mask"));
  }
  _attachDropEventHandler() {
    const useMaskBehavior = this._useMaskBehavior();
    if (!useMaskBehavior) {
      return;
    }
    const eventName = addNamespace("drop", this.NAME);
    const input = this._input();
    m_events_engine_default.off(input, eventName);
    m_events_engine_default.on(input, eventName, ((e) => e.preventDefault()));
  }
  _render() {
    this._attachMouseWheelEventHandlers();
    this._renderMask();
    super._render();
    this._attachDropEventHandler();
  }
  _renderHiddenElement() {
    if (this.option("mask")) {
      this._$hiddenElement = renderer_default("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
    }
  }
  _removeHiddenElement() {
    this._$hiddenElement && this._$hiddenElement.remove();
  }
  _renderMask() {
    this.$element().removeClass("dx-texteditor-masked");
    this._maskRulesChain = null;
    this._maskStrategy.detachEvents();
    if (!this.option("mask")) {
      return;
    }
    this.$element().addClass("dx-texteditor-masked");
    this._maskStrategy.attachEvents();
    this._parseMask();
    this._renderMaskedValue();
  }
  _changeHandler(e) {
    const $input = this._input();
    const inputValue = $input.val();
    if (inputValue === this._changedValue) {
      return;
    }
    this._changedValue = inputValue;
    const changeEvent = createEvent(e, {
      type: "change"
    });
    m_events_engine_default.trigger($input, changeEvent);
  }
  _parseMask() {
    this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
    this._maskRulesChain = this._parseMaskRule(0);
  }
  _parseMaskRule(index) {
    const {
      mask
    } = this.option();
    if (index >= mask.length) {
      return new EmptyMaskRule();
    }
    const currentMaskChar = mask[index];
    const isEscapedChar = "\\" === currentMaskChar;
    const result2 = isEscapedChar ? new StubMaskRule({
      maskChar: mask[index + 1]
    }) : this._getMaskRule(currentMaskChar);
    result2.next(this._parseMaskRule(index + 1 + isEscapedChar));
    return result2;
  }
  _getMaskRule(pattern) {
    let ruleConfig;
    each(this._maskRules, ((rulePattern, allowedChars) => {
      if (rulePattern === pattern) {
        ruleConfig = {
          pattern: rulePattern,
          allowedChars
        };
        return false;
      }
    }));
    return isDefined(ruleConfig) ? new MaskRule(extend({
      maskChar: this.option("maskChar") || " "
    }, ruleConfig)) : new StubMaskRule({
      maskChar: pattern
    });
  }
  _renderMaskedValue() {
    if (!this._maskRulesChain) {
      return;
    }
    const value2 = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    const chainArgs = {
      length: value2.length
    };
    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
    this._handleChain(chainArgs);
    this._displayMask();
  }
  _replaceSelectedText(text, selection2, char) {
    if (void 0 === char) {
      return text;
    }
    const textBefore = text.slice(0, selection2.start);
    const textAfter = text.slice(selection2.end);
    const edited = textBefore + char + textAfter;
    return edited;
  }
  _isMaskedValueMode() {
    return this.option("useMaskedValue");
  }
  _displayMask(caret3) {
    caret3 = caret3 || this._caret();
    this._renderValue();
    this._caret(caret3);
  }
  _isValueEmpty() {
    return isEmpty(this._value);
  }
  _shouldShowMask() {
    const {
      showMaskMode
    } = this.option();
    if ("onFocus" === showMaskMode) {
      return focused(this._input()) || !this._isValueEmpty();
    }
    return true;
  }
  _showMaskPlaceholder() {
    if (this._shouldShowMask()) {
      const text = this._maskRulesChain.text();
      this.option("text", text);
      const {
        showMaskMode
      } = this.option();
      if ("onFocus" === showMaskMode) {
        this._renderDisplayText(text);
      }
    }
  }
  _renderValue() {
    if (this._maskRulesChain) {
      this._showMaskPlaceholder();
      if (this._$hiddenElement) {
        const value2 = this._maskRulesChain.value();
        const submitElementValue = !isEmpty(value2) ? this._getPreparedValue() : "";
        this._$hiddenElement.val(submitElementValue);
      }
    }
    return super._renderValue();
  }
  _getPreparedValue() {
    return this._convertToValue().replace(/\s+$/, "");
  }
  _valueChangeEventHandler(e, value2) {
    if (!this._maskRulesChain) {
      super._valueChangeEventHandler.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", this._getPreparedValue());
  }
  _isControlKeyFired(e) {
    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
  }
  _handleChain(args) {
    const handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
    this._updateMaskInfo();
    return handledCount;
  }
  _normalizeChainArguments(args) {
    args = args || {};
    args.index = 0;
    args.fullText = this._maskRulesChain.text();
    return args;
  }
  _convertToValue(text) {
    if (this._isMaskedValueMode()) {
      text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
    } else {
      text = text || this._value || "";
    }
    return text;
  }
  _replaceMaskCharWithEmpty(text) {
    const {
      maskChar
    } = this.option();
    return text.replace(new RegExp(maskChar, "g"), " ");
  }
  _maskKeyHandler(e, keyHandler) {
    if (this.option("readOnly")) {
      return;
    }
    this.setForwardDirection();
    e.preventDefault();
    this._handleSelection();
    const previousText = this._input().val();
    const raiseInputEvent = () => {
      if (previousText !== this._input().val()) {
        m_events_engine_default.trigger(this._input(), "input");
      }
    };
    const handled = keyHandler();
    if (handled) {
      handled.then(raiseInputEvent);
    } else {
      this.setForwardDirection();
      this._adjustCaret();
      this._displayMask();
      this._maskRulesChain.reset();
      raiseInputEvent();
    }
  }
  _handleKey(key, direction) {
    this._direction(direction || "forward");
    this._adjustCaret(key);
    this._handleKeyChain(key);
    this._moveCaret();
  }
  _handleSelection() {
    if (!this._hasSelection()) {
      return;
    }
    const caret3 = this._caret();
    const emptyChars = new Array(caret3.end - caret3.start + 1).join(" ");
    this._handleKeyChain(emptyChars);
  }
  _handleKeyChain(chars) {
    const caret3 = this._caret();
    const start = this.isForwardDirection() ? caret3.start : caret3.start - 1;
    const end = this.isForwardDirection() ? caret3.end : caret3.end - 1;
    const length = start === end ? 1 : end - start;
    this._handleChain({
      text: chars,
      start,
      length
    });
  }
  _tryMoveCaretBackward() {
    this.setBackwardDirection();
    const currentCaret = this._caret().start;
    this._adjustCaret();
    return !currentCaret || currentCaret !== this._caret().start;
  }
  _adjustCaret(char) {
    const caretStart = this._caret().start;
    const isForwardDirection = this.isForwardDirection();
    const caret3 = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
    this._caret({
      start: caret3,
      end: caret3
    });
  }
  _moveCaret() {
    const currentCaret = this._caret().start;
    const maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
    const caret3 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
    this._caret({
      start: caret3,
      end: caret3
    });
  }
  _caret(position2, force) {
    const $input = this._input();
    if (!$input.length) {
      return;
    }
    if (!arguments.length) {
      return caret2($input);
    }
    caret2($input, position2, force);
  }
  _hasSelection() {
    const caret3 = this._caret();
    return caret3.start !== caret3.end;
  }
  _direction(direction) {
    if (!arguments.length) {
      return this._typingDirection;
    }
    this._typingDirection = direction;
  }
  setForwardDirection() {
    this._direction("forward");
  }
  setBackwardDirection() {
    this._direction("backward");
  }
  isForwardDirection() {
    return "forward" === this._direction();
  }
  _updateMaskInfo() {
    this._textValue = this._maskRulesChain.text();
    this._value = this._maskRulesChain.value();
  }
  _clean() {
    this._maskStrategy && this._maskStrategy.clean();
    super._clean();
  }
  _validateMask() {
    if (!this._maskRulesChain) {
      return;
    }
    const isValid = isEmpty(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("maskInvalidMessage")
      }
    });
  }
  _updateHiddenElement() {
    this._removeHiddenElement();
    if (this.option("mask")) {
      this._input().removeAttr("name");
      this._renderHiddenElement();
    }
    const {
      name: name2
    } = this.option();
    this._setSubmitElementName(name2);
  }
  _updateMaskOption() {
    this._updateHiddenElement();
    this._renderMask();
    this._validateMask();
    this._refreshValueChangeEvent();
  }
  _processEmptyMask(mask) {
    if (mask) {
      return;
    }
    const value2 = this.option("value");
    this.option({
      text: value2,
      isValid: true,
      validationError: null
    });
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
    this._renderValue();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "mask":
        this._updateMaskOption();
        this._processEmptyMask(args.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue();
        this._validateMask();
        super._optionChanged(args);
        this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", "");
        this._renderValue();
        break;
      default:
        super._optionChanged(args);
    }
  }
  clear() {
    const {
      value: defaultValue
    } = this._getDefaultOptions();
    if (this.option("value") === defaultValue) {
      this._renderMaskedValue();
    }
    super.clear();
  }
};
var m_text_editor_mask_default = TextEditorMask;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_box.js
var window3 = getWindow();
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TextBox = class extends m_text_editor_mask_default {
  ctor(element, options2) {
    if (options2) {
      this._showClearButton = options2.showClearButton;
    }
    super.ctor(element, options2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  }
  _initMarkup() {
    this.$element().addClass("dx-textbox");
    super._initMarkup();
    this.setAria("role", "textbox");
  }
  _renderInputType() {
    super._renderInputType();
    this._renderSearchMode();
  }
  _useTemplates() {
    return false;
  }
  _renderProps() {
    super._renderProps();
    this._toggleMaxLengthProp();
  }
  _toggleMaxLengthProp() {
    const maxLength = this._getMaxLength();
    if (maxLength && maxLength > 0) {
      this._input().attr("maxLength", maxLength);
    } else {
      this._input().removeAttr("maxLength");
    }
  }
  _renderSearchMode() {
    const {
      mode
    } = this.option();
    if ("search" === mode) {
      this.$element().addClass("dx-searchbox");
      this._renderSearchIcon();
      if (void 0 === this._showClearButton) {
        const {
          showClearButton
        } = this.option();
        this._showClearButton = showClearButton;
        this.option("showClearButton", true);
      }
    } else {
      this.$element().removeClass("dx-searchbox");
      if (this._$searchIcon) {
        this._$searchIcon.remove();
      }
      this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
      delete this._showClearButton;
    }
  }
  _renderSearchIcon() {
    const $searchIcon = renderer_default("<div>").addClass("dx-icon").addClass("dx-icon-search");
    $searchIcon.prependTo(this._input().parent());
    this._$searchIcon = $searchIcon;
  }
  _getLabelContainerWidth() {
    if (this._$searchIcon) {
      const $inputContainer = this._input().parent();
      return getWidth($inputContainer) - this._getLabelBeforeWidth();
    }
    return super._getLabelContainerWidth();
  }
  _getLabelBeforeWidth() {
    let labelBeforeWidth = super._getLabelBeforeWidth();
    if (this._$searchIcon) {
      labelBeforeWidth += getOuterWidth(this._$searchIcon);
    }
    return labelBeforeWidth;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        break;
      case "mode":
        super._optionChanged(args);
        this._updateLabelWidth();
        break;
      case "mask":
        super._optionChanged(args);
        this._toggleMaxLengthProp();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _onKeyDownCutOffHandler(e) {
    const actualMaxLength = this._getMaxLength();
    if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
      const $input = renderer_default(e.target);
      const key = normalizeKeyName(e);
      this._cutOffExtraChar($input);
      return $input.val().length < actualMaxLength || ignoreKeys.includes(key) || "" !== window3.getSelection().toString();
    }
    return true;
  }
  _onChangeCutOffHandler(e) {
    const $input = renderer_default(e.target);
    if (this.option("maxLength")) {
      this._cutOffExtraChar($input);
    }
  }
  _cutOffExtraChar($input) {
    const actualMaxLength = this._getMaxLength();
    const textInput = $input.val();
    if (actualMaxLength && textInput.length > actualMaxLength) {
      $input.val(textInput.substr(0, actualMaxLength));
    }
  }
  _getMaxLength() {
    const {
      mask,
      maxLength
    } = this.option();
    const isMaskSpecified = !!mask;
    return isMaskSpecified ? null : maxLength;
  }
};
component_registrator_default("dxTextBox", TextBox);
var m_text_box_default = TextBox;

// node_modules/devextreme/esm/ui/text_box/text_box.js
var text_box_default = m_text_box_default;

// node_modules/devextreme/esm/ui/text_box.js
var text_box_default2 = text_box_default;

// node_modules/devextreme/esm/__internal/core/utils/m_stubs.js
function stubComponent(componentName) {
  return class {
    constructor() {
      throw new Error(`Module '${componentName}' not found`);
    }
    static getInstance() {
    }
  };
}

// node_modules/devextreme/esm/__internal/ui/collection/m_search_box_mixin.js
var EditorClass = stubComponent("TextBox");
var m_search_box_mixin_default = {
  _getDefaultOptions() {
    return extend(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: false,
      searchEditorOptions: {}
    });
  },
  _initMarkup() {
    this._renderSearch();
    this.callBase();
  },
  _renderSearch() {
    const $element = this.$element();
    const searchEnabled = this.option("searchEnabled");
    const searchBoxClassName = this._addWidgetPrefix("search");
    const rootElementClassName = this._addWidgetPrefix("with-search");
    if (!searchEnabled) {
      $element.removeClass(rootElementClassName);
      this._removeSearchBox();
      return;
    }
    const editorOptions = this._getSearchEditorOptions();
    if (this._searchEditor) {
      this._searchEditor.option(editorOptions);
    } else {
      $element.addClass(rootElementClassName);
      this._$searchEditorElement = renderer_default("<div>").addClass(searchBoxClassName).prependTo($element);
      this._searchEditor = this._createComponent(this._$searchEditorElement, EditorClass, editorOptions);
    }
  },
  _removeSearchBox() {
    this._$searchEditorElement && this._$searchEditorElement.remove();
    delete this._$searchEditorElement;
    delete this._searchEditor;
  },
  _getSearchEditorOptions() {
    const that = this;
    const userEditorOptions = that.option("searchEditorOptions");
    const searchText = message_default.format("Search");
    return extend({
      mode: "search",
      placeholder: searchText,
      tabIndex: that.option("tabIndex"),
      value: that.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": searchText
      },
      onValueChanged(e) {
        const searchTimeout = that.option("searchTimeout");
        that._valueChangeDeferred = Deferred();
        clearTimeout(that._valueChangeTimeout);
        that._valueChangeDeferred.done((function() {
          this.option("searchValue", e.value);
        }).bind(that));
        if (e.event && "input" === e.event.type && searchTimeout) {
          that._valueChangeTimeout = setTimeout((() => {
            that._valueChangeDeferred.resolve();
          }), searchTimeout);
        } else {
          that._valueChangeDeferred.resolve();
        }
      }
    }, userEditorOptions);
  },
  _getAriaTarget() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _focusTarget() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _updateFocusState(e, isFocused) {
    if (this.option("searchEnabled")) {
      this._toggleFocusClass(isFocused, this.$element());
    }
    this.callBase(e, isFocused);
  },
  getOperationBySearchMode: (searchMode) => "equals" === searchMode ? "=" : searchMode,
  _optionChanged(args) {
    switch (args.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          ui_errors_default.log("W1009");
          return;
        }
        if ("searchMode" === args.name) {
          this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
        } else {
          this._dataSource[args.name](args.value);
        }
        this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(args);
    }
  },
  focus() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _cleanAria() {
    const $element = this.$element();
    this.setAria({
      role: null,
      activedescendant: null
    }, $element);
    $element.attr("tabIndex", null);
  },
  _clean() {
    this.callBase();
    this._cleanAria();
  },
  _refresh() {
    if (this._valueChangeDeferred) {
      this._valueChangeDeferred.resolve();
    }
    this.callBase();
  },
  setEditorClass(value2) {
    EditorClass = value2;
  }
};

// node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js
var ui_search_box_mixin_default = m_search_box_mixin_default;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_data_converter.js
var DataConverter = class_default.inherit({
  ctor() {
    this._dataStructure = [];
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
  },
  _indexByKey: {},
  _convertItemsToNodes(items, parentKey) {
    const that = this;
    each(items, ((_, item) => {
      const parentId = isDefined(parentKey) ? parentKey : that._getParentId(item);
      const node = that._convertItemToNode(item, parentId);
      that._dataStructure.push(node);
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
      if (that._itemHasChildren(item)) {
        that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key);
      }
    }));
  },
  _checkForDuplicateId(key) {
    if (isDefined(this._indexByKey[key])) {
      throw ui_errors_default.Error("E1040", key);
    }
  },
  _getParentId(item) {
    return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0;
  },
  _itemHasChildren(item) {
    if ("plain" === this._dataType) {
      return;
    }
    const items = this._dataAccessors.getters.items(item);
    return items && items.length;
  },
  _getUniqueKey(item) {
    const keyGetter = this._dataAccessors.getters.key;
    const itemKey = keyGetter(item);
    const isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && isPrimitive(itemKey);
    return isCorrectKey ? itemKey : this.getItemsCount();
  },
  _convertItemToNode(item, parentKey) {
    this._itemsCount++;
    false !== item.visible && this._visibleItemsCount++;
    const node = {
      internalFields: {
        disabled: this._dataAccessors.getters.disabled(item, {
          defaultValue: false
        }),
        expanded: this._dataAccessors.getters.expanded(item, {
          defaultValue: false
        }),
        selected: this._dataAccessors.getters.selected(item, {
          defaultValue: false
        }),
        key: this._getUniqueKey(item),
        parentKey: isDefined(parentKey) ? parentKey : this._rootValue,
        item: this._makeObjectFromPrimitive(item),
        childrenKeys: []
      }
    };
    extend(node, item);
    delete node.items;
    return node;
  },
  setChildrenKeys() {
    const that = this;
    each(this._dataStructure, ((_, node) => {
      if (node.internalFields.parentKey === that._rootValue) {
        return;
      }
      const parent = that.getParentNode(node);
      parent && parent.internalFields.childrenKeys.push(node.internalFields.key);
    }));
  },
  _makeObjectFromPrimitive(item) {
    if (isPrimitive(item)) {
      const key = item;
      item = {};
      this._dataAccessors.setters.key(item, key);
    }
    return item;
  },
  _convertToPublicNode(node, parent) {
    if (!node) {
      return null;
    }
    const publicNode = {
      text: this._dataAccessors.getters.display(node),
      key: node.internalFields.key,
      selected: node.internalFields.selected,
      expanded: node.internalFields.expanded,
      disabled: node.internalFields.disabled,
      parent: parent || null,
      itemData: node.internalFields.item,
      children: [],
      items: []
    };
    if (publicNode.parent) {
      publicNode.parent.children.push(publicNode);
      publicNode.parent.items.push(publicNode);
    }
    return publicNode;
  },
  convertToPublicNodes(data17, parent) {
    if (!data17.length) {
      return [];
    }
    const that = this;
    const publicNodes = [];
    each(data17, ((_, node) => {
      node = isPrimitive(node) ? that._getByKey(node) : node;
      const publicNode = that._convertToPublicNode(node, parent);
      publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
      publicNodes.push(publicNode);
      node.internalFields.publicNode = publicNode;
    }));
    return publicNodes;
  },
  setDataAccessors(accessors) {
    this._dataAccessors = accessors;
  },
  _getByKey(key) {
    return this._dataStructure[this.getIndexByKey(key)] || null;
  },
  getParentNode(node) {
    return this._getByKey(node.internalFields.parentKey);
  },
  getByKey(data17, key) {
    if (null === key || void 0 === key) {
      return null;
    }
    let result2 = null;
    const that = this;
    return (function(data18, key2) {
      each(data18, ((_, element) => {
        const currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element);
        if (currentElementKey.toString() === key2.toString()) {
          result2 = element;
          return false;
        }
      }));
      return result2;
    })(data17, key);
  },
  getItemsCount() {
    return this._itemsCount;
  },
  getVisibleItemsCount() {
    return this._visibleItemsCount;
  },
  updateIndexByKey() {
    const that = this;
    this._indexByKey = {};
    each(this._dataStructure, ((index, node) => {
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = index;
    }));
  },
  updateChildrenKeys() {
    this._indexByKey = {};
    this.removeChildrenKeys();
    this.updateIndexByKey();
    this.setChildrenKeys();
  },
  removeChildrenKeys() {
    this._indexByKey = {};
    each(this._dataStructure, ((index, node) => {
      node.internalFields.childrenKeys = [];
    }));
  },
  getIndexByKey(key) {
    return this._indexByKey[key];
  },
  createPlainStructure(items, rootValue, dataType) {
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
    this._rootValue = rootValue;
    this._dataType = dataType;
    this._indexByKey = {};
    this._convertItemsToNodes(items);
    this.setChildrenKeys();
    return this._dataStructure;
  }
});
var m_data_converter_default = DataConverter;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_data_adapter.js
var EXPANDED = "expanded";
var SELECTED = "selected";
var DISABLED = "disabled";
ui_search_box_mixin_default.setEditorClass(text_box_default2);
var DataAdapter = class_default.inherit({
  ctor(options2) {
    this.options = {};
    extend(this.options, this._defaultOptions(), options2);
    this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
    this._selectedNodesKeys = [];
    this._expandedNodesKeys = [];
    this._dataStructure = [];
    this._createInternalDataStructure();
    this.getTreeNodes();
  },
  setOption(name2, value2) {
    this.options[name2] = value2;
    if ("recursiveSelection" === name2) {
      this._updateSelection();
    }
  },
  _defaultOptions: () => ({
    dataAccessors: void 0,
    items: [],
    multipleSelection: true,
    recursiveSelection: false,
    recursiveExpansion: false,
    rootValue: 0,
    searchValue: "",
    dataType: "tree",
    searchMode: "contains",
    dataConverter: new m_data_converter_default(),
    onNodeChanged: noop,
    sort: null
  }),
  _createInternalDataStructure() {
    this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
    this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
    this.options.dataConverter._dataStructure = this._dataStructure;
    this._updateSelection();
    this._updateExpansion();
  },
  _updateSelection() {
    if (this.options.recursiveSelection) {
      this._setChildrenSelection();
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _updateExpansion(key) {
    if (this.options.recursiveExpansion) {
      key ? this._updateOneBranch(key) : this._setParentExpansion();
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  _updateNodesKeysArray(property) {
    const that = this;
    let array = [];
    each(that._getDataBySelectionMode(), ((_, node) => {
      if (!that._isNodeVisible(node)) {
        return;
      }
      if (node.internalFields[property]) {
        if (property === EXPANDED || that.options.multipleSelection) {
          array.push(node.internalFields.key);
        } else {
          array.length && that.toggleSelection(array[0], false, true);
          array = [node.internalFields.key];
        }
      }
    }));
    return array;
  },
  _getDataBySelectionMode() {
    return this.options.multipleSelection ? this.getData() : this.getFullData();
  },
  _isNodeVisible: (node) => false !== node.internalFields.item.visible,
  _getByKey(data17, key) {
    return data17 === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data17, key);
  },
  _setChildrenSelection() {
    const that = this;
    each(this._dataStructure, ((_, node) => {
      if (!node.internalFields.childrenKeys.length) {
        return;
      }
      const isSelected = node.internalFields.selected;
      true === isSelected && that._toggleChildrenSelection(node, isSelected);
    }));
  },
  _setParentSelection() {
    const that = this;
    each(this._dataStructure, ((_, node) => {
      const parent = that.options.dataConverter.getParentNode(node);
      if (parent && node.internalFields.parentKey !== that.options.rootValue) {
        that._iterateParents(node, ((parent2) => {
          const newParentState = that._calculateSelectedState(parent2);
          that._setFieldState(parent2, SELECTED, newParentState);
        }));
      }
    }));
  },
  _setParentExpansion() {
    const that = this;
    each(this._dataStructure, ((_, node) => {
      if (!node.internalFields.expanded) {
        return;
      }
      that._updateOneBranch(node.internalFields.key);
    }));
  },
  _updateOneBranch(key) {
    const that = this;
    const node = this.getNodeByKey(key);
    that._iterateParents(node, ((parent) => {
      that._setFieldState(parent, EXPANDED, true);
    }));
  },
  _iterateChildren(node, recursive, callback, processedKeys) {
    if (!isFunction(callback)) {
      return;
    }
    const that = this;
    const nodeKey = node.internalFields.key;
    processedKeys = processedKeys || [];
    if (-1 === processedKeys.indexOf(nodeKey)) {
      processedKeys.push(nodeKey);
      each(node.internalFields.childrenKeys, ((_, key) => {
        const child = that.getNodeByKey(key);
        callback(child);
        if (child.internalFields.childrenKeys.length && recursive) {
          that._iterateChildren(child, recursive, callback, processedKeys);
        }
      }));
    }
  },
  _iterateParents(node, callback, processedKeys) {
    if (node.internalFields.parentKey === this.options.rootValue || !isFunction(callback)) {
      return;
    }
    processedKeys = processedKeys || [];
    const {
      key
    } = node.internalFields;
    if (-1 === processedKeys.indexOf(key)) {
      processedKeys.push(key);
      const parent = this.options.dataConverter.getParentNode(node);
      if (parent) {
        callback(parent);
        if (parent.internalFields.parentKey !== this.options.rootValue) {
          this._iterateParents(parent, callback, processedKeys);
        }
      }
    }
  },
  _calculateSelectedState(node) {
    const itemsCount = node.internalFields.childrenKeys.length;
    let selectedItemsCount = 0;
    let invisibleItemsCount = 0;
    let result2 = false;
    for (let i = 0; i <= itemsCount - 1; i++) {
      const childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]);
      const isChildInvisible = false === childNode.internalFields.item.visible;
      const childState = childNode.internalFields.selected;
      if (isChildInvisible) {
        invisibleItemsCount++;
        continue;
      }
      if (childState) {
        selectedItemsCount++;
      } else if (void 0 === childState) {
        selectedItemsCount += 0.5;
      }
    }
    if (selectedItemsCount) {
      result2 = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0;
    }
    return result2;
  },
  _toggleChildrenSelection(node, state) {
    const that = this;
    this._iterateChildren(node, true, ((child) => {
      if (that._isNodeVisible(child)) {
        that._setFieldState(child, SELECTED, state);
      }
    }));
  },
  _setFieldState(node, field, state) {
    if (node.internalFields[field] === state) {
      return;
    }
    node.internalFields[field] = state;
    if (node.internalFields.publicNode) {
      node.internalFields.publicNode[field] = state;
    }
    this.options.dataAccessors.setters[field](node.internalFields.item, state);
    this.options.onNodeChanged(node);
  },
  _markChildren(keys) {
    const that = this;
    each(keys, ((_, key) => {
      const index = that.getIndexByKey(key);
      const node = that.getNodeByKey(key);
      that._dataStructure[index] = 0;
      node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys);
    }));
  },
  _removeNode(key) {
    const node = this.getNodeByKey(key);
    this._dataStructure[this.getIndexByKey(key)] = 0;
    this._markChildren(node.internalFields.childrenKeys);
    const that = this;
    let counter = 0;
    const items = extend([], this._dataStructure);
    each(items, ((index, item) => {
      if (!item) {
        that._dataStructure.splice(index - counter, 1);
        counter++;
      }
    }));
  },
  _addNode(item) {
    const {
      dataConverter
    } = this.options;
    const node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
    this._dataStructure = this._dataStructure.concat(node);
    this._initialDataStructure = this._initialDataStructure.concat(node);
    dataConverter._dataStructure = dataConverter._dataStructure.concat(node);
  },
  _updateFields() {
    this.options.dataConverter.updateChildrenKeys();
    this._updateSelection();
    this._updateExpansion();
  },
  getSelectedNodesKeys() {
    return this._selectedNodesKeys;
  },
  getExpandedNodesKeys() {
    return this._expandedNodesKeys;
  },
  getData() {
    return this._dataStructure;
  },
  getFullData() {
    return this._initialDataStructure;
  },
  getNodeByItem(item) {
    let result2 = null;
    each(this._dataStructure, ((_, node) => {
      if (node.internalFields.item === item) {
        result2 = node;
        return false;
      }
    }));
    return result2;
  },
  getNodesByItems(items) {
    const that = this;
    const nodes = [];
    each(items, ((_, item) => {
      const node = that.getNodeByItem(item);
      node && nodes.push(node);
    }));
    return nodes;
  },
  getNodeByKey(key, data17) {
    return this._getByKey(data17 || this._getDataBySelectionMode(), key);
  },
  getTreeNodes() {
    return this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
  },
  getItemsCount() {
    return this.options.dataConverter.getItemsCount();
  },
  getVisibleItemsCount() {
    return this.options.dataConverter.getVisibleItemsCount();
  },
  getPublicNode: (node) => node.internalFields.publicNode,
  getRootNodes() {
    return this.getChildrenNodes(this.options.rootValue);
  },
  getChildrenNodes(parentKey) {
    return m_query_default(this._dataStructure, {
      langParams: this.options.langParams
    }).filter(["internalFields.parentKey", parentKey]).toArray();
  },
  getIndexByKey(key) {
    return this.options.dataConverter.getIndexByKey(key);
  },
  addItem(item) {
    this._addNode(item);
    this._updateFields();
  },
  removeItem(key) {
    this._removeNode(key);
    this._updateFields();
  },
  toggleSelection(key, state, selectRecursive) {
    const isSingleModeUnselect = this._isSingleModeUnselect(state);
    const node = this._getByKey(selectRecursive || isSingleModeUnselect ? this._initialDataStructure : this._dataStructure, key);
    this._setFieldState(node, SELECTED, state);
    if (this.options.recursiveSelection && !selectRecursive) {
      state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _isSingleModeUnselect(selectionState) {
    return !this.options.multipleSelection && !selectionState;
  },
  toggleNodeDisabledState(key, state) {
    const node = this.getNodeByKey(key);
    this._setFieldState(node, DISABLED, state);
  },
  toggleSelectAll(state) {
    if (!isDefined(state)) {
      return;
    }
    const that = this;
    const lastSelectedKey = that._selectedNodesKeys[that._selectedNodesKeys.length - 1];
    const dataStructure = that._isSingleModeUnselect(state) ? this._initialDataStructure : this._dataStructure;
    each(dataStructure, ((index, node) => {
      if (!that._isNodeVisible(node)) {
        return;
      }
      that._setFieldState(node, SELECTED, state);
    }));
    that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED);
    if (!state && that.options.selectionRequired) {
      that.toggleSelection(lastSelectedKey, true);
    }
  },
  isAllSelected() {
    if (this.getSelectedNodesKeys().length) {
      return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0;
    }
    return false;
  },
  toggleExpansion(key, state) {
    const node = this.getNodeByKey(key);
    this._setFieldState(node, EXPANDED, state);
    if (state) {
      this._updateExpansion(key);
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  isFiltered(item) {
    return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [item]).length;
  },
  _createCriteria(selector, value2, operation) {
    const searchFilter = [];
    if (!Array.isArray(selector)) {
      return [selector, operation, value2];
    }
    each(selector, ((i, item) => {
      searchFilter.push([item, operation, value2], "or");
    }));
    searchFilter.pop();
    return searchFilter;
  },
  _filterDataStructure(filterValue, dataStructure) {
    const selector = this.options.searchExpr || this.options.dataAccessors.getters.display;
    const operation = ui_search_box_mixin_default.getOperationBySearchMode(this.options.searchMode);
    const criteria = this._createCriteria(selector, filterValue, operation);
    dataStructure = dataStructure || this._initialDataStructure;
    return m_query_default(dataStructure, {
      langParams: this.options.langParams
    }).filter(criteria).toArray();
  },
  search(searchValue) {
    const that = this;
    let matches = this._filterDataStructure(searchValue);
    const {
      dataConverter
    } = this.options;
    !(function lookForParents(matches2, index) {
      const {
        length
      } = matches2;
      while (index < length) {
        const node = matches2[index];
        if (node.internalFields.parentKey === that.options.rootValue) {
          index++;
          continue;
        }
        const parent = dataConverter.getParentNode(node);
        if (!parent) {
          ui_errors_default.log("W1007", node.internalFields.parentKey, node.internalFields.key);
          index++;
          continue;
        }
        if (!parent.internalFields.expanded) {
          that._setFieldState(parent, EXPANDED, true);
        }
        if (matches2.includes(parent)) {
          index++;
          continue;
        }
        matches2.splice(index, 0, parent);
        lookForParents(matches2, index);
      }
    })(matches, 0);
    if (this.options.sort) {
      matches = m_store_helper_default.queryByOptions(m_query_default(matches), {
        sort: this.options.sort,
        langParams: this.options.langParams
      }).toArray();
    }
    dataConverter._indexByKey = {};
    each(matches, ((index, node) => {
      node.internalFields.childrenKeys = [];
      dataConverter._indexByKey[node.internalFields.key] = index;
    }));
    dataConverter._dataStructure = matches;
    dataConverter.setChildrenKeys();
    return dataConverter._dataStructure;
  }
});
var m_data_adapter_default = DataAdapter;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_hierarchical_collection_widget.js
var HierarchicalCollectionWidget = class extends ui_collection_widget_async_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      keyExpr: "id",
      displayExpr: "text",
      selectedExpr: "selected",
      disabledExpr: "disabled",
      itemsExpr: "items",
      hoverStateEnabled: true,
      parentIdExpr: "parentId",
      expandedExpr: "expanded"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _init() {
    super._init();
    this._initAccessors();
    this._initDataAdapter();
    this._initDynamicTemplates();
  }
  _initDataSource() {
    var _this$_dataSource;
    super._initDataSource();
    null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.paginate(false);
  }
  _initDataAdapter() {
    const accessors = this._createDataAdapterAccessors();
    this._dataAdapter = new m_data_adapter_default(extend({
      dataAccessors: {
        getters: accessors.getters,
        setters: accessors.setters
      },
      items: this.option("items")
    }, this._getDataAdapterOptions()));
  }
  _getDataAdapterOptions() {
  }
  _getItemExtraPropNames() {
  }
  _initDynamicTemplates() {
    const fields = ["text", "html", "items", "icon"].concat(this._getItemExtraPropNames());
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(this._addContent.bind(this), fields, this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter,
        items: this._itemsGetter
      })
    });
  }
  _addContent($container, itemData) {
    $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData));
  }
  _getLinkContainer(iconContainer, textContainer, itemData) {
    const {
      linkAttr,
      url
    } = itemData;
    const linkAttributes = isObject(linkAttr) ? linkAttr : {};
    return renderer_default("<a>").addClass("dx-item-url").attr(_extends({}, linkAttributes, {
      href: url
    })).append(iconContainer).append(textContainer);
  }
  _clickByLink(link) {
    link.addEventListener("click", ((e) => {
      e.stopPropagation();
    }), {
      once: true
    });
    link.click();
  }
  _getIconContainer(itemData) {
    if (!itemData.icon) {
      return;
    }
    const $imageContainer = getImageContainer(itemData.icon);
    if ($imageContainer.is("img")) {
      var _this$NAME;
      const componentName = null !== (_this$NAME = this.NAME) && void 0 !== _this$NAME && _this$NAME.startsWith("dxPrivateComponent") ? "" : `${this.NAME} `;
      $imageContainer.attr("alt", `${componentName}item icon`);
    }
    return $imageContainer;
  }
  _getTextContainer(itemData) {
    return renderer_default("<span>").text(itemData.text);
  }
  _initAccessors() {
    const that = this;
    each(this._getAccessors(), ((_, accessor) => {
      that._compileAccessor(accessor);
    }));
    this._compileDisplayGetter();
  }
  _getAccessors() {
    return ["key", "selected", "items", "disabled", "parentId", "expanded"];
  }
  _getChildNodes(node) {
    const that = this;
    const arr = [];
    each(node.internalFields.childrenKeys, ((_, key) => {
      const childNode = that._dataAdapter.getNodeByKey(key);
      arr.push(childNode);
    }));
    return arr;
  }
  _hasChildren(node) {
    return node && node.internalFields.childrenKeys.length;
  }
  _compileAccessor(optionName) {
    const getter = `_${optionName}Getter`;
    const setter = `_${optionName}Setter`;
    const optionExpr = this.option(`${optionName}Expr`);
    if (!optionExpr) {
      this[getter] = noop;
      this[setter] = noop;
      return;
    }
    if (isFunction(optionExpr)) {
      this[setter] = function(obj, value2) {
        obj[optionExpr()] = value2;
      };
      this[getter] = function(obj) {
        return obj[optionExpr()];
      };
      return;
    }
    this[getter] = compileGetter(optionExpr);
    this[setter] = compileSetter(optionExpr);
  }
  _createDataAdapterAccessors() {
    const that = this;
    const accessors = {
      getters: {},
      setters: {}
    };
    each(this._getAccessors(), ((_, accessor) => {
      const getterName = `_${accessor}Getter`;
      const setterName = `_${accessor}Setter`;
      const newAccessor = "parentId" === accessor ? "parentKey" : accessor;
      accessors.getters[newAccessor] = that[getterName];
      accessors.setters[newAccessor] = that[setterName];
    }));
    accessors.getters.display = !this._displayGetter ? (itemData) => itemData.text : this._displayGetter;
    return accessors;
  }
  _initMarkup() {
    super._initMarkup();
    this._addWidgetClass();
  }
  _addWidgetClass() {
    this._focusTarget().addClass(this._widgetClass());
  }
  _widgetClass() {
  }
  _renderItemFrame(index, itemData, $itemContainer) {
    const $itemFrame = super._renderItemFrame.apply(this, arguments);
    $itemFrame.toggleClass("dx-state-disabled", !!this._disabledGetter(itemData));
    return $itemFrame;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "displayExpr":
      case "keyExpr":
        this._initAccessors();
        this._initDynamicTemplates();
        this.repaint();
        break;
      case "itemsExpr":
      case "selectedExpr":
      case "disabledExpr":
      case "expandedExpr":
      case "parentIdExpr":
        this._initAccessors();
        this._initDataAdapter();
        this.repaint();
        break;
      case "items":
        this._initDataAdapter();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_hierarchical_collection_widget_default = HierarchicalCollectionWidget;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_menu_base.js
var ITEM_CLASS2 = "dx-menu-item";
var DX_ITEM_CONTENT_CLASS = `${ITEM_CLASS2}-content`;
var DX_MENU_SELECTED_ITEM_CLASS = `${ITEM_CLASS2}-selected`;
var DX_MENU_ITEM_WRAPPER_CLASS = `${ITEM_CLASS2}-wrapper`;
var DX_MENU_ITEM_EXPANDED_CLASS = `${ITEM_CLASS2}-expanded`;
var DX_ITEM_HAS_TEXT = `${ITEM_CLASS2}-has-text`;
var DX_ITEM_HAS_ICON = `${ITEM_CLASS2}-has-icon`;
var DX_ITEM_HAS_SUBMENU = `${ITEM_CLASS2}-has-submenu`;
var DX_MENU_ITEM_POPOUT_CLASS = `${ITEM_CLASS2}-popout`;
var DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = `${DX_MENU_ITEM_POPOUT_CLASS}-container`;
var DX_MENU_ITEM_CAPTION_CLASS = `${ITEM_CLASS2}-text`;
var DEFAULT_DELAY = {
  show: 50,
  hide: 300
};
var DX_MENU_ITEM_CAPTION_URL_CLASS = `${DX_MENU_ITEM_CAPTION_CLASS}-with-url`;
var MenuBase = class extends m_hierarchical_collection_widget_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      items: [],
      cssClass: "",
      activeStateEnabled: true,
      showSubmenuMode: {
        name: "onHover",
        delay: {
          show: 50,
          hide: 300
        }
      },
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1,
          duration: 100
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0,
          duration: 100
        }
      },
      selectByClick: false,
      focusOnSelectedItem: false,
      keyExpr: null,
      _itemAttributes: {
        role: "menuitem"
      },
      useInkRipple: false
    });
  }
  _itemDataKey() {
    return "dxMenuItemDataKey";
  }
  _itemClass() {
    return ITEM_CLASS2;
  }
  _setAriaSelectionAttribute($itemElement, isSelected) {
  }
  _selectedItemClass() {
    return DX_MENU_SELECTED_ITEM_CLASS;
  }
  _widgetClass() {
    return "dx-menu-base";
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _clean() {
    this.option("focusedElement", null);
    super._clean();
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        const $item = renderer_default(this.option("focusedElement"));
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      pageUp: noop,
      pageDown: noop
    });
  }
  _isSelectionEnabled() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _init() {
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS2}`;
    this._renderSelectedItem();
    this._initActions();
  }
  _getLinkContainer(iconContainer, textContainer, itemData) {
    const {
      linkAttr,
      url
    } = itemData;
    null === iconContainer || void 0 === iconContainer || iconContainer.addClass("dx-icon-with-url");
    null === textContainer || void 0 === textContainer || textContainer.addClass(DX_MENU_ITEM_CAPTION_URL_CLASS);
    return super._getLinkContainer(iconContainer, textContainer, {
      linkAttr,
      url
    });
  }
  _addContent($container, itemData) {
    const {
      html,
      url
    } = itemData;
    if (url) {
      $container.html(html);
      const link = this._getLinkContainer(this._getIconContainer(itemData), this._getTextContainer(itemData), itemData);
      $container.append(link);
    } else {
      super._addContent($container, itemData);
    }
    $container.append(this._getPopoutContainer(itemData));
    this._addContentClasses(itemData, $container.parent());
  }
  _getTextContainer(itemData) {
    const {
      text
    } = itemData;
    if (!text) {
      return;
    }
    const $itemContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS);
    const itemText = isPlainObject(itemData) ? text : String(itemData);
    return $itemContainer.text(itemText);
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _getPopoutContainer(itemData) {
    const {
      items
    } = itemData;
    let $popOutContainer;
    if (null !== items && void 0 !== items && items.length) {
      const $popOutImage = renderer_default("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
      $popOutContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage);
    }
    return $popOutContainer;
  }
  _getDataAdapterOptions() {
    return {
      rootValue: 0,
      multipleSelection: false,
      recursiveSelection: false,
      recursiveExpansion: false,
      searchValue: ""
    };
  }
  _selectByItem(selectedItem) {
    if (!selectedItem) {
      return;
    }
    const nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
    this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true);
  }
  _renderSelectedItem() {
    const selectedKeys = this._dataAdapter.getSelectedNodesKeys();
    const selectedKey = selectedKeys.length && selectedKeys[0];
    const selectedItem = this.option("selectedItem");
    if (!selectedKey) {
      this._selectByItem(selectedItem);
      return;
    }
    const node = this._dataAdapter.getNodeByKey(selectedKey);
    if (false === node.selectable) {
      return;
    }
    if (!selectedItem) {
      this.option("selectedItem", node.internalFields.item);
      return;
    }
    if (selectedItem !== node.internalFields.item) {
      this._dataAdapter.toggleSelection(selectedKey, false);
      this._selectByItem(selectedItem);
    }
  }
  _initActions() {
  }
  _initMarkup() {
    super._initMarkup();
    this.option("useInkRipple") && this._renderInkRipple();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState.apply(this, arguments);
    if (!this._inkRipple) {
      return;
    }
    const config2 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config2);
    } else {
      this._inkRipple.hideWave(config2);
    }
  }
  _getShowSubmenuMode() {
    const {
      showSubmenuMode
    } = this.option();
    const showMode = isObject(showSubmenuMode) ? showSubmenuMode.name : showSubmenuMode;
    return this._isDesktopDevice() ? showMode : "onClick";
  }
  _initSelectedItems() {
  }
  _isDesktopDevice() {
    return "desktop" === devices_default.real().deviceType;
  }
  _initEditStrategy() {
    const Strategy = m_menu_base_edit_strategy_default;
    this._editStrategy = new Strategy(this);
  }
  _addCustomCssClass($element) {
    $element.addClass(this.option("cssClass"));
  }
  _itemWrapperSelector() {
    return `.${DX_MENU_ITEM_WRAPPER_CLASS}`;
  }
  _hoverStartHandler(e) {
    const $itemElement = this._getItemElementByEventArgs(e);
    if (!$itemElement || this._isItemDisabled($itemElement)) {
      return;
    }
    e.stopPropagation();
    if ("onHover" === this._getShowSubmenuMode()) {
      const submenuDelay = this._getSubmenuDelay("show");
      if (0 === submenuDelay) {
        this._showSubmenu($itemElement);
      } else {
        clearTimeout(this._showSubmenusTimeout);
        this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, $itemElement), submenuDelay);
      }
    }
  }
  _getAvailableItems($itemElements) {
    return super._getAvailableItems($itemElements).filter((function() {
      return "hidden" !== renderer_default(this).css("visibility");
    }));
  }
  _isItemDisabled($item) {
    return this._disabledGetter($item.data(this._itemDataKey()));
  }
  _showSubmenu($itemElement) {
    this._addExpandedClass($itemElement);
  }
  _addExpandedClass(itemElement) {
    renderer_default(itemElement).addClass(DX_MENU_ITEM_EXPANDED_CLASS);
  }
  _getSubmenuDelay(action) {
    const {
      delay
    } = this.option("showSubmenuMode");
    if (!isDefined(delay)) {
      return DEFAULT_DELAY[action];
    }
    return isObject(delay) ? delay[action] : delay;
  }
  _getItemElementByEventArgs(eventArgs) {
    let $target = renderer_default(eventArgs.target);
    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
      return $target;
    }
    while (!$target.hasClass(this._itemClass())) {
      $target = $target.parent();
      if ($target.hasClass("dx-submenu")) {
        return null;
      }
    }
    return $target;
  }
  _hoverEndHandler(event) {
    clearTimeout(this._showSubmenusTimeout);
  }
  _hasSubmenu(node) {
    return null === node || void 0 === node ? void 0 : node.internalFields.childrenKeys.length;
  }
  _renderContentImpl() {
    this._renderItems(this._dataAdapter.getRootNodes());
  }
  _renderItems(nodes, submenuContainer) {
    if (!nodes.length) {
      return;
    }
    this.hasIcons = false;
    const $nodeContainer = this._renderContainer(this.$element(), submenuContainer);
    let firstVisibleIndex = -1;
    let nextGroupFirstIndex = -1;
    each(nodes, ((index, node) => {
      const isVisibleNode = false !== node.visible;
      if (isVisibleNode && firstVisibleIndex < 0) {
        firstVisibleIndex = index;
      }
      const isBeginGroup = firstVisibleIndex < index && (node.beginGroup || index === nextGroupFirstIndex);
      if (isBeginGroup) {
        nextGroupFirstIndex = isVisibleNode ? index : index + 1;
      }
      if (index === nextGroupFirstIndex && firstVisibleIndex < index) {
        this._renderSeparator($nodeContainer);
      }
      this._renderItem(index, node, $nodeContainer);
    }));
    if (!this.hasIcons) {
      $nodeContainer.addClass("dx-menu-no-icons");
    }
  }
  _renderContainer($wrapper, submenuContainer) {
    const $container = renderer_default("<ul>");
    this.setAria("role", "none", $container);
    return $container.appendTo($wrapper).addClass("dx-menu-items-container");
  }
  _createDOMElement($nodeContainer) {
    const $node = renderer_default("<li>");
    this.setAria("role", "none", $node);
    return $node.appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
  }
  _renderItem(index, node, $nodeContainer, $nodeElement) {
    var _items;
    const {
      items = []
    } = this.option();
    const $node = $nodeElement ?? this._createDOMElement($nodeContainer);
    if (null !== (_items = items[index + 1]) && void 0 !== _items && _items.beginGroup) {
      $node.addClass("dx-menu-last-group-item");
    }
    const $itemFrame = super._renderItem(index, node.internalFields.item, $node);
    if (node.internalFields.item === this.option("selectedItem")) {
      $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
    }
    $itemFrame.attr("tabIndex", -1);
    if (this._hasSubmenu(node)) {
      this.setAria("haspopup", "true", $itemFrame);
    }
    return $itemFrame;
  }
  _renderItemFrame(index, itemData, $itemContainer) {
    const $itemFrame = $itemContainer.children(`.${ITEM_CLASS2}`);
    return $itemFrame.length ? $itemFrame : super._renderItemFrame.apply(this, arguments);
  }
  _refreshItem($item, item) {
    const node = this._dataAdapter.getNodeByItem(item);
    const index = $item.data(this._itemIndexKey());
    const $nodeContainer = $item.closest("ul");
    const $nodeElement = $item.closest("li");
    this._renderItem(index, node, $nodeContainer, $nodeElement);
  }
  _addContentClasses(itemData, $itemFrame) {
    const hasText = itemData.text ? !!itemData.text.length : false;
    const hasIcon = !!itemData.icon;
    const hasSubmenu = itemData.items ? !!itemData.items.length : false;
    $itemFrame.toggleClass(DX_ITEM_HAS_TEXT, hasText);
    $itemFrame.toggleClass(DX_ITEM_HAS_ICON, hasIcon);
    if (!this.hasIcons) {
      this.hasIcons = hasIcon;
    }
    $itemFrame.toggleClass(DX_ITEM_HAS_SUBMENU, hasSubmenu);
  }
  _getItemContent($itemFrame) {
    let $itemContent = super._getItemContent($itemFrame);
    if (!$itemContent.length) {
      $itemContent = $itemFrame.children(`.${DX_ITEM_CONTENT_CLASS}`);
    }
    return $itemContent;
  }
  _postprocessRenderItem(args) {
    const $itemElement = renderer_default(args.itemElement);
    const selectedIndex = this._dataAdapter.getSelectedNodesKeys();
    if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
      this._setAriaSelectionAttribute($itemElement, "false");
      return;
    }
    const node = this._dataAdapter.getNodeByItem(args.itemData);
    if (node.internalFields.key === selectedIndex[0]) {
      $itemElement.addClass(this._selectedItemClass());
      this._setAriaSelectionAttribute($itemElement, "true");
    } else {
      this._setAriaSelectionAttribute($itemElement, "false");
    }
  }
  _isItemSelectable(item) {
    return false !== item.selectable;
  }
  _renderSeparator($itemsContainer) {
    renderer_default("<li>").appendTo($itemsContainer).addClass("dx-menu-separator");
  }
  _itemClickHandler(e) {
    if (e._skipHandling) {
      return;
    }
    const itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
    this._itemDXEventHandler(e, "onItemClick", {}, {
      beforeExecute: this._itemClick,
      afterExecute: itemClickActionHandler.bind(this)
    });
    e._skipHandling = true;
  }
  _itemClick(actionArgs) {
    const {
      event,
      itemData
    } = actionArgs.args[0];
    const $itemElement = this._getItemElementByEventArgs(event);
    const link = $itemElement && $itemElement.find(".dx-item-url")[0];
    if (!itemData.url || !link) {
      return;
    }
    const isNativeLinkClick = renderer_default(event.target).closest(".dx-item-url").length;
    if (isNativeLinkClick) {
      return;
    }
    this._clickByLink(link);
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    this._updateSelectedItemOnClick(actionArgs);
    if ("onClick" === this._getShowSubmenuMode()) {
      this._addExpandedClass(actionArgs.args[0].itemElement);
    }
  }
  _updateSelectedItemOnClick(actionArgs) {
    const args = actionArgs.args ? actionArgs.args[0] : actionArgs;
    if (!this._isItemSelectAllowed(args.itemData)) {
      return;
    }
    const selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
    const selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
    if (selectedNode) {
      this._toggleItemSelection(selectedNode, false);
    }
    if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
      this.selectItem(args.itemData);
    } else {
      this._fireSelectionChangeEvent(null, this.option("selectedItem"));
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
  _isItemSelectAllowed(item) {
    const isSelectByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
    return !this._isContainerEmpty() && isSelectByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item);
  }
  _isContainerEmpty() {
    return this._itemContainer().is(":empty");
  }
  _syncSelectionOptions() {
    return asyncNoop();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showSubmenuMode":
        break;
      case "selectedItem": {
        const node = this._dataAdapter.getNodeByItem(args.value);
        const selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
        if (node && node.internalFields.key !== selectedKey) {
          if (false === node.selectable) {
            break;
          }
          if (selectedKey) {
            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
          }
          this._toggleItemSelection(node, true);
          this._updateSelectedItems();
        }
        break;
      }
      case "cssClass":
      case "position":
      case "selectByClick":
      case "animation":
      case "useInkRipple":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _toggleItemSelection(node, value2) {
    const itemElement = this._getElementByItem(node.internalFields.item);
    itemElement && renderer_default(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
  }
  _getElementByItem(itemData) {
    let result2;
    each(this._itemElements(), ((_, itemElement) => {
      if (renderer_default(itemElement).data(this._itemDataKey()) !== itemData) {
        return true;
      }
      result2 = itemElement;
      return false;
    }));
    return result2;
  }
  _updateSelectedItems(oldSelection, newSelection) {
    if (oldSelection || newSelection) {
      this._fireSelectionChangeEvent(newSelection, oldSelection);
    }
  }
  _fireSelectionChangeEvent(addedSelection, removedSelection) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems: [addedSelection],
      removedItems: [removedSelection]
    });
  }
  selectItem(itemElement) {
    const itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    const selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
    const selectedItem = this.option("selectedItem");
    const node = this._dataAdapter.getNodeByItem(itemData);
    if (node.internalFields.key !== selectedKey) {
      if (selectedKey) {
        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
      }
      this._toggleItemSelection(node, true);
      this._updateSelectedItems(selectedItem, itemData);
      this._setOptionWithoutOptionChange("selectedItem", itemData);
    }
  }
  unselectItem(itemElement) {
    const itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    const node = this._dataAdapter.getNodeByItem(itemData);
    const selectedItem = this.option("selectedItem");
    if (node.internalFields.selected) {
      this._toggleItemSelection(node, false);
      this._updateSelectedItems(selectedItem, null);
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
};
MenuBase.ItemClass = item_default;
var m_menu_base_default = MenuBase;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_context_menu.js
var DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
var ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
var LOCAL_SUBMENU_DIRECTIONS = ["up", "down", "first", "last"];
var window4 = getWindow();
var ContextMenu2 = class extends m_menu_base_default {
  getShowEvent(showEventOption) {
    if (isObject(showEventOption)) {
      if (null !== showEventOption.name) {
        return showEventOption.name ?? "dxcontextmenu";
      }
    } else {
      return showEventOption;
    }
    return null;
  }
  getShowDelay(showEventOption) {
    return isObject(showEventOption) && showEventOption.delay;
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showEvent: "dxcontextmenu",
      hideOnOutsideClick: true,
      position: {
        at: "top left",
        my: "top left"
      },
      onShowing: null,
      onShown: null,
      onSubmenuCreated: null,
      onHiding: null,
      onHidden: null,
      onPositioning: null,
      submenuDirection: "auto",
      visible: false,
      target: void 0,
      onLeftFirstItem: null,
      onLeftLastItem: null,
      onCloseRootSubmenu: null,
      onExpandLastSubmenu: null
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !hasWindow(),
      options: {
        animation: null
      }
    }]);
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      closeOnOutsideClick: {
        since: "22.2",
        alias: "hideOnOutsideClick"
      }
    });
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS, ((index, action) => {
      this._actions[action] = this._createActionByOption(action) || noop;
    }));
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _focusInHandler() {
  }
  _itemContainer() {
    return this._overlay ? this._overlay.$content() : renderer_default();
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  itemsContainer() {
    return this._overlay ? this._overlay.$content() : void 0;
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        const $item = renderer_default(this.option("focusedElement"));
        this.hide();
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      escape: this.hide
    });
  }
  _getActiveItem(last) {
    const $availableItems = this._getAvailableItems();
    const $focusedItem = $availableItems.filter(".dx-state-focused");
    const $hoveredItem = $availableItems.filter(".dx-state-hover");
    const $hoveredItemContainer = $hoveredItem.closest(".dx-menu-items-container");
    if ($hoveredItemContainer.find(".dx-menu-item").index($focusedItem) >= 0) {
      return $focusedItem;
    }
    if ($hoveredItem.length) {
      return $hoveredItem;
    }
    return super._getActiveItem();
  }
  _moveFocus(location) {
    const $items = this._getItemsByLocation(location);
    const $oldTarget = this._getActiveItem(true);
    const $hoveredItem = this.itemsContainer().find(".dx-state-hover");
    const $focusedItem = renderer_default(this.option("focusedElement"));
    const $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);
    let $newTarget;
    switch (location) {
      case "up":
        $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.first())) {
          this._actions.onLeftFirstItem($oldTarget);
        }
        break;
      case "down":
        $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.last())) {
          this._actions.onLeftLastItem($oldTarget);
        }
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
        this._setFocusedElement($newTarget);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
        this._setFocusedElement($newTarget);
        break;
      case "first":
        $newTarget = $items.first();
        this._setFocusedElement($newTarget);
        break;
      case "last":
        $newTarget = $items.last();
        this._setFocusedElement($newTarget);
        break;
      default:
        return super._moveFocus(location);
    }
  }
  _setFocusedElement($element) {
    if ($element && 0 !== $element.length) {
      this.option("focusedElement", getPublicElement($element));
      this._scrollToElement($element);
    }
  }
  _scrollToElement($element) {
    const $scrollableElement = $element.closest(".dx-scrollable");
    const scrollableInstance = $scrollableElement.dxScrollable("instance");
    null === scrollableInstance || void 0 === scrollableInstance || scrollableInstance.scrollToElement($element);
  }
  _getItemsByLocation(location) {
    const $activeItem = this._getActiveItem(true);
    let $items;
    if (LOCAL_SUBMENU_DIRECTIONS.includes(location)) {
      $items = $activeItem.closest(".dx-menu-items-container").children().children();
    }
    $items = this._getAvailableItems($items);
    return $items;
  }
  _getAriaTarget() {
    return this.$element();
  }
  _refreshActiveDescendant() {
    if (isDefined(this._overlay)) {
      const $target = this._overlay.$content();
      super._refreshActiveDescendant($target);
    }
  }
  _hideSubmenuHandler() {
    const $curItem = this._getActiveItem(true);
    const $parentItem = $curItem.parents(".dx-menu-item-expanded").first();
    if ($parentItem.length) {
      this._hideSubmenusOnSameLevel($parentItem);
      this._hideSubmenu($curItem.closest(".dx-submenu"));
      return $parentItem;
    }
    this._actions.onCloseRootSubmenu($curItem);
  }
  _expandSubmenuHandler($items, location) {
    const $curItem = this._getActiveItem(true);
    const itemData = this._getItemData($curItem);
    const node = this._dataAdapter.getNodeByItem(itemData);
    const isItemHasSubmenu = this._hasSubmenu(node);
    const $submenu = $curItem.children(".dx-submenu");
    if (isItemHasSubmenu && !$curItem.hasClass("dx-state-disabled")) {
      if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
        this._showSubmenu($curItem);
      }
      return this._nextItem(this._getItemsByLocation(location));
    }
    this._actions.onExpandLastSubmenu($curItem);
    return;
  }
  _clean() {
    if (this._overlay) {
      this._overlay.$element().remove();
      this._overlay = null;
    }
    this._detachShowContextMenuEvents(this._getTarget());
    this._shownSubmenus = [];
    super._clean();
  }
  _initMarkup() {
    this.$element().addClass("dx-has-context-menu");
    this._eventNamespace = `${this.NAME}${new guid_default()}`;
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderVisibility(this.option("visible"));
    this._addWidgetClass();
  }
  _isTargetOutOfComponent(relatedTarget) {
    const isInsideContextMenu = 0 !== renderer_default(relatedTarget).closest(".dx-context-menu").length;
    return !isInsideContextMenu;
  }
  _focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    if (relatedTarget) {
      const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
      if (isTargetOutside) {
        this.hide();
      }
    }
    super._focusOutHandler(e);
  }
  _renderContentImpl() {
    this._detachShowContextMenuEvents(this._getTarget());
    this._showContextMenuEventHandler = this._createShowContextMenuEventHandler();
    this._attachShowContextMenuEvents();
  }
  _attachKeyboardEvents() {
    !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();
  }
  _renderContextMenuOverlay() {
    if (this._overlay) {
      return;
    }
    const overlayOptions = this._getOverlayOptions();
    this._overlay = this._createComponent(renderer_default("<div>").appendTo(this._$element), ui_overlay_default, overlayOptions);
    const $overlayContent = this._overlay.$content();
    $overlayContent.addClass("dx-context-menu");
    this._addCustomCssClass($overlayContent);
    this._addPlatformDependentClass($overlayContent);
    this._attachContextMenuEvent();
  }
  preventShowingDefaultContextMenuAboveOverlay() {
    const $itemContainer = this._itemContainer();
    const eventName = addNamespace(name, this._eventNamespace);
    m_events_engine_default.off($itemContainer, eventName, ".dx-submenu");
    m_events_engine_default.on($itemContainer, eventName, ".dx-submenu", ((e) => {
      e.stopPropagation();
      e.preventDefault();
      m_events_engine_default.off($itemContainer, eventName, ".dx-submenu");
    }));
  }
  _itemContextMenuHandler(e) {
    super._itemContextMenuHandler(e);
    e.stopPropagation();
  }
  _addPlatformDependentClass($element) {
    if (devices_default.current().phone) {
      $element.addClass(DX_MENU_PHONE_CLASS);
    }
  }
  _createShowContextMenuEventHandler() {
    const showContextMenuAction = this._createAction(((e) => {
      const {
        showEvent
      } = this.option();
      const delay = this.getShowDelay(showEvent);
      if (delay) {
        setTimeout((() => this._show(e.event)), delay);
      } else {
        this._show(e.event);
      }
    }), {
      validatingTargetName: "target"
    });
    return (e) => showContextMenuAction({
      event: e,
      target: renderer_default(e.currentTarget)
    });
  }
  _detachShowContextMenuEvents(target, event) {
    const {
      showEvent: showEventOption
    } = this.option();
    const showEvent = this.getShowEvent(event ?? showEventOption);
    if (!showEvent) {
      return;
    }
    const isSelector = isString(target);
    const eventName = addNamespace(showEvent, this._eventNamespace);
    if (isSelector) {
      m_events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
    } else {
      m_events_engine_default.off(renderer_default(target), eventName, this._showContextMenuEventHandler);
    }
  }
  _attachShowContextMenuEvents() {
    const {
      showEvent: showEventOption,
      disabled
    } = this.option();
    const showEvent = this.getShowEvent(showEventOption);
    if (!showEvent || disabled) {
      return;
    }
    const target = this._getTarget();
    const isSelector = isString(target);
    const eventName = addNamespace(showEvent, this._eventNamespace);
    if (isSelector) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
    } else {
      m_events_engine_default.on(target, eventName, this._showContextMenuEventHandler);
    }
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    e.stopPropagation();
  }
  _renderDimensions() {
  }
  _renderContainer($wrapper, submenuContainer) {
    const $holder = submenuContainer || this._itemContainer();
    $wrapper = renderer_default("<div>");
    $wrapper.appendTo($holder).addClass("dx-submenu").css("visibility", submenuContainer ? "hidden" : "visible");
    if (!$wrapper.parent().hasClass("dx-overlay-content")) {
      this._addCustomCssClass($wrapper);
    }
    const $itemsContainer = super._renderContainer($wrapper);
    if (submenuContainer) {
      return $itemsContainer;
    }
    if (this.option("width")) {
      return $itemsContainer.css("minWidth", this.option("width"));
    }
    if (this.option("height")) {
      return $itemsContainer.css("minHeight", this.option("height"));
    }
    return $itemsContainer;
  }
  _renderSubmenuItems(node, $itemFrame) {
    this._renderItems(this._getChildNodes(node), $itemFrame);
    const $submenu = $itemFrame.children(".dx-submenu");
    this._actions.onSubmenuCreated({
      itemElement: getPublicElement($itemFrame),
      itemData: node.internalFields.item,
      submenuElement: getPublicElement($submenu)
    });
    this._initScrollable($submenu);
    this.setAria({
      role: "menu"
    }, $submenu);
  }
  _getOverlayOptions() {
    const position2 = this.option("position");
    const overlayOptions = {
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      innerOverlay: true,
      hideOnOutsideClick: (e) => this._hideOnOutsideClickHandler(e),
      propagateOutsideClick: true,
      hideOnParentScroll: true,
      deferRendering: false,
      position: {
        at: position2.at,
        my: position2.my,
        of: this._getTarget(),
        collision: "flipfit"
      },
      shading: false,
      showTitle: false,
      height: "auto",
      width: "auto",
      onShown: this._overlayShownActionHandler.bind(this),
      onHiding: this._overlayHidingActionHandler.bind(this),
      onHidden: this._overlayHiddenActionHandler.bind(this),
      visualContainer: window4
    };
    return overlayOptions;
  }
  _overlayShownActionHandler(arg) {
    this._actions.onShown(arg);
  }
  _overlayHidingActionHandler(arg) {
    this._actions.onHiding(arg);
    if (!arg.cancel) {
      this._hideAllShownSubmenus();
      this._setOptionWithoutOptionChange("visible", false);
    }
  }
  _overlayHiddenActionHandler(arg) {
    this._actions.onHidden(arg);
  }
  _shouldHideOnOutsideClick(e) {
    const {
      closeOnOutsideClick,
      hideOnOutsideClick
    } = this.option();
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    if (isFunction(closeOnOutsideClick)) {
      return closeOnOutsideClick(e);
    }
    return hideOnOutsideClick || closeOnOutsideClick;
  }
  _hideOnOutsideClickHandler(e) {
    if (!this._shouldHideOnOutsideClick(e)) {
      return false;
    }
    if (dom_adapter_default.isDocument(e.target)) {
      return true;
    }
    const $activeItemContainer = this._getActiveItemsContainer(e.target);
    const $itemContainers = this._getItemsContainers();
    const $clickedItem = this._searchActiveItem(e.target);
    const $rootItem = this.$element().parents(".dx-menu-item");
    const isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
    const isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
    if (isInnerOverlayClicked || isRootItemClicked) {
      if ("onClick" === this._getShowSubmenuMode()) {
        this._hideAllShownChildSubmenus($clickedItem);
      }
      return false;
    }
    return true;
  }
  _getActiveItemsContainer(target) {
    return renderer_default(target).closest(".dx-menu-items-container");
  }
  _getItemsContainers() {
    return this._overlay.$content().find(".dx-menu-items-container");
  }
  _searchActiveItem(target) {
    return renderer_default(target).closest(".dx-menu-item").eq(0);
  }
  _isIncludeOverlay($activeOverlay, $allOverlays) {
    let isSame = false;
    each($allOverlays, ((index, $overlay) => {
      if ($activeOverlay.is($overlay) && !isSame) {
        isSame = true;
      }
    }));
    return isSame;
  }
  _hideAllShownChildSubmenus($clickedItem) {
    const $submenuElements = $clickedItem.find(".dx-submenu");
    const shownSubmenus = extend([], this._shownSubmenus);
    if ($submenuElements.length > 0) {
      each(shownSubmenus, ((index, $submenu) => {
        const $context = this._searchActiveItem($submenu.context).parent();
        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
          this._hideSubmenu($submenu);
        }
      }));
    }
  }
  _initScrollable($container) {
    this._createComponent($container, ui_scrollable_default, {
      useKeyboard: false,
      _onVisibilityChanged: (scrollable) => {
        scrollable.scrollTo(0);
      }
    });
  }
  _setSubMenuHeight($submenu, anchor, isNestedSubmenu) {
    const $itemsContainer = $submenu.find(".dx-menu-items-container");
    const contentHeight = getOuterHeight($itemsContainer);
    const maxHeight = this._getMaxHeight(anchor, !isNestedSubmenu);
    const menuHeight = Math.min(contentHeight, maxHeight);
    $submenu.css("height", isNestedSubmenu ? menuHeight : "100%");
  }
  _getMaxUsableSpace(offsetTop, windowHeight, anchorHeight) {
    return windowHeight;
  }
  _getMaxHeight(anchor) {
    let considerAnchorHeight = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    const windowHeight = getOuterHeight(window4);
    const isAnchorRenderer = isRenderer(anchor);
    const document2 = dom_adapter_default.getDocument();
    const isAnchorDocument = anchor.length && anchor[0] === document2;
    if (!isAnchorRenderer || isAnchorDocument) {
      return windowHeight;
    }
    const offsetTop = anchor[0].getBoundingClientRect().top;
    const anchorHeight = getOuterHeight(anchor);
    const availableHeight = considerAnchorHeight ? this._getMaxUsableSpace(offsetTop, windowHeight, anchorHeight) : Math.max(offsetTop + anchorHeight, windowHeight - offsetTop);
    return availableHeight - 10;
  }
  _dimensionChanged() {
    if (!this._shownSubmenus) {
      return;
    }
    this._shownSubmenus.forEach((($submenu) => {
      const $item = $submenu.closest(".dx-menu-item");
      this._setSubMenuHeight($submenu, $item, true);
      this._scrollToElement($item);
      const submenuPosition = this._getSubmenuPosition($item);
      position_default.setup($submenu, submenuPosition);
    }));
  }
  _getSubmenuBorderWidth() {
    return isGeneric(current()) ? 1 : 0;
  }
  _showSubmenu($item) {
    const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    this._hideSubmenusOnSameLevel($item);
    if (!this._hasSubmenu(node)) {
      return;
    }
    let $submenu = $item.children(".dx-submenu");
    const isSubmenuRendered = $submenu.length;
    super._showSubmenu($item);
    if (!isSubmenuRendered) {
      this._renderSubmenuItems(node, $item);
      $submenu = $item.children(".dx-submenu");
    }
    this._planPostRenderActions($submenu);
  }
  _setSubmenuVisible($submenu) {
    if (!$submenu) {
      return;
    }
    const $item = null === $submenu || void 0 === $submenu ? void 0 : $submenu.closest(".dx-menu-item");
    this._setSubMenuHeight($submenu, $item, true);
    if (!this._isSubmenuVisible($submenu) && $item) {
      this._drawSubmenu($item);
    }
  }
  _hideSubmenusOnSameLevel($item) {
    const $expandedItems = $item.parent(".dx-menu-item-wrapper").siblings().find(".dx-menu-item-expanded");
    if ($expandedItems.length) {
      $expandedItems.removeClass("dx-menu-item-expanded");
      this._hideSubmenu($expandedItems.find(".dx-submenu"));
    }
  }
  _hideSubmenuGroup($submenu) {
    if (this._isSubmenuVisible($submenu)) {
      this._hideSubmenuCore($submenu);
    }
  }
  _isSubmenuVisible($submenu) {
    return "visible" === $submenu.css("visibility");
  }
  _drawSubmenu($itemElement) {
    const animation2 = this.option("animation") ? this.option("animation").show : {};
    const $submenu = $itemElement.children(".dx-submenu");
    const submenuPosition = this._getSubmenuPosition($itemElement);
    if (this._overlay && this._overlay.option("visible")) {
      if (!isDefined(this._shownSubmenus)) {
        this._shownSubmenus = [];
      }
      if (!this._shownSubmenus.includes($submenu)) {
        this._shownSubmenus.push($submenu);
      }
      if (animation2) {
        fx_default.stop($submenu);
      }
      position_default.setup($submenu, submenuPosition);
      if (animation2) {
        if (isPlainObject(animation2.to)) {
          animation2.to.position = submenuPosition;
        }
        this._animate($submenu, animation2);
      }
      $submenu.css("visibility", "visible");
    }
  }
  _animate($container, options2) {
    fx_default.animate($container, options2);
  }
  _getSubmenuPosition($rootItem) {
    const submenuDirection = this.option("submenuDirection").toLowerCase();
    const $rootItemWrapper = $rootItem.parent(".dx-menu-item-wrapper");
    const position2 = {
      collision: "flip",
      of: $rootItemWrapper,
      offset: {
        h: 0,
        v: -1
      }
    };
    switch (submenuDirection) {
      case "left":
        position2.at = "left top";
        position2.my = "right top";
        break;
      case "right":
        position2.at = "right top";
        position2.my = "left top";
        break;
      default:
        if (this.option("rtlEnabled")) {
          position2.at = "left top";
          position2.my = "right top";
        } else {
          position2.at = "right top";
          position2.my = "left top";
        }
    }
    return position2;
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    if (!actionArgs.args.length) {
      return;
    }
    const {
      itemData
    } = actionArgs.args[0];
    const node = this._dataAdapter.getNodeByItem(itemData);
    if (!node) {
      return;
    }
    const $itemElement = renderer_default(actionArgs.args[0].itemElement);
    let $submenu = $itemElement.find(".dx-submenu");
    const shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
    if (shouldRenderSubmenu) {
      this._renderSubmenuItems(node, $itemElement);
      $submenu = $itemElement.find(".dx-submenu");
    }
    if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
      return;
    }
    this._updateSelectedItemOnClick(actionArgs);
    const notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
    if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
      return;
    }
    if (0 === $submenu.length) {
      const $prevSubmenu = renderer_default($itemElement.parents(".dx-submenu")[0]);
      this._hideSubmenu($prevSubmenu);
      if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
        this.option("visible", false);
      }
    } else {
      if (this._shownSubmenus && this._shownSubmenus.length > 0) {
        if (this._shownSubmenus[0].is($submenu)) {
          this._hideSubmenu($submenu);
        }
      }
      this._showSubmenu($itemElement);
    }
  }
  _hideSubmenu($curSubmenu) {
    const shownSubmenus = extend([], this._shownSubmenus);
    each(shownSubmenus, ((index, $submenu) => {
      if ($curSubmenu.is($submenu) || contains($curSubmenu[0], $submenu[0])) {
        $submenu.parent().removeClass("dx-menu-item-expanded");
        this._hideSubmenuCore($submenu);
      }
    }));
  }
  _hideSubmenuCore($submenu) {
    const index = this._shownSubmenus.indexOf($submenu);
    const animation2 = this.option("animation") ? this.option("animation").hide : null;
    if (index >= 0) {
      this._shownSubmenus.splice(index, 1);
    }
    this._stopAnimate($submenu);
    animation2 && this._animate($submenu, animation2);
    $submenu.css("visibility", "hidden");
    const scrollableInstance = $submenu.dxScrollable("instance");
    scrollableInstance.scrollTo(0);
    this.option("focusedElement", null);
  }
  _stopAnimate($container) {
    fx_default.stop($container, true);
  }
  _hideAllShownSubmenus() {
    const shownSubmenus = extend([], this._shownSubmenus);
    const $expandedItems = this._overlay.$content().find(".dx-menu-item-expanded");
    $expandedItems.removeClass("dx-menu-item-expanded");
    each(shownSubmenus, ((_, $submenu) => {
      this._hideSubmenu($submenu);
    }));
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._renderContentImpl();
    }
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    if (ACTIONS.includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "visible":
        this._renderVisibility(value2);
        break;
      case "disabled":
      case "position":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showEvent":
        if (previousValue) {
          this._detachShowContextMenuEvents(this._getTarget(), previousValue);
        }
        this._invalidate();
        break;
      case "target":
        if (previousValue) {
          this._detachShowContextMenuEvents(previousValue);
        }
        this._invalidate();
        break;
      case "closeOnOutsideClick":
      case "hideOnOutsideClick":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderVisibility(showing) {
    return showing ? this._show() : this._hide();
  }
  _toggleVisibility() {
  }
  _show(event) {
    const args = {
      jQEvent: event
    };
    let promise = Deferred().reject().promise();
    this._actions.onShowing(args);
    if (args.cancel) {
      return promise;
    }
    const position2 = this._positionContextMenu(event);
    if (position2) {
      var _event$originalEvent;
      if (!this._overlay) {
        this._renderContextMenuOverlay();
        this._overlay.$content().addClass(this._widgetClass());
        this._renderFocusState();
        this._attachHoverEvents();
        this._attachClickEvent();
        this._renderItems(this._dataAdapter.getRootNodes());
      }
      const $subMenu = renderer_default(this._overlay.content()).children(".dx-submenu");
      this._setOptionWithoutOptionChange("visible", true);
      this._overlay.option({
        height: () => this._getMaxHeight(position2.of),
        maxHeight: () => {
          const $content = $subMenu.find(".dx-menu-items-container");
          const borderWidth = this._getSubmenuBorderWidth();
          return getOuterHeight($content) + 2 * borderWidth;
        },
        position: position2
      });
      if ($subMenu.length) {
        this._setSubMenuHeight($subMenu, position2.of, false);
      }
      promise = this._overlay.show();
      event && event.stopPropagation();
      this._setAriaAttributes();
      if ((null === event || void 0 === event || null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === m_hold_default.name) {
        this.preventShowingDefaultContextMenuAboveOverlay();
      }
    }
    return promise;
  }
  _renderItems(nodes, submenuContainer) {
    super._renderItems(nodes, submenuContainer);
    const $submenu = renderer_default(this._overlay.content()).children(".dx-submenu");
    if ($submenu.length) {
      this._initScrollable($submenu);
    }
  }
  _setAriaAttributes() {
    this._overlayContentId = `dx-${new guid_default()}`;
    this.setAria("owns", this._overlayContentId);
    this.setAria({
      id: this._overlayContentId,
      role: "menu"
    }, this._overlay.$content());
  }
  _cleanAriaAttributes() {
    this._overlay && this.setAria("id", null, this._overlay.$content());
    this.setAria("owns", void 0);
  }
  _getTarget() {
    return this.option("target") || this.option("position").of || renderer_default(dom_adapter_default.getDocument());
  }
  _getContextMenuPosition() {
    return extend({}, this.option("position"), {
      of: this._getTarget()
    });
  }
  _positionContextMenu(jQEvent) {
    let position2 = this._getContextMenuPosition();
    const isInitialPosition = this._isInitialOptionValue("position");
    const positioningAction = this._createActionByOption("onPositioning");
    if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
      position2.of = jQEvent;
    }
    const actionArgs = {
      position: position2,
      event: jQEvent
    };
    positioningAction(actionArgs);
    if (actionArgs.cancel) {
      position2 = null;
    } else if (actionArgs.event) {
      actionArgs.event.cancel = true;
      jQEvent.preventDefault();
    }
    return position2;
  }
  _refresh() {
    if (!hasWindow()) {
      super._refresh();
    } else if (this._overlay) {
      const lastPosition = this._overlay.option("position");
      super._refresh();
      this._overlay && this._overlay.option("position", lastPosition);
    } else {
      super._refresh();
    }
  }
  _hide() {
    let promise;
    if (this._overlay) {
      promise = this._overlay.hide();
      this._setOptionWithoutOptionChange("visible", false);
    }
    this._cleanAriaAttributes();
    this.option("focusedElement", null);
    return promise || Deferred().reject().promise();
  }
  toggle(showing) {
    const visible = this.option("visible");
    showing = void 0 === showing ? !visible : showing;
    return this._renderVisibility(showing);
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
  _postProcessRenderItems($submenu) {
    this._setSubmenuVisible($submenu);
  }
};
component_registrator_default("dxContextMenu", ContextMenu2);
var m_context_menu_default = ContextMenu2;

// node_modules/devextreme/esm/ui/context_menu.js
var context_menu_default = m_context_menu_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/m_context_menu.js
var CONTEXT_MENU = "dx-context-menu";
var viewName = {
  columnHeadersView: "header",
  rowsView: "content",
  footerView: "footer",
  headerPanel: "headerPanel"
};
var VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
var ContextMenuController = class extends m_modules_default.ViewController {
  init() {
    this.createAction("onContextMenuPreparing");
  }
  getContextMenuItems(dxEvent) {
    if (!dxEvent) {
      return false;
    }
    const that = this;
    const $targetElement = renderer_default(dxEvent.target);
    let menuItems;
    each(VIEW_NAMES, (function() {
      const view = that.getView(this);
      if (!view) {
        return;
      }
      const $viewElement = view.element();
      const isTargetElementInsideView = (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.is($targetElement)) || (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.find($targetElement).length);
      if (isTargetElementInsideView) {
        var _$targetCellElement$, _rowOptions$cells;
        const isGroupRow3 = $targetElement.hasClass("dx-group-row");
        const $targetCellElement = isGroupRow3 ? $targetElement.find(".dx-group-cell").first() : $targetElement.closest(".dx-row > td, .dx-row > tr");
        const $targetRowElement = $targetCellElement.parent();
        const rowIndex = view.getRowIndex($targetRowElement);
        const columnIndex = null === (_$targetCellElement$ = $targetCellElement[0]) || void 0 === _$targetCellElement$ ? void 0 : _$targetCellElement$.cellIndex;
        const rowOptions = $targetRowElement.data("options");
        const options2 = {
          event: dxEvent,
          targetElement: getPublicElement($targetElement),
          target: viewName[this],
          rowIndex,
          row: view._getRows()[rowIndex],
          columnIndex,
          column: null === rowOptions || void 0 === rowOptions || null === (_rowOptions$cells = rowOptions.cells) || void 0 === _rowOptions$cells || null === (_rowOptions$cells = _rowOptions$cells[columnIndex]) || void 0 === _rowOptions$cells ? void 0 : _rowOptions$cells.column
        };
        options2.items = view.getContextMenuItems && view.getContextMenuItems(options2);
        that.executeAction("onContextMenuPreparing", options2);
        that._contextMenuPrepared(options2);
        menuItems = options2.items;
        if (menuItems) {
          return false;
        }
      }
      return;
    }));
    return menuItems;
  }
  _contextMenuPrepared(options2) {
  }
};
var ContextMenuView = class extends m_modules_default.View {
  init() {
    super.init();
    this._contextMenuController = this.getController("contextMenu");
  }
  _renderCore() {
    const $element = this.element().addClass(CONTEXT_MENU);
    this.setAria("role", "presentation", $element);
    this._createComponent($element, context_menu_default, {
      onPositioning: (actionArgs) => {
        const {
          event
        } = actionArgs;
        const contextMenuInstance = actionArgs.component;
        const items = this._contextMenuController.getContextMenuItems(event);
        if (items) {
          contextMenuInstance.option("items", items);
          event.stopPropagation();
        } else {
          actionArgs.cancel = true;
        }
      },
      onItemClick(params) {
        var _params$itemData, _params$itemData$onIt;
        null === (_params$itemData = params.itemData) || void 0 === _params$itemData || null === (_params$itemData$onIt = _params$itemData.onItemClick) || void 0 === _params$itemData$onIt || _params$itemData$onIt.call(_params$itemData, params);
      },
      cssClass: this.getWidgetContainerClass(),
      target: this.component.$element()
    });
  }
};
var contextMenuModule = {
  defaultOptions: () => ({
    onContextMenuPreparing: null
  }),
  controllers: {
    contextMenu: ContextMenuController
  },
  views: {
    contextMenuView: ContextMenuView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/context_menu.js
m_core_default.registerModule("contextMenu", contextMenuModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/error_handling/m_error_handling.js
var ErrorHandlingController = class extends m_modules_default.ViewController {
  init() {
    this._resizingController = this.getController("resizing");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
  }
  _createErrorRow(error, $tableElements) {
    let $errorRow;
    let $closeButton;
    const $errorMessage = this._renderErrorMessage(error);
    if ($tableElements) {
      $errorRow = renderer_default("<tr>").attr("role", "row").addClass("dx-error-row");
      $closeButton = renderer_default("<div>").addClass("dx-closebutton").addClass(this.addWidgetPrefix("action"));
      m_events_engine_default.on($closeButton, CLICK_EVENT_NAME, this.createAction(((args) => {
        var _this$_resizingContro, _this$_resizingContro2;
        const e = args.event;
        let $errorRow2;
        const errorRowIndex = renderer_default(e.currentTarget).closest(".dx-error-row").index();
        e.stopPropagation();
        each($tableElements, ((_, tableElement) => {
          $errorRow2 = renderer_default(tableElement).children("tbody").children("tr").eq(errorRowIndex);
          this.removeErrorRow($errorRow2);
        }));
        null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro || null === (_this$_resizingContro2 = _this$_resizingContro.fireContentReadyAction) || void 0 === _this$_resizingContro2 || _this$_resizingContro2.call(_this$_resizingContro);
      })));
      renderer_default("<td>").attr({
        colSpan: this._columnsController.getVisibleColumns().length,
        role: "gridcell"
      }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
      return $errorRow;
    }
    return $errorMessage;
  }
  _renderErrorMessage(error) {
    const message = error.url ? error.message.replace(error.url, "") : error.message || error;
    const $message = renderer_default("<div>").attr("role", "alert").attr("aria-roledescription", message_default.format("dxDataGrid-ariaError")).addClass("dx-error-message").text(message);
    if (error.url) {
      renderer_default("<a>").attr("href", error.url).text(error.url).appendTo($message);
    }
    return $message;
  }
  renderErrorRow(error, rowIndex, $popupContent) {
    var _this$_resizingContro3, _this$_resizingContro4;
    const that = this;
    let $errorMessageElement;
    let $firstErrorRow;
    if ($popupContent) {
      $popupContent.find(".dx-error-message").remove();
      $errorMessageElement = that._createErrorRow(error);
      $popupContent.prepend($errorMessageElement);
      return $errorMessageElement;
    }
    const viewElement = rowIndex >= 0 || !that._columnHeadersView.isVisible() ? that._rowsView : that._columnHeadersView;
    const $tableElements = viewElement.getTableElements();
    each($tableElements, ((_, tableElement) => {
      $errorMessageElement = that._createErrorRow(error, $tableElements);
      $firstErrorRow = $firstErrorRow || $errorMessageElement;
      if (rowIndex >= 0) {
        const $row = viewElement._getRowElements(renderer_default(tableElement)).eq(rowIndex);
        that.removeErrorRow($row.next());
        $errorMessageElement.insertAfter($row);
      } else {
        const $tbody = renderer_default(tableElement).children("tbody");
        const rowElements = $tbody.children("tr");
        if (that._columnHeadersView.isVisible()) {
          that.removeErrorRow(rowElements.last());
          renderer_default(tableElement).append($errorMessageElement);
        } else {
          that.removeErrorRow(rowElements.first());
          $tbody.first().prepend($errorMessageElement);
        }
      }
    }));
    null === (_this$_resizingContro3 = this._resizingController) || void 0 === _this$_resizingContro3 || null === (_this$_resizingContro4 = _this$_resizingContro3.fireContentReadyAction) || void 0 === _this$_resizingContro4 || _this$_resizingContro4.call(_this$_resizingContro3);
    return $firstErrorRow;
  }
  removeErrorRow($row) {
    if (!$row) {
      const $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
      $row = $columnHeaders && $columnHeaders.find(".dx-error-row");
      if (!$row || !$row.length) {
        const $rowsViewElement = this._rowsView.element();
        $row = $rowsViewElement && $rowsViewElement.find(".dx-error-row");
      }
    }
    $row && $row.hasClass("dx-error-row") && $row.remove();
  }
  optionChanged(args) {
    if ("errorRowEnabled" === args.name) {
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var data2 = (Base) => class extends Base {
  init() {
    super.init();
    this.dataErrorOccurred.add(((error, $popupContent) => {
      if (this.option("errorRowEnabled")) {
        this._errorHandlingController.renderErrorRow(error, void 0, $popupContent);
      }
    }));
    this.changed.add(((e) => {
      if (e && "loadError" === e.changeType) {
        return;
      }
      if (this._editingController && !this._editingController.hasChanges()) {
        var _this$_errorHandlingC, _this$_errorHandlingC2;
        null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || null === (_this$_errorHandlingC2 = _this$_errorHandlingC.removeErrorRow) || void 0 === _this$_errorHandlingC2 || _this$_errorHandlingC2.call(_this$_errorHandlingC);
      }
    }));
  }
};
var errorHandlingModule = {
  defaultOptions: () => ({
    errorRowEnabled: true
  }),
  controllers: {
    errorHandling: ErrorHandlingController
  },
  extenders: {
    controllers: {
      data: data2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/error_handling.js
m_core_default.registerModule("errorHandling", errorHandlingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/views/a11y_status_container_component.js
var CLASSES4 = {
  container: "dx-gridbase-a11y-status-container"
};
var A11yStatusContainerComponent = (_ref) => {
  let {
    statusText
  } = _ref;
  return renderer_default("<div>").text(statusText ?? "").addClass(CLASSES4.container).attr("role", "status");
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_grid_view.js
var VIEW_NAMES2 = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"];
var E2E_ATTRIBUTES = {
  a11yStatusContainer: "e2e-a11y-general-status-container"
};
var isPercentWidth = function(width) {
  return isString(width) && width.endsWith("%");
};
var isPixelWidth = function(width) {
  return isString(width) && width.endsWith("px");
};
var calculateFreeWidth = function(that, widths) {
  const contentWidth = that._rowsView.contentWidth();
  const totalWidth = that._getTotalWidth(widths, contentWidth);
  return contentWidth - totalWidth;
};
var calculateFreeWidthWithCurrentMinWidth = function(that, columnIndex, currentMinWidth, widths) {
  return calculateFreeWidth(that, widths.map(((width, index) => index === columnIndex ? currentMinWidth : width)));
};
var restoreFocus2 = function(focusedElement, selectionRange) {
  hiddenFocus(focusedElement, true);
  m_utils_default.setSelectionRange(focusedElement, selectionRange);
};
var ResizingController = class extends m_modules_default.ViewController {
  init() {
    this._prevContentMinHeight = null;
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editorFactoryController = this.getController("editorFactory");
    this._footerView = this.getView("footerView");
    this._rowsView = this.getView("rowsView");
    this._gridView = this.getView("gridView");
  }
  _initPostRenderHandlers() {
    if (!this._refreshSizesHandler) {
      this._refreshSizesHandler = (e) => {
        let resizeDeferred = new Deferred().resolve(null);
        const changeType = null === e || void 0 === e ? void 0 : e.changeType;
        const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
        const needFireContentReady = changeType && "updateSelection" !== changeType && "updateFocusedRow" !== changeType && "pageIndex" !== changeType && !isDelayed;
        this._dataController.changed.remove(this._refreshSizesHandler);
        if (this._checkSize()) {
          resizeDeferred = this._refreshSizes(e);
        }
        if (needFireContentReady) {
          when(resizeDeferred).done((() => {
            this._setAriaLabel(e);
            this.fireContentReadyAction();
          }));
        }
      };
      this._dataController.changed.add((() => {
        this._dataController.changed.add(this._refreshSizesHandler);
      }));
    }
  }
  _refreshSizes(e) {
    let resizeDeferred = new Deferred().resolve(null);
    const changeType = null === e || void 0 === e ? void 0 : e.changeType;
    const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
    const items = this._dataController.items();
    if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
      if (!isDelayed) {
        resizeDeferred = this.resize();
      }
    } else if ("update" === changeType) {
      var _e$changeTypes;
      if (0 === (null === (_e$changeTypes = e.changeTypes) || void 0 === _e$changeTypes ? void 0 : _e$changeTypes.length)) {
        return resizeDeferred;
      }
      if ((items.length > 1 || "insert" !== e.changeTypes[0]) && !(0 === items.length && "remove" === e.changeTypes[0]) && !e.needUpdateDimensions) {
        resizeDeferred = new Deferred();
        this._waitAsyncTemplates().done((() => {
          deferUpdate((() => deferRender((() => deferUpdate((() => {
            this._setScrollerSpacing();
            this._rowsView.resize();
            resizeDeferred.resolve();
          }))))));
        })).fail(resizeDeferred.reject);
      } else {
        resizeDeferred = this.resize();
      }
    }
    return resizeDeferred;
  }
  fireContentReadyAction() {
    this.component._fireContentReadyAction();
  }
  _getWidgetAriaLabel() {
    return "dxDataGrid-ariaDataGrid";
  }
  _setAriaLabel(e) {
    var _this$_columnsControl;
    let widgetStatusText = "";
    let labelParts = [];
    const columnCount = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl || null === (_this$_columnsControl = _this$_columnsControl._columns) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.filter(((_ref) => {
      let {
        visible
      } = _ref;
      return !!visible;
    })).length) ?? 0;
    const totalItemsCount = Math.max(0, this._dataController.totalItemsCount());
    const widgetAriaLabel = this._getWidgetAriaLabel();
    widgetStatusText = message_default.format(widgetAriaLabel, totalItemsCount, columnCount);
    const expandableWidgetAriaLabel = message_default.format(this._expandableWidgetAriaId);
    labelParts = [widgetStatusText];
    if (expandableWidgetAriaLabel) {
      labelParts.push(expandableWidgetAriaLabel);
    }
    const $ariaLabelElement = this.component.$element().children(".dx-gridbase-container");
    this.component.setAria("label", labelParts.join(". "), $ariaLabelElement);
    if (!(null !== e && void 0 !== e && e.isFirstRender)) {
      this._gridView.setWidgetA11yStatusText(widgetStatusText);
    }
  }
  _getBestFitWidths() {
    var _widths;
    const rowsView18 = this._rowsView;
    const columnHeadersView9 = this._columnHeadersView;
    let widths = rowsView18.getColumnWidths();
    if (!(null !== (_widths = widths) && void 0 !== _widths && _widths.length)) {
      var _rowsView$getTableEle;
      const headersTableElement = columnHeadersView9.getTableElement();
      columnHeadersView9.setTableElement(null === (_rowsView$getTableEle = rowsView18.getTableElement()) || void 0 === _rowsView$getTableEle ? void 0 : _rowsView$getTableEle.children(".dx-header"));
      widths = columnHeadersView9.getColumnWidths();
      columnHeadersView9.setTableElement(headersTableElement);
    }
    return widths;
  }
  _setVisibleWidths(visibleColumns, widths) {
    const columnsController = this._columnsController;
    columnsController.beginUpdate();
    each(visibleColumns, ((index, column) => {
      const columnId = columnsController.getColumnId(column);
      columnsController.columnOption(columnId, "visibleWidth", widths[index]);
    }));
    columnsController.endUpdate();
  }
  _toggleBestFitModeForView(view, className, isBestFit) {
    if (!view || !view.isVisible()) {
      return;
    }
    const $rowsTables = this._rowsView.getTableElements();
    const $viewTables = view.getTableElements();
    each($rowsTables, ((index, tableElement) => {
      let $tableBody;
      const $rowsTable = renderer_default(tableElement);
      const $viewTable = $viewTables.eq(index);
      if ($viewTable && $viewTable.length) {
        if (isBestFit) {
          $tableBody = $viewTable.children("tbody").appendTo($rowsTable);
        } else {
          $tableBody = $rowsTable.children(`.${className}`).appendTo($viewTable);
        }
        $tableBody.toggleClass(className, isBestFit);
        $tableBody.toggleClass(this.addWidgetPrefix("best-fit"), isBestFit);
      }
    }));
  }
  _toggleBestFitMode(isBestFit) {
    const $rowsTable = this._rowsView.getTableElement();
    const $rowsFixedTable = this._rowsView.getTableElements().eq(1);
    if (!$rowsTable) {
      return;
    }
    $rowsTable.css("tableLayout", isBestFit ? "auto" : "fixed");
    $rowsTable.children("colgroup").css("display", isBestFit ? "none" : "");
    each($rowsFixedTable.find("tr.dx-group-row"), ((idx, item) => {
      renderer_default(item).css("display", isBestFit ? "none" : "");
    }));
    $rowsFixedTable.toggleClass(this.addWidgetPrefix("table-fixed"), !isBestFit);
    this._toggleBestFitModeForView(this._columnHeadersView, "dx-header", isBestFit);
    this._toggleBestFitModeForView(this._footerView, "dx-footer", isBestFit);
    if (this._needStretch()) {
      $rowsTable.get(0).style.width = isBestFit ? "auto" : "";
    }
  }
  _toggleContentMinHeight(value2) {
    const scrollable = this._rowsView.getScrollable();
    const $contentElement = this._rowsView._findContentElement();
    if (false === (null === scrollable || void 0 === scrollable ? void 0 : scrollable.option("useNative"))) {
      if (true === value2) {
        this._prevContentMinHeight = $contentElement.get(0).style.minHeight;
      }
      if (isDefined(this._prevContentMinHeight)) {
        $contentElement.css({
          minHeight: value2 ? m_utils_default.getContentHeightLimit(browser_default) : this._prevContentMinHeight
        });
      }
    }
  }
  _synchronizeColumns() {
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnAutoWidth = this.option("columnAutoWidth");
    const hasUndefinedColumnWidth = visibleColumns.some(((column) => !isDefined(column.width)));
    let needBestFit = this._needBestFit();
    let hasMinWidth = false;
    let resetBestFitMode;
    let isColumnWidthsCorrected = false;
    let resultWidths = [];
    let focusedElement;
    let selectionRange;
    !needBestFit && each(visibleColumns, ((index, column) => {
      if ("auto" === column.width) {
        needBestFit = true;
        return false;
      }
      return;
    }));
    each(visibleColumns, ((index, column) => {
      if (column.minWidth) {
        hasMinWidth = true;
        return false;
      }
      return;
    }));
    this._toggleContentMinHeight(this._hasHeight);
    this._setVisibleWidths(visibleColumns, []);
    const $element = this.component.$element();
    if (needBestFit) {
      focusedElement = dom_adapter_default.getActiveElement($element.get(0));
      selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._toggleBestFitMode(true);
      resetBestFitMode = true;
    }
    if ($element && $element.get(0) && this._maxWidth) {
      delete this._maxWidth;
      $element[0].style.maxWidth = "";
    }
    deferUpdate((() => {
      if (needBestFit) {
        resultWidths = this._getBestFitWidths();
        each(visibleColumns, ((index, column) => {
          const columnId = columnsController.getColumnId(column);
          columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true);
        }));
      } else if (hasMinWidth) {
        resultWidths = this._getBestFitWidths();
      }
      each(visibleColumns, (function(index) {
        const {
          width
        } = this;
        if ("auto" !== width) {
          if (isDefined(width)) {
            resultWidths[index] = isNumeric(width) || isPixelWidth(width) ? parseFloat(width) : width;
          } else if (!columnAutoWidth) {
            resultWidths[index] = void 0;
          }
        }
      }));
      if (resetBestFitMode) {
        this._toggleBestFitMode(false);
        resetBestFitMode = false;
        if (focusedElement && focusedElement !== dom_adapter_default.getActiveElement()) {
          const isFocusOutsideWindow = getBoundingRect(focusedElement).bottom < 0;
          if (!isFocusOutsideWindow) {
            restoreFocus2(focusedElement, selectionRange);
          }
        }
      }
      isColumnWidthsCorrected = this._correctColumnWidths(resultWidths, visibleColumns);
      if (columnAutoWidth) {
        !(function() {
          let expandColumnWidth;
          each(visibleColumns, ((index, column) => {
            if ("groupExpand" === column.type) {
              expandColumnWidth = resultWidths[index];
            }
          }));
          each(visibleColumns, ((index, column) => {
            if ("groupExpand" === column.type && expandColumnWidth) {
              resultWidths[index] = expandColumnWidth;
            }
          }));
        })();
        if (this._needStretch()) {
          this._processStretch(resultWidths, visibleColumns);
        }
      }
      deferRender((() => {
        if (needBestFit || isColumnWidthsCorrected || hasUndefinedColumnWidth) {
          this._setVisibleWidths(visibleColumns, resultWidths);
        }
        this._toggleContentMinHeight(false);
      }));
    }));
  }
  _needBestFit() {
    return this.option("columnAutoWidth");
  }
  _needStretch() {
    return this._columnsController.getVisibleColumns().some(((c) => "auto" === c.width && !c.command));
  }
  _getAverageColumnsWidth(resultWidths) {
    const freeWidth = calculateFreeWidth(this, resultWidths);
    const columnCountWithoutWidth = resultWidths.filter(((width) => void 0 === width)).length;
    return freeWidth / columnCountWithoutWidth;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const that = this;
    let i;
    let hasPercentWidth = false;
    let hasAutoWidth = false;
    let isColumnWidthsCorrected = false;
    const $element = that.component.$element();
    const hasWidth = that._hasWidth;
    for (i = 0; i < visibleColumns.length; i++) {
      const index = i;
      const column = visibleColumns[index];
      const isHiddenColumn = "adaptiveHidden" === resultWidths[index];
      let width = resultWidths[index];
      const {
        minWidth
      } = column;
      if (minWidth) {
        if (void 0 === width) {
          const averageColumnsWidth = that._getAverageColumnsWidth(resultWidths);
          width = averageColumnsWidth;
        } else if (isPercentWidth(width)) {
          const freeWidth = calculateFreeWidthWithCurrentMinWidth(that, index, minWidth, resultWidths);
          if (freeWidth < 0) {
            width = -1;
          }
        }
      }
      const realColumnWidth = that._getRealColumnWidth(index, resultWidths.map(((columnWidth, columnIndex) => index === columnIndex ? width : columnWidth)));
      if (minWidth && !isHiddenColumn && realColumnWidth < minWidth) {
        resultWidths[index] = minWidth;
        isColumnWidthsCorrected = true;
        i = -1;
      }
      if (!isDefined(column.width)) {
        hasAutoWidth = true;
      }
      if (isPercentWidth(column.width)) {
        hasPercentWidth = true;
      }
    }
    if (!hasAutoWidth && resultWidths.length) {
      const $rowsViewElement = that._rowsView.element();
      const contentWidth = that._rowsView.contentWidth();
      const scrollbarWidth = that._rowsView.getScrollbarWidth();
      const totalWidth = that._getTotalWidth(resultWidths, contentWidth);
      if (totalWidth < contentWidth) {
        const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns, resultWidths);
        if (lastColumnIndex >= 0) {
          resultWidths[lastColumnIndex] = "auto";
          isColumnWidthsCorrected = true;
          if (false === hasWidth && !hasPercentWidth) {
            const borderWidth = m_utils_default.getComponentBorderWidth(this, $rowsViewElement);
            that._maxWidth = totalWidth + scrollbarWidth + borderWidth;
            $element.css("maxWidth", that._maxWidth);
          }
        }
      }
    }
    return isColumnWidthsCorrected;
  }
  _processStretch(resultSizes, visibleColumns) {
    const groupSize = this._rowsView.contentWidth();
    const tableSize = this._getTotalWidth(resultSizes, groupSize);
    const unusedIndexes = {
      length: 0
    };
    if (!resultSizes.length) {
      return;
    }
    each(visibleColumns, (function(index) {
      if (this.width || "adaptiveHidden" === resultSizes[index]) {
        unusedIndexes[index] = true;
        unusedIndexes.length++;
      }
    }));
    const diff = groupSize - tableSize;
    const diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
    let onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
    if (diff >= 0) {
      for (let i = 0; i < resultSizes.length; i++) {
        if (unusedIndexes[i]) {
          continue;
        }
        resultSizes[i] += diffElement;
        if (onePixelElementsCount > 0) {
          if (onePixelElementsCount < 1) {
            resultSizes[i] += onePixelElementsCount;
            onePixelElementsCount = 0;
          } else {
            resultSizes[i]++;
            onePixelElementsCount--;
          }
        }
      }
    }
  }
  _getRealColumnWidth(columnIndex, columnWidths, groupWidth) {
    let ratio = 1;
    const width = columnWidths[columnIndex];
    if (!isPercentWidth(width)) {
      return parseFloat(width);
    }
    const percentTotalWidth = columnWidths.reduce(((sum, width2, index) => {
      if (!isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }), 0);
    const pixelTotalWidth = columnWidths.reduce(((sum, width2) => {
      if (!width2 || "adaptiveHidden" === width2 || isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }), 0);
    groupWidth = groupWidth || this._rowsView.contentWidth();
    const freeSpace = groupWidth - pixelTotalWidth;
    const percentTotalWidthInPixel = percentTotalWidth * groupWidth / 100;
    if (pixelTotalWidth > 0 && percentTotalWidthInPixel + pixelTotalWidth >= groupWidth) {
      ratio = percentTotalWidthInPixel > freeSpace ? freeSpace / percentTotalWidthInPixel : 1;
    }
    return parseFloat(width) * groupWidth * ratio / 100;
  }
  _getTotalWidth(widths, groupWidth) {
    let result2 = 0;
    for (let i = 0; i < widths.length; i++) {
      const width = widths[i];
      if (width && "adaptiveHidden" !== width) {
        result2 += this._getRealColumnWidth(i, widths, groupWidth);
      }
    }
    return Math.ceil(result2);
  }
  _getGroupElement() {
    return this.component.$element().children().get(0);
  }
  updateSize(rootElement) {
    const that = this;
    const $rootElement = renderer_default(rootElement);
    const importantMarginClass = that.addWidgetPrefix("important-margin");
    if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible") && getWidth($rootElement)) {
      const $groupElement = $rootElement.children(`.${that.getWidgetContainerClass()}`);
      if ($groupElement.length) {
        $groupElement.detach();
      }
      that._hasHeight = !!getHeight($rootElement);
      const width = getWidth($rootElement);
      $rootElement.addClass(importantMarginClass);
      that._hasWidth = getWidth($rootElement) === width;
      $rootElement.removeClass(importantMarginClass);
      if ($groupElement.length) {
        $groupElement.appendTo($rootElement);
      }
    }
  }
  publicMethods() {
    return ["resize", "updateDimensions"];
  }
  _waitAsyncTemplates() {
    var _this$_columnHeadersV, _this$_rowsView, _this$_footerView;
    return when(null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.waitAsyncTemplates(true), null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.waitAsyncTemplates(true), null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.waitAsyncTemplates(true));
  }
  resize() {
    if (this.component._requireResize) {
      return new Deferred().resolve();
    }
    const d = new Deferred();
    this._waitAsyncTemplates().done((() => {
      when(this.updateDimensions()).done(d.resolve).fail(d.reject);
    })).fail(d.reject);
    return d.promise();
  }
  updateDimensions(checkSize) {
    const that = this;
    that._initPostRenderHandlers();
    if (!that._checkSize(checkSize)) {
      return;
    }
    const prevResult = that._resizeDeferred;
    const result2 = that._resizeDeferred = new Deferred();
    when(prevResult).always((() => {
      deferRender((() => {
        if (that._dataController.isLoaded()) {
          that._synchronizeColumns();
        }
        that._resetGroupElementHeight();
        deferUpdate((() => {
          deferRender((() => {
            deferUpdate((() => {
              that._updateDimensionsCore();
            }));
          }));
        }));
      })).done(result2.resolve).fail(result2.reject);
    }));
    return result2.promise();
  }
  _resetGroupElementHeight() {
    const groupElement = this._getGroupElement();
    const scrollable = this._rowsView.getScrollable();
    if (groupElement && groupElement.style.height && (!scrollable || !scrollable.scrollTop())) {
      groupElement.style.height = "";
    }
  }
  _checkSize(checkSize) {
    const $rootElement = this.component.$element();
    const isWidgetVisible = $rootElement.is(":visible");
    const isGridSizeChanged = this._lastWidth !== getWidth($rootElement) || this._lastHeight !== getHeight($rootElement) || this._devicePixelRatio !== getWindow().devicePixelRatio;
    return isWidgetVisible && (!checkSize || isGridSizeChanged);
  }
  _setScrollerSpacingCore() {
    const that = this;
    const vScrollbarWidth = that._rowsView.getScrollbarWidth();
    const hScrollbarWidth = that._rowsView.getScrollbarWidth(true);
    deferRender((() => {
      that._columnHeadersView && that._columnHeadersView.setScrollerSpacing(vScrollbarWidth);
      that._footerView && that._footerView.setScrollerSpacing(vScrollbarWidth);
      that._rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth);
    }));
  }
  _setScrollerSpacing() {
    const scrollable = this._rowsView.getScrollable();
    const isNativeScrolling = true === this.option("scrolling.useNative");
    if (!scrollable || isNativeScrolling) {
      deferRender((() => {
        deferUpdate((() => {
          this._setScrollerSpacingCore();
        }));
      }));
    } else {
      this._setScrollerSpacingCore();
    }
  }
  _setAriaOwns() {
    var _this$_columnHeadersV2, _this$_footerView2, _this$_rowsView2;
    const headerTable = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.getTableElement();
    const footerTable = null === (_this$_footerView2 = this._footerView) || void 0 === _this$_footerView2 ? void 0 : _this$_footerView2.getTableElement();
    null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.setAriaOwns(null === headerTable || void 0 === headerTable ? void 0 : headerTable.attr("id"), null === footerTable || void 0 === footerTable ? void 0 : footerTable.attr("id"));
  }
  _updateDimensionsCore() {
    const that = this;
    const dataController2 = that._dataController;
    const rowsView18 = that._rowsView;
    const $rootElement = that.component.$element();
    const groupElement = this._getGroupElement();
    const rootElementHeight = getHeight($rootElement);
    const height = that.option("height") ?? $rootElement.get(0).style.height;
    const isHeightSpecified = !!height && "auto" !== height;
    const maxHeight = parseInt($rootElement.css("maxHeight"));
    const maxHeightHappened = maxHeight && rootElementHeight >= maxHeight;
    const isMaxHeightApplied = groupElement && groupElement.scrollHeight === groupElement.offsetHeight;
    that.updateSize($rootElement);
    deferRender((() => {
      const hasHeight = that._hasHeight || !!maxHeight || isHeightSpecified;
      rowsView18.hasHeight(hasHeight);
      this._setAriaOwns();
      if (maxHeightHappened && !isMaxHeightApplied) {
        renderer_default(groupElement).css("height", maxHeight);
      }
      if (!dataController2.isLoaded()) {
        rowsView18.setLoading(dataController2.isLoading());
        return;
      }
      deferUpdate((() => {
        that._updateLastSizes($rootElement);
        that._setScrollerSpacing();
        each(VIEW_NAMES2, ((index, viewName2) => {
          const view = that.getView(viewName2);
          if (view) {
            view.resize();
          }
        }));
        this._editorFactoryController && this._editorFactoryController.resize();
      }));
    }));
  }
  _updateLastSizes($rootElement) {
    this._lastWidth = getWidth($rootElement);
    this._lastHeight = getHeight($rootElement);
    this._devicePixelRatio = getWindow().devicePixelRatio;
  }
  optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this.component._renderDimensions();
        this.resize();
      case "renderAsync":
        args.handled = true;
        return;
      default:
        super.optionChanged(args);
    }
  }
};
var SynchronizeScrollingController = class extends m_modules_default.ViewController {
  _scrollChangedHandler(views, pos, viewName2) {
    for (let j = 0; j < views.length; j++) {
      if (views[j] && views[j].name !== viewName2) {
        views[j].scrollTo({
          left: pos.left,
          top: pos.top
        });
      }
    }
  }
  init() {
    const views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      if (view) {
        view.scrollChanged.add(this._scrollChangedHandler.bind(this, views));
      }
    }
  }
};
var GridView = class extends m_modules_default.View {
  init() {
    this._resizingController = this.getController("resizing");
    this._dataController = this.getController("data");
  }
  _endUpdateCore() {
    if (this.component._requireResize) {
      this.component._requireResize = false;
      this._resizingController.resize();
    }
  }
  getView(name2) {
    return this.component._views[name2];
  }
  element() {
    return this._groupElement;
  }
  optionChanged(args) {
    const that = this;
    if (isDefined(that._groupElement) && "showBorders" === args.name) {
      that._groupElement.toggleClass(that.addWidgetPrefix("borders"), !!args.value);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _renderViews($groupElement) {
    const that = this;
    each(VIEW_NAMES2, ((index, viewName2) => {
      const view = that.getView(viewName2);
      if (view) {
        view.render($groupElement);
      }
    }));
  }
  _getTableRoleName() {
    return "group";
  }
  render($rootElement) {
    const isFirstRender = !this._groupElement;
    const $groupElement = this._groupElement || renderer_default("<div>").addClass(this.getWidgetContainerClass());
    $groupElement.addClass("dx-gridbase-container");
    $groupElement.toggleClass(this.addWidgetPrefix("borders"), !!this.option("showBorders"));
    this.setAria("role", "presentation", $rootElement);
    this.component.setAria("role", this._getTableRoleName(), $groupElement);
    this._rootElement = $rootElement || this._rootElement;
    if (isFirstRender) {
      this._groupElement = $groupElement;
      hasWindow() && this._resizingController.updateSize($rootElement);
      $groupElement.appendTo($rootElement);
    }
    if (!this._a11yGeneralStatusElement) {
      this._a11yGeneralStatusElement = A11yStatusContainerComponent({});
      this._a11yGeneralStatusElement.attr(E2E_ATTRIBUTES.a11yStatusContainer, "true");
      $groupElement.append(this._a11yGeneralStatusElement);
    }
    this._renderViews($groupElement);
  }
  update() {
    const that = this;
    const $rootElement = that._rootElement;
    const $groupElement = that._groupElement;
    if ($rootElement && $groupElement) {
      this._resizingController.resize();
      if (that._dataController.isLoaded()) {
        that._resizingController.fireContentReadyAction();
      }
    }
  }
  setWidgetA11yStatusText(statusText) {
    var _this$_a11yGeneralSta;
    null === (_this$_a11yGeneralSta = this._a11yGeneralStatusElement) || void 0 === _this$_a11yGeneralSta || _this$_a11yGeneralSta.text(statusText);
  }
};
var gridViewModule = {
  defaultOptions: () => ({
    showBorders: false,
    renderAsync: false
  }),
  controllers: {
    resizing: ResizingController,
    synchronizeScrolling: SynchronizeScrollingController
  },
  views: {
    gridView: GridView
  },
  VIEW_NAMES: VIEW_NAMES2
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/grid_view.js
m_core_default.registerModule("gridView", gridViewModule);

// node_modules/devextreme/esm/__internal/ui/toolbar/m_constants.js
var TOOLBAR_CLASS = "dx-toolbar";

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.base.js
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = class extends m_collection_widget_async_default {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter(((item) => "disabled" !== item));
  }
  _initTemplates() {
    super._initTemplates();
    const template = new BindableTemplate((($container, data17, rawModel) => {
      if (isPlainObject(data17)) {
        const {
          text,
          html,
          widget
        } = data17;
        if (text) {
          $container.text(text).wrapInner("<div>");
        }
        if (html) {
          $container.html(html);
        }
        if ("dxDropDownButton" === widget) {
          data17.options = data17.options ?? {};
          if (!isDefined(data17.options.stylingMode)) {
            data17.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained";
          }
        }
        if ("dxButton" === widget) {
          if (this.option("useFlatButtons")) {
            data17.options = data17.options ?? {};
            data17.options.stylingMode = data17.options.stylingMode ?? "text";
          }
          if (this.option("useDefaultButtons")) {
            data17.options = data17.options ?? {};
            data17.options.type = data17.options.type ?? "default";
          }
        }
      } else {
        $container.text(String(data17));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        useFlatButtons: true
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return TOOLBAR_ITEM_DATA_KEY;
  }
  _dimensionChanged(dimension) {
    if (this._disposed) {
      return;
    }
    this._arrangeItems();
    this._applyCompactMode();
  }
  _initMarkup() {
    this._renderToolbar();
    this._renderSections();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(TOOLBAR_CLASS);
    this._$toolbarItemsContainer = renderer_default("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element());
    this.setAria("role", "toolbar");
  }
  _renderSections() {
    const $container = this._$toolbarItemsContainer;
    each(["before", "center", "after"], ((_, section) => {
      const sectionClass = `dx-toolbar-${section}`;
      const $section = $container.find(`.${sectionClass}`);
      if (!$section.length) {
        this[`_$${section}Section`] = renderer_default("<div>").addClass(sectionClass).attr("role", "presentation").appendTo($container);
      }
    }));
  }
  _arrangeItems(width) {
    var _this$_$beforeSection, _this$_$afterSection;
    const elementWidth = width ?? getWidth(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const beforeRect = getBoundingRect(null === (_this$_$beforeSection = this._$beforeSection) || void 0 === _this$_$beforeSection ? void 0 : _this$_$beforeSection.get(0));
    const afterRect = getBoundingRect(null === (_this$_$afterSection = this._$afterSection) || void 0 === _this$_$afterSection ? void 0 : _this$_$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    const $label = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    const $section = $label.parent();
    if (!$label.length) {
      return;
    }
    const labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    const widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset;
    const widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width;
    let elemsAtSectionWidth = 0;
    $section.children().not(".dx-toolbar-label").each(((index, element) => {
      elemsAtSectionWidth += getOuterWidth(element);
    }));
    const freeSpace = elementWidth - elemsAtSectionWidth;
    const sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass("dx-toolbar-before")) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      const labelPaddings = getOuterWidth($label) - getWidth($label);
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  }
  _alignCenterSection(beforeRect, afterRect, elementWidth) {
    var _this$_$centerSection;
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    const isRTL = this.option("rtlEnabled");
    const leftRect = isRTL ? afterRect : beforeRect;
    const rightRect = isRTL ? beforeRect : afterRect;
    const centerRect = getBoundingRect(null === (_this$_$centerSection = this._$centerSection) || void 0 === _this$_$centerSection ? void 0 : _this$_$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  }
  _alignSection($section, maxWidth) {
    const $labels = $section.find(".dx-toolbar-label");
    let labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    const currentWidth = this._getCurrentLabelsWidth(labels);
    const difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  }
  _alignSectionLabels(labels, difference, expanding) {
    const getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (let i = 0; i < labels.length; i++) {
      const $label = renderer_default(labels[i]);
      const currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      let labelMaxWidth;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      const possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  }
  _applyCompactMode() {
    const $element = renderer_default(this.element());
    $element.removeClass("dx-toolbar-compact");
    if (this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), true) > getWidth($element)) {
      $element.addClass("dx-toolbar-compact");
    }
  }
  _getCurrentLabelsWidth(labels) {
    let width = 0;
    labels.forEach(((label) => {
      width += getOuterWidth(label);
    }));
    return width;
  }
  _getCurrentLabelsPaddings(labels) {
    let padding = 0;
    labels.forEach(((label) => {
      padding += getOuterWidth(label) - getWidth(label);
    }));
    return padding;
  }
  _renderItem(index, item, itemContainer, $after) {
    const location = item.location ?? "center";
    const container = itemContainer ?? this[`_$${location}Section`];
    const itemHasText = !!(item.text ?? item.html);
    const itemElement = super._renderItem(index, item, container, $after);
    itemElement.toggleClass("dx-toolbar-button", !itemHasText).toggleClass("dx-toolbar-label", itemHasText).addClass(item.cssClass);
    return itemElement;
  }
  _renderGroupedItems() {
    each(this.option("items"), ((groupIndex, group) => {
      const groupItems = group.items;
      const $container = renderer_default("<div>").addClass("dx-toolbar-group");
      const location = group.location ?? "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, ((itemIndex, item) => {
        this._renderItem(itemIndex, item, $container, null);
      }));
      this._$toolbarItemsContainer.find(`.dx-toolbar-${location}`).append($container);
    }));
  }
  _renderItems(items) {
    const grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : super._renderItems(items);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const items = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", 0 === items.length);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
    delete this._$beforeSection;
    delete this._$centerSection;
    delete this._$afterSection;
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._arrangeItems();
    }
  }
  _isVisible() {
    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;
  }
  _getIndexByItem(item) {
    return this._getToolbarItems().indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    super._itemOptionChanged(item, property, value2, prevValue);
    this._arrangeItems();
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (isMaterial()) {
      const _waitParentAnimationFinished = () => new Promise(((resolve) => {
        const check = () => {
          let readyToResolve = true;
          this.$element().parents().each(((_, parent) => {
            if (fx_default.isAnimating(renderer_default(parent))) {
              readyToResolve = false;
              return false;
            }
          }));
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        };
        const runCheck = () => {
          clearTimeout(this._waitParentAnimationTimeout);
          this._waitParentAnimationTimeout = setTimeout((() => check() || runCheck()), 15);
        };
        runCheck();
      }));
      const _checkWebFontForLabelsLoaded = () => {
        const $labels = this.$element().find(".dx-toolbar-label");
        const promises = [];
        $labels.each(((_, label) => {
          const text = renderer_default(label).text();
          const fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        }));
        return Promise.all(promises);
      };
      Promise.all([_waitParentAnimationFinished(), _checkWebFontForLabelsLoaded()]).then((() => {
        this._dimensionChanged();
      }));
    }
  }
};
component_registrator_default("dxToolbarBase", ToolbarBase);
var m_toolbar_base_default = ToolbarBase;

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.utils.js
var TOOLBAR_ITEMS = ["dxAutocomplete", "dxButton", "dxCheckBox", "dxDateBox", "dxMenu", "dxSelectBox", "dxTabs", "dxTextBox", "dxButtonGroup", "dxDropDownButton"];
var getItemInstance = function($element) {
  const itemData = $element.data && $element.data();
  const dxComponents = itemData && itemData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && itemData[widgetName];
};
function toggleItemFocusableElementTabIndex(context, item) {
  var _itemData$options;
  if (!context) {
    return;
  }
  const $item = context._findItemElementByItem(item);
  if (!$item.length) {
    return;
  }
  const itemData = context._getItemData($item);
  const isItemNotFocusable = !!(null !== (_itemData$options = itemData.options) && void 0 !== _itemData$options && _itemData$options.disabled || itemData.disabled || context.option("disabled"));
  const {
    widget
  } = itemData;
  if (widget && TOOLBAR_ITEMS.includes(widget)) {
    const $widget = $item.find(widget.toLowerCase().replace("dx", ".dx-"));
    if ($widget.length) {
      var _itemInstance$_focusT, _itemData$options2;
      const itemInstance = getItemInstance($widget);
      if (!itemInstance) {
        return;
      }
      let $focusTarget = null === (_itemInstance$_focusT = itemInstance._focusTarget) || void 0 === _itemInstance$_focusT ? void 0 : _itemInstance$_focusT.call(itemInstance);
      if ("dxDropDownButton" === widget) {
        $focusTarget = $focusTarget && $focusTarget.find(".dx-buttongroup");
      } else {
        $focusTarget = $focusTarget ?? renderer_default(itemInstance.element());
      }
      const tabIndex = null === (_itemData$options2 = itemData.options) || void 0 === _itemData$options2 ? void 0 : _itemData$options2.tabIndex;
      if (isItemNotFocusable) {
        $focusTarget.attr("tabIndex", -1);
      } else {
        $focusTarget.attr("tabIndex", tabIndex ?? 0);
      }
    }
  }
}

// node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.multiline.js
var MultiLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
  }
  _updateMenuVisibility() {
  }
  _renderMenuItems() {
  }
  _renderItem() {
  }
  _getMenuItems() {
  }
  _getToolbarItems() {
    return this._toolbar.option("items") ?? [];
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", this._toolbar._itemElements(), true);
  }
  _arrangeItems() {
    const $label = this._toolbar._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    if (!$label.length) {
      return;
    }
    const elementWidth = getWidth(this._toolbar.$element());
    const labelPaddings = getOuterWidth($label) - getWidth($label);
    $label.css("maxWidth", elementWidth - labelPaddings);
  }
  _hideOverflowItems() {
  }
  _dimensionChanged() {
  }
  _itemOptionChanged() {
  }
  _optionChanged() {
  }
};

// node_modules/devextreme/esm/__internal/ui/resizable/m_resizable.js
var RESIZABLE = "dxResizable";
var DRAGSTART_START_EVENT_NAME = addNamespace(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME = addNamespace(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = class extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true,
      keepAspectRatio: true
    });
  }
  _init() {
    super._init();
    this.$element().addClass("dx-resizable");
  }
  _initMarkup() {
    super._initMarkup();
    this._renderHandles();
  }
  _render() {
    super._render();
    this._renderActions();
  }
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  }
  _renderHandles() {
    this._handles = [];
    const {
      handles
    } = this.option();
    if ("none" === handles || !handles) {
      return;
    }
    const directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
    const activeHandlesMap = {};
    each(directions, ((index, handleName) => {
      activeHandlesMap[handleName] = true;
      this._renderHandle(handleName);
    }));
    activeHandlesMap.bottom && activeHandlesMap.right && this._renderHandle("corner-bottom-right");
    activeHandlesMap.bottom && activeHandlesMap.left && this._renderHandle("corner-bottom-left");
    activeHandlesMap.top && activeHandlesMap.right && this._renderHandle("corner-top-right");
    activeHandlesMap.top && activeHandlesMap.left && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  }
  _renderHandle(handleName) {
    const $handle = renderer_default("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${handleName}`).appendTo(this.$element());
    this._handles.push($handle);
  }
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    const handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach(((handleElement) => {
      m_events_engine_default.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    }));
  }
  _detachEventHandlers() {
    this._handles.forEach(((handleElement) => {
      m_events_engine_default.off(handleElement);
    }));
  }
  _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  }
  _getElementSize() {
    const $element = this.$element();
    return "border-box" === $element.css("boxSizing") ? {
      width: getOuterWidth($element),
      height: getOuterHeight($element)
    } : {
      width: getWidth($element),
      height: getHeight($element)
    };
  }
  _dragStartHandler(e) {
    var _this$_resizeStartAct;
    const $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    this._elementSize = this._getElementSize();
    this._renderDragOffsets(e);
    null === (_this$_resizeStartAct = this._resizeStartAction) || void 0 === _this$_resizeStartAct || _this$_resizeStartAct.call(this, {
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  }
  _toggleResizingClass(value2) {
    this.$element().toggleClass("dx-resizable-resizing", value2);
  }
  _renderDragOffsets(e) {
    const area = this._getArea();
    if (!area) {
      return;
    }
    const $handle = renderer_default(e.target).closest(".dx-resizable-handle");
    const handleWidth = getOuterWidth($handle);
    const handleHeight = getOuterHeight($handle);
    const handleOffset = $handle.offset();
    const areaOffset = area.offset;
    const scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  }
  _getBorderWidth($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    const borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  }
  _proportionate(direction, value2) {
    const size = this._elementSize;
    const factor = "x" === direction ? size.width / size.height : size.height / size.width;
    return value2 * factor;
  }
  _getProportionalDelta(_ref) {
    let {
      x,
      y
    } = _ref;
    const proportionalY = this._proportionate("y", x);
    if (proportionalY >= y) {
      return {
        x,
        y: proportionalY
      };
    }
    const proportionalX = this._proportionate("x", y);
    if (proportionalX >= x) {
      return {
        x: proportionalX,
        y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  _getDirectionName(axis) {
    const sides = this._movingSides;
    if ("x" === axis) {
      return sides.left ? "left" : "right";
    }
    return sides.top ? "top" : "bottom";
  }
  _fitIntoArea(axis, value2) {
    const directionName = this._getDirectionName(axis);
    return Math.min(value2, this[`_${directionName}MaxOffset`] ?? 1 / 0);
  }
  _fitDeltaProportionally(delta) {
    let fittedDelta = _extends({}, delta);
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    const getWidth2 = () => size.width + fittedDelta.x;
    const getHeight2 = () => size.height + fittedDelta.y;
    const isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
    const isFittedX = () => inRange(getWidth2(), minWidth, maxWidth) && isInArea("x");
    const isFittedY = () => inRange(getHeight2(), minHeight, maxHeight) && isInArea("y");
    if (!isFittedX()) {
      const x = this._fitIntoArea("x", fitIntoRange(getWidth2(), minWidth, maxWidth) - size.width);
      fittedDelta = {
        x,
        y: this._proportionate("y", x)
      };
    }
    if (!isFittedY()) {
      const y = this._fitIntoArea("y", fitIntoRange(getHeight2(), minHeight, maxHeight) - size.height);
      fittedDelta = {
        x: this._proportionate("x", y),
        y
      };
    }
    return isFittedX() && isFittedY() ? fittedDelta : {
      x: 0,
      y: 0
    };
  }
  _fitDelta(_ref2) {
    let {
      x,
      y
    } = _ref2;
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    return {
      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
    };
  }
  _getDeltaByOffset(offset) {
    const sides = this._movingSides;
    const shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("keepAspectRatio");
    let delta = {
      x: offset.x * (sides.left ? -1 : 1),
      y: offset.y * (sides.top ? -1 : 1)
    };
    if (shouldKeepAspectRatio) {
      const proportionalDelta = this._getProportionalDelta(delta);
      const fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
      delta = fittedProportionalDelta;
    } else {
      const fittedDelta = this._fitDelta(delta);
      const roundedFittedDelta = this._roundByStep(fittedDelta);
      delta = roundedFittedDelta;
    }
    return delta;
  }
  _updatePosition(delta, _ref3) {
    let {
      width,
      height
    } = _ref3;
    const location = this._elementLocation;
    const sides = this._movingSides;
    const $element = this.$element();
    const elementRect = this._getElementSize();
    const offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
    const offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
  }
  _dragHandler(e) {
    const offset = this._getOffset(e);
    const delta = this._getDeltaByOffset(offset);
    const dimensions = this._updateDimensions(delta);
    this._updatePosition(delta, dimensions);
    this._triggerResizeAction(e, dimensions);
  }
  _updateDimensions(delta) {
    const isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
    const {
      stepPrecision
    } = this.option();
    const isStepPrecisionStrict = "strict" === stepPrecision;
    const size = this._elementSize;
    const width = size.width + delta.x;
    const height = size.height + delta.y;
    const elementStyle = this.$element().get(0).style;
    const shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
    const shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
    if (shouldRenderWidth) {
      this.option({
        width
      });
    }
    if (shouldRenderHeight) {
      this.option({
        height
      });
    }
    return {
      width: shouldRenderWidth ? width : size.width,
      height: shouldRenderHeight ? height : size.height
    };
  }
  _triggerResizeAction(e, _ref4) {
    var _this$_resizeAction;
    let {
      width,
      height
    } = _ref4;
    null === (_this$_resizeAction = this._resizeAction) || void 0 === _this$_resizeAction || _this$_resizeAction.call(this, {
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent(this.$element());
  }
  _isCornerHandler(sides) {
    return 0 === Object.values(sides).reduce(((xor, value2) => xor ^ value2), 0);
  }
  _getOffset(e) {
    const {
      offset
    } = e;
    const sides = this._movingSides;
    if (!sides.left && !sides.right) {
      offset.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset.y = 0;
    }
    return offset;
  }
  _roundByStep(delta) {
    const {
      stepPrecision
    } = this.option();
    return "strict" === stepPrecision ? this._roundStrict(delta) : this._roundNotStrict(delta);
  }
  _getSteps() {
    return pairToObject(this.option("step"), !this.option("roundStepValue"));
  }
  _roundNotStrict(delta) {
    const steps = this._getSteps();
    return {
      x: delta.x - delta.x % steps.h,
      y: delta.y - delta.y % steps.v
    };
  }
  _roundStrict(delta) {
    const sides = this._movingSides;
    const offset = {
      x: delta.x * (sides.left ? -1 : 1),
      y: delta.y * (sides.top ? -1 : 1)
    };
    const steps = this._getSteps();
    const location = this._elementLocation;
    const size = this._elementSize;
    const xPos = sides.left ? location.left : location.left + size.width;
    const yPos = sides.top ? location.top : location.top + size.height;
    const newXShift = (xPos + offset.x) % steps.h;
    const newYShift = (yPos + offset.y) % steps.v;
    const sign2 = Math.sign || ((x) => {
      x = +x;
      if (0 === x || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    const separatorOffset = (steps2, offset2) => (1 + 0.2 * sign2(offset2)) % 1 * steps2;
    const isSmallOffset = (offset2, steps2) => Math.abs(offset2) < 0.2 * steps2;
    let newOffsetX = offset.x - newXShift;
    let newOffsetY = offset.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset.y)) {
      newOffsetY += steps.v;
    }
    const roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0;
    return {
      x: roundedOffset_x * (sides.left ? -1 : 1),
      y: roundedOffset_y * (sides.top ? -1 : 1)
    };
  }
  _getMovingSides(e) {
    const $target = renderer_default(e.target);
    const hasCornerTopLeftClass = $target.hasClass("dx-resizable-handle-corner-top-left");
    const hasCornerTopRightClass = $target.hasClass("dx-resizable-handle-corner-top-right");
    const hasCornerBottomLeftClass = $target.hasClass("dx-resizable-handle-corner-bottom-left");
    const hasCornerBottomRightClass = $target.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: $target.hasClass("dx-resizable-handle-top") || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass("dx-resizable-handle-left") || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass("dx-resizable-handle-bottom") || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass("dx-resizable-handle-right") || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  }
  _getArea() {
    let area = this.option("area");
    if (isFunction(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  }
  _getAreaScrollOffset() {
    const area = this.option("area");
    const isElement = !isFunction(area) && !isPlainObject(area);
    const scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      const areaElement = renderer_default(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  }
  _getAreaFromObject(area) {
    const result2 = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result2);
    return result2;
  }
  _getAreaFromElement(area) {
    const $area = renderer_default(area);
    let result2;
    if ($area.length) {
      result2 = {
        width: getInnerWidth($area),
        height: getInnerHeight($area),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result2, $area);
    }
    return result2;
  }
  _correctAreaGeometry(result2, $area) {
    const areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    const areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result2.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());
    result2.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());
  }
  _dragEndHandler(e) {
    var _this$_resizeEndActio;
    const $element = this.$element();
    null === (_this$_resizeEndActio = this._resizeEndAction) || void 0 === _this$_resizeEndActio || _this$_resizeEndActio.call(this, {
      event: e,
      width: getOuterWidth($element),
      height: getOuterHeight($element),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  }
  _renderWidth(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  }
  _renderHeight(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        super._optionChanged(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default(RESIZABLE, Resizable);
var m_resizable_default = Resizable;

// node_modules/devextreme/esm/ui/resizable.js
var resizable_default = m_resizable_default;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_drag.js
var PopupDrag = class {
  constructor(config2) {
    this.init(config2);
  }
  init(_ref) {
    let {
      dragEnabled,
      handle,
      draggableElement,
      positionController
    } = _ref;
    this._positionController = positionController;
    this._draggableElement = draggableElement;
    this._handle = handle;
    this._dragEnabled = dragEnabled;
    this.unsubscribe();
    if (!dragEnabled) {
      return;
    }
    this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.on(this._handle, eventNames.startEventName, ((e) => {
      this._dragStartHandler(e);
    }));
    m_events_engine_default.on(this._handle, eventNames.updateEventName, ((e) => {
      this._dragUpdateHandler(e);
    }));
    m_events_engine_default.on(this._handle, eventNames.endEventName, ((e) => {
      this._dragEndHandler(e);
    }));
  }
  unsubscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.off(this._handle, eventNames.startEventName);
    m_events_engine_default.off(this._handle, eventNames.updateEventName);
    m_events_engine_default.off(this._handle, eventNames.endEventName);
  }
  _getEventNames() {
    const startEventName = addNamespace(DRAG_START_EVENT, "overlayDrag");
    const updateEventName = addNamespace(DRAG_EVENT, "overlayDrag");
    const endEventName = addNamespace(DRAG_END_EVENT, "overlayDrag");
    return {
      startEventName,
      updateEventName,
      endEventName
    };
  }
  _dragStartHandler(e) {
    const allowedOffsets = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    };
    e.targetElements = [];
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  }
  _dragUpdateHandler(e) {
    const targetOffset = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(targetOffset);
    this._prevOffset = e.offset;
  }
  _dragEndHandler(event) {
    this._positionController.dragHandled();
    this._positionController.detectVisualPositionChange(event);
  }
  _moveTo(top, left, e) {
    if (!this._dragEnabled) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const offset = this._fitOffsetIntoAllowedRange(top, left);
    this._moveByOffset(offset);
    this._dragEndHandler(e);
  }
  _fitOffsetIntoAllowedRange(top, left) {
    const allowedOffsets = this._getAllowedOffsets();
    return {
      top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
      left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
    };
  }
  _getContainerDimensions() {
    const document2 = dom_adapter_default.getDocument();
    const container = this._positionController.$dragResizeContainer.get(0);
    let containerWidth = getOuterWidth(container);
    let containerHeight = getOuterHeight(container);
    if (isWindow(container)) {
      containerHeight = Math.max(document2.body.clientHeight, containerHeight);
      containerWidth = Math.max(document2.body.clientWidth, containerWidth);
    }
    return {
      width: containerWidth,
      height: containerHeight
    };
  }
  _getContainerPosition() {
    const container = this._positionController.$dragResizeContainer.get(0);
    return isWindow(container) ? {
      top: 0,
      left: 0
    } : getOffset(container);
  }
  _getElementPosition() {
    return getOffset(this._draggableElement);
  }
  _getInnerDelta() {
    const containerDimensions = this._getContainerDimensions();
    const elementDimensions = this._getElementDimensions();
    return {
      x: containerDimensions.width - elementDimensions.width,
      y: containerDimensions.height - elementDimensions.height
    };
  }
  _getOuterDelta() {
    const {
      width,
      height
    } = this._getElementDimensions();
    const {
      outsideDragFactor
    } = this._positionController;
    return {
      x: width * outsideDragFactor,
      y: height * outsideDragFactor
    };
  }
  _getFullDelta() {
    const fullDelta = this._getInnerDelta();
    const outerDelta = this._getOuterDelta();
    return {
      x: fullDelta.x + outerDelta.x,
      y: fullDelta.y + outerDelta.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const fullDelta = this._getFullDelta();
    const isDragAllowed = fullDelta.y >= 0 && fullDelta.x >= 0;
    if (!isDragAllowed) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const elementPosition = this._getElementPosition();
    const containerPosition = this._getContainerPosition();
    const outerDelta = this._getOuterDelta();
    return {
      top: elementPosition.top - containerPosition.top + outerDelta.y,
      bottom: -elementPosition.top + containerPosition.top + fullDelta.y,
      left: elementPosition.left - containerPosition.left + outerDelta.x,
      right: -elementPosition.left + containerPosition.left + fullDelta.x
    };
  }
  _moveByOffset(offset) {
    const currentPosition = locate(this._draggableElement);
    const newPosition = {
      left: currentPosition.left + offset.left,
      top: currentPosition.top + offset.top
    };
    move(this._draggableElement, newPosition);
  }
};
var m_popup_drag_default = PopupDrag;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_overflow_manager.js
var overflowManagerMock = {
  setOverflow: noop,
  restoreOverflow: noop
};
var createBodyOverflowManager = () => {
  if (!m_window_default.hasWindow()) {
    return overflowManagerMock;
  }
  const window15 = m_window_default.getWindow();
  const {
    documentElement
  } = dom_adapter_default.getDocument();
  const body = dom_adapter_default.getBody();
  const isIosDevice = "ios" === devices_default.real().platform;
  const prevSettings = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: isIosDevice ? () => {
      if (isDefined(prevSettings.position) || "fixed" === body.style.position) {
        return;
      }
      const {
        scrollY,
        scrollX
      } = window15;
      prevSettings.position = body.style.position;
      prevSettings.top = body.style.top;
      prevSettings.left = body.style.left;
      body.style.setProperty("position", "fixed");
      body.style.setProperty("top", -scrollY + "px");
      body.style.setProperty("left", -scrollX + "px");
    } : () => {
      (() => {
        const scrollBarWidth = window15.innerWidth - documentElement.clientWidth;
        if (prevSettings.paddingRight || scrollBarWidth <= 0) {
          return;
        }
        const paddingRight = window15.getComputedStyle(body).getPropertyValue("padding-right");
        const computedBodyPaddingRight = parseInt(paddingRight, 10);
        prevSettings.paddingRight = computedBodyPaddingRight;
        body.style.setProperty("padding-right", `${computedBodyPaddingRight + scrollBarWidth}px`);
      })();
      if (prevSettings.overflow || "hidden" === body.style.overflow) {
        return;
      }
      prevSettings.overflow = body.style.overflow;
      prevSettings.overflowX = body.style.overflowX;
      prevSettings.overflowY = body.style.overflowY;
      body.style.setProperty("overflow", "hidden");
    },
    restoreOverflow: isIosDevice ? () => {
      if (!isDefined(prevSettings.position)) {
        return;
      }
      const scrollY = -parseInt(body.style.top, 10);
      const scrollX = -parseInt(body.style.left, 10);
      ["position", "top", "left"].forEach(((property) => {
        if (prevSettings[property]) {
          body.style.setProperty(property, prevSettings[property]);
        } else {
          body.style.removeProperty(property);
        }
      }));
      window15.scrollTo(scrollX, scrollY);
      prevSettings.position = null;
    } : () => {
      (() => {
        if (!isDefined(prevSettings.paddingRight)) {
          return;
        }
        if (prevSettings.paddingRight) {
          body.style.setProperty("padding-right", `${prevSettings.paddingRight}px`);
        } else {
          body.style.removeProperty("padding-right");
        }
        prevSettings.paddingRight = null;
      })();
      ["overflow", "overflowX", "overflowY"].forEach(((property) => {
        if (!isDefined(prevSettings[property])) {
          return;
        }
        const propertyInKebabCase = property.replace(/(X)|(Y)/, ((symbol) => `-${symbol.toLowerCase()}`));
        if (prevSettings[property]) {
          body.style.setProperty(propertyInKebabCase, prevSettings[property]);
        } else {
          body.style.removeProperty(propertyInKebabCase);
        }
        prevSettings[property] = null;
      }));
    }
  };
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_position_controller.js
var _excluded3 = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"];
var window5 = m_window_default.getWindow();
var PopupPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded3);
    super(args);
    this._props = _extends({}, this._props, {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
    this._$dragResizeContainer = void 0;
    this._updateDragResizeContainer();
  }
  set fullScreen(fullScreen) {
    this._props.fullScreen = fullScreen;
    if (fullScreen) {
      this._fullScreenEnabled();
    } else {
      this._fullScreenDisabled();
    }
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    if (this._props.dragOutsideBoundary) {
      return 1;
    }
    return this._props.outsideDragFactor;
  }
  set dragAndResizeArea(dragAndResizeArea) {
    this._props.dragAndResizeArea = dragAndResizeArea;
    this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(dragOutsideBoundary) {
    this._props.dragOutsideBoundary = dragOutsideBoundary;
    this._updateDragResizeContainer();
  }
  set outsideDragFactor(outsideDragFactor) {
    this._props.outsideDragFactor = outsideDragFactor;
  }
  updateContainer(containerProp) {
    super.updateContainer(containerProp);
    this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(false);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(false);
  }
  positionContent() {
    if (this._props.fullScreen) {
      move(this._$content, {
        top: 0,
        left: 0
      });
      this.detectVisualPositionChange();
    } else {
      var _this$_props$forceApp, _this$_props;
      null === (_this$_props$forceApp = (_this$_props = this._props).forceApplyBindings) || void 0 === _this$_props$forceApp || _this$_props$forceApp.call(_this$_props);
      super.positionContent();
    }
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    if (this._props.dragOutsideBoundary) {
      return renderer_default(window5);
    }
    if (this._props.dragAndResizeArea) {
      return renderer_default(this._props.dragAndResizeArea);
    }
    const isContainerDefined = originalViewPort().get(0) || this._props.container;
    return isContainerDefined ? this._$markupContainer : renderer_default(window5);
  }
  _getVisualContainer() {
    if (this._props.fullScreen) {
      return renderer_default(window5);
    }
    return super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(false);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(true);
  }
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup.js
var window6 = m_window_default.getWindow();
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var IS_OLD_SAFARI = browser_default.safari && compare(browser_default.version, [11]) < 0;
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
};
var getButtonPlace = (name2) => {
  const device = devices_default.current();
  const {
    platform
  } = device;
  let toolbar = "bottom";
  let location = "before";
  if ("ios" === platform) {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if ("android" === platform) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = class extends m_overlay_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      upArrow: (e) => {
        var _this$_drag;
        null === (_this$_drag = this._drag) || void 0 === _this$_drag || _this$_drag.moveUp(e);
      },
      downArrow: (e) => {
        var _this$_drag2;
        null === (_this$_drag2 = this._drag) || void 0 === _this$_drag2 || _this$_drag2.moveDown(e);
      },
      leftArrow: (e) => {
        var _this$_drag3;
        null === (_this$_drag3 = this._drag) || void 0 === _this$_drag3 || _this$_drag3.moveLeft(e);
      },
      rightArrow: (e) => {
        var _this$_drag4;
        null === (_this$_drag4 = this._drag) || void 0 === _this$_drag4 || _this$_drag4.moveRight(e);
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: false,
      dragEnabled: false,
      enableBodyScroll: true,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: (device) => "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        dragEnabled: true
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }]);
  }
  _iosAnimation() {
    return {
      show: {
        type: "slide",
        duration: 400,
        from: {
          position: {
            my: "top",
            at: "bottom"
          }
        },
        to: {
          position: {
            my: "center",
            at: "center"
          }
        }
      },
      hide: {
        type: "slide",
        duration: 400,
        from: {
          opacity: 1,
          position: {
            my: "center",
            at: "center"
          }
        },
        to: {
          opacity: 1,
          position: {
            my: "top",
            at: "bottom"
          }
        }
      }
    };
  }
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  }
  _init() {
    const {
      _wrapperClassExternal: popupWrapperClassExternal
    } = this.option();
    const popupWrapperClasses = popupWrapperClassExternal ? `dx-popup-wrapper ${popupWrapperClassExternal}` : "dx-popup-wrapper";
    super._init();
    this._createBodyOverflowManager();
    this._updateResizeCallbackSkipCondition();
    this.$element().addClass("dx-popup");
    this.$wrapper().addClass(popupWrapperClasses);
    this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass("dx-popup-content")).children().eq(0);
    this._toggleContentScrollClass();
    this.$overlayContent().attr("role", "dialog");
  }
  _render() {
    const isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    super._render();
  }
  _createBodyOverflowManager() {
    this._bodyOverflowManager = createBodyOverflowManager();
  }
  _toggleFullScreenClass(value2) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", value2).toggleClass("dx-popup-normal", !value2);
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  }
  _getActionsList() {
    return super._getActionsList().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  }
  _contentResizeHandler(entry) {
    if (!this._shouldSkipContentResize(entry)) {
      this._renderGeometry({
        shouldOnlyReposition: true
      });
    }
  }
  _doesShowAnimationChangeDimensions() {
    const animation2 = this.option("animation");
    return ["to", "from"].some(((prop) => {
      var _animation$show;
      const config2 = null === animation2 || void 0 === animation2 || null === (_animation$show = animation2.show) || void 0 === _animation$show ? void 0 : _animation$show[prop];
      return isObject(config2) && ("width" in config2 || "height" in config2);
    }));
  }
  _updateResizeCallbackSkipCondition() {
    const doesShowAnimationChangeDimensions = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (entry) => doesShowAnimationChangeDimensions && this._showAnimationProcessing || this._areContentDimensionsRendered(entry);
  }
  _observeContentResize(shouldObserve) {
    if (!this.option("useResizeObserver")) {
      return;
    }
    const contentElement = this._$content.get(0);
    if (shouldObserve) {
      resize_observer_default.observe(contentElement, ((entry) => {
        this._contentResizeHandler(entry);
      }));
    } else {
      resize_observer_default.unobserve(contentElement);
    }
  }
  _areContentDimensionsRendered(entry) {
    var _entry$contentBoxSize, _this$_renderedDimens3, _this$_renderedDimens4;
    const contentBox = null === (_entry$contentBoxSize = entry.contentBoxSize) || void 0 === _entry$contentBoxSize ? void 0 : _entry$contentBoxSize[0];
    if (contentBox) {
      var _this$_renderedDimens, _this$_renderedDimens2;
      return parseInt(contentBox.inlineSize, 10) === (null === (_this$_renderedDimens = this._renderedDimensions) || void 0 === _this$_renderedDimens ? void 0 : _this$_renderedDimens.width) && parseInt(contentBox.blockSize, 10) === (null === (_this$_renderedDimens2 = this._renderedDimensions) || void 0 === _this$_renderedDimens2 ? void 0 : _this$_renderedDimens2.height);
    }
    const {
      contentRect
    } = entry;
    return parseInt(contentRect.width, 10) === (null === (_this$_renderedDimens3 = this._renderedDimensions) || void 0 === _this$_renderedDimens3 ? void 0 : _this$_renderedDimens3.width) && parseInt(contentRect.height, 10) === (null === (_this$_renderedDimens4 = this._renderedDimensions) || void 0 === _this$_renderedDimens4 ? void 0 : _this$_renderedDimens4.height);
  }
  _renderContent() {
    super._renderContent();
    this._observeContentResize(true);
  }
  _renderContentImpl() {
    this._renderTitle();
    super._renderContentImpl();
    this._renderResize();
    this._renderBottom();
  }
  _renderTitle() {
    const items = this._getToolbarItems("top");
    const {
      title,
      showTitle
    } = this.option();
    if (showTitle && !!title) {
      items.unshift({
        location: devices_default.current().ios ? "center" : "before",
        text: title
      });
    }
    if (showTitle || items.length > 0) {
      if (this._$title) {
        this._$title.remove();
      }
      const $title = renderer_default("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass("dx-popup-title");
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
    this._toggleAriaLabel();
  }
  _toggleAriaLabel() {
    var _this$_$title;
    const {
      title,
      showTitle
    } = this.option();
    const shouldSetAriaLabel = showTitle && !!title;
    const titleId = shouldSetAriaLabel ? new guid_default() : null;
    null === (_this$_$title = this._$title) || void 0 === _this$_$title || _this$_$title.find(".dx-toolbar-label").eq(0).attr("id", titleId);
    this.$overlayContent().attr("aria-labelledby", titleId);
  }
  _renderTemplateByType(optionName, data17, $container, additionalToolbarOptions) {
    const {
      rtlEnabled,
      useDefaultToolbarButtons,
      useFlatToolbarButtons,
      disabled
    } = this.option();
    const template = this._getTemplateByOption(optionName);
    const toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      const integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      const toolbarOptions = extend(additionalToolbarOptions, {
        items: data17,
        rtlEnabled,
        useDefaultButtons: useDefaultToolbarButtons,
        useFlatButtons: useFlatToolbarButtons,
        disabled,
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: this._getToolbarName(),
          options: toolbarOptions
        }
      });
      const $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    }
    const $result = renderer_default(template.render({
      container: getPublicElement($container)
    }));
    if ($result.hasClass("dx-template-wrapper")) {
      $container.replaceWith($result);
      $container = $result;
    }
    return $container;
  }
  _getToolbarName() {
    return "dxToolbarBase";
  }
  _renderVisibilityAnimate(visible) {
    return super._renderVisibilityAnimate(visible);
  }
  _hide() {
    this._observeContentResize(false);
    return super._hide();
  }
  _executeTitleRenderAction($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  }
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  }
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  }
  _getCloseButtonRenderer() {
    return (_, __, container) => {
      const $button = renderer_default("<div>").addClass("dx-closebutton");
      this._createComponent($button, button_default2, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      renderer_default(container).append($button);
    };
  }
  _getToolbarItems(toolbar) {
    const toolbarItems = this.option("toolbarItems");
    const toolbarsItems = [];
    this._toolbarItemClasses = [];
    const currentPlatform = devices_default.current().platform;
    let index = 0;
    each(toolbarItems, ((_, data17) => {
      const isShortcut = isDefined(data17.shortcut);
      const item = isShortcut ? getButtonPlace(data17.shortcut) : data17;
      if (isShortcut && "ios" === currentPlatform && index < 2) {
        item.toolbar = "top";
        index++;
      }
      item.toolbar = data17.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data17.location
          }, this._getToolbarItemByAlias(data17));
        }
        const isLTROrder = "generic" === currentPlatform;
        if ("done" === data17.shortcut && isLTROrder || "cancel" === data17.shortcut && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    }));
    if ("top" === toolbar && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  }
  _hasCloseButton() {
    const {
      showCloseButton,
      showTitle
    } = this.option();
    return showCloseButton && showTitle;
  }
  _getLocalizationKey(itemType) {
    return "done" === itemType.toLowerCase() ? "OK" : camelize(itemType, true);
  }
  _getToolbarButtonStylingMode(shortcut) {
    if (isFluent()) {
      return "done" === shortcut ? "contained" : "outlined";
    }
    return this.option("useFlatToolbarButtons") ? "text" : "contained";
  }
  _getToolbarButtonType(shortcut) {
    if (isFluent() && "done" === shortcut || this.option("useDefaultToolbarButtons")) {
      return "default";
    }
    return "normal";
  }
  _getToolbarItemByAlias(data17) {
    const that = this;
    const itemType = data17.shortcut;
    if (!ALLOWED_TOOLBAR_ITEM_ALIASES.includes(itemType)) {
      return false;
    }
    const itemConfig = extend({
      text: message_default.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data17.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(itemType),
      stylingMode: this._getToolbarButtonStylingMode(itemType)
    }, data17.options || {});
    const itemClass = `dx-popup-${itemType}`;
    this._toolbarItemClasses.push(itemClass);
    return {
      template(_, __, container) {
        const $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, button_default2, itemConfig);
      }
    };
  }
  _createToolbarItemAction(clickAction) {
    return this._createAction(clickAction, {
      afterExecute(e) {
        e.component.hide();
      }
    });
  }
  _renderBottom() {
    const items = this._getToolbarItems("bottom");
    if (items.length) {
      var _this$_$bottom;
      null === (_this$_$bottom = this._$bottom) || void 0 === _this$_$bottom || _this$_$bottom.remove();
      const $bottom = renderer_default("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass("dx-popup-bottom");
      this._toggleClasses();
    } else {
      var _this$_$bottom2;
      null === (_this$_$bottom2 = this._$bottom) || void 0 === _this$_$bottom2 || _this$_$bottom2.detach();
    }
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(...arguments);
    this.$content().toggleClass("dx-state-disabled", Boolean(value2));
  }
  _toggleClasses() {
    const aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, ((_, alias) => {
      const className = `dx-popup-${alias}`;
      if (this._toolbarItemClasses.includes(className)) {
        var _this$_$bottom3;
        this.$wrapper().addClass(`${className}-visible`);
        null === (_this$_$bottom3 = this._$bottom) || void 0 === _this$_$bottom3 || _this$_$bottom3.addClass(className);
      } else {
        var _this$_$bottom4;
        this.$wrapper().removeClass(`${className}-visible`);
        null === (_this$_$bottom4 = this._$bottom) || void 0 === _this$_$bottom4 || _this$_$bottom4.removeClass(className);
      }
    }));
  }
  _toggleFocusClass(isFocused, $element) {
    super._toggleFocusClass(isFocused, $element);
    if (isFocused && !isLastZIndexInStack(this._zIndex)) {
      const zIndex = create(this._zIndexInitValue());
      remove(this._zIndex);
      this._zIndex = zIndex;
      this._$wrapper.css("zIndex", zIndex);
      this._$content.css("zIndex", zIndex);
    }
  }
  _toggleContentScrollClass() {
    const isNativeScrollingEnabled = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", isNativeScrollingEnabled);
  }
  _getPositionControllerConfig() {
    const {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = this.option();
    return _extends({}, super._getPositionControllerConfig(), {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
  }
  _initPositionController() {
    this._positionController = new PopupPositionController(this._getPositionControllerConfig());
  }
  _getDragTarget() {
    return this.topToolbar();
  }
  _renderGeometry(options2) {
    const {
      visible,
      useResizeObserver
    } = this.option();
    if (visible && m_window_default.hasWindow()) {
      const isAnimated = this._showAnimationProcessing;
      const shouldRepeatAnimation = isAnimated && !(null !== options2 && void 0 !== options2 && options2.forceStopAnimation) && useResizeObserver;
      this._isAnimationPaused = shouldRepeatAnimation || void 0;
      this._stopAnimation();
      if (null !== options2 && void 0 !== options2 && options2.shouldOnlyReposition) {
        this._renderPosition(false);
      } else {
        this._renderGeometryImpl(null === options2 || void 0 === options2 ? void 0 : options2.isDimensionChange);
      }
      if (shouldRepeatAnimation) {
        this._animateShowing();
        this._isAnimationPaused = void 0;
      }
    }
  }
  _cacheDimensions() {
    if (!this.option("useResizeObserver")) {
      return;
    }
    this._renderedDimensions = {
      width: parseInt(getWidth(this._$content), 10),
      height: parseInt(getHeight(this._$content), 10)
    };
  }
  _renderGeometryImpl() {
    let isDimensionChange = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!isDimensionChange) {
      this._resetContentHeight();
    }
    super._renderGeometryImpl();
    this._cacheDimensions();
    this._setContentHeight();
  }
  _resetContentHeight() {
    const height = this._getOptionValue("height");
    if ("auto" === height) {
      this.$content().css({
        height: "auto",
        maxHeight: "none"
      });
    }
  }
  _renderDrag() {
    const $dragTarget = this._getDragTarget();
    const {
      dragEnabled
    } = this.option();
    if (!$dragTarget) {
      return;
    }
    const config2 = {
      dragEnabled,
      handle: $dragTarget.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    if (this._drag) {
      this._drag.init(config2);
    } else {
      this._drag = new m_popup_drag_default(config2);
    }
    this.$overlayContent().toggleClass("dx-popup-draggable", dragEnabled);
  }
  _renderResize() {
    this._resizable = this._createComponent(this._$content, resizable_default, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e);
        this._observeContentResize(true);
      },
      onResize: (e) => {
        this._setContentHeight();
        this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(false);
        this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: false
    });
  }
  _resizeEndHandler(e) {
    const width = this._resizable.option("width");
    const height = this._resizable.option("height");
    width && this._setOptionWithoutOptionChange("width", width);
    height && this._setOptionWithoutOptionChange("height", height);
    this._cacheDimensions();
    this._positionController.resizeHandled();
    this._positionController.detectVisualPositionChange(e.event);
    this._actions.onResizeEnd(e);
  }
  _setContentHeight() {
    const {
      forceApplyBindings
    } = this.option();
    (forceApplyBindings || noop)();
    const overlayContent = this.$overlayContent().get(0);
    const currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  }
  _heightStrategyChangeOffset(currentHeightStrategyClass, popupVerticalPaddings) {
    return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0;
  }
  _chooseHeightStrategy(overlayContent) {
    const isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
    let currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth || IS_OLD_SAFARI) {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  }
  _getHeightCssStyles(currentHeightStrategyClass, overlayContent) {
    let cssStyles = {};
    const contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    const contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    const popupHeightParts = this._splitPopupHeight();
    const toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        const overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, m_window_default.getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        const contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const container = renderer_default(this._positionController.$visualContainer).get(0);
      const maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      const minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  }
  _setHeightClasses($container, currentClass) {
    let excessClasses = "";
    for (const name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += ` ${HEIGHT_STRATEGIES[name2]}`;
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  }
  _isAutoHeight() {
    return "auto" === this.$overlayContent().get(0).style.height;
  }
  _splitPopupHeight() {
    const topToolbar = this.topToolbar();
    const bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(null === topToolbar || void 0 === topToolbar ? void 0 : topToolbar.get(0)),
      footer: getVisibleHeight(null === bottomToolbar || void 0 === bottomToolbar ? void 0 : bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  }
  _isAllWindowCovered() {
    const {
      fullScreen
    } = this.option();
    return super._isAllWindowCovered() || fullScreen;
  }
  _renderDimensions() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      super._renderDimensions();
    }
    if (m_window_default.hasWindow()) {
      this._renderFullscreenWidthClass();
    }
  }
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: true
    });
  }
  _clean() {
    super._clean();
    this._observeContentResize(false);
  }
  _dispose() {
    super._dispose();
    this._toggleBodyScroll(true);
  }
  _renderFullscreenWidthClass() {
    const isFullScreen = getOuterWidth(this.$overlayContent()) === getWidth(window6);
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", isFullScreen);
  }
  _toggleSafariScrolling() {
    if (!this.option("enableBodyScroll")) {
      return;
    }
    super._toggleSafariScrolling();
  }
  _toggleBodyScroll(enabled) {
    if (!this._bodyOverflowManager) {
      return;
    }
    const {
      setOverflow,
      restoreOverflow
    } = this._bodyOverflowManager;
    if (enabled) {
      restoreOverflow();
    } else {
      setOverflow();
    }
  }
  refreshPosition() {
    this._renderPosition();
  }
  _optionChanged(args) {
    var _this$_resizable2;
    const {
      value: value2,
      name: name2
    } = args;
    switch (name2) {
      case "disabled":
        super._optionChanged(args);
        this._renderTitle();
        this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        if (this.option("visible")) {
          this._toggleBodyScroll(value2);
        }
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "container":
        super._optionChanged(args);
        if (this.option("resizeEnabled")) {
          var _this$_resizable;
          null === (_this$_resizable = this._resizable) || void 0 === _this$_resizable || _this$_resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_resizable2 = this._resizable) || void 0 === _this$_resizable2 || _this$_resizable2.option(name2, value2);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction();
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent(this.$overlayContent());
        }
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = value2;
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = value2;
        this._toggleFullScreenClass(value2);
        this._toggleSafariScrolling();
        this._renderGeometry();
        triggerResizeEvent(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        super._optionChanged(args);
        this._toggleContentScrollClass();
        break;
      default:
        super._optionChanged(args);
    }
  }
  bottomToolbar() {
    return this._$bottom;
  }
  topToolbar() {
    return this._$title;
  }
  $content() {
    return this._$popupContent;
  }
  content() {
    return getPublicElement(this.$content());
  }
  $overlayContent() {
    return this._$content;
  }
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter(((index, item) => item.getAttribute("tabindex") >= 0));
  }
};
component_registrator_default("dxPopup", Popup);
var m_popup_default = Popup;

// node_modules/devextreme/esm/ui/popup/ui.popup.js
var ui_popup_default = m_popup_default;

// node_modules/devextreme/esm/__internal/events/m_swipe.js
var SWIPE_START_EVENT = "dxswipestart";
var SWIPE_EVENT = "dxswipe";
var SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
  defaultItemSizeFunc() {
    return getWidth(this.getElement());
  },
  getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = eventData(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc() {
    return getHeight(this.getElement());
  },
  getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = eventData(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
var SwipeEmitter = m_emitter_gesture_default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor(element) {
    this.callBase(element);
    this.direction = "horizontal";
    this.elastic = true;
  },
  _getStrategy() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init(e) {
    this._tickData = eventData(e);
  },
  _start(e) {
    this._savedEventData = eventData(e);
    e = this._fireEvent("dxswipestart", e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move(e) {
    const strategy = this._getStrategy();
    const moveEventData = eventData(e);
    let offset = strategy.calcOffsetRatio.call(this, e);
    offset = this._fitOffset(offset, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent("dxswipe", e, {
      offset
    });
    if (false !== e.cancelable) {
      e.preventDefault();
    }
  },
  _end(e) {
    const strategy = this._getStrategy();
    const offsetRatio = strategy.calcOffsetRatio.call(this, e);
    const isFast = strategy.isFastSwipe.call(this, e);
    let startOffset = offsetRatio;
    let targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent("dxswipeend", e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset(offset, elastic) {
    const strategy = this._getStrategy();
    const bounds = strategy.getBounds.call(this);
    if (offset < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
    }
    if (offset > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
    }
    return offset;
  },
  _calcTargetOffset(offsetRatio, isFast) {
    let result2;
    if (isFast) {
      result2 = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result2 = -result2;
      }
    } else {
      result2 = Math.round(offsetRatio);
    }
    return result2;
  }
});
m_emitter_registrator_default({
  emitter: SwipeEmitter,
  events: ["dxswipestart", "dxswipe", "dxswipeend"]
});

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.pull_down.js
var PullDownNativeScrollViewStrategy = class extends m_scrollable_native_default {
  _init(scrollView) {
    super._init(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    super.render();
    this._renderPullDown();
    this._releaseState();
  }
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  }
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, ((_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    }));
  }
  update() {
    super.update();
    this._setTopPocketOffset();
  }
  _updateDimensions() {
    super._updateDimensions();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  }
  _allowedDirections() {
    const allowedDirections = super._allowedDirections();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  }
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  }
  handleEnd() {
    super.handleEnd();
    this._complete();
  }
  handleStop() {
    super.handleStop();
    this._complete();
  }
  _complete() {
    if (1 === this._state) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout((() => {
        this._pullDownRefreshing();
      }), 400);
    }
  }
  _setPullDownOffset(offset) {
    move(this._$topPocket, {
      top: offset
    });
    move(this._$scrollViewContent, {
      top: offset
    });
  }
  handleScroll(e) {
    super.handleScroll(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this.reachBottomCallbacks.fire();
  }
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._releaseState();
  }
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  }
  pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  }
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (3 === this._state) {
      this._state = 0;
    }
    this._releaseTimeout = setTimeout((() => {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }), 400);
    return deferred.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    super.dispose();
  }
};
var m_scroll_view_native_pull_down_default = PullDownNativeScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.swipe_down.js
var SwipeDownNativeScrollViewStrategy = class extends m_scrollable_native_default {
  _init(scrollView) {
    super._init(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    super.render();
    this._renderPullDown();
    this._releaseState();
  }
  _renderPullDown() {
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$icon = renderer_default("<div>").addClass("dx-icon-pulldown");
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  }
  _releaseState() {
    this._state = 0;
    this._releasePullDown();
    this._updateDimensions();
  }
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  }
  _updateDimensions() {
    super._updateDimensions();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  }
  _allowedDirections() {
    const allowedDirections = super._allowedDirections();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  }
  handleInit(e) {
    super.handleInit(e);
    if (0 === this._state && 0 === this._location) {
      this._startClientY = eventData(e.originalEvent).y;
      this._state = 4;
    }
  }
  handleMove(e) {
    super.handleMove(e);
    this._deltaY = eventData(e.originalEvent).y - this._startClientY;
    if (4 === this._state) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = 5;
      } else {
        this._complete();
      }
    }
    if (5 === this._state) {
      e.preventDefault();
      this._movePullDown();
    }
  }
  _movePullDown() {
    const pullDownHeight = this._getPullDownHeight();
    const top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
    const angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass("dx-scrollview-pull-down-refreshing", top < pullDownHeight);
    move(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: `rotate(${angle}deg)`
    });
  }
  _isPullDown() {
    return this._pullDownEnabled && 5 === this._state && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  }
  _getPullDownHeight() {
    return Math.round(0.05 * getOuterHeight(this._$element));
  }
  _getPullDownStartPosition() {
    return -Math.round(1.5 * getOuterHeight(this._$pullDown));
  }
  handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  }
  handleStop() {
    this._complete();
  }
  _complete() {
    if (4 === this._state || 5 === this._state) {
      this._releaseState();
    }
  }
  handleScroll(e) {
    super.handleScroll(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading");
    this._releaseState();
  }
  _pullDownRefreshing() {
    this._state = 2;
    this._pullDownRefreshHandler();
  }
  _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  }
  _refreshPullDown() {
    this._$pullDown.addClass("dx-scrollview-pull-down-loading");
    move(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  }
  pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  }
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout((() => {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }), 800);
    return deferred.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    super.dispose();
  }
};
var m_scroll_view_native_swipe_down_default = SwipeDownNativeScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.simulated.js
var ScrollViewScroller = class extends Scroller {
  ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    super.ctor.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  }
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, ((_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    }));
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  _updateBounds() {
    const considerPockets = "horizontal" !== this._direction;
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const containerEl = this._$container.get(0);
      const contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    super._updateBounds();
  }
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  }
  _moveContent() {
    super._moveContent();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (0 !== this._state) {
      this._stateReleased();
    }
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    const containerEl = this._$container.get(0);
    return Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  }
  _scrollComplete() {
    if (this._inBounds() && 1 === this._state) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && 3 === this._state) {
      this._reachBottomLoading();
    } else {
      super._scrollComplete();
    }
  }
  _reachBottomReady() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this._minOffset = this._getMinOffset();
  }
  _getMaxOffset() {
    return -this._topPocketSize;
  }
  _getMinOffset() {
    return Math.min(super._getMinOffset(), -this._topPocketSize);
  }
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  }
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._maxOffset = 0;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this.releaseCallbacks.fire();
  }
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  }
  _releaseHandler() {
    var _this$_releaseTask;
    if (0 === this._state) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = executeAsync(this._release.bind(this));
    return null === (_this$_releaseTask = this._releaseTask) || void 0 === _this$_releaseTask ? void 0 : _this$_releaseTask.promise;
  }
  _release() {
    this._stateReleased();
    this._scrollComplete();
  }
  _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  }
  _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  }
  _considerTopPocketChange() {
    this._location -= getHeight(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  }
  _pendingReleaseHandler() {
    this._state = 1;
  }
  dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    super.dispose();
  }
};
var SimulatedScrollViewStrategy = class extends SimulatedStrategy {
  _init(scrollView) {
    super._init(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    this._renderPullDown();
    super.render();
  }
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  }
  pullDownEnable(enabled) {
    this._eventHandler("pullDownEnabling", enabled);
  }
  reachBottomEnable(enabled) {
    this._eventHandler("reachBottomEnabling", enabled);
  }
  _createScroller(direction) {
    const that = this;
    const scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add((() => {
      that.pullDownCallbacks.fire();
    }));
    scroller.releaseCallbacks.add((() => {
      that.releaseCallbacks.fire();
    }));
    scroller.reachBottomCallbacks.add((() => {
      that.reachBottomCallbacks.fire();
    }));
  }
  _scrollerOptions(direction) {
    return _extends({}, super._scrollerOptions(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  }
  pendingRelease() {
    this._eventHandler("pendingRelease");
  }
  release() {
    return this._eventHandler("release").done(this._updateAction);
  }
  location() {
    const location = super.location();
    location.top += getHeight(this._$topPocket);
    return location;
  }
  isBottomReached() {
    return this._scrollers.vertical.isBottomReached();
  }
  dispose() {
    each(this._scrollers, (function() {
      this.dispose();
    }));
    super.dispose();
  }
};
var m_scroll_view_simulated_default = SimulatedScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.js
var SCROLLVIEW_LOADPANEL = "dx-scrollview-loadpanel";
var refreshStrategies = {
  pullDown: m_scroll_view_native_pull_down_default,
  swipeDown: m_scroll_view_native_swipe_down_default,
  simulated: m_scroll_view_simulated_default
};
var isServerSide = !hasWindow();
var ScrollViewServerSide = class extends m_scrollable_default {
  finishLoading() {
  }
  release() {
  }
  refresh() {
  }
  scrollOffset() {
    return {
      top: 0,
      left: 0
    };
  }
  isBottomReached() {
    return false;
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    if ("onUpdated" !== name2) {
      return super._optionChanged.apply(this, arguments);
    }
  }
};
var ScrollView = class extends m_scrollable_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      pullingDownText: message_default.format("dxScrollView-pullingDownText"),
      pulledDownText: message_default.format("dxScrollView-pulledDownText"),
      refreshingText: message_default.format("dxScrollView-refreshingText"),
      reachBottomText: message_default.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const realDevice2 = devices_default.real();
        return "android" === realDevice2.platform;
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  }
  _init() {
    super._init();
    this._loadingIndicatorEnabled = true;
  }
  _initScrollableMarkup() {
    super._initScrollableMarkup();
    this.$element().addClass("dx-scrollview");
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  }
  _initContent() {
    const $content = renderer_default("<div>").addClass("dx-scrollview-content");
    this._$content.wrapInner($content);
  }
  _initTopPocket() {
    this._$topPocket = renderer_default("<div>").addClass("dx-scrollview-top-pocket");
    this._$pullDown = renderer_default("<div>").addClass("dx-scrollview-pull-down");
    this._$topPocket.append(this._$pullDown);
    this._$content.prepend(this._$topPocket);
  }
  _initBottomPocket() {
    this._$bottomPocket = renderer_default("<div>").addClass("dx-scrollview-bottom-pocket");
    this._$reachBottom = renderer_default("<div>").addClass("dx-scrollview-scrollbottom");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$reachBottomText = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-text");
    this._updateReachBottomText();
    this._$reachBottom.append($loadContainer.append($loadIndicator)).append(this._$reachBottomText);
    this._$bottomPocket.append(this._$reachBottom);
    this._$content.append(this._$bottomPocket);
  }
  _initLoadPanel() {
    const $loadPanelElement = renderer_default("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    const {
      refreshingText
    } = this.option();
    this._loadPanel = this._createComponent($loadPanelElement, m_load_panel_default, {
      shading: false,
      delay: 400,
      message: refreshingText,
      position: {
        of: this.$element()
      }
    });
  }
  _updateReachBottomText() {
    const {
      reachBottomText
    } = this.option();
    this._$reachBottomText.text(reachBottomText);
  }
  _createStrategy() {
    const {
      useNative,
      refreshStrategy
    } = this.option();
    const strategyName = useNative ? refreshStrategy : "simulated";
    const strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  }
  _createActions() {
    super._createActions();
    this._pullDownAction = this._createActionByOption("onPullDown");
    this._reachBottomAction = this._createActionByOption("onReachBottom");
    this._tryRefreshPocketState();
  }
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown"));
    this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  }
  on(eventName) {
    const result2 = super.on.apply(this, arguments);
    if ("pullDown" === eventName || "reachBottom" === eventName) {
      this._tryRefreshPocketState();
    }
    return result2;
  }
  _pullDownEnable(enabled) {
    if (0 === arguments.length) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  }
  _reachBottomEnable(enabled) {
    if (0 === arguments.length) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  }
  _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  }
  _loadingIndicator(value2) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value2;
  }
  _pullDownLoading() {
    var _this$_pullDownAction;
    this.startLoading();
    null === (_this$_pullDownAction = this._pullDownAction) || void 0 === _this$_pullDownAction || _this$_pullDownAction.call(this);
  }
  _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  }
  _reachBottomLoading() {
    var _this$_reachBottomAct;
    this.startLoading();
    null === (_this$_reachBottomAct = this._reachBottomAction) || void 0 === _this$_reachBottomAct || _this$_reachBottomAct.call(this);
  }
  _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        super._optionChanged(args);
    }
  }
  content() {
    return getPublicElement(this._$content.children().eq(1));
  }
  release(preventReachBottom) {
    if (void 0 !== preventReachBottom) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  }
  toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  }
  refresh() {
    if (!this.hasActionSubscription("onPullDown")) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  }
  startLoading() {
    if (this._loadingIndicator() && this.$element().is(":visible")) {
      this._loadPanel.show();
    }
    this._lock();
  }
  finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  }
  isBottomReached() {
    return this._strategy.isBottomReached();
  }
  _dispose() {
    this._strategy.dispose();
    super._dispose();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
};
component_registrator_default("dxScrollView", isServerSide ? ScrollViewServerSide : ScrollView);
var m_scroll_view_default = isServerSide ? ScrollViewServerSide : ScrollView;

// node_modules/devextreme/esm/ui/scroll_view.js
var scroll_view_default = m_scroll_view_default;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.live_update.js
var PRIVATE_KEY_FIELD = "__dx_key__";
var CollectionWidgetLiveUpdate = class extends m_collection_widget_async_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      repaintChangesOnly: false
    });
  }
  _customizeStoreLoadOptions(e) {
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !this._dataController.isLoaded()) {
      this._correctionIndex = 0;
    }
    if (this._correctionIndex && e.storeLoadOptions) {
      e.storeLoadOptions.skip += this._correctionIndex;
    }
  }
  reload() {
    this._correctionIndex = 0;
  }
  _init() {
    super._init();
    this._refreshItemsCache();
    this._correctionIndex = 0;
    this._subscribeLoadOptionsCustomization(true);
  }
  _findItemElementByKey(key) {
    let result2 = renderer_default();
    const keyExpr = this.key();
    this.itemElements().each(((_, item) => {
      const $item = renderer_default(item);
      const itemData = this._getItemData($item);
      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
        result2 = $item;
        return false;
      }
    }));
    return result2;
  }
  _dataSourceChangedHandler(newItems, e) {
    if (null !== e && void 0 !== e && e.changes) {
      this._modifyByChanges(e.changes);
    } else {
      super._dataSourceChangedHandler(newItems, e);
      this._refreshItemsCache();
    }
  }
  _isItemEquals(item1, item2) {
    if (item1 && item1.__dx_key__) {
      item1 = item1.data;
    }
    try {
      return JSON.stringify(item1) === JSON.stringify(item2);
    } catch (e) {
      return item1 === item2;
    }
  }
  _isItemStrictEquals(item1, item2) {
    return this._isItemEquals(item1, item2);
  }
  _shouldAddNewGroup(changes, items) {
    let result2 = false;
    if (this.option("grouped")) {
      if (!changes.length) {
        result2 = true;
      }
      each(changes, ((i, change) => {
        if ("insert" === change.type) {
          result2 = true;
          each(items, ((_, item) => {
            if (void 0 !== change.data.key && change.data.key === item.key) {
              result2 = false;
              return false;
            }
          }));
        }
      }));
    }
    return result2;
  }
  _partialRefresh() {
    if (this.option("repaintChangesOnly")) {
      const keyOf = (data17) => {
        if (data17 && void 0 !== data17.__dx_key__) {
          return data17.__dx_key__;
        }
        return this.keyOf(data17);
      };
      const result2 = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), keyOf, this._isItemStrictEquals.bind(this));
      if (result2 && this._itemsCache.length && !this._shouldAddNewGroup(result2, this._itemsCache)) {
        this._modifyByChanges(result2, true);
        this._renderEmptyMessage();
        return true;
      }
      this._refreshItemsCache();
    }
    return false;
  }
  _refreshItemsCache() {
    if (this.option("repaintChangesOnly")) {
      const items = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = extend(true, [], items);
        if (!this.key()) {
          this._itemsCache = this._itemsCache.map(((itemCache, index) => ({
            [PRIVATE_KEY_FIELD]: items[index],
            data: itemCache
          })));
        }
      } catch (e) {
        this._itemsCache = extend([], items);
      }
    }
  }
  _dispose() {
    this._subscribeLoadOptionsCustomization(false);
    super._dispose();
  }
  _updateByChange(keyInfo, items, change, isPartialRefresh) {
    if (isPartialRefresh) {
      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
    } else {
      const changedItem = items[indexByKey(keyInfo, items, change.key)];
      if (changedItem) {
        update(keyInfo, items, change.key, change.data).done((() => {
          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
        }));
      }
    }
  }
  _insertByChange(keyInfo, items, change, isPartialRefresh) {
    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done((() => {
      this._beforeItemElementInserted(change);
      this._renderItem(change.index ?? items.length, change.data);
      this._afterItemElementInserted();
      this._correctionIndex++;
    }));
  }
  _updateSelectionAfterRemoveByChange(removeIndex) {
    const {
      selectedIndex,
      selectedItems
    } = this.option();
    if (selectedIndex > removeIndex) {
      this.option("selectedIndex", selectedIndex - 1);
    } else if (selectedIndex === removeIndex && 1 === selectedItems.length) {
      this.option("selectedItems", []);
    } else {
      this._normalizeSelectedItems();
    }
  }
  _beforeItemElementInserted(change) {
    const {
      selectedIndex
    } = this.option();
    if (change.index <= selectedIndex) {
      this.option("selectedIndex", selectedIndex + 1);
    }
  }
  _afterItemElementInserted() {
    this._renderEmptyMessage();
  }
  _removeByChange(keyInfo, items, change, isPartialRefresh) {
    const index = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
    const removedItem = isPartialRefresh ? change.oldItem : items[index];
    if (removedItem) {
      const $removedItemElement = this._findItemElementByKey(change.key);
      const deletedActionArgs = this._extendActionArgs($removedItemElement);
      this._waitDeletingPrepare($removedItemElement).done((() => {
        if (isPartialRefresh) {
          this._updateIndicesAfterIndex(index - 1);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
          this._updateSelectionAfterRemoveByChange(index);
        } else {
          this._deleteItemElementByIndex(index);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
        }
      }));
      this._correctionIndex--;
    }
  }
  _modifyByChanges(changes, isPartialRefresh) {
    const items = this._editStrategy.itemsGetter();
    const keyInfo = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    };
    const dataController2 = this._dataController;
    const paginate = dataController2.paginate();
    const group = dataController2.group();
    if (paginate || group) {
      changes = changes.filter(((item) => "insert" !== item.type || void 0 !== item.index));
    }
    changes.forEach(((change) => this[`_${change.type}ByChange`](keyInfo, items, change, isPartialRefresh)));
    this._renderedItemsCount = items.length;
    this._refreshItemsCache();
    this._fireContentReadyAction();
  }
  _appendItemToContainer($container, $itemFrame, index) {
    const nextSiblingElement = $container.children(this._itemSelector()).get(index);
    dom_adapter_default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
  }
  _subscribeLoadOptionsCustomization(enable) {
    if (!this._dataController) {
      return;
    }
    if (enable) {
      this._correctionIndex = 0;
      this._dataController.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this));
    } else {
      this._dataController.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this));
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "items": {
        const isItemsUpdated = this._partialRefresh(args.value);
        if (!isItemsUpdated) {
          super._optionChanged(args);
        }
        break;
      }
      case "dataSource":
        if (!this.option("repaintChangesOnly") || !args.value) {
          this.option("items", []);
        }
        this._subscribeLoadOptionsCustomization(false);
        super._optionChanged(args);
        this._subscribeLoadOptionsCustomization(true);
        break;
      case "repaintChangesOnly":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_collection_widget_live_update_default = CollectionWidgetLiveUpdate;

// node_modules/devextreme/esm/__internal/utils/type_conversion.js
function toNumber(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_element_style.js
function getElementStyle(el) {
  var _getWindow$getCompute, _getWindow;
  return el && hasWindow() ? null === (_getWindow$getCompute = (_getWindow = getWindow()).getComputedStyle) || void 0 === _getWindow$getCompute ? void 0 : _getWindow$getCompute.call(_getWindow, el) : null;
}
function getElementMargin(element, side) {
  const style = getElementStyle(element);
  return style ? toNumber(style[`margin${titleize(side)}`]) : 0;
}

// node_modules/devextreme/esm/__internal/ui/shared/m_grouped_data_converter_mixin.js
var isCorrectStructure = (data17) => Array.isArray(data17) && data17.every(((item) => {
  const hasTwoFields = 2 === Object.keys(item).length;
  const hasCorrectFields = "key" in item && "items" in item;
  return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
}));
var m_grouped_data_converter_mixin_default = {
  _getSpecificDataSourceOption() {
    let dataSource = this.option("dataSource");
    let hasSimpleItems = false;
    let data17 = {};
    if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
      data17 = dataSource.reduce(((accumulator, item) => {
        const items = item.items.map(((innerItem) => {
          if (!isObject(innerItem)) {
            innerItem = {
              text: innerItem
            };
            hasSimpleItems = true;
          }
          if (!("key" in innerItem)) {
            innerItem.key = item.key;
          }
          return innerItem;
        }));
        return accumulator.concat(items);
      }), []);
      dataSource = {
        store: {
          type: "array",
          data: data17
        },
        group: {
          selector: "key",
          keepInitialKeyOrder: true
        }
      };
      if (hasSimpleItems) {
        dataSource.searchExpr = "text";
      }
    }
    return dataSource;
  }
};

// node_modules/devextreme/esm/__internal/ui/list/m_item.js
var ListItem = class extends item_default {
  _renderWatchers() {
    super._renderWatchers();
    this._startWatcher("badge", this._renderBadge.bind(this));
    this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  }
  _renderBadge(badge) {
    this._$element.children(".dx-list-item-badge-container").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-list-item-badge-container").append(renderer_default("<div>").addClass("dx-list-item-badge").addClass("dx-badge").text(badge));
    const $chevron = this._$element.children(".dx-list-item-chevron-container").first();
    $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
  }
  _renderShowChevron(showChevron) {
    this._$element.children(".dx-list-item-chevron-container").remove();
    if (!showChevron) {
      return;
    }
    const $chevronContainer = renderer_default("<div>").addClass("dx-list-item-chevron-container");
    const $chevron = renderer_default("<div>").addClass("dx-list-item-chevron");
    $chevronContainer.append($chevron).appendTo(this._$element);
  }
};
var m_item_default = ListItem;

// node_modules/devextreme/esm/__internal/ui/list/m_list.base.js
var LIST_SELECT_CHECKBOX = "dx-list-select-checkbox";
var LIST_SELECT_RADIOBUTTON = "dx-list-select-radiobutton";
var groupItemsGetter = compileGetter("items");
var _scrollView;
var ListBase = class extends m_collection_widget_live_update_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      leftArrow: noop,
      rightArrow: noop,
      pageUp(e) {
        this._moveFocusPerPage(e, "prev");
      },
      pageDown(e) {
        this._moveFocusPerPage(e, "next");
      }
    });
  }
  _moveFocusPerPage(e, direction) {
    if (this._isLastItemFocused(direction)) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    let $item = this._getEdgeVisibleItem(direction);
    const {
      focusedElement
    } = this.option();
    const isFocusedItem = $item.is(renderer_default(focusedElement));
    if (isFocusedItem) {
      this.scrollTo(this._getItemLocation($item, direction));
      $item = this._getEdgeVisibleItem(direction);
    }
    this.option("focusedElement", getPublicElement($item));
    this.scrollToItem($item);
  }
  _isLastItemFocused(direction) {
    const lastItemInDirection = "prev" === direction ? this._itemElements().first() : this._itemElements().last();
    const {
      focusedElement
    } = this.option();
    return lastItemInDirection.is(renderer_default(focusedElement));
  }
  _getNextItem($item, direction) {
    const $items = this._getAvailableItems();
    const itemIndex = $items.index($item);
    if ("prev" === direction) {
      return renderer_default($items[itemIndex - 1]);
    }
    return renderer_default($items[itemIndex + 1]);
  }
  _getEdgeVisibleItem(direction) {
    const scrollTop = this.scrollTop();
    const containerHeight = getHeight(this.$element());
    const {
      focusedElement
    } = this.option();
    let $item = renderer_default(focusedElement);
    let isItemVisible = true;
    if (!$item.length) {
      return renderer_default();
    }
    while (isItemVisible) {
      var _$nextItem$position;
      const $nextItem = this._getNextItem($item, direction);
      if (!$nextItem.length) {
        break;
      }
      const nextItemLocation = ((null === (_$nextItem$position = $nextItem.position()) || void 0 === _$nextItem$position ? void 0 : _$nextItem$position.top) ?? 0) + getOuterHeight($nextItem) / 2;
      isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
      if (isItemVisible) {
        $item = $nextItem;
      }
    }
    return $item;
  }
  _getItemLocation($item, direction) {
    if ("prev" === direction) {
      return $item.position().top - getHeight(this.$element()) + getOuterHeight($item);
    }
    return $item.position().top;
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      pullRefreshEnabled: false,
      scrollingEnabled: true,
      selectByClick: true,
      showScrollbar: "onScroll",
      useNativeScrolling: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      pullingDownText: message_default.format("dxList-pullingDownText"),
      pulledDownText: message_default.format("dxList-pulledDownText"),
      refreshingText: message_default.format("dxList-refreshingText"),
      pageLoadingText: message_default.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: message_default.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: false,
      onGroupRendered: null,
      collapsibleGroups: false,
      groupTemplate: "group",
      indicateLoading: true,
      activeStateEnabled: true,
      _itemAttributes: {
        role: "option"
      },
      useInkRipple: false,
      wrapItemText: false,
      _swipeEnabled: true,
      showChevronExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.showChevron,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _onItemsRendered: () => {
      }
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat(deviceDependentOptions(), [{
      device: () => !m_support_default.nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }, {
      device: (device) => !m_support_default.nativeScrolling && !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: ""
      }
    }]);
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._updateLoadingState(true);
    }
  }
  _itemClass() {
    return "dx-list-item";
  }
  _itemDataKey() {
    return "dxListItemData";
  }
  _itemContainer() {
    return this._$container;
  }
  _getItemsContainer() {
    return this._$listContainer;
  }
  _cleanItemContainer() {
    super._cleanItemContainer();
    const listContainer = this._getItemsContainer();
    renderer_default(listContainer).empty();
    listContainer.appendTo(this._$container);
  }
  _saveSelectionChangeEvent(e) {
    this._selectionChangeEventInstance = e;
  }
  _getSelectionChangeEvent() {
    return this._selectionChangeEventInstance;
  }
  _refreshItemElements() {
    const {
      grouped
    } = this.option();
    const $itemsContainer = this._getItemsContainer();
    if (grouped) {
      this._itemElementsCache = $itemsContainer.children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector());
    } else {
      this._itemElementsCache = $itemsContainer.children(this._itemSelector());
    }
  }
  _getItemAndHeaderElements() {
    const itemSelector = `> .dx-list-group-body > ${this._itemSelector()}`;
    const itemAndHeaderSelector = `${itemSelector}, > .dx-list-group-header`;
    const $listGroup = this._getItemsContainer().children(".dx-list-group");
    const $items = $listGroup.find(itemAndHeaderSelector);
    return $items;
  }
  _getAvailableItems($itemElements) {
    const {
      collapsibleGroups
    } = this.option();
    if (collapsibleGroups) {
      const $elements = this._getItemAndHeaderElements();
      const $visibleItems = $elements.filter(((_, element) => {
        if (renderer_default(element).hasClass("dx-list-group-header")) {
          return true;
        }
        return !renderer_default(element).closest(".dx-list-group").hasClass("dx-list-group-collapsed");
      }));
      return $visibleItems;
    }
    return super._getAvailableItems($itemElements);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments);
    this._refreshItemElements();
    this._updateLoadingState(true);
  }
  reorderItem(itemElement, toItemElement) {
    const promise = super.reorderItem(itemElement, toItemElement);
    return promise.done((function() {
      this._refreshItemElements();
    }));
  }
  deleteItem(itemElement) {
    const promise = super.deleteItem(itemElement);
    return promise.done((function() {
      this._refreshItemElements();
    }));
  }
  _itemElements() {
    return this._itemElementsCache;
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    const isSingleSelectedItemClicked = "single" === selectionMode && this.isItemSelected(e.currentTarget);
    if (isSingleSelectedItemClicked) {
      return;
    }
    const isSelectionControlClicked = renderer_default(e.target).closest(`.${LIST_SELECT_CHECKBOX}`).length || renderer_default(e.target).closest(`.${LIST_SELECT_RADIOBUTTON}`).length;
    if (isSelectionControlClicked) {
      this.option("focusedElement", e.currentTarget);
    }
    return super._itemSelectHandler(e, isSelectionControlClicked);
  }
  _allowDynamicItemsAppend() {
    return true;
  }
  _updateActiveStateUnit() {
    const {
      collapsibleGroups
    } = this.option();
    const selectors = [".dx-list-item", ".dx-list-select-all"];
    if (collapsibleGroups) {
      selectors.push(".dx-list-group-header");
    }
    this._activeStateUnit = selectors.join(",");
  }
  _init() {
    super._init();
    this._updateActiveStateUnit();
    this._dataController.resetDataSourcePageIndex();
    this._$container = this.$element();
    this._$listContainer = renderer_default("<div>").addClass("dx-list-items");
    this._initScrollView();
    this._feedbackShowTimeout = 70;
    this._createGroupRenderAction();
  }
  _scrollBottomMode() {
    const {
      pageLoadMode
    } = this.option();
    return "scrollBottom" === pageLoadMode;
  }
  _nextButtonMode() {
    const {
      pageLoadMode
    } = this.option();
    return "nextButton" === pageLoadMode;
  }
  _dataSourceOptions() {
    const scrollBottom = this._scrollBottomMode();
    const nextButton = this._nextButtonMode();
    return extend(super._dataSourceOptions(), {
      paginate: ensureDefined(scrollBottom || nextButton, true)
    });
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _getGroupContainerByIndex(groupIndex) {
    return this._getItemsContainer().find(".dx-list-group").eq(groupIndex).find(".dx-list-group-body");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _initScrollView() {
    const scrollingEnabled = this.option("scrollingEnabled");
    const pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
    const autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataController.getDataSource();
    this._scrollView = this._createComponent(this.$element(), getScrollView(), {
      height: this.option("height"),
      width: this.option("width"),
      disabled: this.option("disabled") || !scrollingEnabled,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
      onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: false
    });
    this._$container = renderer_default(this._scrollView.content());
    this._$listContainer.appendTo(this._$container);
    this._toggleWrapItemText(this.option("wrapItemText"));
    this._createScrollViewActions();
  }
  _toggleWrapItemText(value2) {
    this._$listContainer.toggleClass("dx-wrap-item-text", value2);
  }
  _createScrollViewActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._pullRefreshAction = this._createActionByOption("onPullRefresh");
    this._pageLoadingAction = this._createActionByOption("onPageLoading");
  }
  _scrollHandler(e) {
    var _this$_scrollAction;
    null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this, e);
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      group: new BindableTemplate((($container, data17) => {
        if (isPlainObject(data17)) {
          if (data17.key) {
            $container.text(data17.key);
          }
        } else {
          $container.text(String(data17));
        }
      }), ["key"], this.option("integrationOptions.watchMethod"))
    });
    super._initTemplates();
  }
  _prepareDefaultItemTemplate(data17, $container) {
    super._prepareDefaultItemTemplate(data17, $container);
    if (data17.icon) {
      const $icon = getImageContainer(data17.icon).addClass("dx-list-item-icon");
      const $iconContainer = renderer_default("<div>").addClass("dx-list-item-icon-container");
      $iconContainer.append($icon);
      $container.prepend($iconContainer);
    }
  }
  _getBindableFields() {
    return ["text", "html", "icon"];
  }
  _updateLoadingState(tryLoadMore) {
    const dataController2 = this._dataController;
    const shouldLoadNextPage = this._scrollBottomMode() && tryLoadMore && !dataController2.isLoading() && !this._isLastPage();
    if (this._shouldContinueLoading(shouldLoadNextPage)) {
      this._infiniteDataLoading();
    } else {
      this._scrollView.release(!shouldLoadNextPage && !dataController2.isLoading());
      this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
      this._loadIndicationSuppressed(false);
    }
  }
  _shouldRenderNextButton() {
    return this._nextButtonMode() && this._dataController.isLoaded();
  }
  _isDataSourceFirstLoadCompleted(newValue) {
    if (isDefined(newValue)) {
      this._isFirstLoadCompleted = newValue;
    }
    return this._isFirstLoadCompleted;
  }
  _dataSourceLoadingChangedHandler(isLoading) {
    if (this._loadIndicationSuppressed()) {
      return;
    }
    if (isLoading && this.option("indicateLoading")) {
      this._showLoadingIndicatorTimer = setTimeout((() => {
        const isEmpty3 = !this._itemElements().length;
        const shouldIndicateLoading = !isEmpty3 || this._isDataSourceFirstLoadCompleted();
        if (shouldIndicateLoading) {
          var _this$_scrollView;
          null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView || _this$_scrollView.startLoading();
        }
      }));
    } else {
      var _this$_scrollView2;
      clearTimeout(this._showLoadingIndicatorTimer);
      null === (_this$_scrollView2 = this._scrollView) || void 0 === _this$_scrollView2 || _this$_scrollView2.finishLoading();
    }
    if (!isLoading) {
      this._isDataSourceFirstLoadCompleted(false);
    }
  }
  _dataSourceChangedHandler() {
    if (!this._shouldAppendItems() && hasWindow()) {
      var _this$_scrollView3;
      null === (_this$_scrollView3 = this._scrollView) || void 0 === _this$_scrollView3 || _this$_scrollView3.scrollTo(0);
    }
    super._dataSourceChangedHandler.apply(this, arguments);
    this._isDataSourceFirstLoadCompleted(true);
  }
  _refreshContent() {
    this._prepareContent();
    this._fireContentReadyAction();
  }
  _hideLoadingIfLoadIndicationOff() {
    if (!this.option("indicateLoading")) {
      this._dataSourceLoadingChangedHandler(false);
    }
  }
  _loadIndicationSuppressed(value2) {
    if (!arguments.length) {
      return this._isLoadIndicationSuppressed;
    }
    this._isLoadIndicationSuppressed = value2;
  }
  _scrollViewIsFull() {
    const scrollView = this._scrollView;
    return !scrollView || getHeight(scrollView.content()) > getHeight(scrollView.container());
  }
  _pullDownHandler(e) {
    var _this$_pullRefreshAct;
    null === (_this$_pullRefreshAct = this._pullRefreshAction) || void 0 === _this$_pullRefreshAct || _this$_pullRefreshAct.call(this, e);
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !dataController2.isLoading()) {
      this._clearSelectedItems();
      dataController2.pageIndex(0);
      dataController2.reload();
    } else {
      this._updateLoadingState();
    }
  }
  _shouldContinueLoading(shouldLoadNextPage) {
    var _this$_scrollView$scr;
    const isBottomReached = getHeight(this._scrollView.content()) - getHeight(this._scrollView.container()) < ((null === (_this$_scrollView$scr = this._scrollView.scrollOffset()) || void 0 === _this$_scrollView$scr ? void 0 : _this$_scrollView$scr.top) ?? 0);
    return shouldLoadNextPage && (!this._scrollViewIsFull() || isBottomReached);
  }
  _infiniteDataLoading() {
    const isElementVisible2 = this.$element().is(":visible");
    if (isElementVisible2) {
      clearTimeout(this._loadNextPageTimer);
      this._loadNextPageTimer = setTimeout((() => {
        this._loadNextPage();
      }));
    }
  }
  _scrollBottomHandler(e) {
    var _this$_pageLoadingAct;
    null === (_this$_pageLoadingAct = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct || _this$_pageLoadingAct.call(this, e);
    const dataController2 = this._dataController;
    if (!dataController2.isLoading() && !this._isLastPage()) {
      this._loadNextPage();
    } else {
      this._updateLoadingState();
    }
  }
  _renderItems(items) {
    if (this.option("grouped")) {
      each(items, this._renderGroup.bind(this));
      this._attachGroupCollapseEvent();
      this._renderEmptyMessage();
      if (isMaterial()) {
        this.attachGroupHeaderInkRippleEvents();
      }
    } else {
      super._renderItems.apply(this, arguments);
    }
    this._refreshItemElements();
    this._updateLoadingState(true);
  }
  _postProcessRenderItems() {
    const {
      _onItemsRendered: onItemsRendered
    } = this.option();
    null === onItemsRendered || void 0 === onItemsRendered || onItemsRendered();
  }
  _attachGroupCollapseEvent() {
    const {
      collapsibleGroups
    } = this.option();
    const eventNameClick = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    $element.toggleClass("dx-list-collapsible-groups", collapsibleGroups);
    m_events_engine_default.off($element, eventNameClick, ".dx-list-group-header");
    if (collapsibleGroups) {
      m_events_engine_default.on($element, eventNameClick, ".dx-list-group-header", ((e) => {
        this._processGroupCollapse(e);
      }));
    }
  }
  _processGroupCollapse(e) {
    const action = this._createAction(((e2) => {
      const {
        focusStateEnabled
      } = this.option();
      const $group = renderer_default(e2.event.currentTarget).parent();
      this._collapseGroupHandler($group);
      if (focusStateEnabled) {
        const groupHeader = getPublicElement($group.find(".dx-list-group-header"));
        this.option({
          focusedElement: groupHeader
        });
      }
    }), {
      validatingTargetName: "element"
    });
    action({
      event: e
    });
  }
  _enterKeyHandler(e) {
    const {
      collapsibleGroups,
      focusedElement
    } = this.option();
    const isGroupHeader = renderer_default(focusedElement).hasClass("dx-list-group-header");
    if (collapsibleGroups && isGroupHeader) {
      const params = this._getHandlerExtendedParams(e, renderer_default(focusedElement));
      this._processGroupCollapse(params);
      return;
    }
    super._enterKeyHandler(e);
  }
  _collapseGroupHandler($group, toggle) {
    const deferred = Deferred();
    const $groupHeader = $group.children(".dx-list-group-header");
    const collapsed = $group.hasClass("dx-list-group-collapsed");
    this._updateGroupHeaderAriaExpanded($groupHeader, collapsed);
    if (collapsed === toggle) {
      return deferred.resolve();
    }
    const $groupBody = $group.children(".dx-list-group-body");
    const startHeight = getOuterHeight($groupBody);
    let endHeight = 0;
    if (collapsed) {
      setHeight($groupBody, "auto");
      endHeight = getOuterHeight($groupBody);
    }
    $group.toggleClass("dx-list-group-collapsed", toggle);
    if (fx_default.isAnimating($groupBody)) {
      fx_default.stop($groupBody, false);
    }
    fx_default.animate($groupBody, {
      type: "custom",
      from: {
        height: startHeight
      },
      to: {
        height: endHeight
      },
      duration: 200,
      complete: (function() {
        this.updateDimensions();
        this._updateLoadingState(true);
        deferred.resolve();
      }).bind(this)
    });
    return deferred.promise();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    if (this._initialized) {
      this._renderEmptyMessage();
      this._updateLoadingState();
    }
  }
  _initMarkup() {
    this._itemElementsCache = renderer_default();
    this.$element().addClass("dx-list");
    super._initMarkup();
    this.option("useInkRipple") && this._renderInkRipple();
    const elementAria = {
      role: "group",
      roledescription: message_default.format("dxList-ariaRoleDescription")
    };
    this.setAria(elementAria, this.$element());
    this.setAria({
      role: "application"
    }, this._focusTarget());
    this._setListAria();
  }
  _setListAria() {
    const {
      items,
      allowItemDeleting,
      collapsibleGroups
    } = this.option();
    const label = allowItemDeleting ? message_default.format("dxList-listAriaLabel-deletable") : message_default.format("dxList-listAriaLabel");
    const shouldSetAria = (null === items || void 0 === items ? void 0 : items.length) && !collapsibleGroups;
    const listArea = {
      role: shouldSetAria ? "listbox" : void 0,
      label: shouldSetAria ? label : void 0
    };
    this.setAria(listArea, this._$listContainer);
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState.apply(this, arguments);
    const that = this;
    if (!this._inkRipple) {
      return;
    }
    const config2 = {
      element: $element,
      event: e
    };
    if (value2) {
      if (isMaterial()) {
        this._inkRippleTimer = setTimeout((() => {
          var _that$_inkRipple;
          null === (_that$_inkRipple = that._inkRipple) || void 0 === _that$_inkRipple || _that$_inkRipple.showWave(config2);
        }), 35);
      } else {
        var _that$_inkRipple2;
        null === (_that$_inkRipple2 = that._inkRipple) || void 0 === _that$_inkRipple2 || _that$_inkRipple2.showWave(config2);
      }
    } else {
      clearTimeout(this._inkRippleTimer);
      this._inkRipple.hideWave(config2);
    }
  }
  _postprocessRenderItem(args) {
    this._refreshItemElements();
    super._postprocessRenderItem.apply(this, arguments);
    if (this.option("_swipeEnabled")) {
      this._attachSwipeEvent(renderer_default(args.itemElement));
    }
  }
  _getElementClassToSkipRefreshId() {
    return "dx-list-group-header";
  }
  _attachSwipeEvent($itemElement) {
    const endEventName = addNamespace(SWIPE_END_EVENT, this.NAME);
    m_events_engine_default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeEndHandler(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  }
  _nextButtonHandler(e) {
    var _this$_pageLoadingAct2;
    null === (_this$_pageLoadingAct2 = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct2 || _this$_pageLoadingAct2.call(this, e);
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !dataController2.isLoading()) {
      var _this$_$nextButton;
      this._scrollView.toggleLoading(true);
      null === (_this$_$nextButton = this._$nextButton) || void 0 === _this$_$nextButton || _this$_$nextButton.detach();
      this._loadIndicationSuppressed(true);
      this._loadNextPage();
    }
  }
  _setGroupAria($group, groupHeaderId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupAria = {
      role: collapsibleGroups ? void 0 : "group",
      labelledby: collapsibleGroups ? void 0 : groupHeaderId
    };
    this.setAria(groupAria, $group);
  }
  _updateGroupHeaderAriaExpanded($groupHeader, expanded) {
    this.setAria({
      expanded
    }, $groupHeader);
  }
  _setGroupHeaderAria($groupHeader, listGroupBodyId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupHeaderAria = {
      role: collapsibleGroups ? "button" : void 0,
      expanded: collapsibleGroups ? true : void 0,
      controls: collapsibleGroups ? listGroupBodyId : void 0
    };
    this.setAria(groupHeaderAria, $groupHeader);
  }
  _setGroupBodyAria($groupBody, groupHeaderId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupHeaderAria = {
      role: collapsibleGroups ? "listbox" : void 0,
      labelledby: collapsibleGroups ? groupHeaderId : void 0
    };
    this.setAria(groupHeaderAria, $groupBody);
  }
  _renderGroup(index, group) {
    const $groupElement = renderer_default("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer());
    const groupHeaderId = `dx-${new guid_default().toString()}`;
    const $groupHeaderElement = renderer_default("<div>").addClass("dx-list-group-header").attr("id", groupHeaderId).appendTo($groupElement);
    const {
      groupTemplate: templateName
    } = this.option();
    const groupTemplate = this._getTemplate(group.template || templateName, group, index, $groupHeaderElement);
    const renderArgs = {
      index,
      itemData: group,
      container: getPublicElement($groupHeaderElement)
    };
    this._createItemByTemplate(groupTemplate, renderArgs);
    renderer_default("<div>").addClass("dx-list-group-header-indicator").prependTo($groupHeaderElement);
    const groupBodyId = `dx-${new guid_default().toString()}`;
    const $groupBody = renderer_default("<div>").addClass("dx-list-group-body").attr("id", groupBodyId).appendTo($groupElement);
    each(groupItemsGetter(group) || [], ((itemIndex, item) => {
      this._renderItem({
        group: index,
        item: itemIndex
      }, item, $groupBody);
    }));
    this._groupRenderAction({
      groupElement: getPublicElement($groupElement),
      groupIndex: index,
      groupData: group
    });
    this._setGroupAria($groupElement, groupHeaderId);
    this._setGroupHeaderAria($groupHeaderElement, groupBodyId);
    this._setGroupBodyAria($groupBody, groupHeaderId);
  }
  downInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), true, e);
  }
  upInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), false);
  }
  attachGroupHeaderInkRippleEvents() {
    const $element = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
    this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    const downArguments = [$element, "dxpointerdown", ".dx-list-group-header", this._downInkRippleHandler];
    const upArguments = [$element, "dxpointerup dxpointerout", ".dx-list-group-header", this._upInkRippleHandler];
    m_events_engine_default.off(...downArguments);
    m_events_engine_default.on(...downArguments);
    m_events_engine_default.off(...upArguments);
    m_events_engine_default.on(...upArguments);
  }
  _createGroupRenderAction() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  }
  _clean() {
    clearTimeout(this._inkRippleTimer);
    if (this._$nextButton) {
      this._$nextButton.remove();
      this._$nextButton = null;
    }
    super._clean.apply(this, arguments);
  }
  _dispose() {
    this._isDataSourceFirstLoadCompleted(false);
    clearTimeout(this._holdTimer);
    clearTimeout(this._loadNextPageTimer);
    clearTimeout(this._showLoadingIndicatorTimer);
    super._dispose();
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(value2);
    this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
  }
  _toggleNextButton(value2) {
    const dataController2 = this._dataController;
    const $nextButton = this._getNextButton();
    this.$element().toggleClass("dx-has-next", value2);
    if (value2 && dataController2.isLoaded()) {
      $nextButton.appendTo(this._itemContainer());
    }
    if (!value2) {
      $nextButton.detach();
    }
  }
  _getNextButton() {
    if (!this._$nextButton) {
      this._$nextButton = this._createNextButton();
    }
    return this._$nextButton;
  }
  _createNextButton() {
    const $result = renderer_default("<div>").addClass("dx-list-next-button");
    const $button = renderer_default("<div>").appendTo($result);
    this._createComponent($button, button_default2, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: isMaterialBased() ? "default" : void 0,
      integrationOptions: {}
    });
    return $result;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments);
    this.scrollToItem(this.option("focusedElement"));
  }
  _refresh() {
    if (!hasWindow()) {
      super._refresh();
    } else {
      const scrollTop = this._scrollView.scrollTop();
      super._refresh();
      scrollTop && this._scrollView.scrollTo(scrollTop);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "pageLoadMode":
        this._toggleNextButton(args.value);
        this._initScrollView();
        break;
      case "dataSource":
        super._optionChanged(args);
        this._initScrollView();
        this._updateLoadingState(true);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "items":
        super._optionChanged(args);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView();
        this._updateLoadingState(true);
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
      case "grouped":
      case "groupTemplate":
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "collapsibleGroups":
        this._updateActiveStateUnit();
        this._invalidate();
        break;
      case "wrapItemText":
        this._toggleWrapItemText(args.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._scrollView.option(args.name, args.value);
        this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        super._optionChanged(args);
        this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView();
        super._optionChanged(args);
        break;
      case "_swipeEnabled":
      case "_onItemsRendered":
      case "selectByClick":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _extendActionArgs($itemElement) {
    if (!this.option("grouped")) {
      return super._extendActionArgs($itemElement);
    }
    const $group = $itemElement.closest(".dx-list-group");
    const $item = $group.find(".dx-list-item");
    return extend(super._extendActionArgs($itemElement), {
      itemIndex: {
        group: $group.index(),
        item: $item.index($itemElement)
      }
    });
  }
  expandGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, false).done((() => {
      deferred.resolveWith(this);
    }));
    return deferred.promise();
  }
  collapseGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, true).done((() => {
      deferred.resolveWith(this);
    }));
    return deferred;
  }
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollView) {
      that._scrollView.update().done((() => {
        !that._scrollViewIsFull() && that._updateLoadingState(true);
        deferred.resolveWith(that);
      }));
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  }
  reload() {
    super.reload();
    this.scrollTo(0);
    this._pullDownHandler();
  }
  repaint() {
    this.scrollTo(0);
    super.repaint();
  }
  scrollTop() {
    return this._scrollView.scrollOffset().top;
  }
  clientHeight() {
    return this._scrollView.clientHeight();
  }
  scrollHeight() {
    return this._scrollView.scrollHeight();
  }
  scrollBy(distance) {
    this._scrollView.scrollBy(distance);
  }
  scrollTo(location) {
    this._scrollView.scrollTo(location);
  }
  scrollToItem(itemElement) {
    const $item = this._editStrategy.getItemElement(itemElement);
    const item = null === $item || void 0 === $item ? void 0 : $item.get(0);
    this._scrollView.scrollToElement(item, {
      bottom: getElementMargin(item, "bottom")
    });
  }
  _dimensionChanged() {
    this.updateDimensions();
  }
};
ListBase.include(m_grouped_data_converter_mixin_default);
ListBase.ItemClass = m_item_default;
function getScrollView() {
  return _scrollView || scroll_view_default;
}

// node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.list.js
var TOOLBAR_MENU_ACTION_CLASS = "dx-toolbar-menu-action";
var ToolbarMenuList = class extends ListBase {
  _init() {
    super._init();
    this._activeStateUnit = ".dx-toolbar-menu-action:not(.dx-toolbar-hidden-button-group)";
  }
  _initMarkup() {
    this._renderSections();
    super._initMarkup();
    this._setMenuRole();
  }
  _getSections() {
    return this._itemContainer().children();
  }
  _itemElements() {
    return this._getSections().children(this._itemSelector());
  }
  _renderSections() {
    const $container = this._itemContainer();
    each(["before", "center", "after", "menu"], ((_, section) => {
      const sectionName = `_$${section}Section`;
      if (!this[sectionName]) {
        this[sectionName] = renderer_default("<div>").addClass("dx-toolbar-menu-section");
      }
      this[sectionName].appendTo($container);
    }));
  }
  _renderItems() {
    super._renderItems.apply(this, arguments);
    this._updateSections();
  }
  _setMenuRole() {
    const $menuContainer = this.$element().find(".dx-scrollview-content");
    $menuContainer.attr("role", "menu");
  }
  _updateSections() {
    const $sections = this.$element().find(".dx-toolbar-menu-section");
    $sections.removeClass("dx-toolbar-menu-last-section");
    $sections.not(":empty").eq(-1).addClass("dx-toolbar-menu-last-section");
  }
  _renderItem(index, item, itemContainer, $after) {
    const $container = this[`_$${item.location ?? "menu"}Section`];
    const itemElement = super._renderItem(index, item, $container, $after);
    const itemCssClasses = this._getItemCssClasses(item);
    itemElement.addClass(itemCssClasses.join(" "));
    return itemElement;
  }
  _getItemCssClasses(item) {
    const cssClasses = [];
    const actionableComponents = this._getActionableComponents();
    if (this._getItemTemplateName({
      itemData: item
    })) {
      cssClasses.push("dx-toolbar-menu-custom");
    }
    if (!item.location && !item.widget || actionableComponents.some(((component) => component === item.widget))) {
      cssClasses.push("dx-toolbar-menu-action");
    }
    if ("dxButton" === item.widget) {
      cssClasses.push("dx-toolbar-hidden-button");
    }
    if ("dxButtonGroup" === item.widget) {
      cssClasses.push("dx-toolbar-hidden-button-group");
    }
    if (item.cssClass) {
      cssClasses.push(item.cssClass);
    }
    return cssClasses;
  }
  _getActionableComponents() {
    return ["dxButton", "dxButtonGroup"];
  }
  _getItemTemplateName(args) {
    const template = super._getItemTemplateName(args);
    const data17 = args.itemData;
    const menuTemplate = null === data17 || void 0 === data17 ? void 0 : data17.menuItemTemplate;
    return menuTemplate || template;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _itemClickHandler(e, args, config2) {
    if (renderer_default(e.target).closest(".dx-toolbar-menu-action").length) {
      super._itemClickHandler(e, args, config2);
    }
  }
  _clean() {
    this._getSections().empty();
    super._clean();
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.js
var DropDownMenu = class extends widget_default {
  _supportedKeys() {
    var _this$_list;
    let extension = {};
    if (!this.option("opened") || !(null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.option("focusedElement"))) {
      extension = this._button._supportedKeys();
    }
    return extend(super._supportedKeys(), extension, {
      tab() {
        var _this$_popup;
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      items: [],
      onItemClick: null,
      dataSource: null,
      itemTemplate: "item",
      onButtonClick: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      opened: false,
      onItemRendered: null,
      closeOnClick: true,
      useInkRipple: false,
      container: void 0,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useInkRipple: true,
        animation: {
          show: {
            type: "pop",
            duration: 200,
            from: {
              scale: 0
            },
            to: {
              scale: 1
            }
          },
          hide: {
            type: "pop",
            duration: 200,
            from: {
              scale: 1
            },
            to: {
              scale: 0
            }
          }
        }
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-dropdownmenu");
    this._initItemClickAction();
    this._initButtonClickAction();
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick", {});
  }
  _initButtonClickAction() {
    this._buttonClickAction = this._createActionByOption("onButtonClick", {});
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new ChildDefaultTemplate("content")
    });
    super._initTemplates();
  }
  _initMarkup() {
    this._renderButton();
    super._initMarkup();
  }
  _render() {
    super._render();
    this.setAria({
      haspopup: true,
      expanded: this.option("opened")
    });
  }
  _renderContentImpl() {
    if (this.option("opened")) {
      this._renderPopup();
    }
  }
  _clean() {
    var _this$_list2, _this$_popup2;
    this._cleanFocusState();
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2.$element().remove();
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.$element().remove();
    delete this._list;
    delete this._popup;
  }
  _renderButton() {
    const $button = this.$element().addClass("dx-dropdownmenu-button");
    this._button = this._createComponent($button, button_default2, {
      icon: "overflow",
      template: "content",
      stylingMode: isFluent() ? "text" : "contained",
      useInkRipple: this.option("useInkRipple"),
      hoverStateEnabled: false,
      focusStateEnabled: false,
      onClick: (e) => {
        this.option("opened", !this.option("opened"));
        this._buttonClickAction(e);
      }
    });
  }
  _toggleActiveState($element, value2, e) {
    this._button._toggleActiveState($element, value2, e);
  }
  _toggleMenuVisibility(opened) {
    var _this$_popup3, _this$_popup4;
    const state = opened ?? !(null !== (_this$_popup3 = this._popup) && void 0 !== _this$_popup3 && _this$_popup3.option("visible"));
    if (opened) {
      this._renderPopup();
    }
    null === (_this$_popup4 = this._popup) || void 0 === _this$_popup4 || _this$_popup4.toggle(state);
    this.setAria("expanded", state);
  }
  _renderPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").appendTo(this.$element());
    const {
      rtlEnabled,
      container,
      animation: animation2
    } = this.option();
    this._popup = this._createComponent(this._$popup, "dxPopup", {
      onInitialized(_ref) {
        let {
          component
        } = _ref;
        component.$wrapper().addClass("dx-dropdownmenu-popup-wrapper").addClass("dx-dropdownmenu-popup");
      },
      deferRendering: false,
      preventScrollEvents: false,
      _ignorePreventScrollEventsDeprecation: true,
      contentTemplate: (contentElement) => this._renderList(contentElement),
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => this._getMaxHeight(),
      position: {
        my: "top " + (rtlEnabled ? "left" : "right"),
        at: "bottom " + (rtlEnabled ? "left" : "right"),
        collision: "fit flip",
        offset: {
          v: 3
        },
        of: this.$element()
      },
      animation: animation2,
      onOptionChanged: (_ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        if ("visible" === name2) {
          this.option("opened", value2);
        }
      },
      container,
      autoResizeEnabled: false,
      height: "auto",
      width: "auto",
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      hideOnParentScroll: true,
      shading: false,
      dragEnabled: false,
      showTitle: false,
      fullScreen: false,
      ignoreChildEvents: false,
      _fixWrapperPosition: true
    });
    this._popup.registerKeyHandler("space", ((e) => {
      this._popupKeyHandler(e);
    }));
    this._popup.registerKeyHandler("enter", ((e) => {
      this._popupKeyHandler(e);
    }));
    this._popup.registerKeyHandler("escape", ((e) => {
      var _this$_popup5;
      if (null !== (_this$_popup5 = this._popup) && void 0 !== _this$_popup5 && _this$_popup5.$overlayContent().is(renderer_default(e.target))) {
        this.option("opened", false);
      }
    }));
  }
  _getMaxHeight() {
    const $element = this.$element();
    const offsetTop = $element.offset().top;
    const windowHeight = getOuterHeight(getWindow());
    const maxHeight = Math.max(offsetTop, windowHeight - offsetTop - getOuterHeight($element));
    return Math.min(windowHeight, maxHeight - 3 - 10);
  }
  _closeOutsideDropDownHandler(e) {
    const isOutsideClick = !renderer_default(e.target).closest(this.$element()).length;
    return isOutsideClick;
  }
  _renderList(contentElement) {
    const $content = renderer_default(contentElement);
    $content.addClass("dx-dropdownmenu-list");
    const {
      itemTemplate,
      onItemRendered
    } = this.option();
    this._list = this._createComponent($content, ToolbarMenuList, {
      dataSource: this._getListDataSource(),
      pageLoadMode: "scrollBottom",
      indicateLoading: false,
      noDataText: "",
      itemTemplate,
      onItemClick: (e) => {
        this._itemClickHandler(e);
      },
      tabIndex: -1,
      focusStateEnabled: false,
      activeStateEnabled: true,
      onItemRendered,
      _itemAttributes: {
        role: "menuitem"
      }
    });
  }
  _popupKeyHandler(e) {
    if (renderer_default(e.target).closest(`.${TOOLBAR_MENU_ACTION_CLASS}`).length) {
      this._closePopup();
    }
  }
  _closePopup() {
    if (this.option("closeOnClick")) {
      this.option("opened", false);
    }
  }
  _itemClickHandler(e) {
    var _this$_itemClickActio;
    this._closePopup();
    null === (_this$_itemClickActio = this._itemClickAction) || void 0 === _this$_itemClickActio || _this$_itemClickActio.call(this, e);
  }
  _itemOptionChanged(item, property, value2) {
    var _this$_list3;
    null === (_this$_list3 = this._list) || void 0 === _this$_list3 || _this$_list3._itemOptionChanged(item, property, value2);
    toggleItemFocusableElementTabIndex(this._list, item);
  }
  _getListDataSource() {
    return this.option("dataSource") ?? this.option("items");
  }
  _setListDataSource() {
    var _this$_list4;
    null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option("dataSource", this._getListDataSource());
    delete this._deferRendering;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._list]);
  }
  _toggleVisibility(visible) {
    var _this$_button;
    super._toggleVisibility(visible);
    null === (_this$_button = this._button) || void 0 === _this$_button || _this$_button.option("visible", visible);
  }
  _optionChanged(args) {
    var _this$_list5, _this$_list6, _this$_list7;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "items":
      case "dataSource":
        if (!this.option("opened")) {
          this._deferRendering = true;
        } else {
          this._setListDataSource();
        }
        break;
      case "itemTemplate":
        null === (_this$_list5 = this._list) || void 0 === _this$_list5 || _this$_list5.option(name2, this._getTemplate(value2));
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "onButtonClick":
        this._buttonClickAction();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      case "focusStateEnabled":
        null === (_this$_list6 = this._list) || void 0 === _this$_list6 || _this$_list6.option(name2, value2);
        super._optionChanged(args);
        break;
      case "onItemRendered":
        null === (_this$_list7 = this._list) || void 0 === _this$_list7 || _this$_list7.option(name2, value2);
        break;
      case "opened":
        if (this._deferRendering) {
          this._setListDataSource();
        }
        this._toggleMenuVisibility(value2);
        this._updateFocusableItemsTabIndex();
        break;
      case "closeOnClick":
        break;
      case "container":
        this._popup && this._popup.option(name2, value2);
        break;
      case "disabled":
        if (this._list) {
          this._updateFocusableItemsTabIndex();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _updateFocusableItemsTabIndex() {
    this.option("items").forEach(((item) => toggleItemFocusableElementTabIndex(this._list, item)));
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.singleline.js
var TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var SingleLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
    deferRender((() => {
      this._renderOverflowMenu();
      this._renderMenuItems();
    }));
  }
  _renderOverflowMenu() {
    if (!this._hasVisibleMenuItems()) {
      return;
    }
    this._renderMenuButtonContainer();
    const $menu = renderer_default("<div>").appendTo(this._overflowMenuContainer());
    const itemClickAction = this._toolbar._createActionByOption("onItemClick");
    const menuItemTemplate = this._toolbar._getTemplateByOption("menuItemTemplate");
    const {
      disabled,
      menuContainer
    } = this._toolbar.option();
    this._menu = this._toolbar._createComponent($menu, DropDownMenu, {
      disabled,
      itemTemplate: () => menuItemTemplate,
      onItemClick: (e) => {
        itemClickAction(e);
      },
      container: menuContainer,
      onOptionChanged: (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if ("opened" === name2) {
          this._toolbar.option("overflowMenuVisible", value2);
        }
        if ("items" === name2) {
          this._updateMenuVisibility(value2);
        }
      }
    });
  }
  renderMenuItems() {
    var _this$_menu;
    if (!this._menu) {
      this._renderOverflowMenu();
    }
    null === (_this$_menu = this._menu) || void 0 === _this$_menu || _this$_menu.option("items", this._getMenuItems());
    if (this._menu && !this._menu.option("items").length) {
      this._menu.option("opened", false);
    }
  }
  _renderMenuButtonContainer() {
    this._$overflowMenuContainer = renderer_default("<div>").appendTo(this._toolbar._$afterSection).addClass("dx-toolbar-button").addClass("dx-toolbar-menu-container");
  }
  _overflowMenuContainer() {
    return this._$overflowMenuContainer;
  }
  _updateMenuVisibility(menuItems) {
    const items = menuItems ?? this._getMenuItems();
    const isMenuVisible = items.length && this._hasVisibleMenuItems(items);
    this._toggleMenuVisibility(isMenuVisible);
  }
  _toggleMenuVisibility(value2) {
    if (!this._overflowMenuContainer()) {
      return;
    }
    this._overflowMenuContainer().toggleClass("dx-state-invisible", !value2);
  }
  _renderMenuItems() {
    deferRender((() => {
      this.renderMenuItems();
    }));
  }
  _dimensionChanged() {
    this.renderMenuItems();
  }
  _getToolbarItems() {
    return grep(this._toolbar.option("items") ?? [], ((item) => !this._toolbar._isMenuItem(item)));
  }
  _getHiddenItems() {
    return this._toolbar._itemContainer().children(`.dx-toolbar-item-auto-hide.${TOOLBAR_HIDDEN_ITEM}`).not(".dx-state-invisible");
  }
  _getMenuItems() {
    const menuItems = grep(this._toolbar.option("items") ?? [], ((item) => this._toolbar._isMenuItem(item)));
    const $hiddenItems = this._getHiddenItems();
    this._restoreItems = this._restoreItems ?? [];
    const overflowItems = [].slice.call($hiddenItems).map(((hiddenItem) => {
      const itemData = this._toolbar._getItemData(hiddenItem);
      const $itemContainer = renderer_default(hiddenItem);
      const $itemMarkup = $itemContainer.children();
      return extend({
        menuItemTemplate: () => {
          this._restoreItems.push({
            container: $itemContainer,
            item: $itemMarkup
          });
          const $container = renderer_default("<div>").addClass("dx-toolbar-item-auto-hide");
          return $container.append($itemMarkup);
        }
      }, itemData);
    }));
    return [...overflowItems, ...menuItems];
  }
  _hasVisibleMenuItems(items) {
    const menuItems = items ?? this._toolbar.option("items");
    let result2 = false;
    const optionGetter = compileGetter("visible");
    const overflowGetter = compileGetter("locateInMenu");
    each(menuItems, ((index, item) => {
      const itemVisible = optionGetter(item, {
        functionsAsIs: true
      });
      const itemOverflow = overflowGetter(item, {
        functionsAsIs: true
      });
      if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow)) {
        result2 = true;
      }
    }));
    return result2;
  }
  _arrangeItems() {
    this._toolbar._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    each(this._restoreItems ?? [], ((_, obj) => {
      renderer_default(obj.container).append(obj.item);
    }));
    this._restoreItems = [];
    const elementWidth = getWidth(this._toolbar.$element());
    this._hideOverflowItems(elementWidth);
    return elementWidth;
  }
  _hideOverflowItems(width) {
    const overflowItems = this._toolbar.$element().find(".dx-toolbar-item-auto-hide");
    if (!overflowItems.length) {
      return;
    }
    const elementWidth = width ?? getWidth(this._toolbar.$element());
    renderer_default(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
    let itemsWidth = this._getItemsWidth();
    while (overflowItems.length && elementWidth < itemsWidth) {
      const $item = overflowItems.eq(-1);
      $item.addClass(TOOLBAR_HIDDEN_ITEM);
      itemsWidth = this._getItemsWidth();
      overflowItems.splice(-1, 1);
    }
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", [this._toolbar._$beforeSection, this._toolbar._$centerSection, this._toolbar._$afterSection]);
  }
  _itemOptionChanged(item, property, value2) {
    if ("disabled" === property || "options.disabled" === property) {
      if (this._toolbar._isMenuItem(item)) {
        var _this$_menu2;
        null === (_this$_menu2 = this._menu) || void 0 === _this$_menu2 || _this$_menu2._itemOptionChanged(item, property, value2);
        return;
      }
    }
    this.renderMenuItems();
  }
  _renderItem(item, itemElement) {
    if ("auto" === item.locateInMenu) {
      itemElement.addClass("dx-toolbar-item-auto-hide");
    }
  }
  _optionChanged(name2, value2) {
    var _this$_menu3, _this$_menu4, _this$_menu5, _this$_menu6, _this$_menu7;
    switch (name2) {
      case "disabled":
        null === (_this$_menu3 = this._menu) || void 0 === _this$_menu3 || _this$_menu3.option(name2, value2);
        break;
      case "overflowMenuVisible":
        null === (_this$_menu4 = this._menu) || void 0 === _this$_menu4 || _this$_menu4.option("opened", value2);
        break;
      case "onItemClick":
        null === (_this$_menu5 = this._menu) || void 0 === _this$_menu5 || _this$_menu5.option(name2, value2);
        break;
      case "menuContainer":
        null === (_this$_menu6 = this._menu) || void 0 === _this$_menu6 || _this$_menu6.option("container", value2);
        break;
      case "menuItemTemplate":
        null === (_this$_menu7 = this._menu) || void 0 === _this$_menu7 || _this$_menu7.option("itemTemplate", value2);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.js
var Toolbar = class extends m_toolbar_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      menuItemTemplate: "menuItem",
      menuContainer: void 0,
      overflowMenuVisible: false,
      multiline: false
    });
  }
  _isMultiline() {
    return this.option("multiline");
  }
  _dimensionChanged(dimension) {
    if ("height" === dimension) {
      return;
    }
    super._dimensionChanged();
    this._layoutStrategy._dimensionChanged();
  }
  _initMarkup() {
    super._initMarkup();
    this._updateFocusableItemsTabIndex();
    this._layoutStrategy._initMarkup();
  }
  _renderToolbar() {
    super._renderToolbar();
    this._renderLayoutStrategy();
  }
  _itemContainer() {
    if (this._isMultiline()) {
      return this._$toolbarItemsContainer;
    }
    return super._itemContainer();
  }
  _renderLayoutStrategy() {
    this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline());
    this._layoutStrategy = this._isMultiline() ? new MultiLineStrategy(this) : new SingleLineStrategy(this);
  }
  _renderSections() {
    if (this._isMultiline()) {
      return;
    }
    return super._renderSections();
  }
  _postProcessRenderItems() {
    this._layoutStrategy._hideOverflowItems();
    this._layoutStrategy._updateMenuVisibility();
    super._postProcessRenderItems();
    this._layoutStrategy._renderMenuItems();
  }
  _renderItem(index, item, itemContainer, $after) {
    const itemElement = super._renderItem(index, item, itemContainer, $after);
    this._layoutStrategy._renderItem(item, itemElement);
    const {
      widget,
      showText
    } = item;
    if ("dxButton" === widget && "inMenu" === showText) {
      itemElement.toggleClass("dx-toolbar-text-auto-hide");
    }
    return itemElement;
  }
  _getItemsWidth() {
    return this._layoutStrategy._getItemsWidth();
  }
  _getMenuItems() {
    return this._layoutStrategy._getMenuItems();
  }
  _getToolbarItems() {
    return this._layoutStrategy._getToolbarItems();
  }
  _arrangeItems() {
    if (this.$element().is(":hidden")) {
      return;
    }
    const elementWidth = this._layoutStrategy._arrangeItems();
    if (!this._isMultiline()) {
      super._arrangeItems(elementWidth);
    }
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if (!this._isMenuItem(item)) {
      super._itemOptionChanged(item, property, value2, prevValue);
    }
    this._layoutStrategy._itemOptionChanged(item, property, value2);
    if ("disabled" === property || "options.disabled" === property) {
      toggleItemFocusableElementTabIndex(this, item);
    }
    if ("location" === property) {
      this.repaint();
    }
  }
  _updateFocusableItemsTabIndex() {
    this._getToolbarItems().forEach(((item) => toggleItemFocusableElementTabIndex(this, item)));
  }
  _isMenuItem(itemData) {
    return "always" === itemData.locateInMenu;
  }
  _isToolbarItem(itemData) {
    return void 0 === itemData.location || "never" === itemData.locateInMenu;
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._layoutStrategy._optionChanged(name2, value2);
    switch (name2) {
      case "menuContainer":
      case "menuItemTemplate":
      case "overflowMenuVisible":
        break;
      case "multiline":
        this._invalidate();
        break;
      case "disabled":
        super._optionChanged(args);
        this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateDimensions() {
    this._dimensionChanged();
  }
};
component_registrator_default("dxToolbar", Toolbar);
var m_toolbar_default = Toolbar;

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.js
var ui_toolbar_default = m_toolbar_default;

// node_modules/devextreme/esm/ui/toolbar.js
var toolbar_default = ui_toolbar_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/header_panel/m_header_panel.js
var DEFAULT_TOOLBAR_ITEM_NAMES = ["addRowButton", "applyFilterButton", "columnChooserButton", "exportButton", "groupPanel", "revertButton", "saveButton", "searchPanel"];
var HeaderPanel = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._headerFilterController = this.getController("headerFilter");
    this.createAction("onToolbarPreparing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getToolbarItems() {
    return [];
  }
  _getButtonContainer() {
    return renderer_default("<div>").addClass(this.addWidgetPrefix("toolbar-button"));
  }
  _getToolbarButtonClass(specificClass) {
    const secondClass = specificClass ? ` ${specificClass}` : "";
    return this.addWidgetPrefix("toolbar-button") + secondClass;
  }
  _getToolbarOptions() {
    const userToolbarOptions = this.option("toolbar");
    const options2 = {
      toolbarOptions: {
        items: this._getToolbarItems(),
        visible: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.visible,
        disabled: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.disabled,
        onItemRendered(e) {
          const itemRenderedCallback = e.itemData.onItemRendered;
          if (itemRenderedCallback) {
            itemRenderedCallback(e);
          }
        }
      }
    };
    const userItems = null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.items;
    options2.toolbarOptions.items = this._normalizeToolbarItems(options2.toolbarOptions.items, userItems);
    this.executeAction("onToolbarPreparing", options2);
    if (options2.toolbarOptions && !isDefined(options2.toolbarOptions.visible)) {
      const toolbarItems = options2.toolbarOptions.items;
      options2.toolbarOptions.visible = !!(null !== toolbarItems && void 0 !== toolbarItems && toolbarItems.length);
    }
    return options2.toolbarOptions;
  }
  _normalizeToolbarItems(defaultItems, userItems) {
    defaultItems.forEach(((button) => {
      if (!DEFAULT_TOOLBAR_ITEM_NAMES.includes(button.name)) {
        throw new Error(`Default toolbar item '${button.name}' is not added to DEFAULT_TOOLBAR_ITEM_NAMES`);
      }
    }));
    const defaultProps = {
      location: "after"
    };
    const isArray2 = Array.isArray(userItems);
    if (!isDefined(userItems)) {
      return defaultItems;
    }
    if (!isArray2) {
      userItems = [userItems];
    }
    const defaultButtonsByNames = {};
    defaultItems.forEach(((button) => {
      defaultButtonsByNames[button.name] = button;
    }));
    const normalizedItems = userItems.map(((button) => {
      if (isString(button)) {
        button = {
          name: button
        };
      }
      if (isDefined(button.name)) {
        if (isDefined(defaultButtonsByNames[button.name])) {
          button = extend(true, {}, defaultButtonsByNames[button.name], button);
        } else if (DEFAULT_TOOLBAR_ITEM_NAMES.includes(button.name)) {
          button = _extends({}, button, {
            visible: false
          });
        }
      }
      return extend(true, {}, defaultProps, button);
    }));
    return isArray2 ? normalizedItems : normalizedItems[0];
  }
  _renderCore() {
    if (!this._toolbar) {
      const $headerPanel = this.element();
      $headerPanel.addClass(this.addWidgetPrefix("header-panel"));
      const label = message_default.format(this.component.NAME + "-ariaToolbar");
      const $toolbar = renderer_default("<div>").attr("aria-label", label).appendTo($headerPanel);
      this._toolbar = this._createComponent($toolbar, toolbar_default, this._toolbarOptions);
    } else {
      this._toolbar.option(this._toolbarOptions);
    }
  }
  _columnOptionChanged() {
  }
  _handleDataChanged() {
    if (this._requireReady) {
      this.render();
    }
  }
  _isDisabledDefinedByUser(name2) {
    var _this$option;
    const userItems = null === (_this$option = this.option("toolbar")) || void 0 === _this$option ? void 0 : _this$option.items;
    const userItem = null === userItems || void 0 === userItems ? void 0 : userItems.find(((item) => (null === item || void 0 === item ? void 0 : item.name) === name2));
    return isDefined(null === userItem || void 0 === userItem ? void 0 : userItem.disabled);
  }
  render() {
    this._toolbarOptions = this._getToolbarOptions();
    super.render.apply(this, arguments);
  }
  setToolbarItemDisabled(name2, disabled) {
    const toolbar = this._toolbar;
    const isDefinedByUser = this._isDisabledDefinedByUser(name2);
    if (!toolbar || isDefinedByUser) {
      return;
    }
    const items = toolbar.option("items") ?? [];
    const itemIndex = items.findIndex(((item2) => item2.name === name2));
    if (itemIndex < 0) {
      return;
    }
    const item = toolbar.option(`items[${itemIndex}]`);
    toolbar.option(`items[${itemIndex}].disabled`, disabled);
    if (item.options) {
      toolbar.option(`items[${itemIndex}].options.disabled`, disabled);
    }
  }
  updateToolbarDimensions() {
    var _this$_toolbar;
    null === (_this$_toolbar = this._toolbar) || void 0 === _this$_toolbar || _this$_toolbar.updateDimensions();
  }
  getHeaderPanel() {
    return this.element();
  }
  getHeight() {
    return this.getElementHeight();
  }
  optionChanged(args) {
    if ("onToolbarPreparing" === args.name) {
      this._invalidate();
      args.handled = true;
    }
    if ("toolbar" === args.name) {
      const parts = getPathParts(args.fullName);
      const optionName = args.fullName.replace(/^toolbar\./, "");
      if (1 === parts.length || "visible" === parts[1]) {
        this._invalidate();
      } else if ("items" === parts[1]) {
        if (2 === parts.length) {
          this._invalidate();
        } else if (3 === parts.length) {
          var _this$_toolbar2;
          const normalizedItem = this._normalizeToolbarItems(this._getToolbarItems(), args.value);
          null === (_this$_toolbar2 = this._toolbar) || void 0 === _this$_toolbar2 || _this$_toolbar2.option(optionName, normalizedItem);
        } else if (parts.length >= 4) {
          var _this$_toolbar3;
          null === (_this$_toolbar3 = this._toolbar) || void 0 === _this$_toolbar3 || _this$_toolbar3.option(optionName, args.value);
        }
      } else {
        var _this$_toolbar4;
        null === (_this$_toolbar4 = this._toolbar) || void 0 === _this$_toolbar4 || _this$_toolbar4.option(optionName, args.value);
      }
      args.handled = true;
    }
    super.optionChanged(args);
  }
  isVisible() {
    return !!(this._toolbarOptions && this._toolbarOptions.visible);
  }
  allowDragging() {
  }
  hasGroupedColumns() {
  }
};
var resizing = (Base) => class extends Base {
  _updateDimensionsCore() {
    super._updateDimensionsCore.apply(this, arguments);
    this.getView("headerPanel").updateToolbarDimensions();
  }
};
var headerPanelModule = {
  defaultOptions: () => ({}),
  views: {
    headerPanel: HeaderPanel
  },
  extenders: {
    controllers: {
      resizing
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_panel.js
var HeaderPanel2 = headerPanelModule.views.headerPanel;
m_core_default.registerModule("headerPanel", headerPanelModule);

// node_modules/devextreme/esm/ui/widget/ui.widget.js
var ui_widget_default = widget_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/m_widget_base.js
var GridCoreWidget = class extends ui_widget_default {
  _getDefaultOptions() {
    const result2 = super._getDefaultOptions();
    each(this.getGridCoreHelper().modules, (function() {
      if (isFunction(this.defaultOptions)) {
        extend(true, result2, this.defaultOptions());
      }
    }));
    return result2;
  }
  _init() {
    this._activeStateUnit = ".dx-row";
    super._init();
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      "columnChooser.allowSearch": {
        since: "23.1",
        message: 'Use the "columnChooser.search.enabled" option instead'
      },
      "columnChooser.searchTimeout": {
        since: "23.1",
        message: 'Use the "columnChooser.search.timeout" option instead'
      }
    });
  }
  _clean() {
  }
  _optionChanged(args) {
    this.getGridCoreHelper().callModuleItemsMethod(this, "optionChanged", [args]);
    if (!args.handled) {
      super._optionChanged(args);
    }
  }
  _dimensionChanged() {
    this.updateDimensions(true);
  }
  _visibilityChanged(visible) {
    if (visible) {
      this.updateDimensions();
    }
  }
  _renderContentImpl() {
    this.getView("gridView").update();
  }
  _renderContent() {
    const that = this;
    deferRender((() => {
      that._renderContentImpl();
    }));
  }
  _dispose() {
    super._dispose();
    this.getGridCoreHelper().callModuleItemsMethod(this, "dispose");
  }
  isReady() {
    return this.getController("data").isReady();
  }
  getController(name2) {
    return this._controllers[name2];
  }
  getView(name2) {
    return this._views[name2];
  }
  getGridCoreHelper() {
  }
  beginUpdate() {
    super.beginUpdate();
    this.getGridCoreHelper().callModuleItemsMethod(this, "beginUpdate");
  }
  endUpdate() {
    this.getGridCoreHelper().callModuleItemsMethod(this, "endUpdate");
    super.endUpdate();
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget_base.js
var DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the jQuery selector name is now deprecated. Use the DOM Node or the jQuery object that references this selector instead.";
m_core_default.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "grouping", "editing", "editingRowBased", "editingFormBased", "editingCellBased", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
var DataGrid = class extends GridCoreWidget {
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        showRowLines: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        showRowLines: true,
        showColumnLines: false,
        headerFilter: {
          height: 315
        },
        editing: {
          useIcons: true
        },
        selection: {
          showCheckBoxesMode: "always"
        }
      }
    }, {
      device: () => browser_default.webkit,
      options: {
        loadingTimeout: 30,
        loadPanel: {
          animation: {
            show: {
              easing: "cubic-bezier(1, 0, 1, 0)",
              duration: 500,
              from: {
                opacity: 0
              },
              to: {
                opacity: 1
              }
            }
          }
        }
      }
    }, {
      device: (device) => "desktop" !== device.deviceType,
      options: {
        grouping: {
          expandMode: "rowClick"
        }
      }
    }]);
  }
  _init() {
    super._init();
    m_utils_default.logHeaderFilterDeprecatedWarningIfNeed(this);
    m_core_default.processModules(this, m_core_default);
    m_core_default.callModuleItemsMethod(this, "init");
  }
  _initMarkup() {
    super._initMarkup.apply(this, arguments);
    this.getView("gridView").render(this.$element());
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      useKeyboard: {
        since: "19.2",
        alias: "keyboardNavigation.enabled"
      },
      rowTemplate: {
        since: "21.2",
        message: 'Use the "dataRowTemplate" option instead'
      }
    });
  }
  static registerModule(name2, module) {
    m_core_default.registerModule(name2, module);
  }
  getGridCoreHelper() {
    return m_core_default;
  }
  _getTemplate(templateName) {
    let template = templateName;
    if (isString(template) && template.startsWith("#")) {
      template = renderer_default(templateName);
      logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING);
    }
    return super._getTemplate(template);
  }
  focus(element) {
    this.getController("keyboardNavigation").focus(element);
  }
};
component_registrator_default("dxDataGrid", DataGrid);
var m_widget_base_default = DataGrid;

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing_core.js
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function(state) {
  if (!state) {
    return;
  }
  each(state, ((key, value2) => {
    if (isPlainObject(value2) || Array.isArray(value2)) {
      parseDates(value2);
    } else if ("string" === typeof value2) {
      const date = DATE_REGEX.exec(value2);
      if (date) {
        state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]));
      }
    }
  }));
};
var getStorage = function(options2) {
  const storage = "sessionStorage" === options2.type ? getSessionStorage() : getWindow().localStorage;
  if (!storage) {
    throw new Error("E1007");
  }
  return storage;
};
var getUniqueStorageKey = function(options2) {
  return isDefined(options2.storageKey) ? options2.storageKey : "storage";
};
var StateStoringController = class extends m_modules_default.ViewController {
  getDataController() {
    return this.getController("data");
  }
  getExportController() {
    return this.getController("export");
  }
  getColumnsController() {
    return this.getController("columns");
  }
  init() {
    this._state = {};
    this._isLoaded = false;
    this._isLoading = false;
    this._windowUnloadHandler = () => {
      if (void 0 !== this._savingTimeoutID) {
        this._saveState(this.state());
      }
    };
    m_events_engine_default.on(getWindow(), "visibilitychange", this._windowUnloadHandler);
    return this;
  }
  optionChanged(args) {
    const that = this;
    if ("stateStoring" === args.name) {
      if (that.isEnabled() && !that.isLoading()) {
        that.load();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  dispose() {
    clearTimeout(this._savingTimeoutID);
    m_events_engine_default.off(getWindow(), "visibilitychange", this._windowUnloadHandler);
  }
  _loadState() {
    const options2 = this.option("stateStoring");
    if ("custom" === options2.type) {
      return options2.customLoad && options2.customLoad();
    }
    try {
      return JSON.parse(getStorage(options2).getItem(getUniqueStorageKey(options2)));
    } catch (e) {
      ui_errors_default.log("W1022", "State storing", e.message);
    }
  }
  _saveState(state) {
    const options2 = this.option("stateStoring");
    if ("custom" === options2.type) {
      options2.customSave && options2.customSave(state);
      return;
    }
    try {
      getStorage(options2).setItem(getUniqueStorageKey(options2), JSON.stringify(state));
    } catch (e) {
      ui_errors_default.log(e.message);
    }
  }
  publicMethods() {
    return ["state"];
  }
  isEnabled() {
    return this.option("stateStoring.enabled");
  }
  isLoaded() {
    return this._isLoaded;
  }
  isLoading() {
    return this._isLoading;
  }
  load() {
    this._isLoading = true;
    const loadResult = fromPromise(this._loadState());
    loadResult.always((() => {
      this._isLoaded = true;
      this._isLoading = false;
    })).done(((state) => {
      if (null !== state && !isEmptyObject(state)) {
        this.state(state);
      }
    }));
    return loadResult;
  }
  state(state) {
    const that = this;
    if (!arguments.length) {
      return extend(true, {}, that._state);
    }
    that._state = extend({}, state);
    parseDates(that._state);
  }
  save() {
    const that = this;
    clearTimeout(that._savingTimeoutID);
    that._savingTimeoutID = setTimeout((() => {
      that._saveState(that.state());
      that._savingTimeoutID = void 0;
    }), that.option("stateStoring.savingTimeout"));
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing.js
var getDataState = (that) => {
  const pagerView = that.getView("pagerView");
  const dataController2 = that.getController("data");
  const state = {
    allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0,
    filterPanel: {
      filterEnabled: that.option("filterPanel.filterEnabled")
    },
    filterValue: that.option("filterValue"),
    focusedRowKey: that.option("focusedRowEnabled") ? that.option("focusedRowKey") : void 0
  };
  return extend(state, dataController2.getUserState());
};
var processLoadState = (that) => {
  const columnsController = that.getController("columns");
  const selectionController = that.getController("selection");
  const exportController = that.getController("export");
  const dataController2 = that.getController("data");
  if (columnsController) {
    columnsController.columnsChanged.add((() => {
      that.updateState({
        columns: columnsController.getUserState()
      });
    }));
  }
  if (selectionController) {
    selectionController.selectionChanged.add(((e) => {
      that.updateState({
        selectedRowKeys: e.selectedRowKeys,
        selectionFilter: e.selectionFilter
      });
    }));
  }
  if (dataController2) {
    that._initialPageSize = that.option("paging.pageSize");
    that._initialFilterValue = that.option("filterValue");
    dataController2.changed.add((() => {
      const state = getDataState(that);
      that.updateState(state);
    }));
  }
  if (exportController) {
    exportController.selectionOnlyChanged.add((() => {
      that.updateState({
        exportSelectionOnly: exportController.selectionOnly()
      });
    }));
  }
};
var getFilterValue = (that, state) => {
  var _filterSyncController;
  const filterSyncController = that.getController("filterSync");
  if (!filterSyncController) {
    return null;
  }
  if (void 0 !== state.filterValue) {
    return state.filterValue;
  }
  const filterValueFromColumns = null === (_filterSyncController = filterSyncController.getFilterValueFromColumns) || void 0 === _filterSyncController ? void 0 : _filterSyncController.call(filterSyncController, state.columns);
  if ((null === filterValueFromColumns || void 0 === filterValueFromColumns ? void 0 : filterValueFromColumns.length) > 0) {
    return filterValueFromColumns;
  }
  const columns7 = that.getController("columns").getColumns();
  return that._initialFilterValue ?? filterSyncController.getFilterValueFromColumns(columns7);
};
var rowsView = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController.stateLoaded.add((() => {
      if (this._dataController.isLoaded() && !this._dataController.getDataSource()) {
        this.setLoading(false);
        this.renderNoDataText();
        const columnHeadersView9 = this.component.getView("columnHeadersView");
        columnHeadersView9 && columnHeadersView9.render();
        this.component._fireContentReadyAction();
      }
    }));
  }
};
var stateStoring = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    processLoadState(this);
    return this;
  }
  isLoading() {
    return super.isLoading() || this.getDataController().isStateLoading();
  }
  state(state) {
    const result2 = super.state.apply(this, arguments);
    if (void 0 !== state) {
      this.applyState(extend(true, {}, state));
    }
    return result2;
  }
  updateState(state) {
    if (this.isEnabled()) {
      const oldState = this.state();
      const newState = extend({}, oldState, state);
      const oldStateHash = getKeyHash(oldState);
      const newStateHash = getKeyHash(newState);
      if (!equalByValue(oldStateHash, newStateHash)) {
        state = extend(true, {}, state);
        extend(this._state, state);
        this.save();
      }
    } else {
      extend(this._state, state);
    }
  }
  applyState(state) {
    var _this$getView;
    const {
      allowedPageSizes
    } = state;
    const {
      searchText
    } = state;
    const {
      selectedRowKeys
    } = state;
    const {
      selectionFilter
    } = state;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrollingMode = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const showPageSizeSelector = true === this.option("pager.visible") && this.option("pager.showPageSizeSelector");
    const hasHeight = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.hasHeight();
    this.component.beginUpdate();
    if (this.getColumnsController()) {
      this.getColumnsController().setUserState(state.columns);
    }
    if (this.getExportController()) {
      this.getExportController().selectionOnly(state.exportSelectionOnly);
    }
    if (!this.option("selection.deferred")) {
      this.option("selectedRowKeys", selectedRowKeys || []);
    }
    this.option("selectionFilter", selectionFilter);
    if (allowedPageSizes && "auto" === this.option("pager.allowedPageSizes")) {
      this.option("pager").allowedPageSizes = allowedPageSizes;
    }
    if (this.option("focusedRowEnabled")) {
      this.option("focusedRowIndex", -1);
      this.option("focusedRowKey", state.focusedRowKey ?? null);
    }
    this.component.endUpdate();
    this.option("searchPanel.text", searchText || "");
    this.option("filterValue", getFilterValue(this, state));
    this.option("filterPanel.filterEnabled", state.filterPanel ? state.filterPanel.filterEnabled : true);
    this.option("paging.pageIndex", (!isVirtualScrollingMode || hasHeight) && state.pageIndex || 0);
    this.option("paging.pageSize", (!isVirtualScrollingMode || showPageSizeSelector) && isDefined(state.pageSize) ? state.pageSize : this._initialPageSize);
    this.getDataController() && this.getDataController().reset();
  }
};
var columns = (Base) => class extends Base {
  _shouldReturnVisibleColumns() {
    const result2 = super._shouldReturnVisibleColumns.apply(this, arguments);
    return result2 && (!this._stateStoringController.isEnabled() || this._stateStoringController.isLoaded());
  }
};
var data3 = (Base) => class extends Base {
  dispose() {
    clearTimeout(this._restoreStateTimeoutID);
    super.dispose();
  }
  callbackNames() {
    return super.callbackNames().concat(["stateLoaded"]);
  }
  _refreshDataSource() {
    if (this._stateStoringController.isEnabled() && !this._stateStoringController.isLoaded()) {
      clearTimeout(this._restoreStateTimeoutID);
      const deferred = new Deferred();
      this._restoreStateTimeoutID = setTimeout((() => {
        this._stateStoringController.load().always((() => {
          this._restoreStateTimeoutID = null;
        })).done((() => {
          super._refreshDataSource();
          this.stateLoaded.fire();
          deferred.resolve();
        })).fail(((error) => {
          this.stateLoaded.fire();
          this._handleLoadError(error || "Unknown error");
          deferred.reject();
        }));
      }));
      return deferred.promise();
    }
    if (!this.isStateLoading()) {
      super._refreshDataSource();
    }
  }
  isLoading() {
    return super.isLoading() || this._stateStoringController.isLoading();
  }
  isStateLoading() {
    return isDefined(this._restoreStateTimeoutID);
  }
  isLoaded() {
    return super.isLoaded() && !this.isStateLoading();
  }
};
var selection = (Base) => class extends Base {
  _fireSelectionChanged(options2) {
    const isDeferredSelection = this.option("selection.deferred");
    if (this._stateStoringController.isLoading() && isDeferredSelection) {
      return;
    }
    super._fireSelectionChanged.apply(this, arguments);
  }
};
var stateStoringModule = {
  defaultOptions: () => ({
    stateStoring: {
      enabled: false,
      storageKey: null,
      type: "localStorage",
      customLoad: null,
      customSave: null,
      savingTimeout: 2e3
    }
  }),
  controllers: {
    stateStoring: StateStoringController
  },
  extenders: {
    views: {
      rowsView
    },
    controllers: {
      stateStoring,
      columns,
      data: data3,
      selection
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/state_storing.js
m_core_default.registerModule("stateStoring", stateStoringModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/selection/m_selection.js
var CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden";
var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
var SELECTION_MODE = "selection.mode";
var processLongTap = function(that, dxEvent) {
  const rowsView18 = that.getView("rowsView");
  const selectionController = that.getController("selection");
  const $row = renderer_default(dxEvent.target).closest(".dx-data-row");
  const rowIndex = rowsView18.getRowIndex($row);
  if (rowIndex < 0) {
    return;
  }
  if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
    if (selectionController.isSelectionWithCheckboxes()) {
      selectionController.stopSelectionWithCheckboxes();
    } else {
      selectionController.startSelectionWithCheckboxes();
    }
  } else {
    if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.startSelectionWithCheckboxes();
    }
    if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.changeItemSelection(rowIndex, {
        control: true
      });
    }
  }
};
var isSeveralRowsSelected = function(that, selectionFilter) {
  let keyIndex = 0;
  const store = that._dataController.store();
  const key = store && store.key();
  const isComplexKey = Array.isArray(key);
  if (!selectionFilter.length) {
    return false;
  }
  if (isComplexKey && Array.isArray(selectionFilter[0]) && "and" === selectionFilter[1]) {
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i])) {
        if (selectionFilter[i][0] !== key[keyIndex] || "=" !== selectionFilter[i][1]) {
          return true;
        }
        keyIndex++;
      }
    }
    return false;
  }
  return key !== selectionFilter[0];
};
var selectionCellTemplate = (container, options2) => {
  const {
    component
  } = options2;
  const rowsView18 = component.getView("rowsView");
  if (component.option("renderAsync") && !component.option("selection.deferred")) {
    options2.value = component.isRowSelected(options2.row.key);
  }
  rowsView18.renderSelectCheckBoxContainer(renderer_default(container), options2);
};
var selectionHeaderTemplate = (container, options2) => {
  const {
    column
  } = options2;
  const $cellElement = renderer_default(container);
  const columnHeadersView9 = options2.component.getView("columnHeadersView");
  $cellElement.addClass("dx-editor-cell");
  columnHeadersView9._renderSelectAllCheckBox($cellElement, column);
  columnHeadersView9._attachSelectAllCheckBoxClickEvent($cellElement);
};
var SelectionController = class extends m_modules_default.Controller {
  init() {
    const {
      deferred,
      selectAllMode,
      mode
    } = this.option("selection") ?? {};
    if ("infinite" === this.option("scrolling.mode") && !deferred && "multiple" === mode && "allPages" === selectAllMode) {
      ui_errors_default.log("W1018");
    }
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._stateStoringController = this.getController("stateStoring");
    this._selectionMode = mode;
    this._isSelectionWithCheckboxes = false;
    this._selection = this._createSelection();
    this._updateSelectColumn();
    this.createAction("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    if (!this._dataPushedHandler) {
      this._dataPushedHandler = this._handleDataPushed.bind(this);
      this._dataController.pushed.add(this._dataPushedHandler);
    }
  }
  _handleDataPushed(changes) {
    this._deselectRemovedOnPush(changes);
    this._updateSelectedOnPush(changes);
  }
  _deselectRemovedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    let removedKeys = changes.filter(((change) => "remove" === change.type)).map(((change) => change.key));
    if (isDeferredSelection) {
      const selectedKeys = this._dataController.items().filter(((item) => item.isSelected)).map(((item) => item.key));
      removedKeys = removedKeys.filter(((key) => selectedKeys.find(((selectedKey) => equalByValue(selectedKey, key)))));
    }
    removedKeys.length && this.deselectRows(removedKeys);
  }
  _updateSelectedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    if (isDeferredSelection) {
      return;
    }
    const updateChanges = changes.filter(((change) => "update" === change.type));
    const data17 = this.getSelectedRowsData();
    applyBatch({
      keyInfo: this._selection.options,
      data: data17,
      changes: updateChanges
    });
  }
  _getSelectionConfig() {
    const dataController2 = this._dataController;
    const columnsController = this._columnsController;
    const selectionOptions = this.option("selection") ?? {};
    const {
      deferred
    } = selectionOptions;
    const scrollingMode = this.option("scrolling.mode");
    const virtualPaging = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const allowSelectAll = this.option("selection.allowSelectAll");
    const legacyScrollingMode = this.option("scrolling.legacyMode");
    return {
      selectedKeys: this.option("selectedRowKeys"),
      mode: this._selectionMode,
      deferred,
      alwaysSelectByShift: selectionOptions.alwaysSelectByShift,
      maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
      selectionFilter: this.option("selectionFilter"),
      ignoreDisabledItems: true,
      isVirtualPaging: virtualPaging,
      sensitivity: this.option("selection.sensitivity"),
      allowLoadByRange() {
        const hasGroupColumns = columnsController.getGroupColumns().length > 0;
        return virtualPaging && !legacyScrollingMode && !hasGroupColumns && allowSelectAll && !deferred;
      },
      key: () => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.key(),
      keyOf: (item) => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.keyOf(item),
      dataFields() {
        var _dataController$dataS;
        return null === (_dataController$dataS = dataController2.dataSource()) || void 0 === _dataController$dataS ? void 0 : _dataController$dataS.select();
      },
      load(options2) {
        var _dataController$dataS2;
        return (null === (_dataController$dataS2 = dataController2.dataSource()) || void 0 === _dataController$dataS2 ? void 0 : _dataController$dataS2.load(options2)) || new Deferred().resolve([]);
      },
      plainItems: (cached) => dataController2.items(true),
      isItemSelected: (item) => item.selected,
      isSelectableItem: (item) => "data" === (null === item || void 0 === item ? void 0 : item.rowType) && !item.isNewRow,
      getItemData: (item) => isDefined(null === item || void 0 === item ? void 0 : item.rowType) ? (null === item || void 0 === item ? void 0 : item.oldData) || (null === item || void 0 === item ? void 0 : item.data) : item,
      filter: () => dataController2.getCombinedFilter(deferred),
      totalCount: () => dataController2.totalCount(),
      getLoadOptions(loadItemIndex, focusedItemIndex, shiftItemIndex) {
        var _dataController$dataS3;
        const {
          sort,
          filter
        } = (null === (_dataController$dataS3 = dataController2.dataSource()) || void 0 === _dataController$dataS3 ? void 0 : _dataController$dataS3.lastLoadOptions()) ?? {};
        let minIndex = Math.min(loadItemIndex, focusedItemIndex);
        let maxIndex = Math.max(loadItemIndex, focusedItemIndex);
        if (isDefined(shiftItemIndex)) {
          minIndex = Math.min(shiftItemIndex, minIndex);
          maxIndex = Math.max(shiftItemIndex, maxIndex);
        }
        const take = maxIndex - minIndex + 1;
        return {
          skip: minIndex,
          take,
          filter,
          sort
        };
      },
      onSelectionChanged: this._updateSelectedItems.bind(this)
    };
  }
  _updateSelectColumn() {
    const columnsController = this._columnsController;
    const isSelectColumnVisible = this.isSelectColumnVisible();
    columnsController.addCommandColumn({
      type: "selection",
      command: "select",
      visible: isSelectColumnVisible,
      visibleIndex: -1,
      dataType: "boolean",
      alignment: "center",
      cssClass: "dx-command-select",
      width: "auto",
      cellTemplate: selectionCellTemplate,
      headerCellTemplate: selectionHeaderTemplate
    });
    columnsController.columnOption("command:select", "visible", isSelectColumnVisible);
  }
  _createSelection() {
    const options2 = this._getSelectionConfig();
    return new Selection(options2);
  }
  _fireSelectionChanged(options2) {
    const argument = this.option("selection.deferred") ? {
      selectionFilter: this.option("selectionFilter")
    } : {
      selectedRowKeys: this.option("selectedRowKeys")
    };
    this.selectionChanged.fire(argument);
    if (options2) {
      this.executeAction("onSelectionChanged", options2);
    }
  }
  _updateCheckboxesState(options2) {
    const {
      isDeferredMode
    } = options2;
    const {
      selectionFilter
    } = options2;
    const {
      selectedItemKeys
    } = options2;
    const {
      removedItemKeys
    } = options2;
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      if (isDeferredMode ? selectionFilter && isSeveralRowsSelected(this, selectionFilter) : selectedItemKeys.length > 1) {
        this.startSelectionWithCheckboxes();
      } else if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
        this.stopSelectionWithCheckboxes();
      }
    }
  }
  _updateSelectedItems(args) {
    const that = this;
    let selectionChangedOptions;
    const isDeferredMode = that.option("selection.deferred");
    const selectionFilter = that._selection.selectionFilter();
    const dataController2 = that._dataController;
    const items = dataController2.items(true);
    const visibleItems = dataController2.items();
    if (!items) {
      return;
    }
    const isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
    const changedItemIndexes = that.getChangedItemIndexes(items);
    const visibleChangedItemIndexes = that.getChangedItemIndexes(visibleItems);
    that._updateCheckboxesState({
      selectedItemKeys: args.selectedItemKeys,
      removedItemKeys: args.removedItemKeys,
      selectionFilter,
      isDeferredMode
    });
    if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
      dataController2.updateItems({
        changeType: "updateSelection",
        itemIndexes: visibleChangedItemIndexes
      });
    }
    if (isDeferredMode) {
      that.option("selectionFilter", selectionFilter);
      selectionChangedOptions = {};
    } else if (args.addedItemKeys.length || args.removedItemKeys.length) {
      that._selectedItemsInternalChange = true;
      that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
      that._selectedItemsInternalChange = false;
      selectionChangedOptions = {
        selectedRowsData: args.selectedItems.slice(0),
        selectedRowKeys: args.selectedItemKeys.slice(0),
        currentSelectedRowKeys: args.addedItemKeys.slice(0),
        currentDeselectedRowKeys: args.removedItemKeys.slice(0)
      };
    }
    that._fireSelectionChanged(selectionChangedOptions);
  }
  getChangedItemIndexes(items) {
    const that = this;
    const itemIndexes = [];
    const isDeferredSelection = this.option("selection.deferred");
    for (let i = 0, {
      length
    } = items; i < length; i++) {
      const row = items[i];
      const isItemSelected = that.isRowSelected(isDeferredSelection ? row.data : row.key);
      if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
        itemIndexes.push(i);
      }
    }
    return itemIndexes;
  }
  callbackNames() {
    return ["selectionChanged"];
  }
  optionChanged(args) {
    var _this$_selection;
    super.optionChanged(args);
    const selectionOptionsExists = !!(null !== (_this$_selection = this._selection) && void 0 !== _this$_selection && _this$_selection.options);
    switch (args.name) {
      case "selection": {
        const oldSelectionMode = this._selectionMode;
        this.init();
        if (selectionOptionsExists && "selection.sensitivity" === args.fullName) {
          this._selection.options.sensitivity = args.value;
        }
        if ("selection.showCheckBoxesMode" !== args.fullName) {
          const selectionMode = this._selectionMode;
          let selectedRowKeys = this.option("selectedRowKeys");
          if (oldSelectionMode !== selectionMode) {
            if ("single" === selectionMode) {
              if (selectedRowKeys.length > 1) {
                selectedRowKeys = [selectedRowKeys[0]];
              }
            } else if ("multiple" !== selectionMode) {
              selectedRowKeys = [];
            }
          }
          this.selectRows(selectedRowKeys).always((() => {
            this._fireSelectionChanged();
          }));
        }
        this._columnsController.updateColumns();
        args.handled = true;
        break;
      }
      case "selectionFilter":
        this._selection.selectionFilter(args.value);
        args.handled = true;
        break;
      case "selectedRowKeys": {
        const value2 = args.value || [];
        if (Array.isArray(value2) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !value2.length)) {
          this.selectRows(value2);
        }
        args.handled = true;
        break;
      }
    }
  }
  publicMethods() {
    return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"];
  }
  isRowSelected(arg) {
    return this._selection.isItemSelected(arg);
  }
  isSelectColumnVisible() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  _isOnePageSelectAll() {
    return "page" === this.option("selection.selectAllMode");
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isOnePageSelectAll());
  }
  selectAll() {
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      this.startSelectionWithCheckboxes();
    }
    return this._selection.selectAll(this._isOnePageSelectAll());
  }
  deselectAll() {
    return this._selection.deselectAll(this._isOnePageSelectAll());
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  refresh() {
    const selectedRowKeys = this.option("selectedRowKeys") ?? [];
    if (!this.option("selection.deferred") && selectedRowKeys.length) {
      return this.selectedItemKeys(selectedRowKeys);
    }
    return new Deferred().resolve().promise();
  }
  selectedItemKeys(value2, preserve, isDeselect, isSelectAll) {
    return this._selection.selectedItemKeys(value2, preserve, isDeselect, isSelectAll);
  }
  getSelectedRowKeys(mode) {
    return this._selection.getSelectedItemKeys();
  }
  selectRows(keys, preserve) {
    return this.selectedItemKeys(keys, preserve);
  }
  deselectRows(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectRowsByIndexes(indexes) {
    const items = this._dataController.items();
    const keys = [];
    if (!Array.isArray(indexes)) {
      indexes = Array.prototype.slice.call(arguments, 0);
    }
    each(indexes, (function() {
      const item = items[this];
      if (item && "data" === item.rowType) {
        keys.push(item.key);
      }
    }));
    return this.selectRows(keys);
  }
  getSelectedRowsData(mode) {
    return this._selection.getSelectedItems();
  }
  loadSelectedItemsWithFilter() {
    return this._selection.loadSelectedItemsWithFilter();
  }
  changeItemSelection(visibleItemIndex, keys, setFocusOnly) {
    keys = keys || {};
    if (this.isSelectionWithCheckboxes()) {
      keys.control = true;
    }
    const loadedItemIndex = visibleItemIndex + this._dataController.getRowIndexOffset() - this._dataController.getRowIndexOffset(true);
    return this._selection.changeItemSelection(loadedItemIndex, keys, setFocusOnly);
  }
  focusedItemIndex(itemIndex) {
    const that = this;
    if (isDefined(itemIndex)) {
      that._selection._focusedItemIndex = itemIndex;
    } else {
      return that._selection._focusedItemIndex;
    }
    return;
  }
  isSelectionWithCheckboxes() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  startSelectionWithCheckboxes() {
    const that = this;
    if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
      that._isSelectionWithCheckboxes = true;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
  stopSelectionWithCheckboxes() {
    const that = this;
    if (that._isSelectionWithCheckboxes) {
      that._isSelectionWithCheckboxes = false;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
};
var dataSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    const isDeferredMode = this.option("selection.deferred");
    super.init.apply(this, arguments);
    if (isDeferredMode) {
      this._selectionController._updateCheckboxesState({
        isDeferredMode: true,
        selectionFilter: this.option("selectionFilter")
      });
    }
  }
  _loadDataSource() {
    const that = this;
    return super._loadDataSource().always((() => {
      that._selectionController.refresh();
    }));
  }
  _processDataItem(item, options2) {
    const hasSelectColumn = this._selectionController.isSelectColumnVisible();
    const isDeferredSelection = options2.isDeferredSelection = void 0 === options2.isDeferredSelection ? this.option("selection.deferred") : options2.isDeferredSelection;
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isSelected = this._selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
    if (hasSelectColumn && dataItem.values) {
      for (let i = 0; i < options2.visibleColumns.length; i++) {
        if ("select" === options2.visibleColumns[i].command) {
          dataItem.values[i] = dataItem.isSelected;
          break;
        }
      }
    }
    return dataItem;
  }
  refresh(options2) {
    const d = new Deferred();
    super.refresh(options2).done((() => {
      const skipSelectionRefresh = isObject(options2) && !options2.selection;
      if (skipSelectionRefresh) {
        d.resolve();
        return;
      }
      this._selectionController.refresh().done(d.resolve).fail(d.reject);
    })).fail(d.reject);
    return d.promise();
  }
  _handleDataChanged(e) {
    const hasLoadOperation = this.hasLoadOperation();
    super._handleDataChanged.apply(this, arguments);
    if (hasLoadOperation && !this._repaintChangesOnly) {
      this._selectionController.focusedItemIndex(-1);
    }
  }
  _applyChange(change) {
    if (change && "updateSelection" === change.changeType) {
      change.items.forEach(((item, index) => {
        const currentItem = this._items[index];
        if (currentItem) {
          currentItem.isSelected = item.isSelected;
          currentItem.values = item.values;
        }
      }));
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _endUpdateCore() {
    const changes = this._changes;
    const isUpdateSelection = changes.length > 1 && changes.every(((change) => "updateSelection" === change.changeType));
    if (isUpdateSelection) {
      const itemIndexes = changes.map(((change) => change.itemIndexes || [])).reduce(((a, b) => a.concat(b)));
      this._changes = [{
        changeType: "updateSelection",
        itemIndexes
      }];
    }
    super._endUpdateCore.apply(this, arguments);
  }
};
var contextMenu = (Base) => class extends Base {
  _contextMenuPrepared(options2) {
    const dxEvent = options2.event;
    if (dxEvent.originalEvent && "dxhold" !== dxEvent.originalEvent.type || options2.items && options2.items.length > 0) {
      return;
    }
    processLongTap(this, dxEvent);
  }
};
var columnHeadersSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    super.init();
    this._selectionController.selectionChanged.add(this._updateSelectAllValue.bind(this));
  }
  _isSelectAllCheckBoxVisible() {
    const isEmptyData = this._dataController.isEmpty();
    const allowSelectAll = this.option("selection.allowSelectAll");
    const isSelectAll = this._selectionController.isSelectAll();
    return !isEmptyData && (allowSelectAll || false !== isSelectAll);
  }
  _updateSelectAllValue() {
    const $element = this.element();
    const $editor = $element && $element.find(".dx-select-checkbox");
    if ($element && $editor.length && "multiple" === this.option("selection.mode")) {
      const selectAllValue = this._selectionController.isSelectAll();
      const isVisible = this._isSelectAllCheckBoxVisible();
      $editor.dxCheckBox("instance").option({
        visible: isVisible,
        value: selectAllValue
      });
    }
  }
  _handleDataChanged(e) {
    super._handleDataChanged(e);
    if (!e || "refresh" === e.changeType || e.repaintChangesOnly && "update" === e.changeType) {
      this.waitAsyncTemplates().done((() => {
        this._updateSelectAllValue();
      }));
    }
  }
  _renderSelectAllCheckBox($container, column) {
    const $checkbox = this._createSelectAllCheckboxElement(column);
    $checkbox.appendTo($container);
    return $checkbox;
  }
  _createSelectAllCheckboxElement(column) {
    const $groupElement = renderer_default("<div>").addClass("dx-select-checkbox");
    this.setAria("label", message_default.format("dxDataGrid-ariaSelectAll"), $groupElement);
    this._editorFactoryController.createEditor($groupElement, extend({}, column, {
      parentType: "headerRow",
      dataType: "boolean",
      value: this._selectionController.isSelectAll(),
      editorOptions: {
        visible: this._isSelectAllCheckBoxVisible()
      },
      tabIndex: this.option("useLegacyKeyboardNavigation") ? -1 : this.option("tabIndex") || 0,
      setValue: (value2, e) => {
        const allowSelectAll = this.option("selection.allowSelectAll");
        e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
        if (!e.event || this._selectionController.isSelectAll() === value2) {
          return;
        }
        if (e.value && !allowSelectAll) {
          e.component.option("value", false);
        } else {
          e.value ? this._selectionController.selectAll() : this._selectionController.deselectAll();
        }
        e.event.preventDefault();
      }
    }));
    return $groupElement;
  }
  _attachSelectAllCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction(((e) => {
      const {
        event
      } = e;
      if (!this._isSelectAllCheckBoxVisible()) {
        event.preventDefault();
        return;
      }
      if (!renderer_default(event.target).closest(".dx-select-checkbox").length) {
        m_events_engine_default.trigger(renderer_default(event.currentTarget).children(".dx-select-checkbox"), CLICK_EVENT_NAME);
      }
      event.preventDefault();
    })));
  }
};
var rowsViewSelectionExtenderMixin = (Base) => class extends Base {
  renderSelectCheckBoxContainer($container, options2) {
    if ("data" === options2.rowType && !options2.row.isNewRow) {
      $container.addClass("dx-editor-cell");
      this._attachCheckBoxClickEvent($container);
      this._renderSelectCheckBox($container, options2);
    } else {
      m_utils_default.setEmptyText($container);
    }
  }
  _renderSelectCheckBox(container, options2) {
    const groupElement = renderer_default("<div>").addClass("dx-select-checkbox").appendTo(container);
    this.setAria("label", message_default.format("dxDataGrid-ariaSelectRow"), groupElement);
    this._editorFactoryController.createEditor(groupElement, extend({}, options2.column, {
      parentType: "dataRow",
      dataType: "boolean",
      lookup: null,
      value: options2.value,
      setValue(value2, e) {
        var _e$event;
        if ("keydown" === (null === e || void 0 === e || null === (_e$event = e.event) || void 0 === _e$event ? void 0 : _e$event.type)) {
          m_events_engine_default.trigger(e.element, CLICK_EVENT_NAME, e);
        }
      },
      row: options2.row
    }));
    return groupElement;
  }
  _attachCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction((function(e) {
      const {
        event
      } = e;
      const rowIndex = this.getRowIndex(renderer_default(event.currentTarget).closest(".dx-row"));
      if (rowIndex >= 0) {
        this._selectionController.startSelectionWithCheckboxes();
        this._selectionController.changeItemSelection(rowIndex, {
          shift: event.shiftKey
        });
        if (renderer_default(event.target).closest(".dx-select-checkbox").length) {
          this._dataController.updateItems({
            changeType: "updateSelection",
            itemIndexes: [rowIndex]
          });
        }
      }
    })));
  }
  _update(change) {
    const that = this;
    const tableElements = that.getTableElements();
    if ("updateSelection" === change.changeType) {
      if (tableElements.length > 0) {
        each(tableElements, ((_, tableElement) => {
          each(change.itemIndexes || [], ((_2, index) => {
            let $row;
            if (change.items[index]) {
              $row = that._getRowElements(renderer_default(tableElement)).eq(index);
              if ($row.length) {
                const {
                  isSelected
                } = change.items[index];
                $row.toggleClass("dx-selection", void 0 === isSelected ? false : isSelected).find(".dx-select-checkbox").dxCheckBox("option", "value", isSelected);
                that.setAria("selected", isSelected, $row);
              }
            }
          }));
        }));
        that._updateCheckboxesClass();
      }
    } else {
      super._update(change);
    }
  }
  _createTable() {
    const that = this;
    const selectionMode = that.option("selection.mode");
    const $table = super._createTable.apply(that, arguments);
    if ("none" !== selectionMode) {
      if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !m_support_default.touch) {
        m_events_engine_default.on($table, addNamespace(m_hold_default.name, "dxDataGridRowsView"), ".dx-data-row", that.createAction(((e) => {
          processLongTap(that.component, e.event);
          e.event.stopPropagation();
        })));
      }
      m_events_engine_default.on($table, "mousedown selectstart", that.createAction(((e) => {
        const {
          event
        } = e;
        if (event.shiftKey) {
          event.preventDefault();
        }
      })));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const {
        isSelected
      } = row;
      if (isSelected) {
        $row.addClass("dx-selection");
      }
      const selectionMode = this.option(SELECTION_MODE);
      if ("none" !== selectionMode) {
        this.setAria("selected", isSelected, $row);
      }
    }
    return $row;
  }
  _rowClickForTreeList(e) {
    super._rowClick(e);
  }
  _rowClick(e) {
    const that = this;
    const dxEvent = e.event;
    const isSelectionDisabled = renderer_default(dxEvent.target).closest(".dx-selection-disabled").length;
    if (!that.isClickableElement(renderer_default(dxEvent.target))) {
      if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
        if (that._selectionController.changeItemSelection(e.rowIndex, {
          control: isCommandKeyPressed(dxEvent),
          shift: dxEvent.shiftKey
        })) {
          dxEvent.preventDefault();
          e.handled = true;
        }
      }
      super._rowClick(e);
    }
  }
  isClickableElement($target) {
    const isCommandSelect = $target.closest(".dx-command-select").length;
    return !!isCommandSelect;
  }
  _renderCore(change) {
    const deferred = super._renderCore(change);
    this._updateCheckboxesClass();
    return deferred;
  }
  _updateCheckboxesClass() {
    const tableElements = this.getTableElements();
    const isCheckBoxesHidden = this._selectionController.isSelectColumnVisible() && !this._selectionController.isSelectionWithCheckboxes();
    each(tableElements, ((_, tableElement) => {
      renderer_default(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden);
    }));
  }
};
var selectionModule = {
  defaultOptions: () => ({
    selection: {
      mode: "none",
      showCheckBoxesMode: "onClick",
      allowSelectAll: true,
      selectAllMode: "allPages",
      deferred: false,
      maxFilterLengthInRequest: 1500,
      alwaysSelectByShift: false
    },
    selectionFilter: [],
    selectedRowKeys: []
  }),
  controllers: {
    selection: SelectionController
  },
  extenders: {
    controllers: {
      data: dataSelectionExtenderMixin,
      contextMenu
    },
    views: {
      columnHeadersView: columnHeadersSelectionExtenderMixin,
      rowsView: rowsViewSelectionExtenderMixin
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/selection.js
m_core_default.registerModule("selection", selectionModule);

// node_modules/devextreme/esm/__internal/ui/check_box/check_box_icon.js
var _excluded4 = ["size"];
var defaultCheckBoxIconProps = {};
var CheckBoxIcon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.elementRef = createRef();
    this.__getterCache = {};
  }
  get cssStyles() {
    if (void 0 !== this.__getterCache.cssStyles) {
      return this.__getterCache.cssStyles;
    }
    return this.__getterCache.cssStyles = (() => {
      const {
        size
      } = this.props;
      const fontSize = normalizeStyleProp("fontSize", size);
      return {
        fontSize
      };
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded4);
    return restProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.size !== nextProps.size) {
      this.__getterCache.cssStyles = void 0;
    }
  }
  render() {
    const {
      elementRef,
      cssStyles
    } = this;
    return createVNode(1, "span", "dx-checkbox-icon", null, 1, {
      style: normalizeStyles(cssStyles)
    }, null, elementRef);
  }
};
CheckBoxIcon.defaultProps = defaultCheckBoxIconProps;

// node_modules/devextreme/esm/__internal/core/r1/utils/get_updated_options.js
var defaultNotDeepCopyArrays = ["dataSource", "selectedRowKeys"];
var propsToIgnore = {
  integrationOptions: true
};
function getDiffItem(key, value2, previousValue) {
  return {
    path: key,
    value: value2,
    previousValue
  };
}
function compare2(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {
  if (propsToIgnore[key]) {
    return;
  }
  const type1 = type(item1);
  const type2 = type(item2);
  if (item1 === item2) {
    return;
  }
  if (type1 !== type2) {
    resultPaths.push(getDiffItem(key, item2, item1));
  } else if ("object" === type1) {
    if (!isPlainObject(item2)) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      resultPaths.push(...diffPaths.map(((item) => _extends({}, item, {
        path: `${key}.${item.path}`
      }))));
    }
  } else if ("array" === type1) {
    const notDeepCopy = notDeepCopyArrays.some(((prop) => fullPropName.includes(prop)));
    if (notDeepCopy && item1 !== item2) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else if (item1.length !== item2.length) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      [].push.apply(resultPaths, diffPaths.map(((item) => _extends({}, item, {
        path: `${key}${item.path}`
      }))));
    }
  } else {
    resultPaths.push(getDiffItem(key, item2, item1));
  }
}
var objectDiffsFiltered = (propsEnumerator) => (oldProps, props, fullPropName, notDeepCopyArrays) => {
  const resultPaths = [];
  const processItem = !Array.isArray(oldProps) ? (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], propName, `${fullPropName}.${propName}`, notDeepCopyArrays);
  } : (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], `[${propName}]`, `${fullPropName}.${propName}`, notDeepCopyArrays);
  };
  propsEnumerator(oldProps).forEach(processItem);
  Object.keys(props).filter(((propName) => !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName])).forEach(((propName) => {
    resultPaths.push({
      path: propName,
      value: props[propName],
      previousValue: oldProps[propName]
    });
  }));
  return resultPaths;
};
var objectDiffs = objectDiffsFiltered(((oldProps) => Object.keys(oldProps)));
var reactProps = {
  key: true,
  ref: true,
  children: true,
  style: true
};
var objectDiffsWithoutReactProps = objectDiffsFiltered(((prop) => Object.keys(prop).filter(((p2) => !reactProps[p2]))));
function getUpdatedOptions(oldProps, props) {
  let notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;
  return objectDiffsWithoutReactProps(oldProps, props, "", notDeepCopyArrays);
}

// node_modules/devextreme/esm/__internal/core/r1/dom_component_wrapper.js
var _excluded5 = ["componentProps", "componentType", "templateNames"];
var normalizeProps2 = (props) => Object.keys(props).reduce(((accumulator, key) => {
  if (void 0 !== props[key]) {
    accumulator[key] = props[key];
  }
  return accumulator;
}), {});
var DomComponentWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetRef = createRef();
    this.instance = null;
    this.prevProps = null;
    this.getInstance = this.getInstance.bind(this);
    this.setupWidget = this.setupWidget.bind(this);
    this.updateWidget = this.updateWidget.bind(this);
  }
  getConfig() {
    const {
      id
    } = ConfigContext;
    if (this.context[id]) {
      return this.context[id];
    }
    return ConfigContext.defaultValue;
  }
  render() {
    return normalizeProps2(createVNode(1, "div", this.props.componentProps.className, null, 1, _extends({}, this.getRestAttributes()), null, this.widgetRef));
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.setupWidget, []), new InfernoEffect(this.updateWidget, [this.props.componentProps, this.getConfig(), this.props.templateNames])];
  }
  updateEffects() {
    var _this$_effects$;
    const dependency = [this.props.componentProps, this.getConfig(), this.props.templateNames];
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update(dependency);
  }
  setupWidget() {
    const current2 = this.widgetRef.current;
    const componentInstance = new this.props.componentType(current2, this.getProperties());
    this.instance = componentInstance;
    return () => {
      componentInstance.dispose();
      this.instance = null;
    };
  }
  updateWidget() {
    if (!this.instance) {
      return;
    }
    const updatedOptions = getUpdatedOptions(this.prevProps ?? {}, this.getProperties());
    if (updatedOptions.length) {
      this.instance.beginUpdate();
      updatedOptions.forEach(((_ref2) => {
        var _this$instance;
        const {
          path,
          value: value2
        } = _ref2;
        null === (_this$instance = this.instance) || void 0 === _this$instance || _this$instance.option(path, value2);
      }));
      this.instance.endUpdate();
    }
    this.prevProps = this.getProperties();
  }
  getRestAttributes() {
    const _this$props = this.props, restAttr = _objectWithoutPropertiesLoose(_this$props, _excluded5);
    return restAttr;
  }
  getProperties() {
    var _this$getConfig;
    const normalizedProps = normalizeProps2(this.props.componentProps);
    const {
      valueChange
    } = normalizedProps;
    const properties = extend({
      rtlEnabled: null === (_this$getConfig = this.getConfig()) || void 0 === _this$getConfig ? void 0 : _this$getConfig.rtlEnabled,
      isRenovated: true
    }, normalizedProps);
    if (valueChange) {
      properties.onValueChanged = (_ref3) => {
        const {
          value: value2
        } = _ref3;
        return valueChange(value2);
      };
    }
    const templates = this.props.templateNames;
    templates.forEach(((name2) => {
      if (hasTemplate2(name2, properties, this)) {
        properties[name2] = (item, index, container) => {
          renderTemplate(this.props.componentProps[name2], {
            item,
            index,
            container
          }, this);
        };
      }
    }));
    return properties;
  }
  getInstance() {
    return this.instance;
  }
};

// node_modules/devextreme/esm/__internal/ui/check_box/wrappers/validation_message.js
var _excluded6 = ["accessKey", "activeStateEnabled", "boundary", "className", "contentId", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "mode", "offset", "onClick", "onKeyDown", "positionSide", "rtlEnabled", "tabIndex", "target", "validationErrors", "visible", "visualContainer", "width"];
var defaultValidationMessageProps = _extends({}, BaseWidgetDefaultProps, {
  mode: "auto",
  positionSide: "top",
  offset: Object.freeze({
    h: 0,
    v: 0
  }),
  isReactComponentWrapper: true
});
var ValidationMessage2 = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded6);
    return restProps;
  }
  render() {
    return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
      componentType: validation_message_default,
      componentProps: this.props,
      templateNames: []
    }, this.restAttributes)));
  }
};
ValidationMessage2.defaultProps = defaultValidationMessageProps;

// node_modules/devextreme/esm/__internal/ui/check_box/editor_base/editor.js
var _excluded7 = ["accessKey", "activeStateEnabled", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "tabIndex", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses2 = (model) => {
  const {
    classes,
    isValid,
    readOnly
  } = model;
  const classesMap = {
    "dx-state-readonly": !!readOnly,
    "dx-invalid": !isValid,
    [String(classes)]: !!classes
  };
  return combineClasses2(classesMap);
};
var defaultEditorProps = _extends({}, WidgetDefaultProps, {
  readOnly: false,
  name: "",
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: {},
  defaultValue: null,
  valueChange: () => {
  }
});
var Editor2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.widgetRef = createRef();
    this.rootElementRef = createRef();
    this.__getterCache = {};
    this.state = {
      validationMessageGuid: `dx-${new guid_default()}`,
      isValidationMessageVisible: false,
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.updateValidationMessageVisibility = this.updateValidationMessageVisibility.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onFocusIn = this.onFocusIn.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.updateValidationMessageVisibility, [this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects;
    null === (_this$_effects = this._effects) || void 0 === _this$_effects || null === (_this$_effects = _this$_effects[0]) || void 0 === _this$_effects || _this$_effects.update([this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]);
  }
  updateValidationMessageVisibility() {
    this.setState((() => ({
      isValidationMessageVisible: this.shouldShowValidationMessage
    })));
  }
  onFocusIn(event) {
    const {
      onFocusIn
    } = this.props;
    null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
  }
  get cssClasses() {
    return `${getCssClasses2(_extends({}, this.props, { value: void 0 !== this.props.value ? this.props.value : this.state.value }))}`;
  }
  get shouldShowValidationMessage() {
    const {
      isValid,
      validationStatus
    } = this.props;
    const validationErrors = this.validationErrors ?? [];
    const isEditorValid = isValid && "invalid" !== validationStatus;
    return !isEditorValid && validationErrors.length > 0;
  }
  get aria() {
    const {
      isValid,
      readOnly
    } = this.props;
    const result2 = {
      readonly: readOnly ? "true" : "false",
      invalid: !isValid ? "true" : "false"
    };
    if (this.shouldShowValidationMessage) {
      result2.describedBy = this.state.validationMessageGuid;
    }
    return _extends({}, result2, this.props.aria);
  }
  get validationErrors() {
    if (void 0 !== this.__getterCache.validationErrors) {
      return this.__getterCache.validationErrors;
    }
    return this.__getterCache.validationErrors = (() => {
      const {
        validationError,
        validationErrors
      } = this.props;
      let allValidationErrors = validationErrors && [...validationErrors];
      if (!allValidationErrors && validationError) {
        allValidationErrors = [_extends({}, validationError)];
      }
      return allValidationErrors;
    })();
  }
  get validationMessageTarget() {
    var _this$rootElementRef;
    return null === (_this$rootElementRef = this.rootElementRef) || void 0 === _this$rootElementRef ? void 0 : _this$rootElementRef.current;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded7);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  blur() {
    this.widgetRef.current.blur();
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.validationError !== nextProps.validationError || this.props.validationErrors !== nextProps.validationErrors) {
      this.__getterCache.validationErrors = void 0;
    }
  }
  render() {
    return normalizeProps(createComponentVNode(2, Widget, _extends({
      rootElementRef: this.rootElementRef,
      aria: this.aria,
      classes: this.cssClasses,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      accessKey: this.props.accessKey,
      className: this.props.className,
      rtlEnabled: this.props.rtlEnabled,
      hint: this.props.hint,
      disabled: this.props.disabled,
      height: this.props.height,
      width: this.props.width,
      onFocusIn: this.props.onFocusIn,
      onClick: this.props.onClick,
      onKeyDown: this.props.onKeyDown,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible
    }, this.restAttributes, {
      children: createFragment([this.props.children, this.state.isValidationMessageVisible && createComponentVNode(2, ValidationMessage2, {
        validationErrors: this.validationErrors,
        mode: this.props.validationMessageMode,
        positionSide: this.props.validationMessagePosition,
        rtlEnabled: this.props.rtlEnabled,
        target: this.validationMessageTarget,
        boundary: this.validationMessageTarget,
        visualContainer: this.validationMessageTarget,
        contentId: this.state.validationMessageGuid
      })], 0)
    }), null, this.widgetRef));
  }
};
Editor2.defaultProps = defaultEditorProps;

// node_modules/devextreme/esm/__internal/ui/check_box/check_box.js
var _excluded8 = ["accessKey", "activeStateEnabled", "aria", "className", "classes", "defaultValue", "disabled", "enableThreeStateBehavior", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "iconSize", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "saveValueChangeEvent", "tabIndex", "text", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses3 = (model) => {
  const {
    text,
    value: value2
  } = model;
  const checked = value2;
  const indeterminate = null === checked;
  const classesMap = {
    "dx-checkbox": true,
    "dx-checkbox-checked": true === checked,
    "dx-checkbox-has-text": !!text,
    "dx-checkbox-indeterminate": indeterminate
  };
  return combineClasses2(classesMap);
};
var defaultCheckBoxProps = _extends({}, defaultEditorProps, {
  text: "",
  enableThreeStateBehavior: false,
  activeStateEnabled: true,
  hoverStateEnabled: true,
  get focusStateEnabled() {
    return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
  },
  defaultValue: false,
  valueChange: () => {
  }
});
var CheckBox = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.editorRef = createRef();
    this.state = {
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  onWidgetClick(event) {
    const {
      enableThreeStateBehavior,
      readOnly,
      saveValueChangeEvent
    } = this.props;
    if (!readOnly) {
      null === saveValueChangeEvent || void 0 === saveValueChangeEvent || saveValueChangeEvent(event);
      if (enableThreeStateBehavior) {
        var _this$props$valueChan, _this$props;
        let __newValue;
        this.setState(((__state_argument) => {
          __newValue = null === (void 0 !== this.props.value ? this.props.value : __state_argument.value) || (!(void 0 !== this.props.value ? this.props.value : __state_argument.value) ? null : false);
          return {
            value: __newValue
          };
        }));
        null === (_this$props$valueChan = (_this$props = this.props).valueChange) || void 0 === _this$props$valueChan || _this$props$valueChan.call(_this$props, __newValue);
      } else {
        var _this$props$valueChan2, _this$props2;
        let __newValue;
        this.setState(((__state_argument) => {
          __newValue = !((void 0 !== this.props.value ? this.props.value : __state_argument.value) ?? false);
          return {
            value: __newValue
          };
        }));
        null === (_this$props$valueChan2 = (_this$props2 = this.props).valueChange) || void 0 === _this$props$valueChan2 || _this$props$valueChan2.call(_this$props2, __newValue);
      }
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get cssClasses() {
    return getCssClasses3(_extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }));
  }
  get aria() {
    const checked = true === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const indeterminate = null === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const result2 = {
      role: "checkbox",
      checked: indeterminate ? "mixed" : `${checked}`
    };
    return _extends({}, result2, this.props.aria);
  }
  get restAttributes() {
    const _this$props3 = this.props, restProps = _objectWithoutPropertiesLoose(_this$props3, _excluded8);
    return restProps;
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  render() {
    const value2 = void 0 !== this.props.value ? this.props.value : this.state.value;
    return normalizeProps(createComponentVNode(2, Editor2, _extends({
      aria: this.aria,
      classes: this.cssClasses,
      onClick: this.onWidgetClick,
      onKeyDown: this.keyDown,
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      className: this.props.className,
      disabled: this.props.disabled,
      readOnly: this.props.readOnly,
      hint: this.props.hint,
      height: this.props.height,
      width: this.props.width,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      validationError: this.props.validationError,
      validationErrors: this.props.validationErrors,
      validationMessageMode: this.props.validationMessageMode,
      validationMessagePosition: this.props.validationMessagePosition,
      validationStatus: this.props.validationStatus,
      isValid: this.props.isValid,
      onFocusIn: this.props.onFocusIn
    }, this.restAttributes, {
      children: createFragment([normalizeProps(createVNode(64, "input", null, null, 1, _extends({
        type: "hidden",
        value: `${value2}`
      }, this.props.name && {
        name: this.props.name
      }))), createVNode(1, "div", "dx-checkbox-container", [createComponentVNode(2, CheckBoxIcon, {
        size: this.props.iconSize,
        isChecked: true === value2
      }), this.props.text && createVNode(1, "span", "dx-checkbox-text", this.props.text, 0)], 0)], 4)
    }), null, this.editorRef));
  }
};
function __processTwoWayProps(defaultProps) {
  const twoWayProps = ["value"];
  return Object.keys(defaultProps).reduce(((props, propName) => {
    const propValue = defaultProps[propName];
    const defaultPropName = twoWayProps.some(((p2) => p2 === propName)) ? `default${propName.charAt(0).toUpperCase()}${propName.slice(1)}` : propName;
    props[defaultPropName] = propValue;
    return props;
  }), {});
}
CheckBox.defaultProps = defaultCheckBoxProps;
var __defaultOptionRules2 = [];
function defaultOptions2(rule) {
  __defaultOptionRules2.push(rule);
  CheckBox.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(CheckBox.defaultProps), Object.getOwnPropertyDescriptors(__processTwoWayProps(convertRulesToOptions(__defaultOptionRules2)))));
}

// node_modules/devextreme/esm/ui/editor/editor.js
var editor_default2 = editor_default;

// node_modules/devextreme/esm/__internal/core/r1/utils/dom.js
function querySelectorInSameDocument(el, selector) {
  var _el$getRootNode;
  const root = (null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el)) ?? document;
  return root.querySelector(selector);
}

// node_modules/devextreme/esm/__internal/ui/check_box/editor_base/wrapper.js
var INVALID_MESSAGE_AUTO3 = "dx-invalid-message-auto";
var VALIDATION_TARGET2 = "dx-validation-target";
var Editor3 = class extends ComponentWrapper {
  getProps() {
    const props = super.getProps();
    props.onFocusIn = () => {
      const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
      if (isValidationMessageShownOnFocus) {
        const $validationMessageWrapper = renderer_default(querySelectorInSameDocument(this.element(), ".dx-invalid-message.dx-overlay-wrapper"));
        null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO3);
        const timeToWaitBeforeShow = 150;
        if (this.showValidationMessageTimeout) {
          clearTimeout(this.showValidationMessageTimeout);
        }
        this.showValidationMessageTimeout = setTimeout((() => {
          null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO3);
        }), timeToWaitBeforeShow);
      }
    };
    props.saveValueChangeEvent = (e) => {
      this._valueChangeEventInstance = e;
    };
    return props;
  }
  _createElement(element) {
    super._createElement(element);
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    data(this.$element()[0], VALIDATION_TARGET2, this);
  }
  _render() {
    var _this$option;
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  }
  _init() {
    super._init();
    this._initialValue = this.option("value");
  }
  _initializeComponent() {
    super._initializeComponent();
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const innerWidgetOptions = extend({}, innerWidget.option());
    const syncOptions = () => this._silent(optionsContainer, innerWidgetOptions);
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _raiseValidation(value2, previousValue) {
    const areValuesEmpty = !isDefined(value2) && !isDefined(previousValue);
    if (value2 !== previousValue && !areValuesEmpty) {
      this.validationRequest.fire({
        value: value2,
        editor: this
      });
    }
  }
  _raiseValueChangeAction(value2, previousValue) {
    var _this$_valueChangeAct;
    null === (_this$_valueChangeAct = this._valueChangeAction) || void 0 === _this$_valueChangeAct || _this$_valueChangeAct.call(this, {
      element: this.$element(),
      previousValue,
      value: value2,
      event: this._valueChangeEventInstance
    });
    this._valueChangeEventInstance = void 0;
  }
  _optionChanged(option) {
    const {
      name: name2,
      previousValue,
      value: value2
    } = option;
    if (name2 && void 0 !== this._getActionConfigs()[name2]) {
      this._addAction(name2);
    }
    switch (name2) {
      case "value":
        this._raiseValidation(value2, previousValue);
        this.option("isDirty", this._initialValue !== value2);
        this._raiseValueChangeAction(value2, previousValue);
        break;
      case "onValueChanged":
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(option, this.option()));
    }
    super._optionChanged(option);
  }
  clear() {
    const {
      value: value2
    } = this._getDefaultOptions();
    this.option({
      value: value2
    });
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this.option("value", this._initialValue);
    this.option("isDirty", false);
    this.option("isValid", true);
  }
  _dispose() {
    super._dispose();
    data(this.element(), VALIDATION_TARGET2, null);
    if (this.showValidationMessageTimeout) {
      clearTimeout(this.showValidationMessageTimeout);
    }
  }
};
var prevIsEditor = editor_default2.isEditor;
var newIsEditor = (instance) => prevIsEditor(instance) || instance instanceof Editor3;
Editor3.isEditor = newIsEditor;
editor_default2.isEditor = newIsEditor;

// node_modules/devextreme/esm/__internal/ui/check_box/wrapper.js
var CheckBox2 = class extends Editor3 {
  _useTemplates() {
    return false;
  }
  _isFocused() {
    const focusTarget = this.$element()[0];
    return focusTarget.classList.contains("dx-state-focused");
  }
  getSupportedKeyNames() {
    return ["space"];
  }
  getProps() {
    const props = super.getProps();
    if (null !== props.value) {
      props.value = Boolean(props.value);
    }
    return props;
  }
};

// node_modules/devextreme/esm/__internal/ui/check_box/generated_wrapper.js
var CheckBox3 = class extends CheckBox2 {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  blur() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.blur(...arguments);
  }
  _getActionConfigs() {
    return {
      onFocusIn: {},
      onClick: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["value", "defaultValue", "valueChange"]
      ],
      allowNull: ["defaultValue", "validationError", "validationErrors", "value"],
      elements: [],
      templates: [],
      props: ["text", "iconSize", "enableThreeStateBehavior", "activeStateEnabled", "hoverStateEnabled", "focusStateEnabled", "saveValueChangeEvent", "defaultValue", "valueChange", "readOnly", "name", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "isValid", "isDirty", "inputAttr", "onFocusIn", "className", "accessKey", "disabled", "height", "hint", "onClick", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width", "aria", "value"]
    };
  }
  get _viewComponent() {
    return CheckBox;
  }
};
component_registrator_default("dxCheckBox", CheckBox3);
CheckBox3.defaultOptions = defaultOptions2;

// node_modules/devextreme/esm/__internal/ui/check_box/index.js
var check_box_default = CheckBox3;

// node_modules/devextreme/esm/ui/check_box.js
var check_box_default2 = check_box_default;

// node_modules/devextreme/esm/__internal/ui/tree_view/m_tree_view.base.js
var WIDGET_CLASS = "dx-treeview";
var NODE_CLASS = `${WIDGET_CLASS}-node`;
var NODE_CONTAINER_CLASS = `${NODE_CLASS}-container`;
var NODE_LOAD_INDICATOR_CLASS = `${NODE_CLASS}-loadindicator`;
var OPENED_NODE_CONTAINER_CLASS = `${NODE_CLASS}-container-opened`;
var IS_LEAF = `${NODE_CLASS}-is-leaf`;
var ITEM_CLASS3 = `${WIDGET_CLASS}-item`;
var ITEM_WITH_CHECKBOX_CLASS = `${ITEM_CLASS3}-with-checkbox`;
var ITEM_WITH_CUSTOM_EXPANDER_ICON_CLASS = `${ITEM_CLASS3}-with-custom-expander-icon`;
var CUSTOM_EXPANDER_ICON_ITEM_CONTAINER_CLASS = `${WIDGET_CLASS}-custom-expander-icon-item-container`;
var ITEM_WITHOUT_CHECKBOX_CLASS = `${ITEM_CLASS3}-without-checkbox`;
var ITEM_DATA_KEY = `${ITEM_CLASS3}-data`;
var TOGGLE_ITEM_VISIBILITY_CLASS = `${WIDGET_CLASS}-toggle-item-visibility`;
var CUSTOM_COLLAPSE_ICON_CLASS = `${WIDGET_CLASS}-custom-collapse-icon`;
var CUSTOM_EXPAND_ICON_CLASS = `${WIDGET_CLASS}-custom-expand-icon`;
var LOAD_INDICATOR_CLASS = `${WIDGET_CLASS}-loadindicator`;
var LOAD_INDICATOR_WRAPPER_CLASS = `${WIDGET_CLASS}-loadindicator-wrapper`;
var TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = `${WIDGET_CLASS}-toggle-item-visibility-opened`;
var SELECT_ALL_ITEM_CLASS = `${WIDGET_CLASS}-select-all-item`;
var DATA_ITEM_ID = "data-item-id";
var ROOT_NODE_CLASS = `${WIDGET_CLASS}-root-node`;
var EXPANDER_ICON_STUB_CLASS = `${WIDGET_CLASS}-expander-icon-stub`;
var TreeViewBase = class extends m_hierarchical_collection_widget_default {
  _supportedKeys() {
    const click2 = (e) => {
      const {
        focusedElement
      } = this.option();
      const $itemElement = renderer_default(focusedElement);
      if (!$itemElement.length) {
        return;
      }
      e.target = $itemElement;
      e.currentTarget = $itemElement;
      this._itemClickHandler(e, $itemElement.children(`.${ITEM_CLASS3}`));
      const expandEventName = this._getEventNameByOption(this.option("expandEvent"));
      const expandByClick = expandEventName === addNamespace(CLICK_EVENT_NAME, "dxTreeView_expand");
      if (expandByClick) {
        this._expandEventHandler(e);
      }
    };
    const select = (e) => {
      e.preventDefault();
      const {
        focusedElement
      } = this.option();
      const $focusedElement = renderer_default(focusedElement);
      const checkboxInstance = this._getCheckBoxInstance($focusedElement);
      if (!checkboxInstance.option("disabled")) {
        const currentState = checkboxInstance.option("value");
        this._updateItemSelection(!currentState, $focusedElement.find(`.${ITEM_CLASS3}`).get(0), true);
      }
    };
    const toggleExpandedNestedItems = function(state, e) {
      if (!this.option("expandAllEnabled")) {
        return;
      }
      e.preventDefault();
      const $rootElement = renderer_default(this.option("focusedElement"));
      if (!$rootElement.length) {
        return;
      }
      const rootItem = this._getItemData($rootElement.find(`.${ITEM_CLASS3}`));
      this._toggleExpandedNestedItems([rootItem], state);
    };
    return _extends({}, super._supportedKeys(), {
      enter: this._showCheckboxes() ? select : click2,
      space: this._showCheckboxes() ? select : click2,
      asterisk: toggleExpandedNestedItems.bind(this, true),
      minus: toggleExpandedNestedItems.bind(this, false)
    });
  }
  _toggleExpandedNestedItems(items, state) {
    if (!items) {
      return;
    }
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const node = this._dataAdapter.getNodeByItem(item);
      this._toggleExpandedState(node, state);
      this._toggleExpandedNestedItems(item.items, state);
    }
  }
  _getNodeElement(node, cache) {
    const key = this._encodeString(node.internalFields.key);
    if (cache) {
      if (!cache.$nodeByKey) {
        cache.$nodeByKey = {};
        this.$element().find(`.${NODE_CLASS}`).each((function() {
          const $node = renderer_default(this);
          const key2 = $node.attr(DATA_ITEM_ID);
          cache.$nodeByKey[key2] = $node;
        }));
      }
      return cache.$nodeByKey[key] || renderer_default();
    }
    const element = this.$element().get(0).querySelector(`[${DATA_ITEM_ID}="${key}"]`);
    return renderer_default(element);
  }
  _widgetClass() {
    return WIDGET_CLASS;
  }
  _getDefaultOptions() {
    const defaultOptions3 = extend(super._getDefaultOptions(), {
      animationEnabled: true,
      dataStructure: "tree",
      deferRendering: true,
      expandAllEnabled: false,
      hasItemsExpr: "hasItems",
      selectNodesRecursive: true,
      expandNodesRecursive: true,
      showCheckBoxesMode: "none",
      expandIcon: null,
      collapseIcon: null,
      selectAllText: message_default.format("dxList-selectAll"),
      onItemSelectionChanged: null,
      onItemExpanded: null,
      onItemCollapsed: null,
      scrollDirection: "vertical",
      useNativeScrolling: true,
      virtualModeEnabled: false,
      rootValue: 0,
      focusStateEnabled: false,
      selectionMode: "multiple",
      expandEvent: "dblclick",
      selectByClick: false,
      createChildren: null,
      onSelectAllValueChanged: null,
      _supportItemUrl: false
    });
    return extend(true, defaultOptions3, {
      integrationOptions: {
        useDeferUpdateForTemplates: false
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !m_support_default.nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }]);
  }
  _initSelectedItems() {
  }
  _syncSelectionOptions() {
    return Deferred().resolve().promise();
  }
  _fireSelectionChanged() {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })();
  }
  _createSelectAllValueChangedAction() {
    this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _fireSelectAllValueChanged(value2) {
    var _this$_selectAllValue;
    null === (_this$_selectAllValue = this._selectAllValueChangedAction) || void 0 === _this$_selectAllValue || _this$_selectAllValue.call(this, {
      value: value2
    });
  }
  _checkBoxModeChange(value2, previousValue) {
    const searchEnabled = this.option("searchEnabled");
    const previousSelectAllEnabled = this._selectAllEnabled(previousValue);
    const previousItemsContainer = this._itemContainer(searchEnabled, previousSelectAllEnabled);
    this._detachClickEvent(previousItemsContainer);
    this._detachExpandEvent(previousItemsContainer);
    if ("none" === previousValue || "none" === value2) {
      return;
    }
    const selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
    switch (value2) {
      case "selectAll":
        if (!selectAllExists) {
          this._createSelectAllValueChangedAction();
          this._renderSelectAllItem();
        }
        break;
      case "normal":
        if (selectAllExists) {
          var _this$_$selectAllItem;
          null === (_this$_$selectAllItem = this._$selectAllItem) || void 0 === _this$_$selectAllItem || _this$_$selectAllItem.remove();
          delete this._$selectAllItem;
        }
    }
  }
  _removeSelection() {
    const that = this;
    each(this._dataAdapter.getFullData(), ((_, node) => {
      if (!that._hasChildren(node)) {
        return;
      }
      that._dataAdapter.toggleSelection(node.internalFields.key, false, true);
    }));
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "selectAllText":
        if (this._$selectAllItem) {
          this._$selectAllItem.dxCheckBox("instance").option("text", value2);
        }
        break;
      case "showCheckBoxesMode":
        this._checkBoxModeChange(value2, previousValue);
        this._invalidate();
        break;
      case "scrollDirection":
        this.getScrollable().option("direction", value2);
        break;
      case "useNativeScrolling":
        this.getScrollable().option("useNative", value2);
        break;
      case "items":
        delete this._$selectAllItem;
        super._optionChanged(args);
        break;
      case "dataSource":
        super._optionChanged(args);
        this._initDataAdapter();
        this._filter = {};
        break;
      case "hasItemsExpr":
        this._initAccessors();
        this.repaint();
        break;
      case "expandEvent":
        this._attachExpandEvent();
        break;
      case "deferRendering":
      case "dataStructure":
      case "rootValue":
      case "createChildren":
      case "expandNodesRecursive":
      case "onItemSelectionChanged":
      case "onItemExpanded":
      case "onItemCollapsed":
      case "expandAllEnabled":
      case "animationEnabled":
      case "virtualModeEnabled":
      case "selectByClick":
      case "_supportItemUrl":
        break;
      case "selectionMode":
        this._initDataAdapter();
        super._optionChanged(args);
        break;
      case "onSelectAllValueChanged":
        this._createSelectAllValueChangedAction();
        break;
      case "selectNodesRecursive":
        this._dataAdapter.setOption("recursiveSelection", args.value);
        this.repaint();
        break;
      case "expandIcon":
      case "collapseIcon":
        this.repaint();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _initDataSource() {
    if (this._useCustomChildrenLoader()) {
      this._loadChildrenByCustomLoader(null).done(((newItems) => {
        if (newItems && newItems.length) {
          this.option("items", newItems);
        }
      }));
    } else {
      super._initDataSource();
      this._isVirtualMode() && this._initVirtualMode();
    }
  }
  _initVirtualMode() {
    const filter = this._filter;
    if (!filter.custom) {
      filter.custom = this._dataSource.filter();
    }
    if (!filter.internal) {
      filter.internal = [this.option("parentIdExpr"), this.option("rootValue")];
    }
  }
  _useCustomChildrenLoader() {
    return isFunction(this.option("createChildren")) && this._isDataStructurePlain();
  }
  _loadChildrenByCustomLoader(parentNode) {
    const invocationResult = this.option("createChildren").call(this, parentNode);
    if (Array.isArray(invocationResult)) {
      return Deferred().resolve(invocationResult).promise();
    }
    if (invocationResult && isFunction(invocationResult.then)) {
      return fromPromise(invocationResult);
    }
    return Deferred().resolve([]).promise();
  }
  _combineFilter() {
    if (!this._filter.custom || !this._filter.custom.length) {
      return this._filter.internal;
    }
    return [this._filter.custom, this._filter.internal];
  }
  _dataSourceLoadErrorHandler() {
    this._renderEmptyMessage();
  }
  _init() {
    this._filter = {};
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS3}`;
    this._initStoreChangeHandlers();
  }
  _dataSourceChangedHandler(newItems) {
    const items = this.option("items");
    if (this._initialized && this._isVirtualMode() && items.length) {
      return;
    }
    this.option("items", newItems);
  }
  _removeTreeViewLoadIndicator() {
    if (!this._treeViewLoadIndicator) {
      return;
    }
    this._treeViewLoadIndicator.remove();
    this._treeViewLoadIndicator = null;
  }
  _createTreeViewLoadIndicator() {
    this._treeViewLoadIndicator = renderer_default("<div>").addClass(LOAD_INDICATOR_CLASS);
    this._createComponent(this._treeViewLoadIndicator, load_indicator_default, {});
    return this._treeViewLoadIndicator;
  }
  _dataSourceLoadingChangedHandler(isLoading) {
    let resultFilter;
    if (this._isVirtualMode()) {
      resultFilter = this._combineFilter();
      this._dataSource.filter(resultFilter);
    }
    if (isLoading && !this._dataSource.isLoaded()) {
      this.option("items", []);
      const $wrapper = renderer_default("<div>").addClass(LOAD_INDICATOR_WRAPPER_CLASS);
      this._createTreeViewLoadIndicator().appendTo($wrapper);
      this.itemsContainer().append($wrapper);
      if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
        this._dataSource.filter([]);
      }
    } else {
      this._removeTreeViewLoadIndicator();
    }
  }
  _initStoreChangeHandlers() {
    const {
      dataStructure
    } = this.option();
    if ("plain" !== dataStructure) {
      return;
    }
    this._dataSource && this._dataSource.store().on("inserted", ((newItem) => {
      this.option().items = this.option("items").concat(newItem);
      this._dataAdapter.addItem(newItem);
      if (!this._dataAdapter.isFiltered(newItem)) {
        return;
      }
      this._updateLevel(this._parentIdGetter(newItem));
    })).on("removed", ((removedKey) => {
      const node = this._dataAdapter.getNodeByKey(removedKey);
      if (isDefined(node)) {
        this.option("items")[this._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
        this._markChildrenItemsToRemove(node);
        this._removeItems();
        this._dataAdapter.removeItem(removedKey);
        this._updateLevel(this._parentIdGetter(node));
      }
    }));
  }
  _markChildrenItemsToRemove(node) {
    const keys = node.internalFields.childrenKeys;
    each(keys, ((_, key) => {
      this.option("items")[this._dataAdapter.getIndexByKey(key)] = 0;
      this._markChildrenItemsToRemove(this._dataAdapter.getNodeByKey(key));
    }));
  }
  _removeItems() {
    const items = extend(true, [], this.option("items"));
    let counter = 0;
    each(items, ((index, item) => {
      if (!item) {
        this.option("items").splice(index - counter, 1);
        counter++;
      }
    }));
  }
  _updateLevel(parentId) {
    const $container = this._getContainerByParentKey(parentId);
    this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId));
  }
  _getOldContainer($itemElement) {
    if ($itemElement.length) {
      return $itemElement.children(`.${NODE_CONTAINER_CLASS}`);
    }
    const scrollable = this.getScrollable();
    if (scrollable) {
      return renderer_default(scrollable.content()).children();
    }
    return renderer_default();
  }
  _getContainerByParentKey(parentId) {
    const node = this._dataAdapter.getNodeByKey(parentId);
    const $itemElement = node ? this._getNodeElement(node) : [];
    this._getOldContainer($itemElement).remove();
    const $container = this._renderNodeContainer($itemElement);
    if (this._isRootLevel(parentId)) {
      const scrollable = this.getScrollable();
      if (!scrollable) {
        this._renderScrollableContainer();
      }
      renderer_default(scrollable.content()).append($container);
    }
    return $container;
  }
  _isRootLevel(parentId) {
    return parentId === this.option("rootValue");
  }
  _getAccessors() {
    const accessors = super._getAccessors();
    accessors.push("hasItems");
    return accessors;
  }
  _getDataAdapterOptions() {
    var _this$_dataSource, _this$_dataSource2, _this$_dataSource2$lo;
    return {
      rootValue: this.option("rootValue"),
      multipleSelection: !this._isSingleSelection(),
      recursiveSelection: this._isRecursiveSelection(),
      recursiveExpansion: this.option("expandNodesRecursive"),
      selectionRequired: this.option("selectionRequired"),
      dataType: this.option("dataStructure"),
      sort: null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.sort(),
      langParams: null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 || null === (_this$_dataSource2$lo = _this$_dataSource2.loadOptions) || void 0 === _this$_dataSource2$lo || null === (_this$_dataSource2$lo = _this$_dataSource2$lo.call(_this$_dataSource2)) || void 0 === _this$_dataSource2$lo ? void 0 : _this$_dataSource2$lo.langParams
    };
  }
  _initMarkup() {
    this._renderScrollableContainer();
    this._renderEmptyMessage(this._dataAdapter.getRootNodes());
    super._initMarkup();
    this._setAriaRole();
  }
  _setAriaRole() {
    const {
      items
    } = this.option();
    if (items && items.length) {
      this.setAria({
        role: "tree"
      });
    }
  }
  _renderContentImpl() {
    const $nodeContainer = this._renderNodeContainer();
    renderer_default(this.getScrollable().content()).append($nodeContainer);
    if (!this.option("items") || !this.option("items").length) {
      return;
    }
    this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
    this._attachExpandEvent();
    if (this._selectAllEnabled()) {
      this._createSelectAllValueChangedAction();
      this._renderSelectAllItem($nodeContainer);
    }
  }
  _isVirtualMode() {
    return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource");
  }
  _isDataStructurePlain() {
    const {
      dataStructure
    } = this.option();
    return "plain" === dataStructure;
  }
  _fireContentReadyAction() {
    const dataSource = this.getDataSource();
    const skipContentReadyAction = dataSource && !dataSource.isLoaded() || this._skipContentReadyAndItemExpanded;
    const scrollable = this.getScrollable();
    if (scrollable && hasWindow()) {
      scrollable.update();
    }
    if (!skipContentReadyAction) {
      super._fireContentReadyAction();
    }
    if (scrollable && hasWindow()) {
      scrollable.update();
    }
  }
  _renderScrollableContainer() {
    this._scrollable = this._createComponent(renderer_default("<div>").appendTo(this.$element()), m_scrollable_default, {
      useNative: this.option("useNativeScrolling"),
      direction: this.option("scrollDirection"),
      useKeyboard: false
    });
  }
  _renderNodeContainer($parent) {
    const $container = renderer_default("<ul>").addClass(NODE_CONTAINER_CLASS);
    this.setAria("role", "group", $container);
    if (null !== $parent && void 0 !== $parent && $parent.length) {
      const itemData = this._getItemData($parent.children(`.${ITEM_CLASS3}`));
      if (this._expandedGetter(itemData)) {
        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
      }
      $container.appendTo($parent);
    }
    return $container;
  }
  _createDOMElement($nodeContainer, node) {
    var _node$internalFields;
    const $node = renderer_default("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, this._encodeString(node.internalFields.key)).prependTo($nodeContainer);
    const attrs = {
      role: "treeitem",
      label: this._displayGetter(node.internalFields.item) || "",
      level: this._getLevel($nodeContainer)
    };
    const hasChildNodes = !!(null !== node && void 0 !== node && null !== (_node$internalFields = node.internalFields) && void 0 !== _node$internalFields && null !== (_node$internalFields = _node$internalFields.childrenKeys) && void 0 !== _node$internalFields && _node$internalFields.length);
    if (hasChildNodes) {
      attrs.expanded = node.internalFields.expanded || false;
    }
    this.setAria(attrs, $node);
    return $node;
  }
  _getLevel($nodeContainer) {
    const parent = $nodeContainer.parent();
    return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1;
  }
  _showCheckboxes() {
    const {
      showCheckBoxesMode
    } = this.option();
    return "none" !== showCheckBoxesMode;
  }
  _hasCustomExpanderIcons() {
    return this.option("expandIcon") || this.option("collapseIcon");
  }
  _selectAllEnabled(showCheckBoxesMode) {
    const mode = showCheckBoxesMode ?? this.option("showCheckBoxesMode");
    return "selectAll" === mode && !this._isSingleSelection();
  }
  _renderItems($nodeContainer, nodes) {
    const length = nodes.length - 1;
    for (let i = length; i >= 0; i--) {
      this._renderItem(i, nodes[i], $nodeContainer);
    }
    this._renderedItemsCount += nodes.length;
  }
  _renderItem(nodeIndex, node, $nodeContainer) {
    const $node = this._createDOMElement($nodeContainer, node);
    const nodeData = node.internalFields;
    const showCheckBox = this._showCheckboxes();
    $node.addClass(showCheckBox ? ITEM_WITH_CHECKBOX_CLASS : ITEM_WITHOUT_CHECKBOX_CLASS);
    $node.toggleClass("dx-state-invisible", false === nodeData.item.visible);
    if (this._hasCustomExpanderIcons()) {
      $node.addClass(ITEM_WITH_CUSTOM_EXPANDER_ICON_CLASS);
      $nodeContainer.addClass(CUSTOM_EXPANDER_ICON_ITEM_CONTAINER_CLASS);
    }
    this.setAria("selected", nodeData.selected, $node);
    this._toggleSelectedClass($node, nodeData.selected);
    if (nodeData.disabled) {
      this.setAria("disabled", nodeData.disabled, $node);
    }
    super._renderItem(this._renderedItemsCount + nodeIndex, nodeData.item, $node);
    const parent = this._getNode(node.internalFields.parentKey);
    if (!parent) {
      $node.addClass(ROOT_NODE_CLASS);
    }
    if (false !== nodeData.item.visible) {
      this._renderChildren($node, node);
    }
  }
  _setAriaSelectionAttribute() {
  }
  _renderChildren($node, node) {
    if (!this._hasChildren(node)) {
      this._addLeafClass($node);
      renderer_default("<div>").addClass(EXPANDER_ICON_STUB_CLASS).appendTo(this._getItem($node));
      return;
    }
    if (this._hasCustomExpanderIcons()) {
      this._renderCustomExpanderIcons($node, node);
    } else {
      this._renderDefaultExpanderIcons($node, node);
    }
    if (this._shouldRenderSublevel(node.internalFields.expanded)) {
      this._loadSublevel(node).done(((childNodes) => {
        this._renderSublevel($node, this._getActualNode(node), childNodes);
      }));
    }
  }
  _shouldRenderSublevel(expanded) {
    return expanded || !this.option("deferRendering");
  }
  _getActualNode(cachedNode) {
    return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key);
  }
  _hasChildren(node) {
    if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
      return false !== this._hasItemsGetter(node.internalFields.item);
    }
    return super._hasChildren(node);
  }
  _loadSublevel(node) {
    const deferred = Deferred();
    const childrenNodes = this._getChildNodes(node);
    if (childrenNodes.length) {
      deferred.resolve(childrenNodes);
    } else {
      this._loadNestedItems(node).done(((items) => {
        deferred.resolve(this._dataAdapter.getNodesByItems(items));
      }));
    }
    return deferred.promise();
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _addContent($container, itemData) {
    const {
      html,
      url
    } = itemData;
    if (this.option("_supportItemUrl") && url) {
      $container.html(html);
      const link = this._getLinkContainer(this._getIconContainer(itemData), this._getTextContainer(itemData), itemData);
      $container.append(link);
    } else {
      super._addContent($container, itemData);
    }
  }
  _postprocessRenderItem(args) {
    const {
      itemData,
      itemElement
    } = args;
    if (this._showCheckboxes()) {
      this._renderCheckBox(itemElement, this._getNode(itemData));
    }
    super._postprocessRenderItem(args);
  }
  _renderSublevel($node, node, childNodes) {
    const $nestedNodeContainer = this._renderNodeContainer($node);
    const childNodesByChildrenKeys = childNodes.filter(((childNode) => -1 !== node.internalFields.childrenKeys.indexOf(childNode.internalFields.key)));
    this._renderItems($nestedNodeContainer, childNodesByChildrenKeys);
    if (childNodesByChildrenKeys.length && !node.internalFields.selected) {
      const firstChild = childNodesByChildrenKeys[0];
      this._updateParentsState(firstChild, this._getNodeElement(firstChild));
    }
    this._normalizeIconState($node, childNodesByChildrenKeys.length);
    if (node.internalFields.expanded) {
      $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    }
  }
  _executeItemRenderAction(itemIndex, itemData, itemElement) {
    const node = this._getNode(itemElement);
    this._getItemRenderAction()({
      itemElement,
      itemIndex,
      itemData,
      node: this._dataAdapter.getPublicNode(node)
    });
  }
  _addLeafClass($node) {
    $node.addClass(IS_LEAF);
  }
  _expandEventHandler(e) {
    const $nodeElement = renderer_default(e.currentTarget.parentNode);
    if (!$nodeElement.hasClass(IS_LEAF)) {
      this._toggleExpandedState(e.currentTarget, void 0, e);
    }
  }
  _attachExpandEvent() {
    const expandedEventName = this._getEventNameByOption(this.option("expandEvent"));
    const $itemsContainer = this._itemContainer();
    this._detachExpandEvent($itemsContainer);
    m_events_engine_default.on($itemsContainer, expandedEventName, this._itemSelector(), this._expandEventHandler.bind(this));
  }
  _detachExpandEvent(itemsContainer) {
    m_events_engine_default.off(itemsContainer, ".dxTreeView_expand", this._itemSelector());
  }
  _getEventNameByOption(name2) {
    const event = "click" === name2 ? CLICK_EVENT_NAME : DBLCLICK_EVENT_NAME;
    return addNamespace(event, "dxTreeView_expand");
  }
  _getNode(identifier) {
    if (!isDefined(identifier)) {
      return null;
    }
    if (identifier.internalFields) {
      return identifier;
    }
    if (isPrimitive(identifier)) {
      return this._dataAdapter.getNodeByKey(identifier);
    }
    const itemElement = renderer_default(identifier).get(0);
    if (!itemElement) {
      return null;
    }
    if (dom_adapter_default.isElementNode(itemElement)) {
      return this._getNodeByElement(itemElement);
    }
    return this._dataAdapter.getNodeByItem(itemElement);
  }
  _getNodeByElement(itemElement) {
    const $node = renderer_default(itemElement).closest(`.${NODE_CLASS}`);
    const key = this._decodeString($node.attr(DATA_ITEM_ID));
    return this._dataAdapter.getNodeByKey(key);
  }
  _toggleExpandedState(itemElement, state, e) {
    const node = this._getNode(itemElement);
    if (!node) {
      return Deferred().reject().promise();
    }
    if (node.internalFields.disabled) {
      return Deferred().reject().promise();
    }
    const currentState = node.internalFields.expanded;
    if (currentState === state) {
      return Deferred().resolve().promise();
    }
    if (this._hasChildren(node)) {
      const $node = this._getNodeElement(node);
      if ($node.find(`.${NODE_LOAD_INDICATOR_CLASS}:not(.dx-state-invisible)`).length) {
        return Deferred().reject().promise();
      }
      if (!currentState && !this._nodeHasRenderedChildren($node)) {
        this._createLoadIndicator($node);
      }
    }
    if (!isDefined(state)) {
      state = !currentState;
    }
    this._dataAdapter.toggleExpansion(node.internalFields.key, state);
    return this._updateExpandedItemsUI(node, state, e);
  }
  _nodeHasRenderedChildren($node) {
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    return $nodeContainer.not(":empty").length;
  }
  _getItem($node) {
    return $node.children(`.${ITEM_CLASS3}`).eq(0);
  }
  _createLoadIndicator($node) {
    const $treeviewItem = this._getItem($node);
    this._createComponent(renderer_default("<div>").addClass(NODE_LOAD_INDICATOR_CLASS), load_indicator_default, {}).$element().appendTo($treeviewItem);
    const $icon = $treeviewItem.children(`.${TOGGLE_ITEM_VISIBILITY_CLASS},.${CUSTOM_EXPAND_ICON_CLASS}`);
    $icon.hide();
  }
  _renderExpanderIcon($node, node, $icon, iconClass) {
    $icon.appendTo(this._getItem($node));
    $icon.addClass(iconClass);
    if (node.internalFields.disabled) {
      $icon.addClass("dx-state-disabled");
    }
    this._renderToggleItemVisibilityIconClick($icon, node);
  }
  _renderDefaultExpanderIcons($node, node) {
    const $treeViewItem = this._getItem($node);
    const $icon = renderer_default("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($treeViewItem);
    if (node.internalFields.expanded) {
      $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
      $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
    }
    if (node.internalFields.disabled) {
      $icon.addClass("dx-state-disabled");
    }
    this._renderToggleItemVisibilityIconClick($icon, node);
  }
  _renderCustomExpanderIcons($node, node) {
    const {
      expandIcon,
      collapseIcon
    } = this.option();
    const $expandIcon = getImageContainer(expandIcon ?? collapseIcon);
    const $collapseIcon = getImageContainer(collapseIcon ?? expandIcon);
    this._renderExpanderIcon($node, node, $expandIcon, CUSTOM_EXPAND_ICON_CLASS);
    this._renderExpanderIcon($node, node, $collapseIcon, CUSTOM_COLLAPSE_ICON_CLASS);
    const isNodeExpanded = node.internalFields.expanded;
    if (isNodeExpanded) {
      $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
    }
    this._toggleCustomExpanderIcons($expandIcon, $collapseIcon, isNodeExpanded);
  }
  _renderToggleItemVisibilityIconClick($icon, node) {
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    m_events_engine_default.off($icon, eventName);
    m_events_engine_default.on($icon, eventName, ((e) => {
      this._toggleExpandedState(node.internalFields.key, void 0, e);
      return false;
    }));
  }
  _toggleCustomExpanderIcons($expandIcon, $collapseIcon, isNodeExpanded) {
    $collapseIcon.toggle(isNodeExpanded);
    $expandIcon.toggle(!isNodeExpanded);
  }
  _updateExpandedItemsUI(node, state, e) {
    const $node = this._getNodeElement(node);
    const isHiddenNode = !$node.length || state && $node.is(":hidden");
    if (this.option("expandNodesRecursive") && isHiddenNode) {
      const parentNode = this._getNode(node.internalFields.parentKey);
      if (parentNode) {
        this._updateExpandedItemsUI(parentNode, state, e);
      }
    }
    if (!this._hasCustomExpanderIcons()) {
      const $icon = this._getItem($node).children(`.${TOGGLE_ITEM_VISIBILITY_CLASS}`);
      $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
    } else if (this._nodeHasRenderedChildren($node)) {
      const $item = this._getItem($node);
      const $childExpandIcons = $item.children(`.${CUSTOM_EXPAND_ICON_CLASS}`);
      const $childCollapseIcons = $item.children(`.${CUSTOM_COLLAPSE_ICON_CLASS}`);
      this._toggleCustomExpanderIcons($childExpandIcons, $childCollapseIcons, state);
    }
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    const nodeContainerExists = $nodeContainer.length > 0;
    const completionCallback = Deferred();
    if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
      this._animateNodeContainer(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    if (0 === node.internalFields.childrenKeys.length && (this._isVirtualMode() || this._useCustomChildrenLoader())) {
      this._loadNestedItemsWithUpdate(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    this._renderSublevel($node, node, this._getChildNodes(node));
    this._fireContentReadyAction();
    this._animateNodeContainer(node, state, e, completionCallback);
    return completionCallback.promise();
  }
  _loadNestedItemsWithUpdate(node, state, e, completionCallback) {
    const $node = this._getNodeElement(node);
    this._loadNestedItems(node).done(((items) => {
      const actualNodeData = this._getActualNode(node);
      this._renderSublevel($node, actualNodeData, this._dataAdapter.getNodesByItems(items));
      if (!items || !items.length) {
        completionCallback.resolve();
        return;
      }
      this._fireContentReadyAction();
      this._animateNodeContainer(actualNodeData, state, e, completionCallback);
    }));
  }
  _loadNestedItems(node) {
    if (this._useCustomChildrenLoader()) {
      const publicNode = this._dataAdapter.getPublicNode(node);
      return this._loadChildrenByCustomLoader(publicNode).done(((newItems) => {
        if (!this._areNodesExists(newItems)) {
          this._appendItems(newItems);
        }
      }));
    }
    if (!this._isVirtualMode()) {
      return Deferred().resolve([]).promise();
    }
    this._filter.internal = [this.option("parentIdExpr"), node.internalFields.key];
    this._dataSource.filter(this._combineFilter());
    return this._dataSource.load().done(((newItems) => {
      if (!this._areNodesExists(newItems)) {
        this._appendItems(newItems);
      }
    }));
  }
  _areNodesExists(newItems) {
    const keyOfRootItem = this.keyOf(newItems[0]);
    const fullData = this._dataAdapter.getFullData();
    return !!this._dataAdapter.getNodeByKey(keyOfRootItem, fullData);
  }
  _appendItems(newItems) {
    const {
      items = []
    } = this.option();
    this.option().items = items.concat(newItems);
    this._initDataAdapter();
  }
  _animateNodeContainer(node, state, e, completionCallback) {
    const $node = this._getNodeElement(node);
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    if (node && completionCallback && 0 === $nodeContainer.length) {
      completionCallback.resolve();
    }
    $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    const nodeHeight = getHeight($nodeContainer);
    fx_default.stop($nodeContainer, true);
    fx_default.animate($nodeContainer, {
      type: "custom",
      duration: this.option("animationEnabled") ? 400 : 0,
      from: {
        maxHeight: state ? 0 : nodeHeight
      },
      to: {
        maxHeight: state ? nodeHeight : 0
      },
      complete: (function() {
        $nodeContainer.css("maxHeight", "none");
        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
        this.setAria("expanded", state, $node);
        this.getScrollable().update();
        this._fireExpandedStateUpdatedEvent(state, node, e);
        if (completionCallback) {
          completionCallback.resolve();
        }
      }).bind(this)
    });
  }
  _fireExpandedStateUpdatedEvent(isExpanded, node, e) {
    if (!this._hasChildren(node) || this._skipContentReadyAndItemExpanded) {
      return;
    }
    const optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
    if (isDefined(e)) {
      this._itemDXEventHandler(e, optionName, {
        node: this._dataAdapter.getPublicNode(node)
      });
    } else {
      const target = this._getNodeElement(node);
      this._itemEventHandler(target, optionName, {
        event: e,
        node: this._dataAdapter.getPublicNode(node)
      });
    }
  }
  _normalizeIconState($node, hasNewItems) {
    const $loadIndicator = $node.find(`.${NODE_LOAD_INDICATOR_CLASS}`);
    if ($loadIndicator.length) {
      var _LoadIndicator$getIns;
      null === (_LoadIndicator$getIns = load_indicator_default.getInstance($loadIndicator)) || void 0 === _LoadIndicator$getIns || _LoadIndicator$getIns.option("visible", false);
    }
    const $treeViewItem = this._getItem($node);
    const $toggleItem = $treeViewItem.children(`.${CUSTOM_COLLAPSE_ICON_CLASS},.${TOGGLE_ITEM_VISIBILITY_CLASS}`);
    if (hasNewItems) {
      $toggleItem.show();
      return;
    }
    $toggleItem.removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
    $node.addClass(IS_LEAF);
  }
  _emptyMessageContainer() {
    const scrollable = this.getScrollable();
    return scrollable ? renderer_default(scrollable.content()) : super._emptyMessageContainer();
  }
  _renderContent() {
    const {
      items
    } = this.option();
    if (items && items.length) {
      this._contentAlreadyRendered = true;
    }
    super._renderContent();
  }
  _renderSelectAllItem($container) {
    const {
      selectAllText,
      focusStateEnabled
    } = this.option();
    $container = $container || this.$element().find(`.${NODE_CONTAINER_CLASS}`).first();
    this._$selectAllItem = renderer_default("<div>").addClass(SELECT_ALL_ITEM_CLASS);
    const value2 = this._dataAdapter.isAllSelected();
    this._createComponent(this._$selectAllItem, check_box_default2, {
      value: value2,
      elementAttr: {
        "aria-label": message_default.format("dxList-selectAll")
      },
      text: selectAllText,
      focusStateEnabled,
      onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this),
      onInitialized: (_ref) => {
        let {
          component
        } = _ref;
        component.registerKeyHandler("enter", (() => {
          component.option("value", !component.option("value"));
        }));
      }
    });
    this._toggleSelectedClass(this._$selectAllItem, value2);
    $container.before(this._$selectAllItem);
  }
  _onSelectAllCheckboxValueChanged(args) {
    this._toggleSelectAll(args);
    this._fireSelectAllValueChanged(args.value);
  }
  _toggleSelectAll(args) {
    this._dataAdapter.toggleSelectAll(args.value);
    this._updateItemsUI();
    this._fireSelectionChanged();
  }
  _renderCheckBox($node, node) {
    const $checkbox = renderer_default("<div>").appendTo($node);
    this._createComponent($checkbox, check_box_default2, {
      value: node.internalFields.selected,
      onValueChanged: this._changeCheckboxValue.bind(this),
      focusStateEnabled: false,
      elementAttr: {
        "aria-label": message_default.format("CheckState")
      },
      disabled: this._disabledGetter(node)
    });
  }
  _toggleSelectedClass($node, value2) {
    $node.toggleClass("dx-state-selected", !!value2);
  }
  _toggleNodeDisabledState(node, state) {
    const $node = this._getNodeElement(node);
    const $item = $node.find(`.${ITEM_CLASS3}`).eq(0);
    this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
    $item.toggleClass("dx-state-disabled", !!state);
    if (this._showCheckboxes()) {
      const checkbox = this._getCheckBoxInstance($node);
      checkbox.option("disabled", !!state);
    }
  }
  _itemOptionChanged(item, property, value2) {
    const node = this._dataAdapter.getNodeByItem(item);
    if (property === this.option("disabledExpr")) {
      this._toggleNodeDisabledState(node, value2);
    }
  }
  _changeCheckboxValue(e) {
    const $node = renderer_default(e.element).closest(`.${NODE_CLASS}`);
    const $item = this._getItem($node);
    const item = this._getItemData($item);
    const node = this._getNodeByElement($item);
    const {
      value: value2
    } = e;
    if (node && node.internalFields.selected === value2) {
      return;
    }
    this._updateItemSelection(value2, item, e.event);
  }
  _isSingleSelection() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _isRecursiveSelection() {
    const {
      selectionMode
    } = this.option();
    return this.option("selectNodesRecursive") && "single" !== selectionMode;
  }
  _isLastSelectedBranch(publicNode, selectedNodesKeys, deep) {
    const keyIndex = selectedNodesKeys.indexOf(publicNode.key);
    if (keyIndex >= 0) {
      selectedNodesKeys.splice(keyIndex, 1);
    }
    if (deep) {
      each(publicNode.children, ((_, childNode) => {
        this._isLastSelectedBranch(childNode, selectedNodesKeys, true);
      }));
    }
    if (publicNode.parent) {
      this._isLastSelectedBranch(publicNode.parent, selectedNodesKeys);
    }
    return 0 === selectedNodesKeys.length;
  }
  _isLastRequired(node) {
    const selectionRequired = this.option("selectionRequired");
    const isSingleMode = this._isSingleSelection();
    const selectedNodesKeys = this.getSelectedNodeKeys();
    if (!selectionRequired) {
      return;
    }
    if (isSingleMode) {
      return 1 === selectedNodesKeys.length;
    }
    return this._isLastSelectedBranch(node.internalFields.publicNode, selectedNodesKeys.slice(), true);
  }
  _updateItemSelection(value2, itemElement, dxEvent) {
    const node = this._getNode(itemElement);
    if (!node || false === node.visible) {
      return false;
    }
    if (node.internalFields.selected === value2) {
      return true;
    }
    if (!value2 && this._isLastRequired(node)) {
      if (this._showCheckboxes()) {
        const $node = this._getNodeElement(node);
        this._getCheckBoxInstance($node).option("value", true);
      }
      return false;
    }
    if (value2 && this._isSingleSelection()) {
      const selectedKeys = this.getSelectedNodeKeys();
      each(selectedKeys, ((index, key) => {
        this._dataAdapter.toggleSelection(key, false);
        this._updateItemsUI();
        this._fireItemSelectionChanged(this._getNode(key));
      }));
    }
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
    const isAllSelected = this._dataAdapter.isAllSelected();
    const needFireSelectAllChanged = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== isAllSelected;
    this._updateItemsUI();
    this._fireItemSelectionChanged(node, dxEvent);
    this._fireSelectionChanged();
    if (needFireSelectAllChanged) {
      this._fireSelectAllValueChanged(isAllSelected);
    }
    return true;
  }
  _fireItemSelectionChanged(node, dxEvent) {
    const initiator = dxEvent || this._findItemElementByItem(node.internalFields.item);
    const handler = dxEvent ? this._itemDXEventHandler : this._itemEventHandler;
    handler.call(this, initiator, "onItemSelectionChanged", {
      node: this._dataAdapter.getPublicNode(node),
      itemData: node.internalFields.item
    });
  }
  _getCheckBoxInstance($node) {
    const $treeViewItem = this._getItem($node);
    return $treeViewItem.children(".dx-checkbox").dxCheckBox("instance");
  }
  _updateItemsUI() {
    const cache = {};
    each(this._dataAdapter.getData(), ((_, node) => {
      const $node = this._getNodeElement(node, cache);
      const nodeSelection = node.internalFields.selected;
      if (!$node.length) {
        return;
      }
      this._toggleSelectedClass($node, nodeSelection);
      this.setAria("selected", nodeSelection, $node);
      if (this._showCheckboxes()) {
        var _this$_getCheckBoxIns;
        null === (_this$_getCheckBoxIns = this._getCheckBoxInstance($node)) || void 0 === _this$_getCheckBoxIns || _this$_getCheckBoxIns.option("value", nodeSelection);
      }
    }));
    if (this._selectAllEnabled()) {
      const selectAllCheckbox = this._$selectAllItem.dxCheckBox("instance");
      selectAllCheckbox.option("onValueChanged", void 0);
      selectAllCheckbox.option("value", this._dataAdapter.isAllSelected());
      selectAllCheckbox.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this));
    }
  }
  _updateParentsState(node, $node) {
    if (!$node) {
      return;
    }
    const parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
    const $parentNode = renderer_default($node.parents(`.${NODE_CLASS}`)[0]);
    if (this._showCheckboxes()) {
      var _this$_getCheckBoxIns2;
      const parentValue = parentNode.internalFields.selected;
      null === (_this$_getCheckBoxIns2 = this._getCheckBoxInstance($parentNode)) || void 0 === _this$_getCheckBoxIns2 || _this$_getCheckBoxIns2.option("value", parentValue);
      this._toggleSelectedClass($parentNode, parentValue);
    }
    if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
      this._updateParentsState(parentNode, $parentNode);
    }
  }
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = renderer_default(initiator).closest(`.${NODE_CLASS}`).children(`.${ITEM_CLASS3}`);
    return action(extend(this._extendActionArgs($itemElement), actionArgs));
  }
  _itemContextMenuHandler(e) {
    this._createEventHandler("onItemContextMenu", e);
  }
  _itemHoldHandler(e) {
    this._createEventHandler("onItemHold", e);
  }
  _createEventHandler(eventName, e) {
    const node = this._getNodeByElement(e.currentTarget);
    this._itemDXEventHandler(e, eventName, {
      node: this._dataAdapter.getPublicNode(node)
    });
  }
  _itemClass() {
    return ITEM_CLASS3;
  }
  _itemDataKey() {
    return ITEM_DATA_KEY;
  }
  _attachClickEvent() {
    const $itemContainer = this._itemContainer();
    this._detachClickEvent($itemContainer);
    const {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    } = this._getItemClickEventData();
    m_events_engine_default.on($itemContainer, clickEventNamespace, itemSelector, ((e) => {
      if (renderer_default(e.target).hasClass("dx-checkbox-icon") || renderer_default(e.target).hasClass("dx-checkbox")) {
        return;
      }
      this._itemClickHandler(e, renderer_default(e.currentTarget));
    }));
    m_events_engine_default.on($itemContainer, pointerDownEventNamespace, nodeSelector, ((e) => {
      this._itemPointerHandler(e);
    }));
  }
  _detachClickEvent(itemsContainer) {
    const {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    } = this._getItemClickEventData();
    m_events_engine_default.off(itemsContainer, clickEventNamespace, itemSelector);
    m_events_engine_default.off(itemsContainer, pointerDownEventNamespace, nodeSelector);
  }
  _getItemClickEventData() {
    const itemSelector = `.${this._itemClass()}`;
    const nodeSelector = `.${NODE_CLASS}, .${SELECT_ALL_ITEM_CLASS}`;
    const clickEventNamespace = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const pointerDownEventNamespace = addNamespace(m_pointer_default.down, this.NAME);
    return {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    };
  }
  _itemClick(actionArgs) {
    const {
      event,
      itemData
    } = actionArgs.args[0];
    const target = event.target[0] || event.target;
    const link = target.getElementsByClassName("dx-item-url")[0];
    if (itemData.url && link) {
      this._clickByLink(link);
    }
  }
  _itemClickHandler(e, $item) {
    const itemData = this._getItemData($item);
    const node = this._getNodeByElement($item);
    this._itemDXEventHandler(e, "onItemClick", {
      node: this._dataAdapter.getPublicNode(node)
    }, {
      beforeExecute: this._itemClick
    });
    if (this.option("selectByClick") && !e.isDefaultPrevented()) {
      this._updateItemSelection(!node.internalFields.selected, itemData, e);
    }
  }
  _updateSelectionToFirstItem($items, startIndex) {
    let itemIndex = startIndex;
    while (itemIndex >= 0) {
      const $item = renderer_default($items[itemIndex]);
      this._updateItemSelection(true, $item.find(`.${ITEM_CLASS3}`).get(0));
      itemIndex--;
    }
  }
  _updateSelectionToLastItem($items, startIndex) {
    const {
      length
    } = $items;
    let itemIndex = startIndex;
    while (itemIndex < length) {
      const $item = renderer_default($items[itemIndex]);
      this._updateItemSelection(true, $item.find(`.${ITEM_CLASS3}`).get(0));
      itemIndex++;
    }
  }
  focus() {
    const {
      items = []
    } = this.option();
    if (this._selectAllEnabled() && items.length) {
      m_events_engine_default.trigger(this._$selectAllItem, "focus");
      return;
    }
    super.focus();
  }
  _focusInHandler(e) {
    this._updateFocusState(e, true);
    const isSelectAllItem = renderer_default(e.target).hasClass(SELECT_ALL_ITEM_CLASS);
    if (isSelectAllItem || this.option("focusedElement")) {
      clearTimeout(this._setFocusedItemTimeout);
      this._setFocusedItemTimeout = setTimeout((() => {
        const {
          focusedElement
        } = this.option();
        const element = isSelectAllItem ? getPublicElement(this._$selectAllItem) : renderer_default(focusedElement);
        this._setFocusedItem(element);
      }));
      return;
    }
    const $activeItem = this._getActiveItem();
    this.option("focusedElement", getPublicElement($activeItem.closest(`.${NODE_CLASS}`)));
  }
  _itemPointerHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    const $target = renderer_default(e.target).closest(`.${NODE_CLASS}, .${SELECT_ALL_ITEM_CLASS}`);
    if (!$target.length) {
      return;
    }
    const itemElement = $target.hasClass("dx-state-disabled") ? null : $target;
    this.option("focusedElement", getPublicElement(itemElement));
  }
  _findNonDisabledNodes($nodes) {
    return $nodes.not((function() {
      return renderer_default(this).children(`.${ITEM_CLASS3}`).hasClass("dx-state-disabled");
    }));
  }
  _moveFocus(location, e) {
    const FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left";
    const FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
    this.$element().find(`.${NODE_CONTAINER_CLASS}`).each((function() {
      fx_default.stop(this, true);
    }));
    const $items = this._nodeElements();
    if (!$items || !$items.length) {
      return;
    }
    switch (location) {
      case "up": {
        const $prevItem = this._prevItem($items);
        this.option("focusedElement", getPublicElement($prevItem));
        const prevItemElement = this._getNodeItemElement($prevItem);
        this.getScrollable().scrollToElement(prevItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, prevItemElement);
        }
        break;
      }
      case "down": {
        const $nextItem = this._nextItem($items);
        this.option("focusedElement", getPublicElement($nextItem));
        const nextItemElement = this._getNodeItemElement($nextItem);
        this.getScrollable().scrollToElement(nextItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, nextItemElement);
        }
        break;
      }
      case "first": {
        const $firstItem = $items.first();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
        }
        this.option("focusedElement", getPublicElement($firstItem));
        this.getScrollable().scrollToElement(this._getNodeItemElement($firstItem));
        break;
      }
      case "last": {
        const $lastItem = $items.last();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
        }
        this.option("focusedElement", getPublicElement($lastItem));
        this.getScrollable().scrollToElement(this._getNodeItemElement($lastItem));
        break;
      }
      case FOCUS_RIGHT:
        this._expandFocusedContainer();
        break;
      case FOCUS_LEFT:
        this._collapseFocusedContainer();
        break;
      default:
        super._moveFocus.apply(this, arguments);
    }
  }
  _getNodeItemElement($node) {
    return $node.find(`.${ITEM_CLASS3}`).get(0);
  }
  _nodeElements() {
    return this.$element().find(`.${NODE_CLASS}`).not(":hidden");
  }
  _expandFocusedContainer() {
    const {
      focusedElement
    } = this.option();
    const $focusedNode = renderer_default(focusedElement);
    if (!$focusedNode.length || $focusedNode.hasClass(IS_LEAF)) {
      return;
    }
    const $node = $focusedNode.find(`.${NODE_CONTAINER_CLASS}`).eq(0);
    if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      const $nextItem = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
      this.option("focusedElement", getPublicElement($nextItem));
      this.getScrollable().scrollToElement(this._getNodeItemElement($nextItem));
      return;
    }
    const node = this._getNodeByElement(this._getItem($focusedNode));
    this._toggleExpandedState(node, true);
  }
  _getClosestNonDisabledNode($node) {
    do {
      $node = $node.parent().closest(`.${NODE_CLASS}`);
    } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
    return $node;
  }
  _collapseFocusedContainer() {
    const {
      focusedElement
    } = this.option();
    const $focusedNode = renderer_default(focusedElement);
    if (!$focusedNode.length) {
      return;
    }
    const nodeElement = $focusedNode.find(`.${NODE_CONTAINER_CLASS}`).eq(0);
    if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      const node = this._getNodeByElement(this._getItem($focusedNode));
      this._toggleExpandedState(node, false);
    } else {
      const collapsedNode = this._getClosestNonDisabledNode($focusedNode);
      collapsedNode.length && this.option("focusedElement", getPublicElement(collapsedNode));
      this.getScrollable().scrollToElement(this._getNodeItemElement(collapsedNode));
    }
  }
  _encodeString(value2) {
    return isString(value2) ? encodeURI(value2) : value2;
  }
  _decodeString(value2) {
    return isString(value2) ? decodeURI(value2) : value2;
  }
  getScrollable() {
    return this._scrollable;
  }
  updateDimensions() {
    const deferred = Deferred();
    const scrollable = this.getScrollable();
    if (scrollable) {
      scrollable.update().done((() => {
        deferred.resolveWith(this);
      }));
    } else {
      deferred.resolveWith(this);
    }
    return deferred.promise();
  }
  selectItem(itemElement) {
    return this._updateItemSelection(true, itemElement);
  }
  unselectItem(itemElement) {
    return this._updateItemSelection(false, itemElement);
  }
  expandItem(itemElement) {
    return this._toggleExpandedState(itemElement, true);
  }
  collapseItem(itemElement) {
    return this._toggleExpandedState(itemElement, false);
  }
  getNodes() {
    return this._dataAdapter.getTreeNodes();
  }
  getSelectedNodes() {
    return this.getSelectedNodeKeys().map(((key) => {
      const node = this._dataAdapter.getNodeByKey(key);
      return this._dataAdapter.getPublicNode(node);
    }));
  }
  getSelectedNodeKeys() {
    return this._dataAdapter.getSelectedNodesKeys();
  }
  selectAll() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", true);
    } else {
      this._toggleSelectAll({
        value: true
      });
    }
  }
  unselectAll() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", false);
    } else {
      this._toggleSelectAll({
        value: false
      });
    }
  }
  _allItemsExpandedHandler() {
    this._skipContentReadyAndItemExpanded = false;
    this._fireContentReadyAction();
  }
  expandAll() {
    const nodes = this._dataAdapter.getData();
    const expandingPromises = [];
    this._skipContentReadyAndItemExpanded = true;
    nodes.forEach(((node) => expandingPromises.push(this._toggleExpandedState(node.internalFields.key, true))));
    Promise.allSettled(expandingPromises).then((() => {
      var _this$_allItemsExpand;
      return null === (_this$_allItemsExpand = this._allItemsExpandedHandler) || void 0 === _this$_allItemsExpand ? void 0 : _this$_allItemsExpand.call(this);
    }));
  }
  collapseAll() {
    each(this._dataAdapter.getExpandedNodesKeys(), ((_, key) => {
      this._toggleExpandedState(key, false);
    }));
  }
  scrollToItem(keyOrItemOrElement) {
    const node = this._getNode(keyOrItemOrElement);
    if (!node) {
      return Deferred().reject().promise();
    }
    const nodeKeysToExpand = [];
    let parentNode = node.internalFields.publicNode.parent;
    while (null != parentNode) {
      if (!parentNode.expanded) {
        nodeKeysToExpand.push(parentNode.key);
      }
      parentNode = parentNode.parent;
    }
    const scrollCallback = Deferred();
    this._expandNodes(nodeKeysToExpand.reverse()).always((() => {
      const $element = this._getNodeElement(node);
      if ($element && $element.length) {
        this.scrollToElementTopLeft($element.get(0));
        scrollCallback.resolve();
      } else {
        scrollCallback.reject();
      }
    }));
    return scrollCallback.promise();
  }
  scrollToElementTopLeft(targetElement) {
    const scrollable = this.getScrollable();
    const {
      scrollDirection,
      rtlEnabled
    } = this.option();
    const targetLocation = {
      top: 0,
      left: 0
    };
    const relativeOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement);
    if (scrollDirection !== DIRECTION_VERTICAL) {
      const containerElement = renderer_default(scrollable.container()).get(0);
      targetLocation.left = rtlEnabled ? relativeOffset.left + targetElement.offsetWidth - containerElement.clientWidth : relativeOffset.left;
    }
    if (scrollDirection !== DIRECTION_HORIZONTAL) {
      targetLocation.top = relativeOffset.top;
    }
    scrollable.scrollTo(targetLocation);
  }
  _expandNodes(keysToExpand) {
    if (!keysToExpand || 0 === keysToExpand.length) {
      return Deferred().resolve().promise();
    }
    const resultCallback = Deferred();
    const callbacksByNodes = keysToExpand.map(((key) => this.expandItem(key)));
    when.apply(renderer_default, callbacksByNodes).done((() => resultCallback.resolve())).fail((() => resultCallback.reject()));
    return resultCallback.promise();
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._setFocusedItemTimeout);
    this._allItemsExpandedHandler = null;
  }
};
var m_tree_view_base_default = TreeViewBase;

// node_modules/devextreme/esm/__internal/ui/tree_view/m_tree_view.search.js
ui_search_box_mixin_default.setEditorClass(text_box_default2);
var WIDGET_CLASS2 = "dx-treeview";
var NODE_CONTAINER_CLASS2 = `${WIDGET_CLASS2}-node-container`;
var TreeViewSearch = m_tree_view_base_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `${WIDGET_CLASS2}-${className}`,
  _optionChanged(args) {
    switch (args.name) {
      case "searchValue":
        if (this._showCheckboxes() && this._isRecursiveSelection()) {
          this._removeSelection();
        }
        this._initDataAdapter();
        this._updateSearch();
        this._repaintContainer();
        this.option("focusedElement", null);
        break;
      case "searchExpr":
        this._initDataAdapter();
        this.repaint();
        break;
      case "searchMode":
        this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter();
        this.repaint();
        break;
      default:
        this.callBase(args);
    }
  },
  _updateDataAdapter() {
    this._setOptionWithoutOptionChange("expandNodesRecursive", false);
    this._initDataAdapter();
    this._setOptionWithoutOptionChange("expandNodesRecursive", true);
  },
  _getDataAdapterOptions() {
    return extend(this.callBase(), {
      searchValue: this.option("searchValue"),
      searchMode: this.option("searchMode") || "contains",
      searchExpr: this.option("searchExpr")
    });
  },
  _getNodeContainer() {
    return this.$element().find(`.${NODE_CONTAINER_CLASS2}`).first();
  },
  _updateSearch() {
    if (this._searchEditor) {
      const editorOptions = this._getSearchEditorOptions();
      this._searchEditor.option(editorOptions);
    }
  },
  _repaintContainer() {
    const $container = this._getNodeContainer();
    let rootNodes;
    if ($container.length) {
      $container.empty();
      rootNodes = this._dataAdapter.getRootNodes();
      this._renderEmptyMessage(rootNodes);
      this._renderItems($container, rootNodes);
      this._fireContentReadyAction();
    }
  },
  _focusTarget() {
    return this._itemContainer(this.option("searchEnabled"));
  },
  _cleanItemContainer() {
    this.$element().empty();
  },
  _itemContainer(isSearchMode, selectAllEnabled) {
    selectAllEnabled ?? (selectAllEnabled = this._selectAllEnabled());
    const {
      items = []
    } = this.option();
    if (selectAllEnabled && items.length) {
      return this._getNodeContainer();
    }
    if (this._scrollable && isSearchMode) {
      return renderer_default(this._scrollable.content());
    }
    return this.callBase();
  },
  _addWidgetClass() {
    this.$element().addClass(this._widgetClass());
  },
  _clean() {
    this.callBase();
    this._removeSearchBox();
  }
});
component_registrator_default("dxTreeView", TreeViewSearch);
var m_tree_view_search_default = TreeViewSearch;

// node_modules/devextreme/esm/ui/tree_view.js
var tree_view_default = m_tree_view_search_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/column_chooser/m_column_chooser.js
var COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag";
var COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select";
var COLUMN_OPTIONS_USED_IN_ITEMS = ["showInColumnChooser", "caption", "allowHiding", "visible", "cssClass", "ownerBand"];
var processItems = function(that, chooserColumns) {
  const items = [];
  const isSelectMode = that.isSelectMode();
  const isRecursive = that.option("columnChooser.selection.recursive");
  if (chooserColumns.length) {
    each(chooserColumns, ((index, column) => {
      const item = {
        text: column.caption,
        cssClass: column.cssClass,
        allowHiding: column.allowHiding,
        expanded: true,
        id: column.index,
        disabled: false === column.allowHiding,
        parentId: isDefined(column.ownerBand) ? column.ownerBand : null
      };
      const isRecursiveWithColumns = isRecursive && column.hasColumns;
      if (isSelectMode && !isRecursiveWithColumns) {
        item.selected = column.visible;
      }
      items.push(item);
    }));
  }
  return items;
};
var ColumnChooserController = class extends m_modules_default.ViewController {
  init() {
    super.init();
    this._rowsView = this.getView("rowsView");
  }
  renderShowColumnChooserButton($element) {
    const that = this;
    const columnChooserButtonClass = that.addWidgetPrefix("column-chooser-button");
    const columnChooserEnabled = that.option("columnChooser.enabled");
    const $showColumnChooserButton = $element.find(`.${columnChooserButtonClass}`);
    let $columnChooserButton;
    if (columnChooserEnabled) {
      if (!$showColumnChooserButton.length) {
        $columnChooserButton = renderer_default("<div>").addClass(columnChooserButtonClass).appendTo($element);
        that._createComponent($columnChooserButton, button_default2, {
          icon: "column-chooser",
          onClick() {
            that.getView("columnChooserView").showColumnChooser();
          },
          hint: that.option("columnChooser.title"),
          integrationOptions: {}
        });
      } else {
        $showColumnChooserButton.show();
      }
    } else {
      $showColumnChooserButton.hide();
    }
  }
  getPosition() {
    const position2 = this.option("columnChooser.position");
    return isDefined(position2) ? position2 : {
      my: "right bottom",
      at: "right bottom",
      of: this._rowsView && this._rowsView.element(),
      collision: "fit",
      offset: "-2 -2",
      boundaryOffset: "2 2"
    };
  }
};
var ColumnChooserView = class extends ColumnsView {
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._initializePopupContainer();
      this.render(null, "full");
    } else {
      super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["showColumnChooser", "hideColumnChooser"];
  }
  _resizeCore() {
  }
  _isWinDevice() {
    return !!devices_default.real().win;
  }
  _initializePopupContainer() {
    const that = this;
    const columnChooserClass = that.addWidgetPrefix("column-chooser");
    const $element = that.element().addClass(columnChooserClass);
    const columnChooserOptions = that.option("columnChooser");
    const popupPosition = this._columnChooserController.getPosition();
    const themeName = current();
    const isGenericTheme = isGeneric(themeName);
    const isMaterial2 = isMaterial(themeName);
    const dxPopupOptions = {
      visible: false,
      shading: false,
      showCloseButton: false,
      dragEnabled: true,
      resizeEnabled: true,
      wrapperAttr: {
        class: columnChooserClass
      },
      toolbarItems: [{
        text: columnChooserOptions.title,
        toolbar: "top",
        location: isGenericTheme || isMaterial2 ? "before" : "center"
      }],
      position: popupPosition,
      width: columnChooserOptions.width,
      height: columnChooserOptions.height,
      rtlEnabled: that.option("rtlEnabled"),
      onHidden() {
        if (that._isWinDevice()) {
          renderer_default("body").removeClass(that.addWidgetPrefix("notouch-action"));
        }
      },
      container: columnChooserOptions.container,
      _loopFocus: true
    };
    if (isGenericTheme || isMaterial2) {
      extend(dxPopupOptions, {
        showCloseButton: true
      });
    } else {
      dxPopupOptions.toolbarItems[dxPopupOptions.toolbarItems.length] = {
        shortcut: "cancel"
      };
    }
    if (!isDefined(this._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
      that._popupContainer.on("optionChanged", ((args) => {
        if ("visible" === args.name) {
          that.renderCompleted.fire();
        }
      }));
    } else {
      this._popupContainer.option(dxPopupOptions);
    }
    this.setPopupAttributes();
  }
  setPopupAttributes() {
    const isSelectMode = this.isSelectMode();
    const isBandColumnsUsed = this._columnsController.isBandColumnsUsed();
    this._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-columnChooserTitle")
    });
    this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
    this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-list"));
    if (isSelectMode && !isBandColumnsUsed) {
      this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-plain"));
    }
  }
  _renderCore(change) {
    if (this._popupContainer) {
      const isDragMode = !this.isSelectMode();
      if (!this._columnChooserList || "full" === change) {
        this._renderTreeView();
      } else if (isDragMode) {
        this._updateItems();
      }
    }
  }
  _renderTreeView() {
    var _columnChooser$search, _columnChooser$search2, _columnChooser$search3;
    const that = this;
    const $container = this._popupContainer.$content();
    const columnChooser = this.option("columnChooser");
    const isSelectMode = this.isSelectMode();
    const searchEnabled = isDefined(columnChooser.allowSearch) ? columnChooser.allowSearch : null === (_columnChooser$search = columnChooser.search) || void 0 === _columnChooser$search ? void 0 : _columnChooser$search.enabled;
    const searchTimeout = isDefined(columnChooser.searchTimeout) ? columnChooser.searchTimeout : null === (_columnChooser$search2 = columnChooser.search) || void 0 === _columnChooser$search2 ? void 0 : _columnChooser$search2.timeout;
    const treeViewConfig = {
      dataStructure: "plain",
      activeStateEnabled: true,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      itemTemplate: "item",
      showCheckBoxesMode: "none",
      rootValue: null,
      searchEnabled,
      searchTimeout,
      searchEditorOptions: null === (_columnChooser$search3 = columnChooser.search) || void 0 === _columnChooser$search3 ? void 0 : _columnChooser$search3.editorOptions
    };
    if (this._isWinDevice()) {
      treeViewConfig.useNativeScrolling = false;
    }
    extend(treeViewConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
    if (this._columnChooserList) {
      if (!treeViewConfig.searchEnabled) {
        treeViewConfig.searchValue = "";
      }
      this._columnChooserList.option(treeViewConfig);
      this._updateItems();
    } else {
      this._columnChooserList = this._createComponent($container, tree_view_default, treeViewConfig);
      this._updateItems();
      let scrollTop = 0;
      this._columnChooserList.on("optionChanged", ((e) => {
        const scrollable = e.component.getScrollable();
        scrollTop = scrollable.scrollTop();
      }));
      this._columnChooserList.on("contentReady", ((e) => {
        deferUpdate((() => {
          const scrollable = e.component.getScrollable();
          scrollable.scrollTo({
            y: scrollTop
          });
          that.renderCompleted.fire();
        }));
      }));
    }
  }
  _prepareDragModeConfig() {
    const columnChooserOptions = this.option("columnChooser");
    return {
      noDataText: columnChooserOptions.emptyPanelText,
      activeStateEnabled: false,
      hoverStateEnabled: false,
      itemTemplate(data17, index, item) {
        renderer_default(item).text(data17.text).parent().addClass(data17.cssClass).addClass("dx-column-chooser-item");
      }
    };
  }
  _prepareSelectModeConfig() {
    const that = this;
    const selectionOptions = this.option("columnChooser.selection") ?? {};
    let isUpdatingSelection = false;
    return {
      selectByClick: selectionOptions.selectByClick,
      selectNodesRecursive: selectionOptions.recursive,
      showCheckBoxesMode: selectionOptions.allowSelectAll ? "selectAll" : "normal",
      onSelectionChanged: (e) => {
        if (isUpdatingSelection) {
          return;
        }
        const nodes = ((nodes2) => {
          const addNodesToArray = (nodes3, flatNodesArray) => nodes3.reduce(((result2, node) => {
            result2.push(node);
            if (node.children.length) {
              addNodesToArray(node.children, result2);
            }
            return result2;
          }), flatNodesArray);
          return addNodesToArray(nodes2, []);
        })(e.component.getNodes());
        e.component.beginUpdate();
        isUpdatingSelection = true;
        ((e2, nodes2) => {
          nodes2.filter(((node) => false === node.itemData.allowHiding)).forEach(((node) => e2.component.selectItem(node.key)));
        })(e, nodes);
        e.component.endUpdate();
        isUpdatingSelection = false;
        that.component.beginUpdate();
        this._isUpdatingColumnVisibility = true;
        ((nodes2) => {
          nodes2.forEach(((node) => {
            const columnIndex = node.itemData.id;
            const isVisible = false !== node.selected;
            that._columnsController.columnOption(columnIndex, "visible", isVisible);
          }));
        })(nodes);
        that.component.endUpdate();
        this._isUpdatingColumnVisibility = false;
      }
    };
  }
  _updateItems() {
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const items = processItems(this, chooserColumns);
    this._columnChooserList.option("items", items);
  }
  _updateItemsSelection(columnIndices) {
    const changedColumns = null === columnIndices || void 0 === columnIndices ? void 0 : columnIndices.map(((columnIndex) => this._columnsController.columnOption(columnIndex)));
    this._columnChooserList.beginUpdate();
    null === changedColumns || void 0 === changedColumns || changedColumns.forEach(((_ref) => {
      let {
        visible,
        index
      } = _ref;
      if (visible) {
        this._columnChooserList.selectItem(index);
      } else {
        this._columnChooserList.unselectItem(index);
      }
    }));
    this._columnChooserList.endUpdate();
  }
  _columnOptionChanged(changes) {
    super._columnOptionChanged(changes);
    const {
      optionNames
    } = changes;
    const isSelectMode = this.isSelectMode();
    const onlyVisibleChanged = this.isColumnVisibilityOnlyUpdated(optionNames);
    const isOnlyColumnVisibilityUpdated = this._isUpdatingColumnVisibility && onlyVisibleChanged;
    if (!isSelectMode || !this._columnChooserList || isOnlyColumnVisibilityUpdated) {
      return;
    }
    const columnIndices = isDefined(changes.columnIndex) ? [changes.columnIndex] : changes.columnIndices;
    const hasItemsOptionNames = COLUMN_OPTIONS_USED_IN_ITEMS.some(((optionName) => optionNames[optionName]));
    const needUpdate = hasItemsOptionNames || changes.changeTypes.columns && optionNames.all;
    if (!needUpdate) {
      return;
    }
    this._updateItemsSelection(columnIndices);
    if (!onlyVisibleChanged) {
      this._updateItems();
    }
  }
  isColumnVisibilityOnlyUpdated(optionNames) {
    const optionKeys = Object.keys(optionNames ?? {}).filter(((key) => "length" !== key));
    return 1 === optionKeys.length && "visible" === optionKeys[0];
  }
  getColumnElements() {
    const result2 = [];
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const $content = this._popupContainer && this._popupContainer.$content();
    const $nodes = $content && $content.find(".dx-treeview-node");
    if ($nodes) {
      chooserColumns.forEach(((column) => {
        const $node = $nodes.filter(`[data-item-id = '${column.index}']`);
        const item = $node.length ? $node.children(".dx-column-chooser-item").get(0) : null;
        result2.push(item);
      }));
    }
    return renderer_default(result2);
  }
  getName() {
    return "columnChooser";
  }
  getColumns() {
    return this._columnsController.getChooserColumns();
  }
  allowDragging(column) {
    const isParentColumnVisible = this._columnsController.isParentColumnVisible(column.index);
    const isColumnHidden = !column.visible && column.allowHiding;
    return this.isColumnChooserVisible() && isParentColumnVisible && isColumnHidden;
  }
  allowColumnHeaderDragging(column) {
    const isDragMode = !this.isSelectMode();
    return isDragMode && this.isColumnChooserVisible() && column.allowHiding;
  }
  getBoundingRect() {
    const container = this._popupContainer && this._popupContainer.$overlayContent();
    if (container && container.is(":visible")) {
      const offset = container.offset();
      return {
        left: offset.left,
        top: offset.top,
        right: offset.left + getOuterWidth(container),
        bottom: offset.top + getOuterHeight(container)
      };
    }
    return null;
  }
  showColumnChooser() {
    if (!this._popupContainer) {
      this._initializePopupContainer();
      this.render();
    }
    this._popupContainer.show();
    if (this._isWinDevice()) {
      renderer_default("body").addClass(this.addWidgetPrefix("notouch-action"));
    }
  }
  hideColumnChooser() {
    if (this._popupContainer) {
      this._popupContainer.hide();
    }
  }
  isColumnChooserVisible() {
    const popupContainer = this._popupContainer;
    return popupContainer && popupContainer.option("visible");
  }
  isSelectMode() {
    return "select" === this.option("columnChooser.mode");
  }
  hasHiddenColumns() {
    const isEnabled = this.option("columnChooser.enabled");
    const hiddenColumns = this.getColumns().filter(((column) => !column.visible));
    return isEnabled && hiddenColumns.length;
  }
};
var headerPanel2 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendColumnChooserItem(items);
  }
  _appendColumnChooserItem(items) {
    const that = this;
    const columnChooserEnabled = that.option("columnChooser.enabled");
    if (columnChooserEnabled) {
      const onClickHandler = function() {
        that.component.getView("columnChooserView").showColumnChooser();
      };
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass(that.addWidgetPrefix("column-chooser-button")));
      };
      const hintText = that.option("columnChooser.title");
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "column-chooser",
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized,
          elementAttr: {
            "aria-haspopup": "dialog"
          }
        },
        showText: "inMenu",
        location: "after",
        name: "columnChooserButton",
        locateInMenu: "auto",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var columns2 = (Base) => class extends Base {
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const isSelectMode = "select" === this.option("columnChooser.mode");
    const isMoveColumnDisallowed = isSelectMode && "columnChooser" === targetLocation;
    return isMoveColumnDisallowed ? false : super.allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation);
  }
};
var columnHeadersView2 = (Base) => class extends Base {
  allowDragging(column) {
    const isDragMode = !this._columnChooserView.isSelectMode();
    const isColumnChooserVisible = this._columnChooserView.isColumnChooserVisible();
    return isDragMode && isColumnChooserVisible && column.allowHiding || super.allowDragging(column);
  }
};
var columnChooserModule = {
  defaultOptions: () => ({
    columnChooser: {
      enabled: false,
      search: {
        enabled: false,
        timeout: 500,
        editorOptions: {}
      },
      selection: {
        allowSelectAll: false,
        selectByClick: false,
        recursive: false
      },
      position: void 0,
      mode: "dragAndDrop",
      width: 250,
      height: 260,
      title: message_default.format("dxDataGrid-columnChooserTitle"),
      emptyPanelText: message_default.format("dxDataGrid-columnChooserEmptyText"),
      container: void 0
    }
  }),
  controllers: {
    columnChooser: ColumnChooserController
  },
  views: {
    columnChooserView: ColumnChooserView
  },
  extenders: {
    views: {
      headerPanel: headerPanel2,
      columnHeadersView: columnHeadersView2
    },
    controllers: {
      columns: columns2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_chooser.js
var ColumnChooserController2 = columnChooserModule.controllers.columnChooser;
var ColumnChooserView2 = columnChooserModule.views.columnChooserView;
m_core_default.registerModule("columnChooser", columnChooserModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/m_utils.js
function createGroupFilter(path, storeLoadOptions) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  const filter = [];
  for (let i = 0; i < path.length; i++) {
    filter.push([groups[i].selector, "=", path[i]]);
  }
  if (storeLoadOptions.filter) {
    filter.push(storeLoadOptions.filter);
  }
  return m_utils_default.combineFilters(filter);
}

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_core.js
function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  let filter = [];
  for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      const {
        selector
      } = groups[j];
      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {
        if (false === path[j]) {
          filterElement.push([selector, "=", groups[j].desc ? true : null]);
        } else if (path[j] ? !groups[j].desc : groups[j].desc) {
          filterElement.push([selector, "<>", path[j]]);
        } else {
          filterElement.push([selector, "<>", null]);
          filterElement.push([selector, "=", null]);
        }
      } else {
        const currentFilter = [selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]];
        if ("<" === currentFilter[1]) {
          filterElement.push([currentFilter, "or", [selector, "=", null]]);
        } else {
          filterElement.push(currentFilter);
        }
      }
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
}
var findGroupInfoByKey = function(groupsInfo, key) {
  const {
    hash
  } = groupsInfo;
  return hash && hash[JSON.stringify(key)];
};
var getGroupInfoIndexByOffset = function(groupsInfo, offset) {
  let leftIndex = 0;
  let rightIndex = groupsInfo.length - 1;
  if (!groupsInfo.length) {
    return 0;
  }
  do {
    const middleIndex = rightIndex + leftIndex >> 1;
    if (groupsInfo[middleIndex].offset > offset) {
      rightIndex = middleIndex;
    } else {
      leftIndex = middleIndex;
    }
  } while (rightIndex - leftIndex > 1);
  let index;
  for (index = leftIndex; index <= rightIndex; index++) {
    if (groupsInfo[index].offset > offset) {
      break;
    }
  }
  return index;
};
var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
  for (let i = 0; i < groupsInfo.length; i++) {
    if (groupIndex + 1 >= groupsCount) {
      groupsInfo[i].children = [];
    } else {
      cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);
    }
  }
};
var calculateItemsCount = function(that, items, groupsCount) {
  let result2 = 0;
  if (items) {
    if (!groupsCount) {
      result2 = items.length;
    } else {
      for (let i = 0; i < items.length; i++) {
        if (that.isGroupItemCountable(items[i])) {
          result2++;
        }
        result2 += calculateItemsCount(that, items[i].items, groupsCount - 1);
      }
    }
  }
  return result2;
};
var GroupingHelper = class {
  constructor(dataSourceAdapter) {
    this._dataSource = dataSourceAdapter;
    this.reset();
  }
  reset() {
    this._groupsInfo = [];
    this._totalCountCorrection = 0;
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  updateTotalItemsCount(totalCountCorrection) {
    this._totalCountCorrection = totalCountCorrection || 0;
  }
  isGroupItemCountable(item) {
    return !this._isVirtualPaging() || !item.isContinuation;
  }
  _isVirtualPaging() {
    const scrollingMode = this._dataSource.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  itemsCount() {
    const dataSourceAdapter = this._dataSource;
    const dataSource = dataSourceAdapter._dataSource;
    const groupCount = m_core_default.normalizeSortingInfo(dataSource.group() || []).length;
    const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);
    return itemsCount;
  }
  foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups2, updateOffsets, updateParentOffsets) {
    const that = this;
    return (function foreachGroupsCore(groupsInfo, callback2, childrenAtFirst2, parents) {
      const callbackResults = [];
      function executeCallback(callback3, data17, parents2, callbackResults2) {
        const callbackResult = data17 && callback3(data17, parents2);
        callbackResult && callbackResults2.push(callbackResult);
        return callbackResult;
      }
      for (let i = 0; i < groupsInfo.length; i++) {
        parents.push(groupsInfo[i].data);
        if (!childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups2) {
          const {
            children
          } = groupsInfo[i];
          const callbackResult = children.length && foreachGroupsCore(children, callback2, childrenAtFirst2, parents);
          callbackResult && callbackResults.push(callbackResult);
          if (false === callbackResult) {
            return false;
          }
        }
        if (childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {
          updateOffsets = true;
        }
        parents.pop();
      }
      const currentParents = updateParentOffsets && parents.slice(0);
      return updateOffsets && when.apply(renderer_default, callbackResults).always((() => {
        that._updateGroupInfoOffsets(groupsInfo, currentParents);
      }));
    })(that._groupsInfo, callback, childrenAtFirst, []);
  }
  _updateGroupInfoOffsets(groupsInfo, parents) {
    parents = parents || [];
    for (let index = 0; index < groupsInfo.length; index++) {
      const groupInfo = groupsInfo[index];
      if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
        groupInfo.offset = groupInfo.data.offset;
        for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {
          parents[parentIndex].offset = groupInfo.offset;
        }
      }
    }
    groupsInfo.sort(((a, b) => a.offset - b.offset));
  }
  findGroupInfo(path) {
    let groupInfo;
    let groupsInfo = this._groupsInfo;
    for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      groupsInfo = groupInfo && groupInfo.children;
    }
    return groupInfo && groupInfo.data;
  }
  addGroupInfo(groupInfoData) {
    const that = this;
    let groupInfo;
    const {
      path
    } = groupInfoData;
    let groupsInfo = that._groupsInfo;
    for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      if (!groupInfo) {
        groupInfo = {
          key: path[pathIndex],
          offset: groupInfoData.offset,
          data: {
            offset: groupInfoData.offset,
            isExpanded: true,
            path: path.slice(0, pathIndex + 1)
          },
          children: []
        };
        const index = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
        groupsInfo.splice(index, 0, groupInfo);
        groupsInfo.hash = groupsInfo.hash || {};
        groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;
      }
      if (pathIndex === path.length - 1) {
        groupInfo.data = groupInfoData;
        if (groupInfo.offset !== groupInfoData.offset) {
          that._updateGroupInfoOffsets(groupsInfo);
        }
      }
      groupsInfo = groupInfo.children;
    }
  }
  allowCollapseAll() {
    return true;
  }
  refresh(options2) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const groups = normalizeSortingInfo(storeLoadOptions.group || []);
    const oldGroups = "_group" in that ? normalizeSortingInfo(that._group || []) : groups;
    let groupsCount = Math.min(oldGroups.length, groups.length);
    that._group = storeLoadOptions.group;
    for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {
      if (!m_utils_default.isEqualSelectors(oldGroups[groupIndex].selector, groups[groupIndex].selector)) {
        groupsCount = groupIndex;
        break;
      }
    }
    if (!groupsCount) {
      that.reset();
    } else {
      cleanGroupsInfo(that._groupsInfo, 0, groupsCount);
    }
  }
  handleDataLoading() {
  }
  handleDataLoaded(options2, callBase) {
    callBase(options2);
  }
  handleDataLoadedCore(options2, callBase) {
    callBase(options2);
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_collapsed.js
function getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {
  groupIndex = groupIndex || 0;
  if (pageSize > 1 && groupSize > 0) {
    let pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
    pageOffset += groupSize - groupIndex - 2;
    if (pageOffset < 0) {
      pageOffset += pageSize;
    }
    return Math.floor(pageOffset / (pageSize - groupIndex - 1));
  }
  return 0;
}
var foreachExpandedGroups = function(that, callback, updateGroups) {
  return that.foreachGroups(((groupInfo, parents) => {
    if (groupInfo.isExpanded) {
      return callback(groupInfo, parents);
    }
  }), true, false, updateGroups, updateGroups);
};
var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
  let isExpanded;
  expandedInfo.items = expandedInfo.items || [];
  expandedInfo.paths = expandedInfo.paths || [];
  expandedInfo.count = expandedInfo.count || 0;
  expandedInfo.lastCount = expandedInfo.lastCount || 0;
  if (!groupsCount) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      if (isCustomLoading) {
        isExpanded = true;
      } else {
        const groupInfo = that.findGroupInfo(path);
        isExpanded = groupInfo && groupInfo.isExpanded;
      }
      if (!isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
      } else if (item.items) {
        processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);
      } else if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {
        expandedInfo.items.push(item);
        expandedInfo.paths.push(path.slice(0));
        expandedInfo.count += expandedInfo.lastCount;
        expandedInfo.lastCount = item.count;
      }
      path.pop();
    }
  }
};
var updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset) {
  const groupInfo = that.findGroupInfo(path);
  let count;
  if (!groupInfo) {
    if (isLastGroupLevel) {
      count = item.count > 0 ? item.count : item.items.length;
    }
    that.addGroupInfo({
      isExpanded: that._isGroupExpanded(path.length - 1),
      path: path.slice(0),
      offset,
      count: count || 0
    });
  } else {
    if (isLastGroupLevel) {
      groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0;
    } else {
      item.count = groupInfo.count || item.count;
    }
    groupInfo.offset = offset;
  }
};
var updateGroupInfos = function(that, options2, items, loadedGroupCount, groupIndex, path, parentIndex) {
  const groupCount = options2.group ? options2.group.length : 0;
  const isLastGroupLevel = groupCount === loadedGroupCount;
  const remotePaging = options2.remoteOperations.paging;
  let offset = 0;
  let totalCount = 0;
  let count;
  groupIndex = groupIndex || 0;
  path = path || [];
  if (remotePaging && !parentIndex) {
    offset = 0 === groupIndex ? options2.skip || 0 : options2.skips[groupIndex - 1] || 0;
  }
  if (groupIndex >= loadedGroupCount) {
    return items.length;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item) {
      path.push(item.key);
      if (!item.count && !item.items || void 0 === item.items) {
        return -1;
      }
      updateGroupInfoItem(that, item, isLastGroupLevel, path, offset + i);
      count = item.items ? updateGroupInfos(that, options2, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;
      if (count < 0) {
        return -1;
      }
      totalCount += count;
      path.pop();
    }
  }
  return totalCount;
};
var isGroupExpanded = function(groups, groupIndex) {
  return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded;
};
var getTotalOffset = function(groupInfos, pageSize, offset) {
  let groupSize;
  let totalOffset = offset;
  for (let groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
    groupSize = groupInfos[groupIndex].offset + 1;
    if (groupIndex > 0) {
      groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
      if (pageSize) {
        groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex;
      }
    }
    totalOffset += groupSize;
  }
  return totalOffset;
};
function applyContinuationToGroupItem(options2, expandedInfo, groupLevel, expandedItemIndex) {
  const item = expandedInfo.items[expandedItemIndex];
  const skip = options2.skips && options2.skips[groupLevel];
  const take = options2.takes && options2.takes[groupLevel];
  const isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;
  const isFirstExpandedItem = 0 === expandedItemIndex;
  const lastExpandedItemSkip = isFirstExpandedItem && skip || 0;
  const isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;
  if (isFirstExpandedItem && void 0 !== skip) {
    item.isContinuation = true;
  }
  if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {
    item.isContinuationOnNextPage = true;
  }
}
function fillSkipTakeInExpandedInfo(options2, expandedInfo, currentGroupCount) {
  const currentGroupIndex = currentGroupCount - 1;
  const groupCount = options2.group ? options2.group.length : 0;
  expandedInfo.skip = options2.skips && options2.skips[currentGroupIndex];
  if (options2.takes && void 0 !== options2.takes[currentGroupIndex]) {
    if (groupCount === currentGroupCount) {
      expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;
    } else {
      expandedInfo.take = 0;
    }
    expandedInfo.take += options2.takes[currentGroupIndex];
  }
}
function isDataDeferred(data17) {
  return !Array.isArray(data17);
}
function makeDataDeferred(options2) {
  if (!isDataDeferred(options2.data)) {
    options2.data = new Deferred();
  }
}
function loadGroupItems(that, options2, loadedGroupCount, expandedInfo, groupLevel, data17) {
  if (!options2.isCustomLoading) {
    expandedInfo = {};
    processGroupItems(that, data17, loadedGroupCount, expandedInfo, []);
    fillSkipTakeInExpandedInfo(options2, expandedInfo, loadedGroupCount);
  }
  const groupCount = options2.group ? options2.group.length : 0;
  if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {
    makeDataDeferred(options2);
    loadExpandedGroups(that, options2, expandedInfo, loadedGroupCount, groupLevel, data17);
  } else if (expandedInfo.paths.length && options2.storeLoadOptions.group) {
    makeDataDeferred(options2);
    loadLastLevelGroupItems(that, options2, expandedInfo, data17);
  } else if (isDataDeferred(options2.data)) {
    options2.data.resolve(data17);
  }
}
function loadExpandedGroups(that, options2, expandedInfo, loadedGroupCount, groupLevel, data17) {
  const groups = options2.group || [];
  const currentGroup = groups[groupLevel + 1];
  const deferreds = [];
  each(expandedInfo.paths, ((expandedItemIndex) => {
    var _options$storeLoadOpt;
    const loadOptions = {
      requireTotalCount: false,
      requireGroupCount: true,
      group: [currentGroup],
      groupSummary: options2.storeLoadOptions.groupSummary,
      filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {
        filter: options2.storeLoadOptions.filter,
        group: groups
      }),
      select: options2.storeLoadOptions.select,
      langParams: null === (_options$storeLoadOpt = options2.storeLoadOptions) || void 0 === _options$storeLoadOpt ? void 0 : _options$storeLoadOpt.langParams
    };
    if (0 === expandedItemIndex) {
      loadOptions.skip = expandedInfo.skip || 0;
    }
    if (expandedItemIndex === expandedInfo.paths.length - 1) {
      loadOptions.take = expandedInfo.take;
    }
    const loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);
    when(loadResult).done(((data18) => {
      const item = expandedInfo.items[expandedItemIndex];
      applyContinuationToGroupItem(options2, expandedInfo, groupLevel, expandedItemIndex);
      item.items = data18;
    }));
    deferreds.push(loadResult);
  }));
  when.apply(null, deferreds).done((() => {
    updateGroupInfos(that, options2, data17, loadedGroupCount + 1);
    loadGroupItems(that, options2, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data17);
  }));
}
function loadLastLevelGroupItems(that, options2, expandedInfo, data17) {
  const expandedFilters = [];
  const groups = options2.group || [];
  each(expandedInfo.paths, ((_, expandedPath) => {
    expandedFilters.push(createGroupFilter(expandedPath, {
      group: options2.isCustomLoading ? options2.storeLoadOptions.group : groups
    }));
  }));
  let {
    filter
  } = options2.storeLoadOptions;
  if (!options2.storeLoadOptions.isLoadingAll) {
    filter = m_core_default.combineFilters([filter, m_core_default.combineFilters(expandedFilters, "or")]);
  }
  const loadOptions = extend({}, options2.storeLoadOptions, {
    requireTotalCount: false,
    requireGroupCount: false,
    group: null,
    sort: groups.concat(m_core_default.normalizeSortingInfo(options2.storeLoadOptions.sort || [])),
    filter
  });
  const isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();
  if (!isPagingLocal) {
    loadOptions.skip = expandedInfo.skip;
    loadOptions.take = expandedInfo.take;
  }
  when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done(((items) => {
    if (isPagingLocal) {
      items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);
      items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;
      items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items;
    }
    each(expandedInfo.items, ((index, item) => {
      const itemCount = item.count - (0 === index && expandedInfo.skip || 0);
      const expandedItems = items.splice(0, itemCount);
      applyContinuationToGroupItem(options2, expandedInfo, groups.length - 1, index);
      item.items = expandedItems;
    }));
    options2.data.resolve(data17);
  })).fail(options2.data.reject);
}
var loadGroupTotalCount = function(dataSource, options2) {
  const d = new Deferred();
  const isGrouping = !!(options2.group && options2.group.length);
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireGroupCount: isGrouping,
    requireTotalCount: !isGrouping
  }, options2, {
    group: isGrouping ? options2.group : null
  });
  dataSource.load(loadOptions).done(((data17, extra) => {
    const count = extra && (isGrouping ? extra.groupCount : extra.totalCount);
    if (!isFinite(count)) {
      d.reject(errors.Error(isGrouping ? "E4022" : "E4021"));
      return;
    }
    d.resolve(count);
  })).fail(d.reject.bind(d));
  return d;
};
var GroupingHelper2 = class extends GroupingHelper {
  updateTotalItemsCount(options2) {
    let totalItemsCount = 0;
    const totalCount = options2.extra && options2.extra.totalCount || 0;
    const groupCount = options2.extra && options2.extra.groupCount || 0;
    const pageSize = this._dataSource.pageSize();
    const isVirtualPaging2 = this._isVirtualPaging();
    foreachExpandedGroups(this, ((groupInfo) => {
      groupInfo.childrenTotalCount = 0;
    }));
    foreachExpandedGroups(this, ((groupInfo, parents) => {
      const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, totalItemsCount);
      let count = groupInfo.count + groupInfo.childrenTotalCount;
      if (!isVirtualPaging2) {
        count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
      }
      if (parents[parents.length - 2]) {
        parents[parents.length - 2].childrenTotalCount += count;
      } else {
        totalItemsCount += count;
      }
    }));
    super.updateTotalItemsCount(totalItemsCount - totalCount + groupCount);
  }
  _isGroupExpanded(groupIndex) {
    const groups = this._dataSource.group();
    return isGroupExpanded(groups, groupIndex);
  }
  _updatePagingOptions(options2, callback) {
    const that = this;
    const isVirtualPaging2 = that._isVirtualPaging();
    const pageSize = that._dataSource.pageSize();
    const skips = [];
    const takes = [];
    let skipChildrenTotalCount = 0;
    let childrenTotalCount = 0;
    if (options2.take) {
      foreachExpandedGroups(this, ((groupInfo) => {
        groupInfo.childrenTotalCount = 0;
        groupInfo.skipChildrenTotalCount = 0;
      }));
      foreachExpandedGroups(that, ((groupInfo, parents) => {
        let take;
        let takeCorrection = 0;
        let parentTakeCorrection = 0;
        const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, childrenTotalCount);
        let continuationGroupCount = 0;
        let skipContinuationGroupCount = 0;
        let groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;
        let childrenGroupInfoCount = groupInfoCount;
        callback && callback(groupInfo, totalOffset);
        const skip = options2.skip - totalOffset;
        if (totalOffset <= options2.skip + options2.take && groupInfoCount) {
          take = options2.take;
          if (!isVirtualPaging2) {
            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
            groupInfoCount += continuationGroupCount * parents.length;
            childrenGroupInfoCount += continuationGroupCount;
            if (pageSize && skip >= 0) {
              takeCorrection = parents.length;
              parentTakeCorrection = parents.length - 1;
              skipContinuationGroupCount = Math.floor(skip / pageSize);
            }
          }
          if (skip >= 0) {
            if (totalOffset + groupInfoCount > options2.skip) {
              skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
            }
            if (totalOffset + groupInfoCount >= options2.skip + take) {
              takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount);
            }
          } else if (totalOffset + groupInfoCount >= options2.skip + take) {
            takes.unshift(take + skip - groupInfo.childrenTotalCount);
          }
        }
        if (totalOffset <= options2.skip) {
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
          } else {
            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
          }
        }
        if (totalOffset <= options2.skip + take) {
          groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].childrenTotalCount += groupInfoCount;
          } else {
            childrenTotalCount += groupInfoCount;
          }
        }
      }));
      options2.skip -= skipChildrenTotalCount;
      options2.take -= childrenTotalCount - skipChildrenTotalCount;
    }
    options2.skips = skips;
    options2.takes = takes;
  }
  changeRowExpand(path) {
    const groupInfo = this.findGroupInfo(path);
    const dataSource = this._dataSource;
    const remoteGroupPaging = dataSource.remoteOperations().groupPaging;
    const groups = m_core_default.normalizeSortingInfo(dataSource.group());
    if (groupInfo) {
      groupInfo.isExpanded = !groupInfo.isExpanded;
      if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {
        return loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(path, {
            filter: dataSource.lastLoadOptions().filter,
            group: dataSource.group()
          }),
          group: [groups[path.length]],
          select: dataSource.select()
        }).done(((groupCount) => {
          groupInfo.count = groupCount;
        }));
      }
      return new Deferred().resolve();
    }
    return new Deferred().reject();
  }
  handleDataLoading(options2) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const groups = m_core_default.normalizeSortingInfo(storeLoadOptions.group || options2.loadOptions.group);
    if (options2.isCustomLoading || !groups.length) {
      return;
    }
    if (options2.remoteOperations.grouping) {
      const remotePaging = that._dataSource.remoteOperations().paging;
      storeLoadOptions.group = m_core_default.normalizeSortingInfo(storeLoadOptions.group);
      storeLoadOptions.group.forEach(((group, index) => {
        const isLastGroup = index === storeLoadOptions.group.length - 1;
        group.isExpanded = !remotePaging || !isLastGroup;
      }));
    }
    options2.group = options2.group || groups;
    if (options2.remoteOperations.paging) {
      options2.skip = storeLoadOptions.skip;
      options2.take = storeLoadOptions.take;
      storeLoadOptions.requireGroupCount = true;
      storeLoadOptions.group = groups.slice(0, 1);
      that._updatePagingOptions(options2);
      storeLoadOptions.skip = options2.skip;
      storeLoadOptions.take = options2.take;
    } else {
      options2.skip = options2.loadOptions.skip;
      options2.take = options2.loadOptions.take;
      that._updatePagingOptions(options2);
    }
  }
  handleDataLoadedCore(options2, callBase) {
    const that = this;
    const loadedGroupCount = m_core_default.normalizeSortingInfo(options2.storeLoadOptions.group || options2.loadOptions.group).length;
    const groupCount = options2.group ? options2.group.length : 0;
    let totalCount;
    const expandedInfo = {};
    if (options2.isCustomLoading) {
      callBase(options2);
      processGroupItems(that, options2.data, loadedGroupCount, expandedInfo, [], options2.isCustomLoading, options2.storeLoadOptions.isLoadingAll);
    } else {
      if (!options2.remoteOperations.paging) {
        that.foreachGroups(((groupInfo) => {
          groupInfo.count = 0;
        }));
      }
      totalCount = updateGroupInfos(that, options2, options2.data, loadedGroupCount);
      if (totalCount < 0) {
        options2.data = new Deferred().reject(ui_errors_default.Error("E1037"));
        return;
      }
      if (!options2.remoteOperations.paging) {
        if (loadedGroupCount && options2.extra && options2.loadOptions.requireTotalCount) {
          options2.extra.totalCount = totalCount;
          options2.extra.groupCount = options2.data.length;
        }
      }
      if (groupCount && options2.storeLoadOptions.requireGroupCount && !isFinite(options2.extra.groupCount)) {
        options2.data = new Deferred().reject(errors.Error("E4022"));
        return;
      }
      that.updateTotalItemsCount(options2);
      if (!options2.remoteOperations.paging) {
        that._updatePagingOptions(options2);
        options2.lastLoadOptions.skips = options2.skips;
        options2.lastLoadOptions.takes = options2.takes;
      }
      callBase(options2);
      if (!options2.remoteOperations.paging) {
        that._processPaging(options2, loadedGroupCount);
      }
    }
    loadGroupItems(that, options2, loadedGroupCount, expandedInfo, 0, options2.data);
  }
  _processSkips(items, skips, groupCount) {
    if (!groupCount) {
      return;
    }
    const firstItem = items[0];
    const skip = skips[0];
    const children = firstItem && firstItem.items;
    if (void 0 !== skip) {
      firstItem.isContinuation = true;
      if (children) {
        firstItem.items = children.slice(skip);
        this._processSkips(firstItem.items, skips.slice(1), groupCount - 1);
      }
    }
  }
  _processTakes(items, skips, takes, groupCount, parents) {
    if (!groupCount || !items) {
      return;
    }
    parents = parents || [];
    const lastItem = items[items.length - 1];
    let children = lastItem && lastItem.items;
    const take = takes[0];
    const skip = skips[0];
    if (lastItem) {
      const maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;
      if (void 0 !== take && maxTakeCount > take) {
        lastItem.isContinuationOnNextPage = true;
        parents.forEach(((parent) => {
          parent.isContinuationOnNextPage = true;
        }));
        if (children) {
          children = children.slice(0, take);
          lastItem.items = children;
        }
      }
      parents.push(lastItem);
      this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents);
    }
  }
  _processPaging(options2, groupCount) {
    this._processSkips(options2.data, options2.skips, groupCount);
    this._processTakes(options2.data, options2.skips, options2.takes, groupCount);
  }
  isLastLevelGroupItemsPagingLocal() {
    return false;
  }
  sortLastLevelGroupItems(items) {
    return items;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    const {
      storeLoadOptions
    } = options2;
    const group = options2.group || options2.storeLoadOptions.group;
    const oldGroups = m_core_default.normalizeSortingInfo(that._group);
    let isExpanded;
    let groupIndex;
    function handleGroup(groupInfo, parents) {
      if (parents.length === groupIndex + 1) {
        groupInfo.isExpanded = isExpanded;
      }
    }
    for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
      isExpanded = isGroupExpanded(group, groupIndex);
      if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {
        that.foreachGroups(handleGroup);
      }
    }
    super.refresh.apply(this, arguments);
    if (group && options2.remoteOperations.paging && operationTypes.reload) {
      return foreachExpandedGroups(that, ((groupInfo) => {
        const groupCountQuery = loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }),
          group: group.slice(groupInfo.path.length),
          select: storeLoadOptions.select
        });
        const groupOffsetQuery = loadGroupTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }, true),
          group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),
          select: storeLoadOptions.select
        });
        return when(groupOffsetQuery, groupCountQuery).done(((offset, count) => {
          offset = parseInt(offset.length ? offset[0] : offset);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount(options2);
          }
        }));
      }), true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js
var loadTotalCount = function(dataSource, options2) {
  const d = new Deferred();
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireTotalCount: true
  }, options2);
  dataSource.load(loadOptions).done(((data17, extra) => {
    d.resolve(extra && extra.totalCount);
  })).fail(d.reject.bind(d));
  return d;
};
var foreachCollapsedGroups = function(that, callback, updateOffsets) {
  return that.foreachGroups(((groupInfo) => {
    if (!groupInfo.isExpanded) {
      return callback(groupInfo);
    }
  }), false, false, updateOffsets, true);
};
var correctSkipLoadOption = function(that, skip) {
  let skipCorrection = 0;
  let resultSkip = skip || 0;
  if (skip) {
    foreachCollapsedGroups(that, ((groupInfo) => {
      if (groupInfo.offset - skipCorrection >= skip) {
        return false;
      }
      skipCorrection += groupInfo.count - 1;
    }));
    resultSkip += skipCorrection;
  }
  return resultSkip;
};
var processGroupItems2 = function(that, items, path, offset, skipFirstItem, take) {
  let removeLastItemsCount = 0;
  let needRemoveFirstItem = false;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !groupInfo.isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
        offset += groupInfo.count;
        take--;
        if (take < 0) {
          removeLastItemsCount++;
        }
        if (skipFirstItem) {
          needRemoveFirstItem = true;
        }
      } else if (item.items) {
        const offsetInfo = processGroupItems2(that, item.items, path, offset, skipFirstItem, take);
        if (skipFirstItem) {
          if (offsetInfo.offset - offset > 1) {
            item.isContinuation = true;
          } else {
            needRemoveFirstItem = true;
          }
        }
        offset = offsetInfo.offset;
        take = offsetInfo.take;
        if (take < 0) {
          if (item.items.length) {
            item.isContinuationOnNextPage = true;
          } else {
            removeLastItemsCount++;
          }
        }
      }
      path.pop();
    } else {
      if (skipFirstItem) {
        needRemoveFirstItem = true;
      }
      offset++;
      take--;
      if (take < 0) {
        removeLastItemsCount++;
      }
    }
    skipFirstItem = false;
  }
  if (needRemoveFirstItem) {
    items.splice(0, 1);
  }
  if (removeLastItemsCount) {
    items.splice(-removeLastItemsCount, removeLastItemsCount);
  }
  return {
    offset,
    take
  };
};
var pathEquals = function(path1, path2) {
  if (path1.length !== path2.length) {
    return false;
  }
  for (let i = 0; i < path1.length; i++) {
    if (!keysEqual(null, path1[i], path2[i])) {
      return false;
    }
  }
  return true;
};
var updateGroupOffsets = function(that, items, path, offset, additionalGroupInfo) {
  if (!items) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if ("key" in item && void 0 !== item.items) {
      path.push(item.key);
      if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {
        additionalGroupInfo.offset = offset;
      }
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !item.isContinuation) {
        groupInfo.offset = offset;
      }
      if (groupInfo && !groupInfo.isExpanded) {
        offset += groupInfo.count;
      } else {
        offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);
      }
      path.pop();
    } else {
      offset++;
    }
  }
  return offset;
};
var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
  if (loadOptions.group) {
    const groups = m_core_default.normalizeSortingInfo(loadOptions.group);
    const sorts = m_core_default.normalizeSortingInfo(storeLoadOptions.sort);
    storeLoadOptions.sort = m_store_helper_default.arrangeSortingInfo(groups, sorts);
    delete loadOptions.group;
  }
};
var createNotGroupFilter = function(path, storeLoadOptions, group) {
  const groups = m_core_default.normalizeSortingInfo(group || storeLoadOptions.group);
  let filter = [];
  for (let i = 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
};
var getGroupCount = function(item, groupCount) {
  let count = item.count || item.items.length;
  if (!item.count && groupCount > 1) {
    count = 0;
    for (let i = 0; i < item.items.length; i++) {
      count += getGroupCount(item.items[i], groupCount - 1);
    }
  }
  return count;
};
var GroupingHelper3 = class extends GroupingHelper {
  handleDataLoading(options2) {
    const {
      storeLoadOptions
    } = options2;
    const collapsedGroups = [];
    let collapsedItemsCount = 0;
    let skipFirstItem = false;
    let take;
    const {
      group
    } = options2.loadOptions;
    let skipCorrection = 0;
    removeGroupLoadOption(storeLoadOptions, options2.loadOptions);
    options2.group = options2.group || group;
    if (options2.isCustomLoading) {
      return;
    }
    const loadOptions = extend({}, storeLoadOptions);
    loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);
    if (loadOptions.skip && loadOptions.take && group) {
      loadOptions.skip--;
      loadOptions.take++;
      skipFirstItem = true;
    }
    if (loadOptions.take && group) {
      take = loadOptions.take;
      loadOptions.take++;
    }
    foreachCollapsedGroups(this, ((groupInfo) => {
      if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {
        return false;
      }
      if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
        skipCorrection += groupInfo.count - 1;
        collapsedGroups.push(groupInfo);
        collapsedItemsCount += groupInfo.count;
      }
    }));
    each(collapsedGroups, (function() {
      loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);
    }));
    options2.storeLoadOptions = loadOptions;
    options2.collapsedGroups = collapsedGroups;
    options2.collapsedItemsCount = collapsedItemsCount;
    options2.skip = loadOptions.skip || 0;
    options2.skipFirstItem = skipFirstItem;
    options2.take = take;
  }
  handleDataLoaded(options2, callBase) {
    const that = this;
    const {
      collapsedGroups
    } = options2;
    const groups = m_core_default.normalizeSortingInfo(options2.group);
    const groupCount = groups.length;
    function appendCollapsedPath(data17, path, groups2, collapsedGroup, offset) {
      if (!data17 || !path.length || !groups2.length) {
        return;
      }
      let keyValue;
      let i;
      const pathValue = toComparable(path[0], true);
      for (i = 0; i < data17.length; i++) {
        keyValue = toComparable(data17[i].key, true);
        if (offset >= collapsedGroup.offset || pathValue === keyValue) {
          break;
        } else {
          offset += getGroupCount(data17[i], groups2.length);
        }
      }
      if (!data17.length || pathValue !== keyValue) {
        data17.splice(i, 0, {
          key: path[0],
          items: [],
          count: 1 === path.length ? collapsedGroup.count : void 0
        });
      }
      appendCollapsedPath(data17[i].items, path.slice(1), groups2.slice(1), collapsedGroup, offset);
    }
    if (options2.collapsedItemsCount && options2.extra && options2.extra.totalCount >= 0) {
      if (!options2.extra._totalCountWasIncreasedByCollapsedItems) {
        options2.extra.totalCount += options2.collapsedItemsCount;
        options2.extra._totalCountWasIncreasedByCollapsedItems = true;
      }
    }
    callBase(options2);
    if (groupCount) {
      let {
        data: data17
      } = options2;
      const query = m_query_default(data17);
      m_store_helper_default.multiLevelGroup(query, groups).enumerate().done(((groupedData) => {
        data17 = groupedData;
      }));
      if (collapsedGroups) {
        for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {
          appendCollapsedPath(data17, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options2.skip);
        }
      }
      if (!options2.isCustomLoading) {
        processGroupItems2(that, data17, [], options2.skip, options2.skipFirstItem, options2.take);
      }
      options2.data = data17;
    }
  }
  isGroupItemCountable(item) {
    return null === item.items;
  }
  updateTotalItemsCount() {
    let itemsCountCorrection = 0;
    foreachCollapsedGroups(this, ((groupInfo) => {
      if (groupInfo.count) {
        itemsCountCorrection -= groupInfo.count - 1;
      }
    }));
    super.updateTotalItemsCount(itemsCountCorrection);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();
    const dataSourceItems = dataSource.items();
    const offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());
    let groupInfo = that.findGroupInfo(path);
    let groupCountQuery;
    if (groupInfo && !groupInfo.isExpanded) {
      groupCountQuery = new Deferred().resolve(groupInfo.count);
    } else {
      groupCountQuery = loadTotalCount(dataSource, {
        filter: createGroupFilter(path, {
          filter: dataSource.filter(),
          group: dataSource.group()
        })
      });
    }
    return when(groupCountQuery).done(((count) => {
      count = parseInt(count.length ? count[0] : count);
      if (groupInfo) {
        updateGroupOffsets(that, dataSourceItems, [], offset);
        groupInfo.isExpanded = !groupInfo.isExpanded;
        groupInfo.count = count;
      } else {
        groupInfo = {
          offset: -1,
          count,
          path,
          isExpanded: false
        };
        updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);
        if (groupInfo.offset >= 0) {
          that.addGroupInfo(groupInfo);
        }
      }
      that.updateTotalItemsCount();
    })).fail((function() {
      dataSource._eventsStrategy.fireEvent("loadError", arguments);
    }));
  }
  allowCollapseAll() {
    return false;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const dataSource = that._dataSource;
    super.refresh.apply(this, arguments);
    if (operationTypes.reload) {
      return foreachCollapsedGroups(that, ((groupInfo) => {
        const groupCountQuery = loadTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, storeLoadOptions)
        });
        const groupOffsetQuery = loadTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, storeLoadOptions)
        });
        return when(groupOffsetQuery, groupCountQuery).done(((offset, count) => {
          offset = parseInt(offset.length ? offset[0] : offset);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount();
          }
        }));
      }), true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping.js
var dataSourceAdapterExtender = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._initGroupingHelper();
  }
  _initGroupingHelper(options2) {
    const grouping = this._grouping;
    const isAutoExpandAll = this.option("grouping.autoExpandAll");
    const isFocusedRowEnabled = this.option("focusedRowEnabled");
    const remoteOperations = options2 ? options2.remoteOperations : this.remoteOperations();
    const isODataRemoteOperations = remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging;
    if (isODataRemoteOperations && !remoteOperations.grouping && (isAutoExpandAll || !isFocusedRowEnabled)) {
      if (!grouping || grouping instanceof GroupingHelper2) {
        this._grouping = new GroupingHelper3(this);
      }
    } else if (!grouping || grouping instanceof GroupingHelper3) {
      this._grouping = new GroupingHelper2(this);
    }
  }
  totalItemsCount() {
    const totalCount = super.totalItemsCount();
    return totalCount > 0 && this._dataSource.group() && this._dataSource.requireTotalCount() ? totalCount + this._grouping.totalCountCorrection() : totalCount;
  }
  itemsCount() {
    return this._dataSource.group() ? this._grouping.itemsCount() || 0 : super.itemsCount.apply(this, arguments);
  }
  allowCollapseAll() {
    return this._grouping.allowCollapseAll();
  }
  isGroupItemCountable(item) {
    return this._grouping.isGroupItemCountable(item);
  }
  isRowExpanded(key) {
    const groupInfo = this._grouping.findGroupInfo(key);
    return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll();
  }
  collapseAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, false);
  }
  expandAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, true);
  }
  _collapseExpandAll(groupIndex, isExpand) {
    const that = this;
    const dataSource = that._dataSource;
    const group = dataSource.group();
    const groups = m_core_default.normalizeSortingInfo(group || []);
    if (groups.length) {
      for (let i = 0; i < groups.length; i++) {
        if (void 0 === groupIndex || groupIndex === i) {
          groups[i].isExpanded = isExpand;
        } else if (group && group[i]) {
          groups[i].isExpanded = group[i].isExpanded;
        }
      }
      dataSource.group(groups);
      that._grouping.foreachGroups(((groupInfo, parents) => {
        if (void 0 === groupIndex || groupIndex === parents.length - 1) {
          groupInfo.isExpanded = isExpand;
        }
      }), false, true);
      that.resetPagesCache();
    }
    return true;
  }
  refresh() {
    super.refresh.apply(this, arguments);
    return this._grouping.refresh.apply(this._grouping, arguments);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    if (dataSource.group()) {
      dataSource.beginLoading();
      if (that._lastLoadOptions) {
        that._lastLoadOptions.groupExpand = true;
      }
      return that._changeRowExpandCore(path).always((() => {
        dataSource.endLoading();
      }));
    }
  }
  _changeRowExpandCore(path) {
    return this._grouping.changeRowExpand(path);
  }
  _hasGroupLevelsExpandState(group, isExpanded) {
    if (group && Array.isArray(group)) {
      for (let i = 0; i < group.length; i++) {
        if (group[i].isExpanded === isExpanded) {
          return true;
        }
      }
    }
  }
  _customizeRemoteOperations(options2, operationTypes) {
    const {
      remoteOperations
    } = options2;
    if (options2.storeLoadOptions.group) {
      if (remoteOperations.grouping && !options2.isCustomLoading) {
        if (!remoteOperations.groupPaging || this._hasGroupLevelsExpandState(options2.storeLoadOptions.group, true)) {
          remoteOperations.paging = false;
        }
      }
      if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options2.isCustomLoading || this._hasGroupLevelsExpandState(options2.storeLoadOptions.group, false))) {
        remoteOperations.paging = false;
      }
    } else if (!options2.isCustomLoading && remoteOperations.paging && operationTypes.grouping) {
      this.resetCache();
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  _handleDataLoading(options2) {
    super._handleDataLoading(options2);
    this._initGroupingHelper(options2);
    return this._grouping.handleDataLoading(options2);
  }
  _handleDataLoaded(options2) {
    return this._grouping.handleDataLoaded(options2, super._handleDataLoaded.bind(this));
  }
  _handleDataLoadedCore(options2) {
    return this._grouping.handleDataLoadedCore(options2, super._handleDataLoadedCore.bind(this));
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender);
var GroupingDataControllerExtender = (Base) => class extends Base {
  init() {
    super.init();
    this.createAction("onRowExpanding");
    this.createAction("onRowExpanded");
    this.createAction("onRowCollapsing");
    this.createAction("onRowCollapsed");
  }
  _beforeProcessItems(items) {
    const groupColumns = this._columnsController.getGroupColumns();
    items = super._beforeProcessItems(items);
    if (items.length && groupColumns.length) {
      items = this._processGroupItems(items, groupColumns.length);
    }
    return items;
  }
  _processItem(item, options2) {
    if (isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group")) {
      item = this._processGroupItem(item, options2);
      options2.dataIndex = 0;
    } else {
      item = super._processItem.apply(this, arguments);
    }
    return item;
  }
  _processGroupItem(item, options2) {
    return item;
  }
  _processGroupItems(items, groupsCount, options2) {
    const that = this;
    const groupedColumns = that._columnsController.getGroupColumns();
    const column = groupedColumns[groupedColumns.length - groupsCount];
    if (!options2) {
      const scrollingMode = that.option("scrolling.mode");
      options2 = {
        collectContinuationItems: "virtual" !== scrollingMode && "infinite" !== scrollingMode,
        resultItems: [],
        path: [],
        values: []
      };
    }
    const {
      resultItems
    } = options2;
    if (options2.data) {
      if (options2.collectContinuationItems || !options2.data.isContinuation) {
        resultItems.push({
          rowType: "group",
          data: options2.data,
          groupIndex: options2.path.length - 1,
          isExpanded: !!options2.data.items,
          key: options2.path.slice(0),
          values: options2.values.slice(0)
        });
      }
    }
    if (items) {
      if (0 === groupsCount) {
        resultItems.push.apply(resultItems, items);
      } else {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item && "items" in item) {
            options2.data = item;
            options2.path.push(item.key);
            options2.values.push(column && column.deserializeValue && !column.calculateDisplayValue ? column.deserializeValue(item.key) : item.key);
            that._processGroupItems(item.items, groupsCount - 1, options2);
            options2.data = void 0;
            options2.path.pop();
            options2.values.pop();
          } else {
            resultItems.push(item);
          }
        }
      }
    }
    return resultItems;
  }
  publicMethods() {
    return super.publicMethods().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"]);
  }
  collapseAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.collapseAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  expandAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.expandAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  changeRowExpand(key) {
    const that = this;
    const expanded = that.isRowExpanded(key);
    const args = {
      key,
      expanded
    };
    that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
    if (!args.cancel) {
      return when(that._changeRowExpandCore(key)).done((() => {
        args.expanded = !expanded;
        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args);
      }));
    }
    return new Deferred().resolve();
  }
  _changeRowExpandCore(key) {
    const that = this;
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      d.resolve();
    } else {
      when(dataSource.changeRowExpand(key)).done((() => {
        that.load().done(d.resolve).fail(d.reject);
      })).fail(d.reject);
    }
    return d;
  }
  isRowExpanded(key) {
    const dataSource = this._dataSource;
    return dataSource && dataSource.isRowExpanded(key);
  }
  expandRow(key) {
    if (!this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  collapseRow(key) {
    if (this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  optionChanged(args) {
    if ("grouping" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
};
var onGroupingMenuItemClick = function(column, params) {
  const columnsController = this._columnsController;
  switch (params.itemData.value) {
    case "group": {
      const groups = columnsController._dataSource.group() || [];
      columnsController.columnOption(column.dataField, "groupIndex", groups.length);
      break;
    }
    case "ungroup":
      columnsController.columnOption(column.dataField, "groupIndex", -1);
      break;
    case "ungroupAll":
      this.component.clearGrouping();
  }
};
var isGroupPanelVisible = (groupPanelOptions) => {
  const visible = null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.visible;
  return "auto" === visible ? "desktop" === devices_default.current().deviceType : !!visible;
};
var allowDragging = (groupPanelOptions, column) => {
  const isVisible = isGroupPanelVisible(groupPanelOptions);
  const canDrag = (null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.allowColumnDragging) && column.allowGrouping;
  return isVisible && !!canDrag;
};
var GroupingHeaderPanelExtender = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendGroupingItem(items);
  }
  _appendGroupingItem(items) {
    if (this._isGroupPanelVisible()) {
      let isRendered = false;
      const toolbarItem = {
        template: () => {
          const $groupPanel = renderer_default("<div>").addClass("dx-datagrid-group-panel");
          this._updateGroupPanelContent($groupPanel);
          registerKeyboardAction2("groupPanel", this, $groupPanel, void 0, this._handleActionKeyDown.bind(this));
          return $groupPanel;
        },
        name: "groupPanel",
        onItemRendered: () => {
          isRendered && this.renderCompleted.fire();
          isRendered = true;
        },
        location: "before",
        locateInMenu: "never",
        sortIndex: 1
      };
      items.push(toolbarItem);
      this.updateToolbarDimensions();
    }
    return items;
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    const groupColumnIndex = $target.closest(".dx-group-panel-item").index();
    const column = this._columnsController.getGroupColumns()[groupColumnIndex];
    const columnIndex = column && column.index;
    if ($target.is(".dx-header-filter")) {
      this._headerFilterController.showHeaderFilterMenu(columnIndex, true);
    } else {
      this._processGroupItemAction(columnIndex);
    }
    event.preventDefault();
  }
  _isGroupPanelVisible() {
    return isGroupPanelVisible(this.option("groupPanel"));
  }
  _renderGroupPanelItems($groupPanel, groupColumns) {
    const that = this;
    $groupPanel.empty();
    each(groupColumns, ((index, groupColumn) => {
      that._createGroupPanelItem($groupPanel, groupColumn);
    }));
    restoreFocus(this);
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const $groupPanelItem = renderer_default("<div>").addClass(groupColumn.cssClass).addClass("dx-group-panel-item").data("columnData", groupColumn).appendTo($rootElement).text(groupColumn.caption);
    setTabIndex(this, $groupPanelItem);
    return $groupPanelItem;
  }
  _columnOptionChanged(e) {
    if (!this._requireReady && !m_core_default.checkChanges(e.optionNames, ["width", "visibleWidth"])) {
      const $toolbarElement = this.element();
      const $groupPanel = $toolbarElement && $toolbarElement.find(".dx-datagrid-group-panel");
      if ($groupPanel && $groupPanel.length) {
        this._updateGroupPanelContent($groupPanel);
        this.updateToolbarDimensions();
        this.renderCompleted.fire();
      }
    }
    super._columnOptionChanged();
  }
  _updateGroupPanelContent($groupPanel) {
    const groupColumns = this.getColumns();
    const groupPanelOptions = this.option("groupPanel");
    this._renderGroupPanelItems($groupPanel, groupColumns);
    if (groupPanelOptions.allowColumnDragging && !groupColumns.length) {
      renderer_default("<div>").addClass("dx-group-panel-message").text(groupPanelOptions.emptyPanelText).appendTo($groupPanel);
      $groupPanel.closest(".dx-toolbar-item").addClass("dx-toolbar-label");
      $groupPanel.closest(".dx-toolbar-label").css("maxWidth", "none");
    }
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column);
  }
  getColumnElements() {
    const $element = this.element();
    return $element && $element.find(".dx-group-panel-item");
  }
  getColumns() {
    return this._columnsController.getGroupColumns();
  }
  getBoundingRect() {
    const $element = this.element();
    if ($element && $element.find(".dx-datagrid-group-panel").length) {
      const offset = $element.offset();
      return {
        top: offset.top,
        bottom: offset.top + getHeight($element)
      };
    }
    return null;
  }
  getName() {
    return "group";
  }
  getContextMenuItems(options2) {
    const that = this;
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    const $groupedColumnElement = renderer_default(options2.targetElement).closest(".dx-group-panel-item");
    let items;
    if ($groupedColumnElement.length) {
      options2.column = $groupedColumnElement.data("columnData");
    }
    if (contextMenuEnabled && options2.column) {
      const {
        column
      } = options2;
      const isGroupingAllowed = isDefined(column.allowGrouping) ? column.allowGrouping : true;
      if (isGroupingAllowed) {
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const groupingTexts = that.option("grouping.texts");
        const onItemClick = onGroupingMenuItemClick.bind(that, column);
        items = [{
          text: groupingTexts.ungroup,
          value: "ungroup",
          disabled: !isColumnGrouped,
          onItemClick
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick
        }];
      }
    }
    return items;
  }
  hasGroupedColumns() {
    return this._isGroupPanelVisible() && !!this.getColumns().length;
  }
  optionChanged(args) {
    if ("groupPanel" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var GroupingRowsViewExtender = (Base) => class extends Base {
  getContextMenuItems(options2) {
    const that = this;
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items;
    if (contextMenuEnabled && options2.row && "group" === options2.row.rowType) {
      const columnsController = that._columnsController;
      const column = columnsController.columnOption(`groupIndex:${options2.row.groupIndex}`);
      if (column && column.allowGrouping) {
        const groupingTexts = that.option("grouping.texts");
        const onItemClick = onGroupingMenuItemClick.bind(that, column);
        items = [];
        items.push({
          text: groupingTexts.ungroup,
          value: "ungroup",
          onItemClick
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick
        });
      }
    }
    return items;
  }
  _rowClick(e) {
    const that = this;
    const expandMode = that.option("grouping.expandMode");
    const scrollingMode = that.option("scrolling.mode");
    const isGroupRowStateChanged = "infinite" !== scrollingMode && "rowClick" === expandMode && renderer_default(e.event.target).closest(".dx-group-row").length;
    const isExpandButtonClicked = renderer_default(e.event.target).closest(".dx-datagrid-expand").length;
    if (isGroupRowStateChanged || isExpandButtonClicked) {
      that._changeGroupRowState(e);
    }
    super._rowClick(e);
  }
  _changeGroupRowState(e) {
    const row = this._dataController.items()[e.rowIndex];
    const allowCollapsing = this._columnsController.columnOption(`groupIndex:${row.groupIndex}`, "allowCollapsing");
    if ("data" === row.rowType || "group" === row.rowType && false !== allowCollapsing) {
      this._dataController.changeRowExpand(row.key, true);
      e.event.preventDefault();
      e.handled = true;
    }
  }
};
var columnHeadersViewExtender = (Base) => class extends Base {
  getContextMenuItems(options2) {
    const that = this;
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items = super.getContextMenuItems(options2);
    if (contextMenuEnabled && options2.row && ("header" === options2.row.rowType || "detailAdaptive" === options2.row.rowType)) {
      const {
        column
      } = options2;
      if (!column.command && (!isDefined(column.allowGrouping) || column.allowGrouping)) {
        const groupingTexts = that.option("grouping.texts");
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const onItemClick = onGroupingMenuItemClick.bind(that, column);
        items = items || [];
        items.push({
          text: groupingTexts.groupByThisColumn,
          value: "group",
          beginGroup: true,
          disabled: isColumnGrouped,
          onItemClick
        });
        if (column.showWhenGrouped) {
          items.push({
            text: groupingTexts.ungroup,
            value: "ungroup",
            disabled: !isColumnGrouped,
            onItemClick
          });
        }
        items.push({
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick
        });
      }
    }
    return items;
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column) || super.allowDragging(column);
  }
};
m_core_default.registerModule("grouping", {
  defaultOptions: () => ({
    grouping: {
      autoExpandAll: true,
      allowCollapsing: true,
      contextMenuEnabled: false,
      expandMode: "buttonClick",
      texts: {
        groupContinuesMessage: message_default.format("dxDataGrid-groupContinuesMessage"),
        groupContinuedMessage: message_default.format("dxDataGrid-groupContinuedMessage"),
        groupByThisColumn: message_default.format("dxDataGrid-groupHeaderText"),
        ungroup: message_default.format("dxDataGrid-ungroupHeaderText"),
        ungroupAll: message_default.format("dxDataGrid-ungroupAllText")
      }
    },
    groupPanel: {
      visible: false,
      emptyPanelText: message_default.format("dxDataGrid-groupPanelEmptyText"),
      allowColumnDragging: true
    }
  }),
  extenders: {
    controllers: {
      data: GroupingDataControllerExtender,
      columns: (Base) => class extends Base {
        _getExpandColumnOptions() {
          const options2 = super._getExpandColumnOptions.apply(this, arguments);
          options2.cellTemplate = m_core_default.getExpandCellTemplate();
          return options2;
        }
      },
      editing: (Base) => class extends Base {
        _isProcessedItem(item) {
          return isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group");
        }
      }
    },
    views: {
      headerPanel: GroupingHeaderPanelExtender,
      rowsView: GroupingRowsViewExtender,
      columnHeadersView: columnHeadersViewExtender
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/const.js
var CLASSES5 = {
  detailRow: "dx-master-detail-row",
  detailCell: "dx-master-detail-cell",
  detailContainer: "master-detail-container",
  cellFocusDisabledClass: "dx-cell-focus-disabled",
  rowLines: "dx-row-lines"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/utils.js
function isDetailRow(row) {
  const rowType = null === row || void 0 === row ? void 0 : row.rowType;
  return "detail" === rowType || "detailAdaptive" === rowType;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/m_master_detail.js
var columns3 = (Base) => class extends Base {
  _getExpandColumnsCore() {
    const expandColumns = super._getExpandColumnsCore();
    if (this.option("masterDetail.enabled")) {
      expandColumns.push({
        type: "detailExpand",
        cellTemplate: m_utils_default.getExpandCellTemplate()
      });
    }
    return expandColumns;
  }
};
var initMasterDetail = function(that) {
  that._expandedItems = [];
  that._isExpandAll = that.option("masterDetail.autoExpandAll");
};
var dataMasterDetailExtenderMixin = (Base) => class extends Base {
  init() {
    initMasterDetail(this);
    super.init();
  }
  expandAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = true;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.expandAll.apply(that, arguments);
    }
  }
  collapseAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = false;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.collapseAll.apply(that, arguments);
    }
  }
  isRowExpandedHack() {
    return super.isRowExpanded.apply(this, arguments);
  }
  isRowExpanded(key) {
    const that = this;
    const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
    if (Array.isArray(key)) {
      return super.isRowExpanded.apply(that, arguments);
    }
    return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible));
  }
  _getRowIndicesForExpand(key) {
    const rowIndex = this.getRowIndexByKey(key);
    return [rowIndex, rowIndex + 1];
  }
  _changeRowExpandCore(key) {
    const that = this;
    let result2;
    if (Array.isArray(key)) {
      result2 = super._changeRowExpandCore.apply(that, arguments);
    } else {
      const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
      if (expandIndex >= 0) {
        const {
          visible
        } = that._expandedItems[expandIndex];
        that._expandedItems[expandIndex].visible = !visible;
      } else {
        that._expandedItems.push({
          key,
          visible: true
        });
      }
      that.updateItems({
        changeType: "update",
        rowIndices: that._getRowIndicesForExpand(key)
      });
      result2 = new Deferred().resolve();
    }
    return result2;
  }
  _processDataItemHack() {
    return super._processDataItem.apply(this, arguments);
  }
  _processDataItem(data17, options2) {
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isExpanded = this.isRowExpanded(dataItem.key);
    if (void 0 === options2.detailColumnIndex) {
      options2.detailColumnIndex = -1;
      each(options2.visibleColumns, ((index, column) => {
        if ("expand" === column.command && !isDefined(column.groupIndex)) {
          options2.detailColumnIndex = index;
          return false;
        }
        return;
      }));
    }
    if (options2.detailColumnIndex >= 0) {
      dataItem.values[options2.detailColumnIndex] = dataItem.isExpanded;
    }
    return dataItem;
  }
  _processItemsHack() {
    return super._processItems.apply(this, arguments);
  }
  _processItems(items, change) {
    const that = this;
    const {
      changeType
    } = change;
    const result2 = [];
    items = super._processItems.apply(that, arguments);
    if ("loadingAll" === changeType) {
      return items;
    }
    if ("refresh" === changeType) {
      that._expandedItems = grep(that._expandedItems, ((item) => item.visible));
    }
    each(items, ((index, item) => {
      result2.push(item);
      const expandIndex = m_utils_default.getIndexByKey(item.key, that._expandedItems);
      if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.isNewRow) {
        result2.push({
          visible: item.isExpanded,
          rowType: "detail",
          key: item.key,
          data: item.data,
          values: []
        });
      }
    }));
    return result2;
  }
  optionChanged(args) {
    const that = this;
    let isEnabledChanged;
    let isAutoExpandAllChanged;
    if ("masterDetail" === args.name) {
      args.name = "dataSource";
      switch (args.fullName) {
        case "masterDetail": {
          const value2 = args.value || {};
          const previousValue = args.previousValue || {};
          isEnabledChanged = value2.enabled !== previousValue.enabled;
          isAutoExpandAllChanged = value2.autoExpandAll !== previousValue.autoExpandAll;
          break;
        }
        case "masterDetail.template":
          initMasterDetail(that);
          break;
        case "masterDetail.enabled":
          isEnabledChanged = true;
          break;
        case "masterDetail.autoExpandAll":
          isAutoExpandAllChanged = true;
      }
      if (isEnabledChanged || isAutoExpandAllChanged) {
        initMasterDetail(that);
      }
    }
    super.optionChanged(args);
  }
};
var resizing2 = (Base) => class extends Base {
  fireContentReadyAction() {
    super.fireContentReadyAction.apply(this, arguments);
    this._updateParentDataGrids(this.component.$element());
  }
  _updateParentDataGrids($element) {
    const $masterDetailRow = $element.closest(`.${CLASSES5.detailRow}`);
    if ($masterDetailRow.length) {
      when(this._updateMasterDataGrid($masterDetailRow, $element)).done((() => {
        this._updateParentDataGrids($masterDetailRow.parent());
      }));
    }
  }
  _updateMasterDataGrid($masterDetailRow, $detailElement) {
    const masterRowOptions = renderer_default($masterDetailRow).data("options");
    const masterDataGrid = renderer_default($masterDetailRow).closest(`.${this.getWidgetContainerClass()}`).parent().data("dxDataGrid");
    if (masterRowOptions && masterDataGrid) {
      return this._updateMasterDataGridCore(masterDataGrid, masterRowOptions);
    }
    return;
  }
  _updateMasterDataGridCore(masterDataGrid, masterRowOptions) {
    var _masterDataGrid$getVi, _masterDataGrid$getVi2;
    const d = Deferred();
    if (null !== (_masterDataGrid$getVi = masterDataGrid.getView("rowsView")) && void 0 !== _masterDataGrid$getVi && null !== (_masterDataGrid$getVi2 = _masterDataGrid$getVi.isFixedColumns) && void 0 !== _masterDataGrid$getVi2 && _masterDataGrid$getVi2.call(_masterDataGrid$getVi)) {
      this._updateFixedMasterDetailGrids(masterDataGrid, masterRowOptions.rowIndex, renderer_default(masterRowOptions.rowElement)).done(d.resolve);
    } else {
      if (true === masterDataGrid.option("scrolling.useNative")) {
        masterDataGrid.updateDimensions().done((() => d.resolve(true)));
        return;
      }
      const scrollable = masterDataGrid.getScrollable();
      if (scrollable) {
        null === scrollable || void 0 === scrollable || scrollable.update().done((() => d.resolve()));
      } else {
        d.resolve();
      }
    }
    return d.promise();
  }
  _updateFixedMasterDetailGrids(masterDataGrid, masterRowIndex, $detailElement) {
    const d = Deferred();
    const $rows = renderer_default(masterDataGrid.getRowElement(masterRowIndex));
    const $tables = renderer_default(masterDataGrid.getView("rowsView").getTableElements());
    const rowsNotEqual = 2 === (null === $rows || void 0 === $rows ? void 0 : $rows.length) && getHeight($rows.eq(0)) !== getHeight($rows.eq(1));
    const tablesNotEqual = 2 === (null === $tables || void 0 === $tables ? void 0 : $tables.length) && getHeight($tables.eq(0)) !== getHeight($tables.eq(1));
    if (rowsNotEqual || tablesNotEqual) {
      const detailElementWidth = getWidth($detailElement);
      masterDataGrid.updateDimensions().done((() => {
        const isDetailHorizontalScrollCanBeShown = this.option("columnAutoWidth") && true === masterDataGrid.option("scrolling.useNative");
        const isDetailGridWidthChanged = isDetailHorizontalScrollCanBeShown && detailElementWidth !== getWidth($detailElement);
        if (isDetailHorizontalScrollCanBeShown && isDetailGridWidthChanged) {
          this.updateDimensions().done((() => d.resolve(true)));
        } else {
          d.resolve(true);
        }
      }));
      return d.promise();
    }
    return Deferred().resolve();
  }
  _toggleBestFitMode(isBestFit) {
    super._toggleBestFitMode.apply(this, arguments);
    const hasMasterDetailTemplate = this.option("masterDetail.template");
    if (!hasMasterDetailTemplate) {
      return;
    }
    const $rowsTable = this._rowsView.getTableElement();
    if ($rowsTable) {
      const detailSelector = `.${this.addWidgetPrefix(CLASSES5.detailContainer)}, .${CLASSES5.detailCell}`;
      $rowsTable.find(detailSelector).css("maxWidth", isBestFit ? 0 : "");
    }
  }
};
var rowsView2 = (Base) => class extends Base {
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    const editingController = this._editingController;
    const isEditRow2 = editingController && editingController.isEditRow(options2.rowIndex);
    let template;
    if ("detail" === column.command && !isEditRow2) {
      template = that.option("masterDetail.template") || {
        allowRenderToDetachedContainer: false,
        render: that._getDefaultTemplate(column)
      };
    } else {
      template = super._getCellTemplate.apply(that, arguments);
    }
    return template;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    const isDetailRowResult = isDetailRow(row);
    if (isDetailRowResult) {
      const showRowLines = this.option("showRowLines");
      $row.addClass(CLASSES5.detailRow).toggleClass(CLASSES5.rowLines, showRowLines);
      if (isDefined(row.visible)) {
        $row.toggle(row.visible);
      }
    }
    return $row;
  }
  _renderCells($row, options2) {
    const {
      row
    } = options2;
    const isDetailRowResult = isDetailRow(row);
    if (isDetailRowResult) {
      if (this._needRenderCell(0, options2.columnIndices)) {
        this._renderMasterDetailCell($row, row, options2);
      }
    } else {
      super._renderCells.apply(this, arguments);
    }
  }
  _renderMasterDetailCell($row, row, options2) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    const $detailCell = this._renderCell($row, {
      value: null,
      row,
      rowIndex: row.rowIndex,
      column: {
        command: "detail"
      },
      columnIndex: 0,
      change: options2.change
    });
    $detailCell.addClass(CLASSES5.cellFocusDisabledClass).addClass(CLASSES5.detailCell).attr("colSpan", visibleColumns.length);
    const isEditForm2 = row.isEditing;
    if (!isEditForm2) {
      $detailCell.attr("aria-roledescription", message_default.format("dxDataGrid-masterDetail"));
    }
    return $detailCell;
  }
};
var masterDetailModule = {
  defaultOptions: () => ({
    masterDetail: {
      enabled: false,
      autoExpandAll: false,
      template: null
    }
  }),
  extenders: {
    controllers: {
      columns: columns3,
      data: dataMasterDetailExtenderMixin,
      resizing: resizing2
    },
    views: {
      rowsView: rowsView2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/master_detail.js
m_core_default.registerModule("masterDetail", masterDetailModule);

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.js
component_registrator_default("dxTextEditor", m_text_editor_mask_default);
var m_text_editor_default = m_text_editor_mask_default;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spin.js
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
var NUMBER_BOX = "dxNumberBox";
var POINTERUP_EVENT_NAME = addNamespace(m_pointer_default.up, NUMBER_BOX);
var POINTERCANCEL_EVENT_NAME = addNamespace(m_pointer_default.cancel, NUMBER_BOX);
var SpinButton = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      direction: "up",
      onChange: null,
      activeStateEnabled: true,
      hoverStateEnabled: true
    });
  }
  _initMarkup() {
    super._initMarkup();
    const {
      direction: spinDirection
    } = this.option();
    const direction = `${SPIN_CLASS}-${spinDirection}`;
    this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
    this._spinIcon = renderer_default("<div>").addClass(`${direction}-icon`).appendTo(this.$element());
  }
  _render() {
    super._render();
    const eventName = addNamespace(m_pointer_default.down, this.NAME);
    const $element = this.$element();
    m_events_engine_default.off($element, eventName);
    m_events_engine_default.on($element, eventName, this._spinDownHandler.bind(this));
    this._spinChangeHandler = this._createActionByOption("onChange");
  }
  _spinDownHandler(e) {
    e.preventDefault();
    this._clearTimer();
    m_events_engine_default.on(this.$element(), m_hold_default.name, (() => {
      this._feedBackDeferred = Deferred();
      lock(this._feedBackDeferred);
      this._spinChangeHandler({
        event: e
      });
      this._holdTimer = setInterval(this._spinChangeHandler, 100, {
        event: e
      });
    }));
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.on(document2, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
    m_events_engine_default.on(document2, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
    this._spinChangeHandler({
      event: e
    });
  }
  _dispose() {
    this._clearTimer();
    super._dispose();
  }
  _clearTimer() {
    m_events_engine_default.off(this.$element(), m_hold_default.name);
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.off(document2, POINTERUP_EVENT_NAME);
    m_events_engine_default.off(document2, POINTERCANCEL_EVENT_NAME);
    if (this._feedBackDeferred) {
      this._feedBackDeferred.resolve();
    }
    if (this._holdTimer) {
      clearInterval(this._holdTimer);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "onChange":
      case "direction":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_number_box_spin_default = SpinButton;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spins.js
var SPIN_CLASS2 = "dx-numberbox-spin";
var SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
var SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var SpinButtons = class extends TextEditorButton {
  _attachEvents(instance, $spinContainer) {
    const {
      editor
    } = this;
    const eventName = addNamespace(m_pointer_default.down, editor.NAME);
    const $spinContainerChildren = $spinContainer.children();
    const pointerDownAction = editor._createAction(((e) => editor._spinButtonsPointerDownHandler(e)));
    m_events_engine_default.off($spinContainer, eventName);
    m_events_engine_default.on($spinContainer, eventName, ((e) => pointerDownAction({
      event: e
    })));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(0)).option("onChange", ((e) => editor._spinUpChangeHandler(e)));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(1)).option("onChange", ((e) => editor._spinDownChangeHandler(e)));
  }
  _create() {
    const {
      editor
    } = this;
    const $spinContainer = renderer_default("<div>").addClass(SPIN_CONTAINER_CLASS);
    const $spinUp = renderer_default("<div>").appendTo($spinContainer);
    const $spinDown = renderer_default("<div>").appendTo($spinContainer);
    const options2 = this._getOptions();
    this._addToContainer($spinContainer);
    editor._createComponent($spinUp, m_number_box_spin_default, extend({
      direction: "up"
    }, options2));
    editor._createComponent($spinDown, m_number_box_spin_default, extend({
      direction: "down"
    }, options2));
    this._legacyRender(editor.$element(), this._isTouchFriendly(), options2.visible);
    return {
      instance: $spinContainer,
      $element: $spinContainer
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible = this._isVisible();
    const disabled = editor.option("disabled");
    return {
      visible,
      disabled
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showSpinButtons");
  }
  _isTouchFriendly() {
    const {
      editor
    } = this;
    return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons");
  }
  _legacyRender($editor, isTouchFriendly, isVisible) {
    $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
    $editor.toggleClass(SPIN_CLASS2, isVisible);
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const isVisible = this._isVisible();
      const isTouchFriendly = this._isTouchFriendly();
      const $spinButtons = instance.children();
      const spinUp = m_number_box_spin_default.getInstance($spinButtons.eq(0));
      const spinDown = m_number_box_spin_default.getInstance($spinButtons.eq(1));
      const options2 = this._getOptions();
      spinUp.option(options2);
      spinDown.option(options2);
      this._legacyRender($editor, isTouchFriendly, isVisible);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.base.js
var math = Math;
var WIDGET_CLASS3 = "dx-numberbox";
var FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
var NumberBoxBase = class extends m_text_editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinUpChangeHandler(e);
        }
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinDownChangeHandler(e);
        }
      },
      enter() {
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: 0,
      min: void 0,
      max: void 0,
      step: 1,
      showSpinButtons: false,
      useLargeSpinButtons: true,
      mode: "text",
      invalidValueMessage: message_default.format("dxNumberBox-invalidValueMessage"),
      buttons: void 0
    });
  }
  _useTemplates() {
    return false;
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "spins",
      Ctor: SpinButtons
    }]);
  }
  _isSupportInputMode() {
    const version = parseFloat(browser_default.version);
    return browser_default.chrome && version >= 66 || browser_default.safari && version >= 12;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => devices_default.real().generic && !devices_default.isSimulator(),
      options: {
        useLargeSpinButtons: false
      }
    }, {
      device: (function() {
        return "desktop" !== devices_default.real().deviceType && !this._isSupportInputMode();
      }).bind(this),
      options: {
        mode: "number"
      }
    }]);
  }
  _initMarkup() {
    this._renderSubmitElement();
    this.$element().addClass(WIDGET_CLASS3);
    super._initMarkup();
    this._toggleTabIndex();
  }
  _getDefaultAttributes() {
    const attributes = super._getDefaultAttributes();
    attributes.inputmode = "decimal";
    return attributes;
  }
  _renderContentImpl() {
    this.option("isValid") && this._validateValue(this.option("value"));
    this.setAria("role", "spinbutton");
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(value2) {
    this._getSubmitElement().val(applyServerDecimalSeparator(value2));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _keyPressHandler(e) {
    super._keyPressHandler();
    const char = getChar(e);
    const isInputCharValid = /[\d.,eE\-+]/.test(char);
    if (!isInputCharValid) {
      const keyName = normalizeKeyName(e);
      if (isCommandKeyPressed(e) || keyName && FIREFOX_CONTROL_KEYS.includes(keyName)) {
        return;
      }
      e.preventDefault();
      return;
    }
    this._keyPressed = true;
  }
  _hasMouseWheelHandler() {
    return true;
  }
  _onMouseWheel(dxEvent) {
    dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent);
  }
  _renderValue() {
    const inputValue = this._input().val();
    const value2 = this.option("value");
    if (!inputValue.length || Number(inputValue) !== value2) {
      this._forceValueRender();
      this._toggleEmptinessEventHandler();
    }
    const valueText = isDefined(value2) ? null : message_default.format("dxNumberBox-noDataText");
    this.setAria({
      valuenow: ensureDefined(value2, ""),
      valuetext: valueText
    });
    this.option("text", this._input().val());
    this._updateButtons();
    return Deferred().resolve();
  }
  _forceValueRender() {
    const value2 = this.option("value");
    const number = Number(value2);
    const formattedValue = isNaN(number) ? "" : this._applyDisplayValueFormatter(value2);
    this._renderDisplayText(formattedValue);
  }
  _applyDisplayValueFormatter(value2) {
    const {
      displayValueFormatter
    } = this.option();
    return null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(value2);
  }
  _renderProps() {
    this._input().prop({
      min: this.option("min"),
      max: this.option("max"),
      step: this.option("step")
    });
    this.setAria({
      valuemin: ensureDefined(this.option("min"), ""),
      valuemax: ensureDefined(this.option("max"), "")
    });
  }
  _spinButtonsPointerDownHandler() {
    const $input = this._input();
    if (!this.option("useLargeSpinButtons") && dom_adapter_default.getActiveElement() !== $input[0]) {
      m_events_engine_default.trigger($input, "focus");
    }
  }
  _spinUpChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(1, e.event || e);
    }
  }
  _spinDownChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(-1, e.event || e);
    }
  }
  _spinValueChange(sign2, dxEvent) {
    const step = parseFloat(this.option("step"));
    if (0 === step) {
      return;
    }
    let value2 = parseFloat(this._normalizeInputValue()) || 0;
    value2 = this._correctRounding(value2, step * sign2);
    const min = this.option("min");
    const max = this.option("max");
    if (isDefined(min)) {
      value2 = Math.max(min, value2);
    }
    if (isDefined(max)) {
      value2 = Math.min(max, value2);
    }
    this._saveValueChangeEvent(dxEvent);
    this.option("value", value2);
  }
  _correctRounding(value2, step) {
    const regex = /[,.](.*)/;
    const isFloatValue = regex.test(value2);
    const isFloatStep = regex.test(step);
    if (isFloatValue || isFloatStep) {
      const valueAccuracy = isFloatValue ? regex.exec(value2)[0].length : 0;
      const stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
      const accuracy = math.max(valueAccuracy, stepAccuracy);
      value2 = this._round(value2 + step, accuracy);
      return value2;
    }
    return value2 + step;
  }
  _round(value2, precision) {
    precision = precision || 0;
    const multiplier = 10 ** precision;
    value2 *= multiplier;
    value2 = Math.round(value2) / multiplier;
    return value2;
  }
  _renderValueChangeEvent() {
    super._renderValueChangeEvent();
    const forceValueChangeEvent = addNamespace("focusout", "NumberBoxForceValueChange");
    m_events_engine_default.off(this.element(), forceValueChangeEvent);
    m_events_engine_default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this));
  }
  _forceRefreshInputValue() {
    const {
      mode
    } = this.option();
    if ("number" === mode) {
      return;
    }
    const $input = this._input();
    const formattedValue = this._applyDisplayValueFormatter(this.option("value"));
    $input.val(null);
    $input.val(formattedValue);
  }
  _valueChangeEventHandler(e) {
    const $input = this._input();
    const inputValue = this._normalizeText();
    const value2 = this._parseValue(inputValue);
    const valueHasDigits = "." !== inputValue && "-" !== inputValue;
    if (this._isValueValid() && !this._validateValue(value2)) {
      $input.val(this._applyDisplayValueFormatter(value2));
      return;
    }
    if (valueHasDigits) {
      super._valueChangeEventHandler(e, isNaN(value2) ? null : value2);
    }
    this._applyValueBoundaries(inputValue, value2);
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
  }
  _applyValueBoundaries(inputValue, parsedValue) {
    const isValueIncomplete = this._isValueIncomplete(inputValue);
    const isValueCorrect = this._isValueInRange(inputValue);
    if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
      if (Number(inputValue) !== parsedValue) {
        this._input().val(this._applyDisplayValueFormatter(parsedValue));
      }
    }
  }
  _replaceCommaWithPoint(value2) {
    return value2.replace(",", ".");
  }
  _inputIsInvalid() {
    const {
      mode
    } = this.option();
    const isNumberMode = "number" === mode;
    const validityState = this._input().get(0).validity;
    return isNumberMode && (null === validityState || void 0 === validityState ? void 0 : validityState.badInput);
  }
  _renderDisplayText(text) {
    if (this._inputIsInvalid()) {
      return;
    }
    super._renderDisplayText(text);
  }
  _isValueIncomplete(value2) {
    return /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(value2);
  }
  _isValueInRange(value2) {
    return inRange(value2, this.option("min"), this.option("max"));
  }
  _isNumber(value2) {
    return null !== this._parseValue(value2);
  }
  _validateValue(value2) {
    const inputValue = this._normalizeText();
    const isValueValid = this._isValueValid();
    let isValid = true;
    const isNumber2 = this._isNumber(inputValue);
    if (isNaN(Number(value2))) {
      isValid = false;
    }
    if (!value2 && isValueValid) {
      isValid = true;
    } else if (!isNumber2 && !isValueValid) {
      isValid = false;
    }
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("invalidValueMessage")
      }
    });
    return isValid;
  }
  _normalizeInputValue() {
    return this._parseValue(this._normalizeText());
  }
  _normalizeText() {
    const value2 = this._input().val().trim();
    return this._replaceCommaWithPoint(value2);
  }
  _parseValue(value2) {
    const number = parseFloat(value2);
    if (isNaN(number)) {
      return null;
    }
    return fitIntoRange(number, this.option("min"), this.option("max"));
  }
  _clearValue() {
    if (this._inputIsInvalid()) {
      this._input().val("");
      this._validateValue();
    }
    super._clearValue();
  }
  clear() {
    if (null === this.option("value")) {
      this.option("text", "");
      if (this._input().length) {
        this._renderValue();
      }
    } else {
      this.option("value", null);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._validateValue(args.value);
        this._setSubmitValue(args.value);
        super._optionChanged(args);
        this._resumeValueChangeAction();
        break;
      case "step":
        this._renderProps();
        break;
      case "min":
      case "max":
        this._renderProps();
        this.option("value", this._parseValue(this.option("value")));
        break;
      case "showSpinButtons":
      case "useLargeSpinButtons":
        this._updateButtons(["spins"]);
        break;
      case "invalidValueMessage":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_number_box_base_default = NumberBoxBase;

// node_modules/devextreme/esm/__internal/ui/number_box/m_utils.js
var getRealSeparatorIndex = function(str) {
  let quoteBalance = 0;
  let separatorCount = 0;
  for (let i = 0; i < str.length; ++i) {
    if ("'" === str[i]) {
      quoteBalance++;
    }
    if ("." === str[i]) {
      ++separatorCount;
      if (quoteBalance % 2 === 0) {
        return {
          occurrence: separatorCount,
          index: i
        };
      }
    }
  }
  return {
    occurrence: 1,
    index: -1
  };
};
var getNthOccurrence = function(str, c, n) {
  let i = -1;
  while (n-- && i++ < str.length) {
    i = str.indexOf(c, i);
  }
  return i;
};
var splitByIndex = function(str, index) {
  if (-1 === index) {
    return [str];
  }
  return [str.slice(0, index), str.slice(index + 1)];
};
var adjustPercentValue = function(rawValue, interval) {
  if (!rawValue) {
    return rawValue;
  }
  return adjust(rawValue / 100, interval / 100);
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.caret.js
var getCaretBoundaries = function(text, format2) {
  if ("string" === typeof format2) {
    const signParts = format2.split(";");
    const sign2 = number_default.getSign(text, format2);
    signParts[1] = signParts[1] || `-${signParts[0]}`;
    format2 = signParts[sign2 < 0 ? 1 : 0];
    const mockEscapedStubs = (str) => str.replace(/'([^']*)'/g, ((str2) => str2.split("").map((() => " ")).join("").substr(2)));
    format2 = mockEscapedStubs(format2);
    const prefixStubLength = /^[^#0.,]*/.exec(format2)[0].length;
    const postfixStubLength = /[^#0.,]*$/.exec(format2)[0].length;
    return {
      start: prefixStubLength,
      end: text.length - postfixStubLength
    };
  }
  return {
    start: 0,
    end: text.length
  };
};
var _getDigitCountBeforeIndex = function(index, text) {
  const decimalSeparator = number_default.getDecimalSeparator();
  const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, "g");
  const textBeforePosition = text.slice(0, index);
  return textBeforePosition.replace(regExp, "").length;
};
var _reverseText = function(text) {
  return text.split("").reverse().join("");
};
var _getDigitPositionByIndex = function(digitIndex, text) {
  if (!digitIndex) {
    return -1;
  }
  const regExp = /[0-9]/g;
  let counter = 1;
  let index = null;
  let result2 = regExp.exec(text);
  while (result2) {
    index = result2.index;
    if (counter >= digitIndex) {
      return index;
    }
    counter++;
    result2 = regExp.exec(text);
  }
  return null === index ? text.length : index;
};
var _trimNonNumericCharsFromEnd = function(text) {
  return text.replace(/[^0-9e]+$/, "");
};
var getCaretWithOffset = function(caret3, offset) {
  if (void 0 === caret3.start) {
    caret3 = {
      start: caret3,
      end: caret3
    };
  }
  return {
    start: caret3.start + offset,
    end: caret3.end + offset
  };
};
var getCaretAfterFormat = function(text, formatted, caret3, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const point = number_default.getDecimalSeparator();
  const isSeparatorBasedText = isSeparatorBasedString(text);
  const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format2).occurrence;
  const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);
  const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);
  const textParts = splitByIndex(text, pointPosition);
  const formattedParts = splitByIndex(formatted, newPointPosition);
  const isCaretOnFloat = -1 !== pointPosition && caret3.start > pointPosition;
  if (isCaretOnFloat) {
    const relativeIndex = caret3.start - pointPosition - 1;
    const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
    const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
    return getCaretInBoundaries(newPosition, formatted, format2);
  }
  const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
  const positionFromEnd = textParts[0].length - caret3.start;
  const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
  const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
  const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
  return getCaretInBoundaries(newPositionFromBegin, formatted, format2);
};
function isSeparatorBasedString(text) {
  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);
}
var isCaretInBoundaries = function(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretInBoundaries(caret3, text, format2);
  return caret3.start >= boundaries.start && caret3.end <= boundaries.end;
};
function getCaretInBoundaries(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretBoundaries(text, format2);
  const adjustedCaret = {
    start: fitIntoRange(caret3.start, boundaries.start, boundaries.end),
    end: fitIntoRange(caret3.end, boundaries.start, boundaries.end)
  };
  return adjustedCaret;
}
var getCaretOffset = function(previousText, newText, format2) {
  const previousBoundaries = getCaretBoundaries(previousText, format2);
  const newBoundaries = getCaretBoundaries(newText, format2);
  return newBoundaries.start - previousBoundaries.start;
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.mask.js
var NumberBoxMask = class extends m_number_box_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      useMaskBehavior: true,
      format: null
    });
  }
  _isDeleteKey(key) {
    return "del" === key;
  }
  _supportedKeys() {
    if (!this._useMaskBehavior()) {
      return super._supportedKeys();
    }
    return _extends({}, super._supportedKeys(), {
      minus: this._revertSign.bind(this),
      del: this._removeHandler.bind(this),
      backspace: this._removeHandler.bind(this),
      leftArrow: this._arrowHandler.bind(this, -1),
      rightArrow: this._arrowHandler.bind(this, 1),
      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),
      enter: this._updateFormattedValue.bind(this),
      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)
    });
  }
  _getTextSeparatorIndex(text) {
    const decimalSeparator = number_default.getDecimalSeparator();
    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option("format")).occurrence;
    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);
  }
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this.clearCaretTimeout();
      this._caretTimeout = setTimeout((() => {
        this._caretTimeout = void 0;
        const caret3 = this._caret();
        if (caret3.start === caret3.end && this._useMaskBehavior()) {
          const text = this._getInputVal();
          const decimalSeparatorIndex = this._getTextSeparatorIndex(text);
          if (decimalSeparatorIndex >= 0) {
            this._caret({
              start: decimalSeparatorIndex,
              end: decimalSeparatorIndex
            });
          } else {
            this._moveCaretToBoundaryEventHandler(-1, e);
          }
        }
      }), 0);
    }
    super._focusInHandler(e);
  }
  _focusOutHandler(e) {
    const shouldHandleEvent = !this._preventNestedFocusEvent(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = true;
      if (this._useMaskBehavior()) {
        this._updateFormattedValue();
      }
    }
    super._focusOutHandler(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = false;
    }
  }
  _hasValueBeenChanged(inputValue) {
    const format2 = this._getFormatPattern();
    const value2 = this.option("value");
    const formatted = this._format(value2, format2) || "";
    return formatted !== inputValue;
  }
  _updateFormattedValue() {
    const inputValue = this._getInputVal();
    if (this._hasValueBeenChanged(inputValue)) {
      this._updateParsedValue();
      this._adjustParsedValue();
      this._setTextByParsedValue();
      const {
        value: value2
      } = this.option();
      if (this._parsedValue !== value2) {
        m_events_engine_default.trigger(this._input(), "change");
      }
    }
  }
  _arrowHandler(step, e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this._getInputVal();
    const format2 = this._getFormatPattern();
    let nextCaret = getCaretWithOffset(this._caret(), step);
    if (!isCaretInBoundaries(nextCaret, text, format2)) {
      nextCaret = 1 === step ? nextCaret.end : nextCaret.start;
      e.preventDefault();
      this._caret(getCaretInBoundaries(nextCaret, text, format2));
    }
  }
  _moveCaretToBoundary(direction) {
    const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());
    const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);
    this._caret(newCaret);
  }
  _moveCaretToBoundaryEventHandler(direction, e) {
    if (!this._useMaskBehavior() || null !== e && void 0 !== e && e.shiftKey) {
      return;
    }
    this._moveCaretToBoundary(direction);
    null === e || void 0 === e || e.preventDefault();
  }
  _shouldMoveCaret(text, caret3) {
    const decimalSeparator = number_default.getDecimalSeparator();
    const isDecimalSeparatorNext = text.charAt(caret3.end) === decimalSeparator;
    const moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey || "," === this._lastKey) && isDecimalSeparatorNext;
    return moveToFloat;
  }
  _getInputVal() {
    return number_default.convertDigits(this._input().val(), true);
  }
  _keyboardHandler(e) {
    this.clearCaretTimeout();
    this._lastKey = number_default.convertDigits(getChar(e), true);
    this._lastKeyName = normalizeKeyName(e);
    if (!this._shouldHandleKey(e.originalEvent)) {
      return super._keyboardHandler(e);
    }
    const normalizedText = this._getInputVal();
    const caret3 = this._caret();
    let enteredChar;
    if ("minus" === this._lastKeyName) {
      enteredChar = "";
    } else {
      enteredChar = 110 === e.which ? number_default.getDecimalSeparator() : this._lastKey;
    }
    const newValue = this._tryParse(normalizedText, caret3, enteredChar);
    if (this._shouldMoveCaret(normalizedText, caret3)) {
      this._moveCaret(1);
      e.originalEvent.preventDefault();
    }
    if (void 0 === newValue) {
      if ("minus" !== this._lastKeyName) {
        e.originalEvent.preventDefault();
      }
    } else {
      this._parsedValue = newValue;
    }
    return super._keyboardHandler(e);
  }
  _keyPressHandler(e) {
    if (!this._useMaskBehavior()) {
      super._keyPressHandler(e);
    }
  }
  _removeHandler(e) {
    const caret3 = this._caret();
    const text = this._getInputVal();
    let {
      start
    } = caret3;
    let {
      end
    } = caret3;
    this._lastKey = getChar(e);
    this._lastKeyName = normalizeKeyName(e);
    const isDeleteKey = this._isDeleteKey(this._lastKeyName);
    const isBackspaceKey = !isDeleteKey;
    if (start === end) {
      const caretPosition = start;
      const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
      if (canDelete) {
        isDeleteKey && end++;
        isBackspaceKey && start--;
      } else {
        e.preventDefault();
        return;
      }
    }
    const char = text.slice(start, end);
    if (this._isStub(char)) {
      this._moveCaret(isDeleteKey ? 1 : -1);
      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {
        this._revertSign(e);
        this._setTextByParsedValue();
        const shouldTriggerInputEvent = this.option("valueChangeEvent").split(" ").includes("input");
        if (shouldTriggerInputEvent) {
          m_events_engine_default.trigger(this._input(), "input");
        }
      }
      e.preventDefault();
      return;
    }
    const decimalSeparator = number_default.getDecimalSeparator();
    if (char === decimalSeparator) {
      const decimalSeparatorIndex = text.indexOf(decimalSeparator);
      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
        this._moveCaret(isDeleteKey ? 1 : -1);
        e.preventDefault();
      }
      return;
    }
    if (end - start < text.length) {
      const editedText = this._replaceSelectedText(text, {
        start,
        end
      }, "");
      const noDigits = editedText.search(/[0-9]/) < 0;
      if (noDigits && this._isValueInRange(0)) {
        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
        return;
      }
    }
    const valueAfterRemoving = this._tryParse(text, {
      start,
      end
    }, "");
    if (void 0 === valueAfterRemoving) {
      e.preventDefault();
    } else {
      this._parsedValue = valueAfterRemoving;
    }
  }
  _isPercentFormat() {
    const format2 = this._getFormatPattern();
    const noEscapedFormat = format2.replace(/'[^']+'/g, "");
    return -1 !== noEscapedFormat.indexOf("%");
  }
  _parse(text, format2) {
    const formatOption = this.option("format");
    const isCustomParser = isFunction(formatOption.parser);
    const parser = isCustomParser ? formatOption.parser : number_default.parse;
    let integerPartStartIndex = 0;
    if (!isCustomParser) {
      const formatPointIndex = getRealSeparatorIndex(format2).index;
      const textPointIndex = this._getTextSeparatorIndex(text);
      const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format2.length;
      const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;
      if (textIntegerPartLength > formatIntegerPartLength && -1 === format2.indexOf("#")) {
        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;
      }
    }
    text = text.substr(integerPartStartIndex);
    return parser(text, format2);
  }
  _format(value2, format2) {
    const formatOption = this.option("format");
    const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
    const formatter = isFunction(customFormatter) ? customFormatter : number_default.format;
    const formattedValue = null === value2 ? "" : formatter(value2, format2);
    return formattedValue;
  }
  _getFormatPattern() {
    if (!this._currentFormat) {
      this._updateFormat();
    }
    return this._currentFormat;
  }
  _updateFormat() {
    const {
      format: format2
    } = this.option();
    const isCustomParser = isFunction(null === format2 || void 0 === format2 ? void 0 : format2.parser);
    const isLDMLPattern = isString(format2) && (format2.includes("0") || format2.includes("#"));
    const isExponentialFormat = "exponential" === format2 || "exponential" === (null === format2 || void 0 === format2 ? void 0 : format2.type);
    const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;
    this._currentFormat = shouldUseFormatAsIs ? format2 : getFormat(((value2) => {
      const text = this._format(value2, format2);
      return number_default.convertDigits(text, true);
    }));
  }
  _getFormatForSign(text) {
    const format2 = this._getFormatPattern();
    if (isString(format2)) {
      const signParts = format2.split(";");
      const sign3 = number_default.getSign(text, format2);
      signParts[1] = signParts[1] || `-${signParts[0]}`;
      return sign3 < 0 ? signParts[1] : signParts[0];
    }
    const sign2 = number_default.getSign(text);
    return sign2 < 0 ? "-" : "";
  }
  _removeStubs(text, excludeComma) {
    const format2 = this._getFormatForSign(text);
    const thousandsSeparator = number_default.getThousandsSeparator();
    const stubs = this._getStubs(format2);
    let result2 = text;
    if (stubs.length) {
      const prefixStubs = stubs[0];
      const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1] || "")})$`, "g");
      const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma ? "" : thousandsSeparator)}]`, "g");
      result2 = result2.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "");
    }
    return result2;
  }
  _getStubs(format2) {
    const regExpResult = /[^']([#0.,]+)/g.exec(format2);
    const pattern = regExpResult && regExpResult[0].trim();
    return format2.split(pattern).map(((stub) => stub.replace(/'/g, "")));
  }
  _truncateToPrecision(value2, maxPrecision) {
    if (isDefined(value2)) {
      const strValue = value2.toString();
      const decimalSeparatorIndex = strValue.indexOf(".");
      if (strValue && decimalSeparatorIndex > -1) {
        const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
        return isNaN(parsedValue) ? value2 : parsedValue;
      }
    }
    return value2;
  }
  _tryParse(text, selection2, char) {
    const isTextSelected = selection2.start !== selection2.end;
    const isWholeTextSelected = isTextSelected && 0 === selection2.start && selection2.end === text.length;
    const decimalSeparator = number_default.getDecimalSeparator();
    if (isWholeTextSelected && char === decimalSeparator) {
      return 0;
    }
    const editedText = this._replaceSelectedText(text, selection2, char);
    const format2 = this._getFormatPattern();
    let parsedValue = this._getParsedValue(editedText, format2);
    const maxPrecision = !format2.parser && this._getPrecisionLimits(editedText).max;
    const isValueChanged = parsedValue !== this._parsedValue;
    const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
    const isUselessCharRestricted = !isTextSelected && !isValueChanged && "-" !== char && this._isStub(char);
    if (isDecimalPointRestricted || isUselessCharRestricted) {
      return;
    }
    if ("" === this._removeStubs(editedText)) {
      parsedValue = Math.abs(0 * this._parsedValue);
    }
    if (isNaN(parsedValue)) {
      return;
    }
    const value2 = null === parsedValue ? this._parsedValue : parsedValue;
    parsedValue = maxPrecision ? this._truncateToPrecision(value2, maxPrecision) : parsedValue;
    if (!format2.parser && this._isPercentFormat()) {
      const interval = this._getIntervalFromPrecision(maxPrecision);
      return adjustPercentValue(parsedValue, interval);
    }
    return parsedValue;
  }
  _getIntervalFromPrecision(precision) {
    if (precision < 1) {
      return 1;
    }
    return 10 ** -precision;
  }
  _getParsedValue(text, format2) {
    const sign2 = number_default.getSign(text, (null === format2 || void 0 === format2 ? void 0 : format2.formatter) || format2);
    const textWithoutStubs = this._removeStubs(text, true);
    const parsedValue = this._parse(textWithoutStubs, format2);
    const parsedValueSign = parsedValue < 0 ? -1 : 1;
    const parsedValueWithSign = isNumeric(parsedValue) && sign2 !== parsedValueSign ? sign2 * parsedValue : parsedValue;
    return parsedValueWithSign;
  }
  _isValueIncomplete(text) {
    if (!this._useMaskBehavior()) {
      return super._isValueIncomplete(text);
    }
    const caret3 = this._caret();
    const point = number_default.getDecimalSeparator();
    const pointIndex = this._getTextSeparatorIndex(text);
    const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret3.start;
    const textParts = this._removeStubs(text, true).split(point);
    if (!isCaretOnFloat || 2 !== textParts.length) {
      return false;
    }
    const floatLength = textParts[1].length;
    const format2 = this._getFormatPattern();
    const isCustomParser = !!format2.parser;
    const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern());
    const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);
    const endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
    return isPrecisionInRange && (endsWithZero || !floatLength);
  }
  _isValueInRange(value2) {
    const min = ensureDefined(this.option("min"), -1 / 0);
    const max = ensureDefined(this.option("max"), 1 / 0);
    return inRange(value2, min, max);
  }
  _setInputText(text) {
    const normalizedText = number_default.convertDigits(text, true);
    const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
    this._input().val(text);
    this._toggleEmptinessEventHandler();
    this._formattedValue = text;
    if (!this._focusOutOccurs) {
      this._caret(newCaret);
    }
  }
  _useMaskBehavior() {
    const {
      useMaskBehavior
    } = this.option();
    return !!this.option("format") && useMaskBehavior;
  }
  _renderInputType() {
    const {
      mode
    } = this.option();
    const isNumberType = "number" === mode;
    const isDesktop = "desktop" === devices_default.real().deviceType;
    if (this._useMaskBehavior() && isNumberType) {
      this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel");
    } else {
      super._renderInputType();
    }
  }
  _isChar(str) {
    return isString(str) && 1 === str.length;
  }
  _moveCaret(offset) {
    if (!offset) {
      return;
    }
    const newCaret = getCaretWithOffset(this._caret(), offset);
    const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());
    this._caret(adjustedCaret);
  }
  _shouldHandleKey(e) {
    const keyName = normalizeKeyName(e);
    const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
    const isMinusKey = "minus" === keyName;
    const useMaskBehavior = this._useMaskBehavior();
    return useMaskBehavior && !isSpecialChar && !isMinusKey;
  }
  _renderInput() {
    super._renderInput();
    this._renderFormatter();
  }
  _renderFormatter() {
    this._clearCache();
    this._detachFormatterEvents();
    if (this._useMaskBehavior()) {
      this._attachFormatterEvents();
    }
  }
  _detachFormatterEvents() {
    m_events_engine_default.off(this._input(), ".dxNumberFormatter");
  }
  _isInputFromPaste(e) {
    var _e$originalEvent;
    const inputType2 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.inputType;
    if (isDefined(inputType2)) {
      return "insertFromPaste" === inputType2;
    }
    return this._isValuePasted;
  }
  _attachFormatterEvents() {
    const $input = this._input();
    m_events_engine_default.on($input, addNamespace("input", "dxNumberFormatter"), ((e) => {
      this._formatValue(e);
      this._isValuePasted = false;
    }));
    m_events_engine_default.on($input, addNamespace("dxclick", "dxNumberFormatter"), (() => {
      if (!this._caretTimeout) {
        this._caretTimeout = setTimeout((() => {
          this._caretTimeout = void 0;
          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));
        }), 0);
      }
    }));
    m_events_engine_default.on($input, DBLCLICK_EVENT_NAME, (() => {
      this.clearCaretTimeout();
    }));
  }
  clearCaretTimeout() {
    clearTimeout(this._caretTimeout);
    this._caretTimeout = void 0;
  }
  _forceRefreshInputValue() {
    if (!this._useMaskBehavior()) {
      return super._forceRefreshInputValue();
    }
  }
  _isNonStubAfter(index) {
    const text = this._getInputVal().slice(index);
    return text && !this._isStub(text, true);
  }
  _isStub(str, isString4) {
    const escapedDecimalSeparator = escapeRegExp(number_default.getDecimalSeparator());
    const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;
    const stubRegExp = new RegExp(regExpString, "g");
    return stubRegExp.test(str) && (isString4 || this._isChar(str));
  }
  _parseValue(text) {
    if (!this._useMaskBehavior()) {
      return super._parseValue(text);
    }
    return this._parsedValue;
  }
  _getPrecisionLimits(text) {
    const currentFormat = this._getFormatForSign(text);
    const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;
    const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
    const minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
    const maxPrecision = floatPart.length;
    return {
      min: minPrecision,
      max: maxPrecision
    };
  }
  _revertSign(e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const caret3 = this._caret();
    if (caret3.start !== caret3.end) {
      if ("minus" === normalizeKeyName(e)) {
        this._applyRevertedSign(e, caret3, true);
        return;
      }
      this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));
    }
    this._applyRevertedSign(e, caret3);
  }
  _applyRevertedSign(e, caret3, preserveSelectedText) {
    const newValue = -1 * ensureDefined(this._parsedValue, null);
    if (this._isValueInRange(newValue) || 0 === newValue) {
      this._parsedValue = newValue;
      if (preserveSelectedText) {
        const format2 = this._getFormatPattern();
        const previousText = this._getInputVal();
        this._setTextByParsedValue();
        e.preventDefault();
        const currentText = this._getInputVal();
        const offset = getCaretOffset(previousText, currentText, format2);
        caret3 = getCaretWithOffset(caret3, offset);
        const caretInBoundaries = getCaretInBoundaries(caret3, currentText, format2);
        this._caret(caretInBoundaries);
      }
    }
  }
  _removeMinusFromText(text, caret3) {
    const isMinusPressed = "minus" === this._lastKeyName && "-" === text.charAt(caret3.start - 1);
    return isMinusPressed ? this._replaceSelectedText(text, {
      start: caret3.start - 1,
      end: caret3.start
    }, "") : text;
  }
  _setTextByParsedValue() {
    const format2 = this._getFormatPattern();
    const parsed = this._parseValue();
    const formatted = this._format(parsed, format2) || "";
    this._setInputText(formatted);
  }
  _formatValue(e) {
    let normalizedText = this._getInputVal();
    const caret3 = this._caret();
    const textWithoutMinus = this._removeMinusFromText(normalizedText, caret3);
    const wasMinusRemoved = textWithoutMinus !== normalizedText;
    normalizedText = textWithoutMinus;
    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
      this._formattedValue = normalizedText;
      if (wasMinusRemoved) {
        this._setTextByParsedValue();
      }
      return;
    }
    const textWasChanged = number_default.convertDigits(this._formattedValue, true) !== normalizedText;
    if (textWasChanged) {
      const value2 = this._tryParse(normalizedText, caret3, "");
      if (isDefined(value2)) {
        this._parsedValue = value2;
      }
    }
    this._setTextByParsedValue();
  }
  _renderDisplayText() {
    if (this._useMaskBehavior()) {
      this._toggleEmptinessEventHandler();
    } else {
      super._renderDisplayText.apply(this, arguments);
    }
  }
  _renderValue() {
    if (this._useMaskBehavior()) {
      const {
        value: value2
      } = this.option();
      this._parsedValue = value2;
      this._setTextByParsedValue();
    }
    return super._renderValue();
  }
  _updateParsedValue() {
    const inputValue = this._getInputVal();
    this._parsedValue = this._tryParse(inputValue, this._caret());
  }
  _adjustParsedValue() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const clearedText = this._removeStubs(this._getInputVal());
    const parsedValue = clearedText ? this._parseValue() : null;
    if (!isNumeric(parsedValue)) {
      this._parsedValue = parsedValue;
      return;
    }
    this._parsedValue = fitIntoRange(parsedValue, this.option("min"), this.option("max"));
  }
  _valueChangeEventHandler(e) {
    if (!this._useMaskBehavior()) {
      return super._valueChangeEventHandler(e);
    }
    const caret3 = this._caret();
    this._saveValueChangeEvent(e);
    this._lastKey = null;
    this._lastKeyName = null;
    this._updateParsedValue();
    this._adjustParsedValue();
    this.option("value", this._parsedValue);
    if (caret3) {
      this._caret(caret3);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "format":
      case "useMaskBehavior":
        this._renderInputType();
        this._updateFormat();
        this._renderFormatter();
        this._renderValue();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        break;
      case "min":
      case "max":
        this._adjustParsedValue();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearCache() {
    delete this._formattedValue;
    delete this._lastKey;
    delete this._lastKeyName;
    delete this._parsedValue;
    delete this._focusOutOccurs;
    clearTimeout(this._caretTimeout);
    delete this._caretTimeout;
  }
  _clean() {
    this._clearCache();
    super._clean();
  }
};
var m_number_box_mask_default = NumberBoxMask;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.js
component_registrator_default("dxNumberBox", m_number_box_mask_default);
var m_number_box_default = m_number_box_mask_default;

// node_modules/devextreme/esm/ui/number_box.js
var number_box_default = m_number_box_default;

// node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_button.js
var RadioButton = class extends editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false
    });
  }
  _canValueBeChangedByClick() {
    return true;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-radiobutton");
  }
  _initMarkup() {
    super._initMarkup();
    this._renderIcon();
    this._renderCheckedState(this.option("value"));
    this._renderClick();
    this.setAria("role", "radio");
  }
  _renderIcon() {
    this._$icon = renderer_default("<div>").addClass("dx-radiobutton-icon");
    renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo(this._$icon);
    this.$element().append(this._$icon);
  }
  _renderCheckedState(checked) {
    this.$element().toggleClass("dx-radiobutton-checked", checked).find(".dx-radiobutton-icon").toggleClass("dx-radiobutton-icon-checked", checked);
    this.setAria("checked", checked);
  }
  _renderClick() {
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    this._clickAction = this._createAction(((args) => {
      this._clickHandler(args.event);
    }));
    m_events_engine_default.off(this.$element(), eventName);
    m_events_engine_default.on(this.$element(), eventName, ((e) => {
      var _this$_clickAction;
      null === (_this$_clickAction = this._clickAction) || void 0 === _this$_clickAction || _this$_clickAction.call(this, {
        event: e
      });
    }));
  }
  _clickHandler(e) {
    this._saveValueChangeEvent(e);
    this.option("value", true);
    this._saveValueChangeEvent(void 0);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    if ("value" === name2) {
      this._renderCheckedState(value2);
      super._optionChanged(args);
    } else {
      super._optionChanged(args);
    }
  }
};
component_registrator_default("dxRadioButton", RadioButton);
var m_radio_button_default = RadioButton;

// node_modules/devextreme/esm/ui/radio_group/radio_button.js
var radio_button_default = m_radio_button_default;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.js
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = addNamespace(SWIPE_START_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_UPDATE_EVENT_NAME = addNamespace(SWIPE_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_END_EVENT_NAME = addNamespace(SWIPE_END_EVENT, LIST_EDIT_DECORATOR);
var EditDecorator = class extends class_default.inherit({}) {
  ctor(list) {
    this._list = list;
    this._init();
  }
  _shouldHandleSwipe() {
    return false;
  }
  _init() {
  }
  _attachSwipeEvent(config2) {
    const swipeConfig = {
      itemSizeFunc: (function() {
        if (this._clearSwipeCache) {
          this._itemWidthCache = getWidth(this._list.$element());
          this._clearSwipeCache = false;
        }
        return this._itemWidthCache;
      }).bind(this)
    };
    m_events_engine_default.on(config2.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
    m_events_engine_default.on(config2.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
    m_events_engine_default.on(config2.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeStartHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    clearTimeout(this._list._inkRippleTimer);
    this._swipeStartHandler($itemElement, e);
  }
  _itemSwipeUpdateHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeUpdateHandler($itemElement, e);
  }
  _itemSwipeEndHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeEndHandler($itemElement, e);
    this._clearSwipeCache = true;
  }
  beforeBag(config2) {
  }
  afterBag() {
  }
  _commonOptions() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  }
  modifyElement(config2) {
    if (this._shouldHandleSwipe()) {
      this._attachSwipeEvent(config2);
      this._clearSwipeCache = true;
    }
  }
  afterRender() {
  }
  handleClick($itemElement, e) {
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
  }
  handleEnterPressing() {
  }
  handleContextMenu($itemElement) {
  }
  _swipeStartHandler($element, event) {
  }
  _swipeUpdateHandler($element, event) {
  }
  _swipeEndHandler($element, event) {
  }
  visibilityChange() {
  }
  getExcludedSelectors() {
  }
  dispose() {
  }
};
var m_list_edit_decorator_default = EditDecorator;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator_registry.js
var registry = {};
function register(option, type2, decoratorClass) {
  const decoratorsRegistry = registry;
  const decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend(decoratorsRegistry, decoratorConfig);
}

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.selection.js
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var CLICK_EVENT_NAME2 = addNamespace(CLICK_EVENT_NAME, "dxListEditDecorator");
var EditDecoratorSelection = class extends m_list_edit_decorator_default {
  _init() {
    super._init.apply(this, arguments);
    const selectionMode = this._list.option("selectionMode");
    this._singleStrategy = "single" === selectionMode;
    this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
    this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
    this._controlWidget = this._singleStrategy ? radio_button_default : check_box_default2;
    this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
  }
  beforeBag(config2) {
    const {
      $itemElement
    } = config2;
    const $container = config2.$container.addClass(this._containerClass);
    const $control = renderer_default("<div>").addClass(this._controlClass).appendTo($container);
    new this._controlWidget($control, extend(this._commonOptions(), {
      value: this._isSelected($itemElement),
      elementAttr: {
        "aria-label": message_default.format("CheckState")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false,
      onValueChanged: (_ref) => {
        let {
          value: value2,
          component,
          event
        } = _ref;
        const isUiClick = !!event;
        if (isUiClick) {
          component._valueChangeEventInstance = void 0;
          component.option("value", !value2);
        }
      }
    }));
  }
  modifyElement(config2) {
    super.modifyElement.apply(this, arguments);
    const {
      $itemElement
    } = config2;
    const control = this._controlWidget.getInstance($itemElement.find(`.${this._controlClass}`));
    m_events_engine_default.on($itemElement, "stateChanged", ((e, state) => {
      control.option("value", state);
    }));
  }
  _updateSelectAllState() {
    if (!this._$selectAll) {
      return;
    }
    this._selectAllCheckBox.option("value", this._list.isSelectAll());
  }
  afterRender() {
    if ("all" !== this._list.option("selectionMode")) {
      return;
    }
    if (!this._$selectAll) {
      this._renderSelectAll();
    } else {
      this._updateSelectAllState();
    }
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    const moveFocusDown = !moveFocusUp;
    const list = this._list;
    const $selectAll = this._$selectAll;
    const lastItemIndex = list._getLastItemIndex();
    const isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
    const hasSelectAllItem = !!$selectAll;
    if (hasSelectAllItem && isFocusOutOfList) {
      list.option("focusedElement", $selectAll);
      list.scrollToItem(list.option("focusedElement"));
      return true;
    }
    return false;
  }
  handleEnterPressing(e) {
    var _this$_$selectAll;
    if (null !== (_this$_$selectAll = this._$selectAll) && void 0 !== _this$_$selectAll && _this$_$selectAll.hasClass("dx-state-focused")) {
      e.target = this._$selectAll.get(0);
      this._selectAllHandler(e);
      return true;
    }
  }
  _renderSelectAll() {
    this._$selectAll = renderer_default("<div>").addClass("dx-list-select-all");
    const downArrowHandler = this._list._supportedKeys().downArrow.bind(this._list);
    const selectAllCheckBoxElement = renderer_default("<div>").addClass("dx-list-select-all-checkbox").appendTo(this._$selectAll);
    this._selectAllCheckBox = this._list._createComponent(selectAllCheckBoxElement, check_box_default2, {
      elementAttr: {
        "aria-label": message_default.format("dxList-selectAll")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false
    });
    this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
    renderer_default("<div>").addClass("dx-list-select-all-label").text(this._list.option("selectAllText")).appendTo(this._$selectAll);
    this._list.itemsContainer().prepend(this._$selectAll);
    this._updateSelectAllState();
    this._updateSelectAllAriaLabel();
    this._attachSelectAllHandler();
  }
  _attachSelectAllHandler() {
    this._selectAllCheckBox.option("onValueChanged", ((_ref2) => {
      let {
        value: value2,
        event,
        component
      } = _ref2;
      const isUiClick = !!event;
      if (isUiClick) {
        component._setOptionWithoutOptionChange("value", !value2);
        return;
      }
      this._updateSelectAllAriaLabel();
      this._list._createActionByOption("onSelectAllValueChanged")({
        value: value2
      });
    }));
    m_events_engine_default.off(this._$selectAll, CLICK_EVENT_NAME2);
    m_events_engine_default.on(this._$selectAll, CLICK_EVENT_NAME2, this._selectAllHandler.bind(this));
  }
  _updateSelectAllAriaLabel() {
    if (!this._$selectAll) {
      return;
    }
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    const indeterminate = void 0 === value2;
    const stateVariableName = indeterminate ? "indeterminate" : value2 ? "checked" : "notChecked";
    const label = `${message_default.format("dxList-selectAll")}, ${message_default.format(`dxList-selectAll-${stateVariableName}`)}`;
    this._$selectAll.attr({
      "aria-label": label
    });
  }
  _selectAllHandler(event) {
    var _this$_$selectAll2;
    event.stopPropagation();
    this._list._saveSelectionChangeEvent(event);
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    let selectionDeferred;
    if (true !== value2) {
      selectionDeferred = this._selectAllItems();
    } else {
      selectionDeferred = this._unselectAllItems();
    }
    this._list.option("focusedElement", null === (_this$_$selectAll2 = this._$selectAll) || void 0 === _this$_$selectAll2 ? void 0 : _this$_$selectAll2.get(0));
    return selectionDeferred;
  }
  _checkSelectAllCapability() {
    const list = this._list;
    const dataController2 = list._dataController;
    if ("allPages" === list.option("selectAllMode") && list.option("grouped") && !dataController2.group()) {
      ui_errors_default.log("W1010");
      return false;
    }
    return true;
  }
  _selectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return Deferred().resolve();
    }
    return this._list._selection.selectAll("page" === this._list.option("selectAllMode"));
  }
  _unselectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return Deferred().resolve();
    }
    return this._list._selection.deselectAll("page" === this._list.option("selectAllMode"));
  }
  _isSelected($itemElement) {
    return this._list.isItemSelected($itemElement);
  }
  dispose() {
    this._disposeSelectAll();
    this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
    super.dispose.apply(this, arguments);
  }
  _disposeSelectAll() {
    if (this._$selectAll) {
      this._$selectAll.remove();
      this._$selectAll = null;
    }
  }
};
register("selection", "default", EditDecoratorSelection);

// node_modules/devextreme/esm/__internal/ui/editor/m_data_expression.js
var DataExpressionMixin = extend({}, data_helper_default, {
  _dataExpressionDefaultOptions: () => ({
    items: [],
    dataSource: null,
    itemTemplate: "item",
    value: null,
    valueExpr: "this",
    displayExpr: void 0
  }),
  _initDataExpressions() {
    this._compileValueGetter();
    this._compileDisplayGetter();
    this._initDynamicTemplates();
    this._initDataSource();
    this._itemsToDataSource();
  },
  _itemsToDataSource() {
    if (!this.option("dataSource")) {
      this._dataSource = new data_source_default({
        store: new m_array_store_default(this.option("items")),
        pageSize: 0
      });
      this._initDataController();
    }
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this._displayGetterExpr());
  },
  _displayGetterExpr() {
    return this.option("displayExpr");
  },
  _compileValueGetter() {
    this._valueGetter = compileGetter(this._valueGetterExpr());
  },
  _valueGetterExpr() {
    return this.option("valueExpr") || "this";
  },
  _loadValue(value2) {
    const deferred = Deferred();
    value2 = this._unwrappedValue(value2);
    if (!isDefined(value2)) {
      return deferred.reject().promise();
    }
    this._loadSingle(this._valueGetterExpr(), value2).done(((item) => {
      this._isValueEquals(this._valueGetter(item), value2) ? deferred.resolve(item) : deferred.reject();
    })).fail((() => {
      deferred.reject();
    }));
    this._loadValueDeferred = deferred;
    return deferred.promise();
  },
  _rejectValueLoading() {
    var _this$_loadValueDefer;
    null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer || _this$_loadValueDefer.reject({
      shouldSkipCallback: true
    });
  },
  _getCurrentValue() {
    return this.option("value");
  },
  _unwrappedValue(value2) {
    value2 = value2 ?? this._getCurrentValue();
    if (value2 && this._dataSource && "this" === this._valueGetterExpr()) {
      value2 = this._getItemKey(value2);
    }
    return variable_wrapper_default.unwrap(value2);
  },
  _getItemKey(value2) {
    const key = this._dataSource.key();
    if (Array.isArray(key)) {
      const result2 = {};
      for (let i = 0, n = key.length; i < n; i++) {
        result2[key[i]] = value2[key[i]];
      }
      return result2;
    }
    if (key && "object" === typeof value2) {
      value2 = value2[key];
    }
    return value2;
  },
  _isValueEquals(value1, value2) {
    const dataSourceKey = this._dataSource && this._dataSource.key();
    let result2 = this._compareValues(value1, value2);
    if (!result2 && dataSourceKey && isDefined(value1) && isDefined(value2)) {
      if (Array.isArray(dataSourceKey)) {
        result2 = this._compareByCompositeKey(value1, value2, dataSourceKey);
      } else {
        result2 = this._compareByKey(value1, value2, dataSourceKey);
      }
    }
    return result2;
  },
  _compareByCompositeKey(value1, value2, key) {
    const isObject2 = isObject;
    if (!isObject2(value1) || !isObject2(value2)) {
      return false;
    }
    for (let i = 0, n = key.length; i < n; i++) {
      if (value1[key[i]] !== value2[key[i]]) {
        return false;
      }
    }
    return true;
  },
  _compareByKey(value1, value2, key) {
    const unwrapObservable = variable_wrapper_default.unwrap;
    const valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
    const valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
    return this._compareValues(valueKey1, valueKey2);
  },
  _compareValues: (value1, value2) => toComparable(value1, true) === toComparable(value2, true),
  _initDynamicTemplates: noop,
  _setCollectionWidgetItemTemplate() {
    this._initDynamicTemplates();
    this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
  },
  _getCollectionKeyExpr() {
    const valueExpr = this.option("valueExpr");
    const isValueExprField = isString(valueExpr) && "this" !== valueExpr || isFunction(valueExpr);
    return isValueExprField ? valueExpr : null;
  },
  _dataExpressionOptionChanged(args) {
    switch (args.name) {
      case "items":
        this._itemsToDataSource();
        this._setCollectionWidgetOption("items");
        break;
      case "dataSource":
        this._initDataSource();
        break;
      case "itemTemplate":
        this._setCollectionWidgetItemTemplate();
        break;
      case "valueExpr":
        this._compileValueGetter();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("displayExpr");
    }
  }
});
var m_data_expression_default = DataExpressionMixin;

// node_modules/devextreme/esm/ui/editor/ui.data_expression.js
var ui_data_expression_default = m_data_expression_default;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.provider.js
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
  editOptionsRegistry.push({
    enabled: enabledFunc,
    decoratorType: decoratorTypeFunc,
    decoratorSubType: decoratorSubTypeFunc
  });
};
registerOption((function() {
  return this.option("menuItems").length;
}), (() => "menu"), (function() {
  return this.option("menuMode");
}));
registerOption((function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}), (function() {
  const mode = this.option("itemDeleteMode");
  return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu";
}), (function() {
  let mode = this.option("itemDeleteMode");
  if ("slideItem" === mode) {
    mode = "slide";
  }
  return mode;
}));
registerOption((function() {
  return "none" !== this.option("selectionMode") && this.option("showSelectionControls");
}), (() => "selection"), (() => "default"));
registerOption((function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}), (() => "reorder"), (() => "default"));
var EditProvider = class extends class_default.inherit({}) {
  ctor(list) {
    this._list = list;
    this._fetchRequiredDecorators();
  }
  dispose() {
    var _this$_decorators;
    if (null !== (_this$_decorators = this._decorators) && void 0 !== _this$_decorators && _this$_decorators.length) {
      each(this._decorators, ((_, decorator) => {
        decorator.dispose();
      }));
    }
  }
  _fetchRequiredDecorators() {
    this._decorators = [];
    each(editOptionsRegistry, ((_, option) => {
      const optionEnabled = option.enabled.call(this._list);
      if (optionEnabled) {
        const decoratorType = option.decoratorType.call(this._list);
        const decoratorSubType = option.decoratorSubType.call(this._list);
        const decorator = this._createDecorator(decoratorType, decoratorSubType);
        this._decorators.push(decorator);
      }
    }));
  }
  _createDecorator(type2, subType) {
    const decoratorClass = this._findDecorator(type2, subType);
    return new decoratorClass(this._list);
  }
  _findDecorator(type2, subType) {
    var _registry$type;
    const foundDecorator = null === (_registry$type = registry[type2]) || void 0 === _registry$type ? void 0 : _registry$type[subType];
    if (!foundDecorator) {
      throw ui_errors_default.Error("E1012", type2, subType);
    }
    return foundDecorator;
  }
  modifyItemElement(args) {
    const $itemElement = renderer_default(args.itemElement);
    const config2 = {
      $itemElement
    };
    this._prependBeforeBags($itemElement, config2);
    this._appendAfterBags($itemElement, config2);
    this._applyDecorators("modifyElement", config2);
  }
  afterItemsRendered() {
    this._applyDecorators("afterRender");
  }
  _prependBeforeBags($itemElement, config2) {
    const $beforeBags = this._collectDecoratorsMarkup("beforeBag", config2, "dx-list-item-before-bag");
    $itemElement.prepend($beforeBags);
  }
  _appendAfterBags($itemElement, config2) {
    const $afterBags = this._collectDecoratorsMarkup("afterBag", config2, "dx-list-item-after-bag");
    $itemElement.append($afterBags);
  }
  _collectDecoratorsMarkup(method, config2, containerClass) {
    const $collector = renderer_default("<div>");
    each(this._decorators, (function() {
      const $container = renderer_default("<div>").addClass(containerClass);
      this[method](extend({
        $container
      }, config2));
      if ($container.children().length) {
        $collector.append($container);
      }
    }));
    return $collector.children();
  }
  _applyDecorators(method, config2) {
    each(this._decorators, (function() {
      this[method](config2);
    }));
  }
  _handlerExists(name2) {
    if (!this._decorators) {
      return false;
    }
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      if (decorators[i][name2] !== noop) {
        return true;
      }
    }
    return false;
  }
  _eventHandler(name2, $itemElement, e) {
    if (!this._decorators) {
      return false;
    }
    let response = false;
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      response = decorators[i][name2]($itemElement, e);
      if (response) {
        break;
      }
    }
    return response;
  }
  handleClick($itemElement, e) {
    return this._eventHandler("handleClick", $itemElement, e);
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
  }
  handleEnterPressing(e) {
    return this._eventHandler("handleEnterPressing", e);
  }
  contextMenuHandlerExists() {
    return this._handlerExists("handleContextMenu");
  }
  handleContextMenu($itemElement, e) {
    return this._eventHandler("handleContextMenu", $itemElement, e);
  }
  getExcludedItemSelectors() {
    const excludedSelectors = [];
    this._applyDecorators("getExcludedSelectors", excludedSelectors);
    return excludedSelectors.join(",");
  }
};
var m_list_edit_provider_default = EditProvider;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.strategy.grouped.js
var combineIndex = (indices) => (indices.group << 20) + indices.item;
var splitIndex = (combinedIndex) => ({
  group: combinedIndex >> 20,
  item: 1048575 & combinedIndex
});
var GroupedEditStrategy = class extends m_collection_widget_edit_strategy_plain_default {
  _groupElements() {
    return this._collectionWidget._itemContainer().find(".dx-list-group");
  }
  _groupItemElements($group) {
    return $group.find(".dx-list-item");
  }
  getIndexByItemData(itemData) {
    var _itemData$items;
    const groups = this._collectionWidget.option("items");
    let index = false;
    if (!itemData) {
      return false;
    }
    if (null !== (_itemData$items = itemData.items) && void 0 !== _itemData$items && _itemData$items.length) {
      itemData = itemData.items[0];
    }
    each(groups, ((groupIndex, group) => {
      if (!group.items) {
        return false;
      }
      each(group.items, ((itemIndex, item) => {
        if (item !== itemData) {
          return true;
        }
        index = {
          group: groupIndex,
          item: itemIndex
        };
        return false;
      }));
      if (index) {
        return false;
      }
    }));
    return index;
  }
  getItemDataByIndex(index) {
    var _items$index$group;
    const items = this._collectionWidget.option("items");
    if (isNumeric(index)) {
      return this.itemsGetter()[index];
    }
    return index && (null === (_items$index$group = items[index.group]) || void 0 === _items$index$group ? void 0 : _items$index$group.items[index.item]) || null;
  }
  itemsGetter() {
    let resultItems = [];
    const {
      items
    } = this._collectionWidget.option();
    for (let i = 0; i < items.length; i++) {
      var _items$i;
      if (null !== (_items$i = items[i]) && void 0 !== _items$i && _items$i.items) {
        resultItems = resultItems.concat(items[i].items);
      } else {
        resultItems.push(items[i]);
      }
    }
    return resultItems;
  }
  deleteItemAtIndex(index) {
    const indices = splitIndex(index);
    const itemGroup = this._collectionWidget.option("items")[indices.group].items;
    itemGroup.splice(indices.item, 1);
  }
  getKeysByItems(items) {
    let plainItems = [];
    let i;
    for (i = 0; i < items.length; i++) {
      var _items$i2;
      if (null !== (_items$i2 = items[i]) && void 0 !== _items$i2 && _items$i2.items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    const result2 = [];
    for (i = 0; i < plainItems.length; i++) {
      result2.push(this._collectionWidget.keyOf(plainItems[i]));
    }
    return result2;
  }
  getIndexByKey(key, items) {
    const groups = items || this._collectionWidget.option("items");
    let index = -1;
    const that = this;
    each(groups, ((groupIndex, group) => {
      if (!group.items) {
        return;
      }
      each(group.items, ((itemIndex, item) => {
        const itemKey = that._collectionWidget.keyOf(item);
        if (that._equalKeys(itemKey, key)) {
          index = {
            group: groupIndex,
            item: itemIndex
          };
          return false;
        }
      }));
      if (-1 !== index) {
        return false;
      }
    }));
    return index;
  }
  _getGroups(items) {
    const dataController2 = this._collectionWidget._dataController;
    const group = dataController2.group();
    if (group) {
      return m_store_helper_default.queryByOptions(m_query_default(items), {
        group
      }).toArray();
    }
    return this._collectionWidget.option("items");
  }
  getItemsByKeys(keys, items) {
    const result2 = [];
    const groups = this._getGroups(items);
    const groupItemByKeyMap = {};
    const getItemMeta = (key) => {
      const index = this.getIndexByKey(key, groups);
      const group = index && groups[index.group];
      if (!group) {
        return;
      }
      return {
        groupKey: group.key,
        item: group.items[index.item]
      };
    };
    each(keys, ((_, key) => {
      const itemMeta = getItemMeta(key);
      if (!itemMeta) {
        return;
      }
      const {
        groupKey
      } = itemMeta;
      const {
        item
      } = itemMeta;
      let selectedGroup = groupItemByKeyMap[groupKey];
      if (!selectedGroup) {
        selectedGroup = {
          key: groupKey,
          items: []
        };
        groupItemByKeyMap[groupKey] = selectedGroup;
        result2.push(selectedGroup);
      }
      selectedGroup.items.push(item);
    }));
    return result2;
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._collectionWidget.option("items");
    const movingIndices = splitIndex(movingIndex);
    const destinationIndices = splitIndex(destinationIndex);
    const movingItemGroup = items[movingIndices.group].items;
    const destinationItemGroup = items[destinationIndices.group].items;
    const movedItemData = movingItemGroup[movingIndices.item];
    movingItemGroup.splice(movingIndices.item, 1);
    destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
  }
  _isItemIndex(index) {
    return index && isNumeric(index.group) && isNumeric(index.item);
  }
  _getNormalizedItemIndex(itemElement) {
    const $item = renderer_default(itemElement);
    const $group = $item.closest(".dx-list-group");
    if (!$group.length) {
      return -1;
    }
    return combineIndex({
      group: this._groupElements().index($group),
      item: this._groupItemElements($group).index($item)
    });
  }
  _normalizeItemIndex(index) {
    return combineIndex(index);
  }
  _denormalizeItemIndex(index) {
    return splitIndex(index);
  }
  _getItemByNormalizedIndex(index) {
    const indices = splitIndex(index);
    const $group = this._groupElements().eq(indices.group);
    return this._groupItemElements($group).eq(indices.item);
  }
  _itemsFromSameParent(firstIndex, secondIndex) {
    return splitIndex(firstIndex).group === splitIndex(secondIndex).group;
  }
};
var m_list_edit_strategy_grouped_default = GroupedEditStrategy;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.js
var ListEdit = class extends ListBase {
  _supportedKeys() {
    const that = this;
    const parent = super._supportedKeys();
    const moveFocusedItem = (e, moveUp) => {
      const editStrategy = this._editStrategy;
      const {
        focusedElement
      } = this.option();
      const focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
      const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
      if (isLastIndexFocused && this._dataController.isLoading()) {
        return;
      }
      if (e.shiftKey && that.option("itemDragging.allowReordering")) {
        const nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
        const $nextItem = editStrategy.getItemElement(nextItemIndex);
        const isMoveFromGroup = this.option("grouped") && renderer_default(focusedElement).parent().get(0) !== $nextItem.parent().get(0);
        if (!isMoveFromGroup) {
          this.reorderItem(focusedElement, $nextItem);
          this.scrollToItem(focusedElement);
        }
        e.preventDefault();
      } else {
        const editProvider = this._editProvider;
        const isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
        if (!isInternalMoving) {
          moveUp ? parent.upArrow(e) : parent.downArrow(e);
        }
      }
    };
    return _extends({}, parent, {
      del: (e) => {
        if (that.option("allowItemDeleting")) {
          e.preventDefault();
          that.deleteItem(that.option("focusedElement"));
        }
      },
      upArrow: (e) => moveFocusedItem(e, true),
      downArrow: (e) => moveFocusedItem(e),
      enter: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.enter.apply(this, arguments);
        }
      },
      space: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.space.apply(this, arguments);
        }
      }
    });
  }
  _updateSelection() {
    this._editProvider.afterItemsRendered();
    super._updateSelection();
  }
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  }
  _refreshItemElements() {
    super._refreshItemElements();
    const excludedSelectors = this._editProvider.getExcludedItemSelectors();
    if (excludedSelectors.length) {
      this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
    }
  }
  _isItemStrictEquals(item1, item2) {
    const privateKey = null === item1 || void 0 === item1 ? void 0 : item1.__dx_key__;
    if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
      return false;
    }
    return super._isItemStrictEquals(item1, item2);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showSelectionControls: false,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: message_default.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: false,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (device) => "ios" === device.platform,
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  }
  _init() {
    super._init();
    this._initEditProvider();
  }
  _initDataSource() {
    super._initDataSource();
    if (!this._isPageSelectAll()) {
      var _this$_dataSource;
      null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.requireTotalCount(true);
    }
  }
  _isPageSelectAll() {
    const {
      selectAllMode
    } = this.option();
    return "page" === selectAllMode;
  }
  _initEditProvider() {
    this._editProvider = new m_list_edit_provider_default(this);
  }
  _disposeEditProvider() {
    if (this._editProvider) {
      this._editProvider.dispose();
    }
  }
  _refreshEditProvider() {
    this._disposeEditProvider();
    this._initEditProvider();
  }
  _initEditStrategy() {
    if (this.option("grouped")) {
      this._editStrategy = new m_list_edit_strategy_grouped_default(this);
    } else {
      super._initEditStrategy();
    }
  }
  _initMarkup() {
    this._refreshEditProvider();
    super._initMarkup();
  }
  _renderItems() {
    super._renderItems(...arguments);
    this._editProvider.afterItemsRendered();
  }
  _renderItem(index, itemData, $container, $itemToReplace) {
    const {
      showSelectionControls,
      selectionMode
    } = this.option();
    const $itemFrame = super._renderItem(index, itemData, $container, $itemToReplace);
    if (showSelectionControls && "none" !== selectionMode) {
      this._updateItemAriaLabel($itemFrame, itemData);
    }
    return $itemFrame;
  }
  _updateItemAriaLabel($itemFrame, itemData) {
    var _this$_displayGetter;
    const label = (null === (_this$_displayGetter = this._displayGetter) || void 0 === _this$_displayGetter ? void 0 : _this$_displayGetter.call(this, itemData)) ?? (null === itemData || void 0 === itemData ? void 0 : itemData.text) ?? itemData;
    this.setAria("label", isObject(label) ? message_default.format("dxList-listAriaLabel-itemContent") : label, $itemFrame);
  }
  _selectedItemClass() {
    return "dx-list-item-selected";
  }
  _itemResponseWaitClass() {
    return "dx-list-item-response-wait";
  }
  _itemClickHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = this._editProvider.handleClick($itemElement, e);
    if (handledByEditProvider) {
      return;
    }
    this._saveSelectionChangeEvent(e);
    super._itemClickHandler(...arguments);
  }
  _shouldFireContextMenuEvent() {
    return super._shouldFireContextMenuEvent(...arguments) || this._editProvider.contextMenuHandlerExists();
  }
  _itemHoldHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.handledByEditProvider = true;
      return;
    }
    super._itemHoldHandler(...arguments);
  }
  _itemContextMenuHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.preventDefault();
      return;
    }
    super._itemContextMenuHandler(...arguments);
  }
  _postprocessRenderItem(args) {
    super._postprocessRenderItem(...arguments);
    this._editProvider.modifyItemElement(args);
  }
  _clean() {
    this._disposeEditProvider();
    super._clean();
  }
  focusListItem(index) {
    const $item = this._editStrategy.getItemElement(index);
    this.option("focusedElement", $item);
    this.focus();
    this.scrollToItem(this.option("focusedElement"));
  }
  _getFlatIndex() {
    const {
      selectedIndex = NOT_EXISTING_INDEX
    } = this.option();
    if (isNumeric(selectedIndex) || !selectedIndex) {
      return selectedIndex;
    }
    const $item = this._editStrategy.getItemElement(selectedIndex);
    const index = this.getFlatIndexByItemElement($item);
    return index;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectAllMode":
        this._initDataSource();
        this._dataController.pageIndex(0);
        this._dataController.load();
        break;
      case "grouped":
        this._clearSelectedItems();
        this._initEditStrategy();
        super._optionChanged(args);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        super._optionChanged(args);
    }
  }
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  }
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  }
  getFlatIndexByItemElement(itemElement) {
    return this._itemElements().index(itemElement);
  }
  getItemElementByFlatIndex(flatIndex) {
    const $itemElements = this._itemElements();
    if (flatIndex < 0 || flatIndex >= $itemElements.length) {
      return renderer_default();
    }
    return $itemElements.eq(flatIndex);
  }
  getItemByIndex(index) {
    return this._editStrategy.getItemDataByIndex(index);
  }
  deleteItem(itemElement) {
    const editStrategy = this._editStrategy;
    const deletingElementIndex = editStrategy.getNormalizedIndex(itemElement);
    const {
      focusedElement,
      focusStateEnabled
    } = this.option();
    const focusedItemIndex = focusedElement ? editStrategy.getNormalizedIndex(focusedElement) : deletingElementIndex;
    const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
    const nextFocusedItem = isLastIndexFocused || deletingElementIndex < focusedItemIndex ? focusedItemIndex - 1 : focusedItemIndex;
    const promise = super.deleteItem(itemElement);
    return promise.done((function() {
      if (focusStateEnabled) {
        this.focusListItem(nextFocusedItem);
      }
    }));
  }
};
var m_list_edit_default = ListEdit;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.search.js
var ListSearch = m_list_edit_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `dx-list-${className}`,
  _getCombinedFilter() {
    const dataController2 = this._dataController;
    const storeLoadOptions = {
      filter: dataController2.filter()
    };
    dataController2.addSearchFilter(storeLoadOptions);
    const {
      filter
    } = storeLoadOptions;
    return filter;
  },
  _initDataSource() {
    const value2 = this.option("searchValue");
    const expr = this.option("searchExpr");
    const mode = this.option("searchMode");
    this.callBase();
    const dataController2 = this._dataController;
    (null === value2 || void 0 === value2 ? void 0 : value2.length) && dataController2.searchValue(value2);
    mode.length && dataController2.searchOperation(ui_search_box_mixin_default.getOperationBySearchMode(mode));
    expr && dataController2.searchExpr(expr);
  }
});
var m_list_edit_search_default = ListSearch;

// node_modules/devextreme/esm/ui/list_light.js
component_registrator_default("dxList", m_list_edit_search_default);
var list_light_default = m_list_edit_search_default;

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_button.js
var DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
var BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
var DropDownButton = class extends TextEditorButton {
  constructor(name2, editor, options2) {
    super(name2, editor, options2);
    this.currentTemplate = null;
  }
  _attachEvents(instance) {
    const {
      editor
    } = this;
    instance.option("onClick", ((e) => {
      var _editor$_shouldCallOp;
      if (null !== (_editor$_shouldCallOp = editor._shouldCallOpenHandler) && void 0 !== _editor$_shouldCallOp && _editor$_shouldCallOp.call(editor)) {
        editor._openHandler(e);
        return;
      }
      !editor.option("openOnFieldClick") && editor._openHandler(e);
    }));
    m_events_engine_default.on(instance.$element(), "mousedown", ((e) => {
      if (editor.$element().is(".dx-state-focused")) {
        e.preventDefault();
      }
    }));
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    const options2 = this._getOptions();
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default2, extend({}, options2, {
      elementAttr: {
        "aria-label": message_default.format(BUTTON_MESSAGE)
      }
    }));
    this._legacyRender(editor.$element(), $element, options2.visible);
    return {
      $element,
      instance
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible = this._isVisible();
    const isReadOnly = editor.option("readOnly");
    const options2 = {
      focusStateEnabled: false,
      hoverStateEnabled: false,
      activeStateEnabled: false,
      useInkRipple: false,
      disabled: isReadOnly,
      visible
    };
    this._addTemplate(options2);
    return options2;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showDropDownButton");
  }
  _legacyRender($editor, $element, isVisible) {
    $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible);
    if ($element) {
      $element.removeClass("dx-button").removeClass("dx-button-mode-contained").addClass("dx-dropdowneditor-button");
    }
  }
  _isSameTemplate() {
    return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
  }
  _addTemplate(options2) {
    if (!this._isSameTemplate()) {
      options2.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
      this.currentTemplate = this.editor.option("dropDownButtonTemplate");
    }
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const options2 = this._getOptions();
      null === instance || void 0 === instance || instance.option(options2);
      this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options2.visible);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_utils.js
var getElementWidth = function($element) {
  if (hasWindow()) {
    return getOuterWidth($element);
  }
};
var getSizeValue = function(size) {
  if (null === size) {
    size = void 0;
  }
  if ("function" === typeof size) {
    size = size();
  }
  return size;
};

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_editor.js
var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor";
var DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
var DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
var DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
var DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
var DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
var isIOs = "ios" === devices_default.current().platform;
function createTemplateWrapperElement() {
  return renderer_default("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER);
}
var DropDownEditor = class extends m_text_box_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      tab: (e) => {
        if (!this.option("opened")) {
          return;
        }
        if (!this._popup.getFocusableElements().length) {
          this.close();
          return;
        }
        const $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
        if ($focusableElement) {
          m_events_engine_default.trigger($focusableElement, "focus");
          $focusableElement.select();
        }
        e.preventDefault();
      },
      escape: (e) => {
        if (this.option("opened")) {
          e.preventDefault();
        }
        this.close();
        return true;
      },
      upArrow: (e) => {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this.close();
            return false;
          }
        }
        return true;
      },
      downArrow: (e) => {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this._validatedOpening();
            return false;
          }
        }
        return true;
      },
      enter: (e) => {
        if (this.option("opened")) {
          e.preventDefault();
          this._valueChangeEventHandler(e);
        }
        return true;
      }
    });
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "dropDown",
      Ctor: DropDownButton
    }]);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: null,
      onOpened: null,
      onClosed: null,
      opened: false,
      acceptCustomValue: true,
      applyValueMode: "instantly",
      deferRendering: true,
      activeStateEnabled: true,
      dropDownButtonTemplate: "dropDownButton",
      fieldTemplate: null,
      openOnFieldClick: false,
      showDropDownButton: true,
      buttons: void 0,
      dropDownOptions: {
        showTitle: false
      },
      popupPosition: this._getDefaultPopupPosition(),
      onPopupInitialized: null,
      applyButtonText: message_default.format("OK"),
      cancelButtonText: message_default.format("Cancel"),
      buttonsLocation: "default",
      useHiddenSubmitElement: false,
      validationMessagePosition: "auto",
      _userDropDownOptions: {}
    });
  }
  _useTemplates() {
    return true;
  }
  _getDefaultPopupPosition(isRtlEnabled) {
    const position2 = getDefaultAlignment(isRtlEnabled);
    return {
      offset: {
        h: 0,
        v: -1
      },
      my: `${position2} top`,
      at: `${position2} bottom`,
      collision: "flip flip"
    };
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device(device) {
        const isGeneric2 = "generic" === device.platform;
        return isGeneric2;
      },
      options: {
        popupPosition: {
          offset: {
            v: 0
          }
        }
      }
    }]);
  }
  _inputWrapper() {
    return this.$element().find(`.${DROP_DOWN_EDITOR_INPUT_WRAPPER}`).first();
  }
  _init() {
    super._init();
    this._initVisibilityActions();
    this._initPopupInitializedAction();
    const {
      rtlEnabled,
      dropDownOptions
    } = this.option();
    this._updatePopupPosition(rtlEnabled);
    this._cacheUserDropDownOptions(dropDownOptions);
  }
  _updatePopupPosition(isRtlEnabled) {
    const {
      my,
      at
    } = this._getDefaultPopupPosition(isRtlEnabled);
    const currentPosition = this.option("popupPosition");
    this.option("popupPosition", extend({}, currentPosition, {
      my,
      at
    }));
  }
  _initVisibilityActions() {
    this._openAction = this._createActionByOption("onOpened", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this._closeAction = this._createActionByOption("onClosed", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initPopupInitializedAction() {
    this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    this._renderSubmitElement();
    super._initMarkup();
    this.$element().addClass("dx-dropdowneditor");
    this.setAria("role", this._getAriaRole());
  }
  _render() {
    this._detachFocusEvents();
    super._render();
    this._renderOpenHandler();
    this._attachFocusOutHandler();
    this._renderOpenedState();
  }
  _renderContentImpl() {
    if (!this.option("deferRendering")) {
      this._createPopup();
    }
  }
  _renderInput() {
    super._renderInput();
    this._renderTemplateWrapper();
    this._wrapInput();
    this._setDefaultAria();
  }
  _wrapInput() {
    this._$container = this.$element().wrapInner(renderer_default("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0);
  }
  _getAriaHasPopup() {
    return "true";
  }
  _getAriaAutocomplete() {
    return "none";
  }
  _getAriaRole() {
    return "combobox";
  }
  _setDefaultAria() {
    this.setAria({
      haspopup: this._getAriaHasPopup(),
      autocomplete: this._getAriaAutocomplete(),
      role: this._getAriaRole()
    });
  }
  _readOnlyPropValue() {
    return !this._isEditable() || super._readOnlyPropValue();
  }
  _cleanFocusState() {
    super._cleanFocusState();
    if (this.option("fieldTemplate")) {
      this._detachFocusEvents();
    }
  }
  _getFieldTemplate() {
    return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
  }
  _renderMask() {
    if (this.option("fieldTemplate")) {
      return;
    }
    super._renderMask();
  }
  _renderField() {
    const fieldTemplate = this._getFieldTemplate();
    if (fieldTemplate) {
      this._renderTemplatedField(fieldTemplate, this._fieldRenderData());
    }
  }
  _renderPlaceholder() {
    const hasFieldTemplate = !!this._getFieldTemplate();
    if (!hasFieldTemplate) {
      super._renderPlaceholder();
    }
  }
  _renderValue() {
    if (this.option("useHiddenSubmitElement")) {
      this._setSubmitValue();
    }
    const promise = super._renderValue();
    return promise.always(this._renderField.bind(this));
  }
  _getButtonsContainer() {
    const fieldTemplate = this._getFieldTemplate();
    return fieldTemplate ? this._$container : this._$textEditorContainer;
  }
  _renderTemplateWrapper() {
    const fieldTemplate = this._getFieldTemplate();
    if (!fieldTemplate) {
      return;
    }
    if (!this._$templateWrapper) {
      this._$templateWrapper = createTemplateWrapperElement().prependTo(this.$element());
    }
  }
  _renderTemplatedField(fieldTemplate, data17) {
    const isFocused = focused(this._input());
    this._detachKeyboardEvents();
    this._detachFocusEvents();
    this._$textEditorContainer.remove();
    const $newTemplateWrapper = createTemplateWrapperElement();
    this._$templateWrapper.replaceWith($newTemplateWrapper);
    this._$templateWrapper = $newTemplateWrapper;
    const currentRenderContext = Symbol("renderContext");
    this._activeRenderContext = currentRenderContext;
    fieldTemplate.render({
      model: data17,
      container: getPublicElement(this._$templateWrapper),
      onRendered: () => {
        if (this._activeRenderContext !== currentRenderContext) {
          return;
        }
        const $input = this._input();
        if (!$input.length) {
          throw ui_errors_default.Error("E1010");
        }
        this._integrateInput();
        if (!isFocused) {
          return;
        }
        if (browser_default.mozilla) {
          const inputElement = $input.get(0);
          inputElement.focus({
            preventScroll: true
          });
        } else {
          m_events_engine_default.trigger($input, "focus");
        }
      }
    });
  }
  _integrateInput() {
    const {
      isValid
    } = this.option();
    this._renderFocusState();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._refreshEmptinessEvent();
    this._setDefaultAria();
    this._setFieldAria();
    this._toggleValidationClasses(!isValid);
    const {
      _onMarkupRendered: markupRendered
    } = this.option();
    null === markupRendered || void 0 === markupRendered || markupRendered();
  }
  _refreshEmptinessEvent() {
    m_events_engine_default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
    this._renderEmptinessEvent();
  }
  _fieldRenderData() {
    return this.option("value");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      dropDownButton: new FunctionTemplate(((options2) => {
        const $icon = renderer_default("<div>").addClass("dx-dropdowneditor-icon");
        renderer_default(options2.container).append($icon);
      }))
    });
    super._initTemplates();
  }
  _renderOpenHandler() {
    const $inputWrapper = this._inputWrapper();
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const {
      openOnFieldClick
    } = this.option();
    m_events_engine_default.off($inputWrapper, eventName);
    m_events_engine_default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
    this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
    if (openOnFieldClick) {
      this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this));
    }
  }
  _attachFocusOutHandler() {
    if (isIOs) {
      this._detachFocusOutEvents();
      m_events_engine_default.on(this._inputWrapper(), addNamespace("focusout", this.NAME), ((event) => {
        const newTarget = event.relatedTarget;
        if (newTarget && this.option("opened")) {
          const isNewTargetOutside = this._isTargetOutOfComponent(newTarget);
          if (isNewTargetOutside) {
            this.close();
          }
        }
      }));
    }
  }
  _isTargetOutOfComponent(newTarget) {
    const popupWrapper = this.content ? renderer_default(this.content()).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`) : this._$popup;
    const isTargetOutsidePopup = 0 === renderer_default(newTarget).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`, popupWrapper).length;
    return isTargetOutsidePopup;
  }
  _detachFocusOutEvents() {
    isIOs && m_events_engine_default.off(this._inputWrapper(), addNamespace("focusout", this.NAME));
  }
  _getInputClickHandler(openOnFieldClick) {
    return openOnFieldClick ? (e) => {
      this._executeOpenAction(e);
    } : () => {
      this._focusInput();
    };
  }
  _openHandler() {
    this._toggleOpenState();
  }
  _executeOpenAction(e) {
    var _this$_openOnFieldCli;
    null === (_this$_openOnFieldCli = this._openOnFieldClickAction) || void 0 === _this$_openOnFieldCli || _this$_openOnFieldCli.call(this, {
      event: e
    });
  }
  _keyboardEventBindingTarget() {
    return this._input();
  }
  _focusInput() {
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("focusStateEnabled") && !focused(this._input())) {
      this._resetCaretPosition();
      m_events_engine_default.trigger(this._input(), "focus");
    }
    return true;
  }
  _resetCaretPosition() {
    let ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const inputElement = this._input().get(0);
    if (inputElement) {
      const {
        value: value2
      } = inputElement;
      const caretPosition = isDefined(value2) && (ignoreEditable || this._isEditable()) ? value2.length : 0;
      this._caret({
        start: caretPosition,
        end: caretPosition
      }, true);
    }
  }
  _isEditable() {
    const {
      acceptCustomValue
    } = this.option();
    return acceptCustomValue;
  }
  _toggleOpenState(isVisible) {
    if (!this._focusInput()) {
      return;
    }
    if (!this.option("readOnly")) {
      isVisible = arguments.length ? isVisible : !this.option("opened");
      this.option("opened", isVisible);
    }
  }
  _getControlsAria() {
    return this._popup && this._popupContentId;
  }
  _renderOpenedState() {
    const opened = this.option("opened");
    if (opened) {
      this._createPopup();
    }
    this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
    this._setPopupOption("visible", opened);
    const arias = {
      expanded: opened,
      controls: this._getControlsAria()
    };
    this.setAria(arias);
    this.setAria("owns", opened ? this._popupContentId : void 0, this.$element());
  }
  _createPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
    this._renderPopup();
    this._renderPopupContent();
    this._setPopupAriaLabel();
  }
  _setPopupAriaLabel() {
    const $overlayContent = this._popup.$overlayContent();
    this.setAria("label", "Dropdown", $overlayContent);
  }
  _renderPopupContent() {
  }
  _renderPopup() {
    const popupConfig = extend(this._popupConfig(), this.option("_userDropDownOptions"));
    delete popupConfig.closeOnOutsideClick;
    this._popup = this._createComponent(this._$popup, ui_popup_default, popupConfig);
    this._popup.on({
      showing: this._popupShowingHandler.bind(this),
      shown: this._popupShownHandler.bind(this),
      hiding: this._popupHidingHandler.bind(this),
      hidden: this._popupHiddenHandler.bind(this),
      contentReady: this._contentReadyHandler.bind(this)
    });
    this._attachPopupKeyHandler();
    this._contentReadyHandler();
    this._setPopupContentId(this._popup.$content());
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _attachPopupKeyHandler() {
    m_events_engine_default.on(this._popup.$overlayContent(), addNamespace("keydown", this.NAME), ((e) => this._popupKeyHandler(e)));
  }
  _popupKeyHandler(e) {
    switch (normalizeKeyName(e)) {
      case "tab":
        this._popupTabHandler(e);
        break;
      case "escape":
        this._popupEscHandler();
    }
  }
  _popupTabHandler(e) {
    const $target = renderer_default(e.target);
    const moveBackward = e.shiftKey && $target.is(this._getFirstPopupElement());
    const moveForward = !e.shiftKey && $target.is(this._getLastPopupElement());
    if (moveForward || moveBackward) {
      m_events_engine_default.trigger(this.field(), "focus");
      e.preventDefault();
    }
  }
  _popupEscHandler() {
    m_events_engine_default.trigger(this._input(), "focus");
    this.close();
  }
  _setPopupContentId($popupContent) {
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $popupContent);
  }
  _contentReadyHandler() {
  }
  _popupConfig() {
    return {
      onInitialized: this._getPopupInitializedHandler(),
      position: extend(this.option("popupPosition"), {
        of: this.$element()
      }),
      showTitle: this.option("dropDownOptions.showTitle"),
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      hideOnParentScroll: true,
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      deferRendering: false,
      focusStateEnabled: false,
      showCloseButton: false,
      dragEnabled: false,
      toolbarItems: this._getPopupToolbarItems(),
      onPositioned: this._popupPositionedHandler.bind(this),
      fullScreen: false,
      contentTemplate: null,
      _hideOnParentScrollTarget: this.$element(),
      _wrapperClassExternal: DROP_DOWN_EDITOR_OVERLAY,
      _ignorePreventScrollEventsDeprecation: true
    };
  }
  _popupInitializedHandler() {
  }
  _getPopupInitializedHandler() {
    const onPopupInitialized = this.option("onPopupInitialized");
    return (e) => {
      this._popupInitializedHandler();
      if (onPopupInitialized) {
        this._popupInitializedAction({
          popup: e.component
        });
      }
    };
  }
  _dimensionChanged() {
    if (hasWindow() && !this.$element().is(":visible")) {
      this.close();
      return;
    }
    this._updatePopupWidth();
  }
  _updatePopupWidth() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", (() => getElementWidth(this.$element())));
    }
  }
  _popupPositionedHandler(e) {
    var _e$position;
    const {
      labelMode,
      stylingMode
    } = this.option();
    if (!this._popup) {
      return;
    }
    const $popupOverlayContent = this._popup.$overlayContent();
    const isOverlayFlipped = null === (_e$position = e.position) || void 0 === _e$position || null === (_e$position = _e$position.v) || void 0 === _e$position ? void 0 : _e$position.flip;
    const shouldIndentForLabel = "hidden" !== labelMode && "outside" !== labelMode && "outlined" === stylingMode;
    if (e.position) {
      $popupOverlayContent.toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, isOverlayFlipped);
    }
    if (isOverlayFlipped && shouldIndentForLabel && this._label.isVisible()) {
      const $label = this._label.$element();
      move($popupOverlayContent, {
        top: locate($popupOverlayContent).top - parseInt($label.css("fontSize"))
      });
    }
  }
  _popupShowingHandler() {
  }
  _popupHidingHandler() {
    this.option("opened", false);
  }
  _popupShownHandler() {
    var _this$_validationMess;
    this._openAction();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.option("positionSide", this._getValidationMessagePositionSide());
  }
  _popupHiddenHandler() {
    var _this$_validationMess2;
    this._closeAction();
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option("positionSide", this._getValidationMessagePositionSide());
  }
  _getValidationMessagePositionSide() {
    var _this$_popup;
    const {
      validationMessagePosition
    } = this.option();
    if ("auto" !== validationMessagePosition) {
      return validationMessagePosition;
    }
    let positionSide = "bottom";
    if (null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible")) {
      const {
        top: myTop
      } = position_default.setup(this.$element());
      const {
        top: popupTop
      } = position_default.setup(this._popup.$content());
      positionSide = myTop + this.option("popupPosition").offset.v > popupTop ? "bottom" : "top";
    }
    return positionSide;
  }
  _closeOutsideDropDownHandler(event) {
    const {
      target
    } = event;
    const $target = renderer_default(target);
    const dropDownButton = this.getButton("dropDown");
    const $dropDownButton = null === dropDownButton || void 0 === dropDownButton ? void 0 : dropDownButton.$element();
    const isInputClicked = !!$target.closest(this.$element()).length;
    const isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
    const isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
    return isOutsideClick;
  }
  _clean() {
    delete this._openOnFieldClickAction;
    delete this._$templateWrapper;
    if (this._$popup) {
      this._$popup.remove();
      delete this._$popup;
      delete this._popup;
    }
    super._clean();
  }
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  }
  _validatedOpening() {
    if (!this.option("readOnly")) {
      this._toggleOpenState(true);
    }
  }
  _getPopupToolbarItems() {
    const {
      applyValueMode
    } = this.option();
    return "useButtons" === applyValueMode ? this._popupToolbarItemsConfig() : [];
  }
  _getFirstPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).first();
  }
  _getLastPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).last();
  }
  _popupToolbarItemsConfig() {
    const buttonsConfig = [{
      shortcut: "done",
      options: {
        onClick: this._applyButtonHandler.bind(this),
        text: this.option("applyButtonText")
      }
    }, {
      shortcut: "cancel",
      options: {
        onClick: this._cancelButtonHandler.bind(this),
        text: this.option("cancelButtonText")
      }
    }];
    return this._applyButtonsLocation(buttonsConfig);
  }
  _applyButtonsLocation(buttonsConfig) {
    const {
      buttonsLocation
    } = this.option();
    const resultConfig = buttonsConfig;
    if ("default" !== buttonsLocation) {
      const position2 = splitPair(buttonsLocation);
      each(resultConfig, ((_, element) => {
        extend(element, {
          toolbar: position2[0],
          location: position2[1]
        });
      }));
    }
    return resultConfig;
  }
  _applyButtonHandler(args) {
    this.close();
    if (this.option("focusStateEnabled")) {
      this.focus();
    }
  }
  _cancelButtonHandler() {
    this.close();
    if (this.option("focusStateEnabled")) {
      this.focus();
    }
  }
  _popupOptionChanged(args) {
    const options2 = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  }
  _cacheUserDropDownOptions(value2) {
    let name2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "dropDownOptions";
    const optionName = name2.replace("dropDownOptions", "_userDropDownOptions");
    this.option(optionName, value2);
  }
  _renderSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    }
  }
  _setSubmitValue() {
    const {
      value: value2
    } = this.option();
    this._getSubmitElement().val(value2);
  }
  _getSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      return this._$submitElement;
    }
    return super._getSubmitElement();
  }
  _dispose() {
    this._detachFocusOutEvents();
    super._dispose();
  }
  _optionChanged(args) {
    var _this$_popup2;
    const {
      name: name2,
      fullName,
      value: value2
    } = args;
    switch (name2) {
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.repaint();
        break;
      case "opened":
        this._renderOpenedState();
        break;
      case "onOpened":
      case "onClosed":
        this._initVisibilityActions();
        break;
      case "onPopupInitialized":
        this._initPopupInitializedAction();
        break;
      case "fieldTemplate":
      case "acceptCustomValue":
      case "openOnFieldClick":
        this._invalidate();
        break;
      case "dropDownButtonTemplate":
      case "showDropDownButton":
        this._updateButtons(["dropDown"]);
        break;
      case "dropDownOptions":
        this._popupOptionChanged(args);
        this._cacheUserDropDownOptions(value2, fullName);
        break;
      case "_userDropDownOptions":
      case "popupPosition":
        break;
      case "deferRendering":
        if (hasWindow()) {
          this._createPopup();
        }
        break;
      case "applyValueMode":
      case "applyButtonText":
      case "cancelButtonText":
      case "buttonsLocation":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "useHiddenSubmitElement":
        if (this._$submitElement) {
          this._$submitElement.remove();
          this._$submitElement = void 0;
        }
        this._renderSubmitElement();
        break;
      case "rtlEnabled":
        this._updatePopupPosition(value2);
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  open() {
    this.option("opened", true);
  }
  close() {
    this.option("opened", false);
  }
  field() {
    return getPublicElement(this._input());
  }
  content() {
    return this._popup ? this._popup.content() : null;
  }
};
component_registrator_default("dxDropDownEditor", DropDownEditor);
var m_drop_down_editor_default = DropDownEditor;

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_list.js
var window7 = getWindow();
var SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var useCompositionEvents = "android" !== devices_default.real().platform;
var DropDownList = class extends m_drop_down_editor_default {
  _supportedKeys() {
    const parentSupportedKeys = super._supportedKeys();
    return _extends({}, parentSupportedKeys, {
      tab(e) {
        if (this._allowSelectItemByTab()) {
          this._saveValueChangeEvent(e);
          const $focusedItem = renderer_default(this._list.option("focusedElement"));
          $focusedItem.length && this._setSelectedElement($focusedItem);
        }
        parentSupportedKeys.tab(e);
      },
      space: noop,
      home: noop,
      end: noop
    });
  }
  _allowSelectItemByTab() {
    const {
      opened,
      applyValueMode
    } = this.option();
    return opened && "instantly" === applyValueMode;
  }
  _setSelectedElement($element) {
    const value2 = this._valueGetter(this._list._getItemData($element));
    this._setValue(value2);
  }
  _setValue(value2) {
    this.option("value", value2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), ui_data_expression_default._dataExpressionDefaultOptions(), {
      displayValue: void 0,
      searchEnabled: false,
      searchMode: "contains",
      searchTimeout: 500,
      minSearchLength: 0,
      searchExpr: null,
      valueChangeEvent: "input change keyup",
      selectedItem: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      onSelectionChanged: null,
      onItemClick: noop,
      showDataBeforeSearch: false,
      grouped: false,
      groupTemplate: "group",
      popupPosition: {
        my: "left top",
        at: "left bottom",
        offset: {
          h: 0,
          v: 0
        },
        collision: "flip"
      },
      wrapItemText: false,
      useItemTextAsTitle: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        popupPosition: {
          offset: {
            v: -1
          }
        }
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        buttonsLocation: "bottom center"
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      value: true,
      selectedItem: true,
      displayValue: true
    });
  }
  _init() {
    super._init();
    this._initDataExpressions();
    this._initActions();
    this._setListDataSource();
    this._validateSearchMode();
    this._clearSelectedItem();
    this._initItems();
  }
  _setListFocusedElementOptionChange() {
    this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
  }
  _initItems() {
    const {
      items
    } = this.option();
    if (items && !items.length && this._dataSource) {
      this.option().items = this._dataSource.items();
    }
  }
  _initActions() {
    this._initContentReadyAction();
    this._initSelectionChangedAction();
    this._initItemClickAction();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new ChildDefaultTemplate("item")
    });
  }
  _isEditable() {
    const {
      searchEnabled
    } = this.option();
    return super._isEditable() || searchEnabled;
  }
  _saveFocusOnWidget() {
    var _this$_list;
    if (null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.initialOption("focusStateEnabled")) {
      this._focusInput();
    }
  }
  _fitIntoRange(value2, start, end) {
    if (value2 > end) {
      return start;
    }
    if (value2 < start) {
      return end;
    }
    return value2;
  }
  _items() {
    const items = this._getPlainItems(!this._list && this._dataSource.items());
    const availableItems = new m_query_default(items).filter("disabled", "<>", true).toArray();
    return availableItems;
  }
  _calcNextItem(step) {
    const items = this._items();
    const nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
    return items[nextIndex];
  }
  _getSelectedIndex() {
    const items = this._items();
    const selectedItem = this.option("selectedItem");
    let result2 = -1;
    each(items, ((index, item) => {
      if (this._isValueEquals(item, selectedItem)) {
        result2 = index;
        return false;
      }
    }));
    return result2;
  }
  _createPopup() {
    super._createPopup();
    this._updateCustomBoundaryContainer();
    this._popup.$wrapper().addClass(this._popupWrapperClass());
    const $popupContent = this._popup.$content();
    m_events_engine_default.off($popupContent, "mouseup");
    m_events_engine_default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
  }
  _updateCustomBoundaryContainer() {
    const customContainer = this.option("dropDownOptions.container");
    const $container = customContainer && renderer_default(customContainer);
    if ($container && $container.length && !isWindow($container.get(0))) {
      const $containerWithParents = [].slice.call($container.parents());
      $containerWithParents.unshift($container.get(0));
      each($containerWithParents, ((i, parent) => {
        if (parent === renderer_default("body").get(0)) {
          return false;
        }
        if ("hidden" === window7.getComputedStyle(parent).overflowY) {
          this._$customBoundaryContainer = renderer_default(parent);
          return false;
        }
      }));
    }
  }
  _popupWrapperClass() {
    return "dx-dropdownlist-popup-wrapper";
  }
  _renderInputValue() {
    var _this = this;
    let {
      value: value2,
      renderOnly
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const currentValue = value2 ?? this._getCurrentValue();
    this._rejectValueLoading();
    if (renderOnly) {
      return super._renderInputValue(currentValue);
    }
    return this._loadInputValue(currentValue, (function() {
      _this._setSelectedItem(...arguments);
    })).always(super._renderInputValue.bind(this, currentValue));
  }
  _loadInputValue(value2, callback) {
    return this._loadItem(value2).always(callback);
  }
  _getItemFromPlain(value2, cache) {
    let plainItems;
    let selectedItem;
    if (cache && "object" !== typeof value2) {
      if (!cache.itemByValue) {
        cache.itemByValue = {};
        plainItems = this._getPlainItems();
        plainItems.forEach((function(item) {
          cache.itemByValue[this._valueGetter(item)] = item;
        }), this);
      }
      selectedItem = cache.itemByValue[value2];
    }
    if (!selectedItem) {
      plainItems = this._getPlainItems();
      selectedItem = grep(plainItems, ((item) => this._isValueEquals(this._valueGetter(item), value2)))[0];
    }
    return selectedItem;
  }
  _resetInputText() {
    this._renderInputValue({
      renderOnly: true
    });
  }
  _loadItem(value2, cache) {
    const selectedItem = this._getItemFromPlain(value2, cache);
    return void 0 !== selectedItem ? Deferred().resolve(selectedItem).promise() : this._loadValue(value2);
  }
  _getPlainItems(items) {
    let plainItems = [];
    const grouped = this._getGroupedOption();
    items = items || this.option("items") || this._dataSource.items() || [];
    for (let i = 0; i < items.length; i++) {
      var _items$i;
      if (grouped && null !== (_items$i = items[i]) && void 0 !== _items$i && _items$i.items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    return plainItems;
  }
  _updateActiveDescendant($target) {
    var _this$_list2;
    const opened = this.option("opened");
    const listFocusedItemId = null === (_this$_list2 = this._list) || void 0 === _this$_list2 ? void 0 : _this$_list2.getFocusedItemId();
    const isElementOnDom = renderer_default(`#${listFocusedItemId}`).length > 0;
    const activedescendant = opened && isElementOnDom && listFocusedItemId;
    this.setAria({
      activedescendant: activedescendant || null
    }, $target);
  }
  _setSelectedItem(item) {
    const displayValue = this._displayValue(item);
    this.option("selectedItem", ensureDefined(item, null));
    this.option("displayValue", displayValue);
  }
  _displayValue(item) {
    return this._displayGetter(item);
  }
  _refreshSelected() {
    const cache = {};
    this._listItemElements().each(((_, itemElement) => {
      const $itemElement = renderer_default(itemElement);
      const itemValue = this._valueGetter($itemElement.data("dxListItemData"));
      const isItemSelected = this._isSelectedValue(itemValue, cache);
      if (isItemSelected) {
        this._list.selectItem($itemElement);
      } else {
        this._list.unselectItem($itemElement);
      }
    }));
  }
  _popupShownHandler() {
    super._popupShownHandler();
    this._setFocusPolicy();
  }
  _setFocusPolicy() {
    if (!this.option("focusStateEnabled") || !this._list) {
      return;
    }
    this._list.option("focusedElement", null);
  }
  _isSelectedValue(value2, cache) {
    return this._isValueEquals(value2, this.option("value"));
  }
  _validateSearchMode() {
    const searchMode = this.option("searchMode");
    const normalizedSearchMode = searchMode.toLowerCase();
    if (!SEARCH_MODES.includes(normalizedSearchMode)) {
      throw ui_errors_default.Error("E1019", searchMode);
    }
  }
  _clearSelectedItem() {
    this.option("selectedItem", null);
  }
  _processDataSourceChanging() {
    this._initDataController();
    this._setListOption("_dataController", this._dataController);
    this._setListDataSource();
    this._renderInputValue().fail((() => {
      if (this._isCustomValueAllowed()) {
        return;
      }
      this._clearSelectedItem();
    }));
  }
  _isCustomValueAllowed() {
    return this.option("displayCustomValue");
  }
  clear() {
    super.clear();
    this._clearFilter();
    this._clearSelectedItem();
  }
  _listItemElements() {
    return this._$list ? this._$list.find(".dx-list-item") : renderer_default();
  }
  _popupConfig() {
    return _extends({}, super._popupConfig(), {
      templatesRenderAsynchronously: false,
      autoResizeEnabled: false,
      maxHeight: this._getMaxHeight.bind(this)
    });
  }
  _renderPopupContent() {
    super._renderPopupContent();
    this._renderList();
  }
  _getKeyboardListeners() {
    const canListHaveFocus = this._canListHaveFocus();
    return super._getKeyboardListeners().concat([!canListHaveFocus && this._list]);
  }
  _renderList() {
    this._listId = `dx-${new guid_default()._value}`;
    const $list = renderer_default("<div>").attr("id", this._listId).appendTo(this._popup.$content());
    this._$list = $list;
    this._list = this._createComponent($list, list_light_default, this._listConfig());
    this._refreshList();
    this._renderPreventBlurOnListClick();
    this._setListFocusedElementOptionChange();
  }
  _renderPreventBlurOnListClick() {
    const eventName = addNamespace("mousedown", "dxDropDownList");
    m_events_engine_default.off(this._$list, eventName);
    m_events_engine_default.on(this._$list, eventName, ((e) => e.preventDefault()));
  }
  _getControlsAria() {
    return this._list && this._listId;
  }
  _renderOpenedState() {
    super._renderOpenedState();
    this._list && this._updateActiveDescendant();
    this.setAria("owns", this._popup && this._popupContentId);
  }
  _getAriaHasPopup() {
    return "listbox";
  }
  _refreshList() {
    if (this._list && this._shouldRefreshDataSource()) {
      this._setListDataSource();
    }
  }
  _shouldRefreshDataSource() {
    const dataSourceProvided = !!this._list.option("dataSource");
    return dataSourceProvided !== this._needPassDataSourceToList();
  }
  _isDesktopDevice() {
    return "desktop" === devices_default.real().deviceType;
  }
  _listConfig() {
    const options2 = {
      selectionMode: "single",
      _templates: this.option("_templates"),
      templateProvider: this.option("templateProvider"),
      noDataText: this.option("noDataText"),
      encodeNoDataText: this.option("encodeNoDataText"),
      grouped: this.option("grouped"),
      wrapItemText: this.option("wrapItemText"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: this._listContentReadyHandler.bind(this),
      itemTemplate: this.option("itemTemplate"),
      indicateLoading: false,
      keyExpr: this._getCollectionKeyExpr(),
      displayExpr: this._displayGetterExpr(),
      groupTemplate: this.option("groupTemplate"),
      onItemClick: this._listItemClickAction.bind(this),
      dataSource: this._getDataSource(),
      _dataController: this._dataController,
      hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
      focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false,
      _onItemsRendered: () => {
        this._popup.repaint();
      }
    };
    if (!this._canListHaveFocus()) {
      options2.tabIndex = null;
    }
    return options2;
  }
  _canListHaveFocus() {
    return false;
  }
  _getDataSource() {
    return this._needPassDataSourceToList() ? this._dataSource : null;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _listContentReadyHandler() {
    this._list = this._list || this._$list.dxList("instance");
    if (!this.option("deferRendering")) {
      this._refreshSelected();
    }
    this._updatePopupWidth();
    this._updateListDimensions();
    this._contentReadyAction();
  }
  _setListOption(optionName, value2) {
    this._setWidgetOption("_list", arguments);
  }
  _listItemClickAction(e) {
    this._listItemClickHandler(e);
    this._itemClickAction(e);
  }
  _listItemClickHandler(e) {
  }
  _setListDataSource() {
    if (!this._list) {
      return;
    }
    this._setListOption("dataSource", this._getDataSource());
    if (!this._needPassDataSourceToList()) {
      this._setListOption("items", []);
    }
  }
  _needPassDataSourceToList() {
    const {
      showDataBeforeSearch
    } = this.option();
    return showDataBeforeSearch || this._isMinSearchLengthExceeded();
  }
  _isMinSearchLengthExceeded() {
    return this._searchValue().toString().length >= this.option("minSearchLength");
  }
  _needClearFilter() {
    return this._canKeepDataSource() ? false : this._needPassDataSourceToList();
  }
  _canKeepDataSource() {
    const isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    return this._dataController.isLoaded() && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded;
  }
  _searchValue() {
    return this._input().val() || "";
  }
  _getSearchEvent() {
    return addNamespace("input", `${this.NAME}Search`);
  }
  _getCompositionStartEvent() {
    return addNamespace("compositionstart", `${this.NAME}CompositionStart`);
  }
  _getCompositionEndEvent() {
    return addNamespace("compositionend", `${this.NAME}CompositionEnd`);
  }
  _getSetFocusPolicyEvent() {
    return addNamespace("input", `${this.NAME}FocusPolicy`);
  }
  _renderEvents() {
    super._renderEvents();
    m_events_engine_default.on(this._input(), this._getSetFocusPolicyEvent(), (() => {
      this._setFocusPolicy();
    }));
    if (this._shouldRenderSearchEvent()) {
      m_events_engine_default.on(this._input(), this._getSearchEvent(), ((e) => {
        this._searchHandler(e);
      }));
      if (useCompositionEvents) {
        m_events_engine_default.on(this._input(), this._getCompositionStartEvent(), (() => {
          this._isTextCompositionInProgress(true);
        }));
        m_events_engine_default.on(this._input(), this._getCompositionEndEvent(), ((e) => {
          this._isTextCompositionInProgress(void 0);
          this._searchHandler(e, this._searchValue());
        }));
      }
    }
  }
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled");
  }
  _refreshEvents() {
    m_events_engine_default.off(this._input(), this._getSearchEvent());
    m_events_engine_default.off(this._input(), this._getSetFocusPolicyEvent());
    if (useCompositionEvents) {
      m_events_engine_default.off(this._input(), this._getCompositionStartEvent());
      m_events_engine_default.off(this._input(), this._getCompositionEndEvent());
    }
    super._refreshEvents();
  }
  _isTextCompositionInProgress(value2) {
    if (arguments.length) {
      this._isTextComposition = value2;
    } else {
      return this._isTextComposition;
    }
  }
  _searchHandler(e, searchValue) {
    if (this._isTextCompositionInProgress()) {
      return;
    }
    if (!this._isMinSearchLengthExceeded()) {
      this._searchCanceled();
      return;
    }
    const {
      searchTimeout
    } = this.option();
    if (searchTimeout) {
      this._clearSearchTimer();
      this._searchTimer = setTimeout((() => {
        this._searchDataSource(searchValue);
      }), searchTimeout);
    } else {
      this._searchDataSource(searchValue);
    }
  }
  _searchCanceled() {
    this._clearSearchTimer();
    if (this._needClearFilter()) {
      this._filterDataSource(null);
    }
    this._refreshList();
  }
  _searchDataSource() {
    let searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
    this._filterDataSource(searchValue);
  }
  _filterDataSource(searchValue) {
    this._clearSearchTimer();
    const dataController2 = this._dataController;
    dataController2.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
    dataController2.searchOperation(this.option("searchMode"));
    dataController2.searchValue(searchValue);
    dataController2.load().done(this._dataSourceFiltered.bind(this, searchValue));
  }
  _clearFilter() {
    const dataController2 = this._dataController;
    dataController2.searchValue() && dataController2.searchValue(null);
  }
  _dataSourceFiltered(searchValue) {
    this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    this._refreshList();
    this._refreshPopupVisibility();
  }
  _shouldOpenPopup() {
    return this._hasItemsToShow();
  }
  _refreshPopupVisibility() {
    if (this.option("readOnly") || !this._searchValue()) {
      return;
    }
    const shouldOpenPopup = this._shouldOpenPopup();
    if (shouldOpenPopup && !this._isFocused()) {
      return;
    }
    this.option("opened", shouldOpenPopup);
    if (shouldOpenPopup) {
      this._updatePopupWidth();
      this._updateListDimensions();
    }
  }
  _dataSourceChangedHandler(newItems) {
    if (0 === this._dataController.pageIndex()) {
      this.option().items = newItems;
    } else {
      this.option().items = this.option().items.concat(newItems);
    }
  }
  _hasItemsToShow() {
    const dataController2 = this._dataController;
    const resultItems = dataController2.items() || [];
    const resultAmount = resultItems.length;
    const isMinSearchLengthExceeded = this._needPassDataSourceToList();
    return !!(isMinSearchLengthExceeded && resultAmount);
  }
  _clearSearchTimer() {
    clearTimeout(this._searchTimer);
    delete this._searchTimer;
  }
  _popupShowingHandler() {
    this._updatePopupWidth();
    this._updateListDimensions();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this._updateListDimensions();
  }
  _needPopupRepaint() {
    const dataController2 = this._dataController;
    const currentPageIndex = dataController2.pageIndex();
    const needRepaint = isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex || dataController2.isLastPage() && !this._list._scrollViewIsFull();
    this._pageIndex = currentPageIndex;
    return needRepaint;
  }
  _updateListDimensions() {
    if (!this._popup) {
      return;
    }
    if (this._needPopupRepaint()) {
      this._popup.repaint();
    }
    if (this._list) {
      this._list.updateDimensions();
    }
  }
  _getMaxHeight() {
    const $element = this.$element();
    const $customBoundaryContainer = this._$customBoundaryContainer;
    const offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
    const windowHeight = getOuterHeight(window7);
    const containerHeight = $customBoundaryContainer ? Math.min(getOuterHeight($customBoundaryContainer), windowHeight) : windowHeight;
    const maxHeight = Math.max(offsetTop, containerHeight - offsetTop - getOuterHeight($element));
    return Math.min(0.5 * containerHeight, maxHeight);
  }
  _clean() {
    if (this._list) {
      delete this._list;
    }
    delete this._isLastMinSearchLengthExceeded;
    super._clean();
  }
  _dispose() {
    this._clearSearchTimer();
    super._dispose();
  }
  _setCollectionWidgetOption() {
    this._setListOption.apply(this, arguments);
  }
  _setSubmitValue() {
    const value2 = this.option("value");
    const submitValue = this._shouldUseDisplayValue(value2) ? this._displayGetter(value2) : value2;
    this._getSubmitElement().val(submitValue);
  }
  _shouldUseDisplayValue(value2) {
    return "this" === this.option("valueExpr") && isObject(value2);
  }
  _optionChanged(args) {
    this._dataExpressionOptionChanged(args);
    switch (args.name) {
      case "hoverStateEnabled":
      case "focusStateEnabled":
        this._isDesktopDevice() && this._setListOption(args.name, args.value);
        super._optionChanged(args);
        break;
      case "items":
        if (!this.option("dataSource")) {
          this._processDataSourceChanging();
        }
        break;
      case "dataSource":
        this._processDataSourceChanging();
        break;
      case "valueExpr":
        this._renderValue();
        this._setListOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "displayExpr":
        this._renderValue();
        this._setListOption("displayExpr", this._displayGetterExpr());
        break;
      case "searchMode":
        this._validateSearchMode();
        break;
      case "minSearchLength":
        this._refreshList();
        break;
      case "searchEnabled":
      case "showDataBeforeSearch":
      case "searchExpr":
        this._invalidate();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      case "onSelectionChanged":
        this._initSelectionChangedAction();
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "grouped":
      case "groupTemplate":
      case "wrapItemText":
      case "noDataText":
      case "encodeNoDataText":
      case "useItemTextAsTitle":
        this._setListOption(args.name);
        break;
      case "displayValue":
        this.option("text", args.value);
        break;
      case "itemTemplate":
      case "searchTimeout":
        break;
      case "selectedItem":
        if (args.previousValue !== args.value) {
          this._selectionChangedAction({
            selectedItem: args.value
          });
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
};
DropDownList.include(ui_data_expression_default, m_grouped_data_converter_mixin_default);
component_registrator_default("dxDropDownList", DropDownList);
var m_drop_down_list_default = DropDownList;

// node_modules/devextreme/esm/__internal/ui/m_select_box.js
var SelectBox = class extends m_drop_down_list_default {
  _supportedKeys() {
    const that = this;
    const parent = super._supportedKeys();
    const clearSelectBox = function(e) {
      const isEditable2 = this._isEditable();
      if (!isEditable2) {
        if (this.option("showClearButton")) {
          e.preventDefault();
          this.clear();
        }
      } else if (this._valueSubstituted()) {
        this._preventFiltering = true;
      }
      this._savedTextRemoveEvent = e;
      this._preventSubstitution = true;
    };
    const searchIfNeeded = function() {
      if (that.option("searchEnabled") && that._valueSubstituted()) {
        that._searchHandler();
      }
    };
    return _extends({}, parent, {
      tab() {
        const {
          opened
        } = this.option();
        const popupHasFocusableElements = opened && !!this._popup.getFocusableElements().length;
        if (!popupHasFocusableElements) {
          this._resetCaretPosition(true);
        }
        parent.tab && parent.tab.apply(this, arguments);
        if (!popupHasFocusableElements) {
          this._cancelSearchIfNeed();
        }
      },
      upArrow(e) {
        if (parent.upArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      downArrow(e) {
        if (parent.downArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      leftArrow() {
        var _parent$leftArrow;
        searchIfNeeded();
        null === (_parent$leftArrow = parent.leftArrow) || void 0 === _parent$leftArrow || _parent$leftArrow.apply(this, arguments);
      },
      rightArrow() {
        var _parent$rightArrow;
        searchIfNeeded();
        null === (_parent$rightArrow = parent.rightArrow) || void 0 === _parent$rightArrow || _parent$rightArrow.apply(this, arguments);
      },
      home() {
        var _parent$home;
        searchIfNeeded();
        null === (_parent$home = parent.home) || void 0 === _parent$home || _parent$home.apply(this, arguments);
      },
      end() {
        var _parent$end;
        searchIfNeeded();
        null === (_parent$end = parent.end) || void 0 === _parent$end || _parent$end.apply(this, arguments);
      },
      escape() {
        var _parent$escape;
        const result2 = null === (_parent$escape = parent.escape) || void 0 === _parent$escape ? void 0 : _parent$escape.apply(this, arguments);
        this._cancelEditing();
        return result2 ?? true;
      },
      enter(e) {
        const isOpened = this.option("opened");
        const inputText = this._input().val().trim();
        const isCustomText = inputText && this._list && !this._list.option("focusedElement");
        if (!inputText && isDefined(this.option("value")) && this.option("allowClearing")) {
          this._saveValueChangeEvent(e);
          this.option({
            selectedItem: null,
            value: null
          });
          this.close();
        } else {
          var _parent$enter;
          if (this.option("acceptCustomValue")) {
            e.preventDefault();
            if (isCustomText) {
              if (isOpened) {
                this._toggleOpenState();
              }
              this._valueChangeEventHandler(e);
            }
            return isOpened;
          }
          if (null !== (_parent$enter = parent.enter) && void 0 !== _parent$enter && _parent$enter.apply(this, arguments)) {
            return isOpened;
          }
        }
      },
      space(e) {
        const isOpened = this.option("opened");
        const isSearchEnabled = this.option("searchEnabled");
        const acceptCustomValue = this.option("acceptCustomValue");
        if (!isOpened || isSearchEnabled || acceptCustomValue) {
          return;
        }
        e.preventDefault();
        this._valueChangeEventHandler(e);
        return true;
      },
      backspace: clearSelectBox,
      del: clearSelectBox
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      placeholder: message_default.format("Select"),
      fieldTemplate: null,
      customItemCreateEvent: "change",
      valueChangeEvent: "change",
      acceptCustomValue: false,
      onCustomItemCreating(e) {
        if (!isDefined(e.customItem)) {
          e.customItem = e.text;
        }
      },
      showSelectionControls: false,
      allowClearing: true,
      tooltipEnabled: false,
      openOnFieldClick: true,
      showDropDownButton: true,
      displayCustomValue: false,
      useHiddenSubmitElement: true
    });
  }
  _init() {
    super._init();
    this._initCustomItemCreatingAction();
  }
  _initMarkup() {
    this.$element().addClass("dx-selectbox");
    this._renderTooltip();
    super._initMarkup();
    this._$container.addClass("dx-selectbox-container");
  }
  _createPopup() {
    var _this$_popup, _this$_popup2;
    super._createPopup();
    null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.$element().addClass("dx-selectbox-popup");
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.$overlayContent().attr("tabindex", -1);
  }
  _popupWrapperClass() {
    return `${super._popupWrapperClass()} dx-selectbox-popup-wrapper`;
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      valueChangeEvent: {
        since: "22.2",
        alias: "customItemCreateEvent"
      }
    });
  }
  _cancelEditing() {
    if (!this.option("searchEnabled") && this._list) {
      this._focusListElement(null);
      this._updateField(this.option("selectedItem"));
    }
  }
  _renderOpenedState() {
    super._renderOpenedState();
    if (this.option("opened")) {
      this._scrollToSelectedItem();
      this._focusSelectedElement();
    }
  }
  _focusSelectedElement() {
    const searchValue = this._searchValue();
    if (!searchValue) {
      this._focusListElement(null);
      return;
    }
    const {
      items,
      selectedItem
    } = this.option();
    const $listItems = this._list._itemElements();
    const index = (null === items || void 0 === items ? void 0 : items.indexOf(selectedItem)) ?? -1;
    const focusedElement = -1 !== index && !this._isCustomItemSelected() ? $listItems.eq(index) : null;
    this._focusListElement(focusedElement);
  }
  _renderFocusedElement() {
    if (!this._list) {
      return;
    }
    const searchValue = this._searchValue();
    if (!searchValue || this.option("acceptCustomValue")) {
      this._focusListElement(null);
      return;
    }
    const $listItems = this._list._itemElements();
    const focusedElement = $listItems.not(".dx-state-disabled").eq(0);
    this._focusListElement(focusedElement);
  }
  _focusListElement(element) {
    this._preventInputValueRender = true;
    this._list.option("focusedElement", getPublicElement(element));
    delete this._preventInputValueRender;
  }
  _scrollToSelectedItem() {
    var _this$_list;
    null === (_this$_list = this._list) || void 0 === _this$_list || _this$_list.scrollToItem(this._list.option("selectedItem"));
  }
  _listContentReadyHandler() {
    super._listContentReadyHandler();
    const isPaginate = this._dataController.paginate();
    if (isPaginate && this._needPopupRepaint()) {
      return;
    }
    this._scrollToSelectedItem();
  }
  _renderValue() {
    this._renderInputValue();
    this._setSubmitValue();
    return Deferred().resolve();
  }
  _renderInputValue() {
    return super._renderInputValue(...arguments).always((() => {
      this._renderInputValueAsync();
    }));
  }
  _renderInputValueAsync() {
    this._renderTooltip();
    this._renderInputValueImpl().always((() => {
      this._refreshSelected();
    }));
  }
  _renderInputValueImpl() {
    this._renderField();
    return Deferred().resolve();
  }
  _setNextItem(step) {
    const item = this._calcNextItem(step);
    const value2 = this._valueGetter(item);
    this._setValue(value2);
  }
  _setNextValue(e) {
    const dataSourceIsLoaded = this._dataController.isLoaded() ? Deferred().resolve() : this._dataController.load();
    dataSourceIsLoaded.done((() => {
      const selectedIndex = this._getSelectedIndex();
      const hasPages = this._dataController.pageSize();
      const isLastPage = this._dataController.isLastPage();
      const isLastItem = selectedIndex === this._items().length - 1;
      this._saveValueChangeEvent(e);
      const step = "downArrow" === normalizeKeyName(e) ? 1 : -1;
      if (hasPages && !isLastPage && isLastItem && step > 0) {
        if (!this._popup) {
          this._createPopup();
        }
        if (!this._dataController.isLoading()) {
          this._list._loadNextPage().done(this._setNextItem.bind(this, step));
        }
      } else {
        this._setNextItem(step);
      }
    }));
  }
  _setSelectedItem(item) {
    const isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
    super._setSelectedItem(isUnknownItem ? null : item);
    if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
      this._setListOption("selectedItem", this.option("selectedItem"));
    }
  }
  _isCustomValueAllowed() {
    return this.option("acceptCustomValue") || super._isCustomValueAllowed();
  }
  _displayValue(item) {
    item = !isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
    return super._displayValue(item);
  }
  _listConfig() {
    const result2 = extend(super._listConfig(), {
      pageLoadMode: "scrollBottom",
      onSelectionChanged: this._getSelectionChangeHandler(),
      selectedItem: this.option("selectedItem"),
      onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this),
      _onItemsRendered: () => {
        this._popup.repaint();
        if (this.option("opened")) {
          this._scrollToSelectedItem();
        }
      }
    });
    if (this.option("showSelectionControls")) {
      extend(result2, {
        showSelectionControls: true,
        selectByClick: true
      });
    }
    return result2;
  }
  _listFocusedItemChangeHandler(e) {
    if (this._preventInputValueRender) {
      return;
    }
    const list = e.component;
    const focusedElement = renderer_default(list.option("focusedElement"));
    const focusedItem = list._getItemData(focusedElement);
    this._updateField(focusedItem);
  }
  _updateField(item) {
    const fieldTemplate = this._getTemplateByOption("fieldTemplate");
    if (!(fieldTemplate && this.option("fieldTemplate"))) {
      const text = this._displayGetter(item);
      this.option("text", text);
      this._renderDisplayText(text);
      return;
    }
    this._renderField();
  }
  _getSelectionChangeHandler() {
    return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : noop;
  }
  _selectionChangeHandler(e) {
    each(e.addedItems || [], ((_, addedItem) => {
      this._setValue(this._valueGetter(addedItem));
    }));
  }
  _getActualSearchValue() {
    return this._dataController.searchValue();
  }
  _isInlineAutocompleteEnabled() {
    const {
      searchEnabled,
      acceptCustomValue,
      searchMode
    } = this.option();
    return searchEnabled && !acceptCustomValue && "startswith" === searchMode;
  }
  _getAriaAutocomplete() {
    const {
      disabled,
      readOnly,
      searchEnabled
    } = this.option();
    const isInputEditable = !(readOnly || disabled);
    const hasAutocomplete = searchEnabled && isInputEditable;
    if (!hasAutocomplete) {
      return "none";
    }
    const isInlineAutocompleteEnabled = this._isInlineAutocompleteEnabled();
    const autocompleteAria = isInlineAutocompleteEnabled ? "both" : "list";
    return autocompleteAria;
  }
  _toggleOpenState(isVisible) {
    if (this.option("disabled")) {
      return;
    }
    isVisible = arguments.length ? isVisible : !this.option("opened");
    if (!isVisible && !this._shouldClearFilter()) {
      this._restoreInputText(true);
    }
    if (this._wasSearch() && isVisible) {
      this._wasSearch(false);
      const showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
      if (showDataImmediately && this._dataController.getDataSource()) {
        if (this._searchTimer) {
          return;
        }
        const searchValue = this._getActualSearchValue();
        searchValue && this._wasSearch(true);
        this._filterDataSource(searchValue || null);
      } else {
        this._setListOption("items", []);
      }
    }
    if (isVisible) {
      this._scrollToSelectedItem();
    }
    super._toggleOpenState(isVisible);
  }
  _renderTooltip() {
    const {
      tooltipEnabled,
      displayValue
    } = this.option();
    if (tooltipEnabled) {
      this.$element().attr("title", displayValue);
    }
  }
  _renderDimensions() {
    super._renderDimensions();
    this._updatePopupWidth();
    this._updateListDimensions();
  }
  _isValueEqualInputText() {
    const initialSelectedItem = this.option("selectedItem");
    if (null === initialSelectedItem) {
      return false;
    }
    const value2 = this._displayGetter(initialSelectedItem);
    const displayValue = value2 ? String(value2) : "";
    const inputText = this._searchValue();
    return displayValue === inputText;
  }
  _popupHidingHandler() {
    if (this._isValueEqualInputText()) {
      this._cancelEditing();
    }
    super._popupHidingHandler();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler();
    if (this._shouldCancelSearch()) {
      this._wasSearch(false);
      this._searchCanceled();
      this._shouldCancelSearch(false);
    }
  }
  _restoreInputText(saveEditingValue) {
    var _this$_loadItemDeferr;
    if (this.option("readOnly")) {
      return;
    }
    null === (_this$_loadItemDeferr = this._loadItemDeferred) || void 0 === _this$_loadItemDeferr || _this$_loadItemDeferr.always((() => {
      const {
        acceptCustomValue,
        text,
        selectedItem: initialSelectedItem,
        customItemCreateEvent
      } = this.option();
      if (acceptCustomValue) {
        if (!saveEditingValue && !this._isValueChanging) {
          let initialItem = null;
          if (isDefined(initialSelectedItem)) {
            initialItem = initialSelectedItem;
          } else if ("" !== customItemCreateEvent) {
            initialItem = this._createCustomItem(text);
          }
          this._updateField(initialItem);
          this._clearFilter();
        }
        return;
      }
      if (this.option("searchEnabled")) {
        if (!this._searchValue() && this.option("allowClearing")) {
          this._clearTextValue();
          return;
        }
      }
      if (this._isValueEqualInputText()) {
        return;
      }
      this._renderInputValue().always(((selectedItem) => {
        const newSelectedItem = ensureDefined(selectedItem, initialSelectedItem);
        this._setSelectedItem(newSelectedItem);
        this._updateField(newSelectedItem);
        this._clearFilter();
      }));
    }));
  }
  _valueChangeEventIncludesBlur() {
    const valueChangeEvent = this.option(this._getValueChangeEventOptionName());
    return valueChangeEvent.includes("blur");
  }
  _isPreventedFocusOutEvent(e) {
    return this._preventNestedFocusEvent(e) || this._valueChangeEventIncludesBlur();
  }
  _focusOutHandler(e) {
    if (!this._isPreventedFocusOutEvent(e)) {
      const isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
      if (!isOverlayTarget) {
        this._restoreInputText();
        this._clearSearchTimer();
      }
      this._cancelSearchIfNeed(e);
    }
    e.target = this._input().get(0);
    super._focusOutHandler(e);
  }
  _cancelSearchIfNeed(e) {
    const {
      searchEnabled
    } = this.option();
    const isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
    const shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
    if (shouldCancelSearch) {
      var _this$_popup3;
      const isPopupVisible = null === (_this$_popup3 = this._popup) || void 0 === _this$_popup3 ? void 0 : _this$_popup3._hideAnimationProcessing;
      this._clearSearchTimer();
      if (isPopupVisible) {
        this._shouldCancelSearch(true);
      } else {
        this._wasSearch(false);
        this._searchCanceled();
      }
    }
  }
  _shouldCancelSearch(value2) {
    if (!arguments.length) {
      return this._shouldCancelSearchValue;
    }
    this._shouldCancelSearchValue = value2;
  }
  _isOverlayNestedTarget(target) {
    return !!renderer_default(target).closest(".dx-selectbox-popup-wrapper").length;
  }
  _clearTextValue() {
    const selectedItem = this.option("selectedItem");
    const selectedItemText = this._displayGetter(selectedItem);
    const shouldRestoreValue = selectedItem && "" !== selectedItemText;
    if (shouldRestoreValue) {
      if (this._savedTextRemoveEvent) {
        this._saveValueChangeEvent(this._savedTextRemoveEvent);
      }
      this.option("value", null);
    }
    delete this._savedTextRemoveEvent;
  }
  _shouldOpenPopup() {
    return this._needPassDataSourceToList() && this._wasSearch();
  }
  _isFocused() {
    const activeElement = dom_adapter_default.getActiveElement(this.element());
    return super._isFocused() && renderer_default(activeElement).closest(this._input()).length > 0;
  }
  _getValueChangeEventOptionName() {
    return "customItemCreateEvent";
  }
  _renderValueChangeEvent() {
    if (this._isEditable()) {
      super._renderValueChangeEvent();
    }
  }
  _fieldRenderData() {
    const {
      focusedElement
    } = this.option();
    const $listFocused = this._list && this.option("opened") && renderer_default(focusedElement);
    if (null !== $listFocused && void 0 !== $listFocused && $listFocused.length) {
      return this._list._getItemData($listFocused);
    }
    return this.option("selectedItem");
  }
  _isSelectedValue(value2, cache) {
    return this._isValueEquals(value2, this.option("value"));
  }
  _shouldCloseOnItemClick() {
    const {
      selectionMode
    } = this.option();
    return !(this.option("showSelectionControls") && "single" !== selectionMode);
  }
  _listItemClickHandler(e) {
    const previousValue = this._getCurrentValue();
    this._focusListElement(renderer_default(e.itemElement));
    this._saveValueChangeEvent(e.event);
    this._completeSelection(this._valueGetter(e.itemData));
    if (this._shouldCloseOnItemClick()) {
      this.option("opened", false);
    }
    if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
      this._updateField(e.itemData);
    }
    if (this._shouldClearFilter()) {
      this._cancelSearchIfNeed();
    }
  }
  _shouldClearFilter() {
    return this._wasSearch();
  }
  _completeSelection(value2) {
    this._setValue(value2);
  }
  _loadItem(value2, cache) {
    const that = this;
    const deferred = Deferred();
    super._loadItem(value2, cache).done(((item) => {
      deferred.resolve(item);
    })).fail(((args) => {
      if (null !== args && void 0 !== args && args.shouldSkipCallback) {
        return;
      }
      const selectedItem = that.option("selectedItem");
      if (that.option("acceptCustomValue") && value2 === that._valueGetter(selectedItem)) {
        deferred.resolve(selectedItem);
      } else {
        deferred.reject();
      }
    }));
    return deferred.promise();
  }
  _loadInputValue(value2, callback) {
    this._loadItemDeferred = this._loadItem(value2).always(callback);
    return this._loadItemDeferred;
  }
  _isCustomItemSelected() {
    const selectedItem = this.option("selectedItem");
    const searchValue = this._searchValue();
    const selectedItemText = this._displayGetter(selectedItem);
    return !selectedItemText || searchValue !== selectedItemText.toString();
  }
  _valueChangeEventHandler(e) {
    if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
      this._isValueChanging = true;
      this._customItemAddedHandler(e);
    }
  }
  _initCustomItemCreatingAction() {
    this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
  }
  _createCustomItem(text) {
    const params = {
      text
    };
    const actionResult = this._customItemCreatingAction(params);
    const item = ensureDefined(actionResult, params.customItem);
    if (isDefined(actionResult)) {
      errors_default.log("W0015", "onCustomItemCreating", "customItem");
    }
    return item;
  }
  _customItemAddedHandler(e) {
    const searchValue = this._searchValue();
    const item = this._createCustomItem(searchValue);
    this._saveValueChangeEvent(e);
    if (void 0 === item) {
      this._renderValue();
      throw errors_default.Error("E0121");
    }
    if (isPromise(item)) {
      fromPromise(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null));
    } else {
      this._setCustomItem(item);
    }
  }
  _setCustomItem(item) {
    if (this._disposed) {
      return;
    }
    item = item || null;
    this.option("selectedItem", item);
    this._cancelSearchIfNeed();
    this._setValue(this._valueGetter(item));
    this._renderDisplayText(this._displayGetter(item));
    this._isValueChanging = false;
  }
  _clearValueHandler(e) {
    this._preventFiltering = true;
    super._clearValueHandler(e);
    this._searchCanceled();
    return false;
  }
  _wasSearch(value2) {
    if (!arguments.length) {
      return !!this._wasSearchValue;
    }
    this._wasSearchValue = value2;
    return;
  }
  _searchHandler(e) {
    if (this._preventFiltering) {
      delete this._preventFiltering;
      return;
    }
    if (this._needPassDataSourceToList()) {
      this._wasSearch(true);
    }
    super._searchHandler(arguments);
  }
  _dataSourceFiltered(searchValue) {
    super._dataSourceFiltered();
    if (null !== searchValue) {
      this._renderInputSubstitution();
      this._renderFocusedElement();
    }
  }
  _valueSubstituted() {
    const input = this._input().get(0);
    const currentSearchLength = this._searchValue().length;
    const isAllSelected = 0 === input.selectionStart && input.selectionEnd === currentSearchLength;
    const inputHasSelection = input.selectionStart !== input.selectionEnd;
    const isLastSymbolSelected = currentSearchLength === input.selectionEnd;
    return this._wasSearch() && inputHasSelection && !isAllSelected && isLastSymbolSelected && this._shouldSubstitutionBeRendered();
  }
  _shouldSubstitutionBeRendered() {
    return !this._preventSubstitution && this._isInlineAutocompleteEnabled();
  }
  _renderInputSubstitution() {
    if (!this._shouldSubstitutionBeRendered()) {
      delete this._preventSubstitution;
      return;
    }
    const item = this._list && this._getPlainItems(this._list.option("items"))[0];
    if (!item) {
      return;
    }
    const $input = this._input();
    const valueLength = $input.val().length;
    if (0 === valueLength) {
      return;
    }
    const inputElement = $input.get(0);
    const displayValue = this._displayGetter(item).toString();
    inputElement.value = displayValue;
    this._caret({
      start: valueLength,
      end: displayValue.length
    });
  }
  _dispose() {
    this._renderInputValueAsync = noop;
    delete this._loadItemDeferred;
    super._dispose();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "customItemCreateEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onCustomItemCreating":
        this._initCustomItemCreatingAction();
        break;
      case "tooltipEnabled":
        this._renderTooltip();
        break;
      case "readOnly":
      case "disabled":
      case "searchMode":
        super._optionChanged(args);
        this._setDefaultAria();
        break;
      case "displayCustomValue":
      case "acceptCustomValue":
      case "showSelectionControls":
        this._invalidate();
        break;
      case "allowClearing":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxSelectBox", SelectBox);
var m_select_box_default = SelectBox;

// node_modules/devextreme/esm/ui/select_box.js
var select_box_default = m_select_box_default;

// node_modules/devextreme/esm/__internal/events/gesture/m_swipeable.js
var DX_SWIPEABLE = "dxSwipeable";
var ACTION_TO_EVENT_MAP = {
  onStart: SWIPE_START_EVENT,
  onUpdated: SWIPE_EVENT,
  onEnd: SWIPE_END_EVENT,
  onCancel: "dxswipecancel"
};
var Swipeable = class extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      elastic: true,
      immediate: false,
      immediateTimeout: 180,
      direction: "horizontal",
      itemSizeFunc: null,
      onStart: null,
      onUpdated: null,
      onEnd: null,
      onCancel: null
    });
  }
  _render() {
    super._render();
    this.$element().addClass("dx-swipeable");
    this._attachEventHandlers();
  }
  _attachEventHandlers() {
    this._detachEventHandlers();
    if (this.option("disabled")) {
      return;
    }
    const {
      NAME
    } = this;
    this._createEventData();
    each(ACTION_TO_EVENT_MAP, ((actionName, eventName) => {
      const action = this._createActionByOption(actionName, {
        context: this
      });
      eventName = addNamespace(eventName, NAME);
      m_events_engine_default.on(this.$element(), eventName, this._eventData, ((e) => action({
        event: e
      })));
    }));
  }
  _createEventData() {
    this._eventData = {
      elastic: this.option("elastic"),
      itemSizeFunc: this.option("itemSizeFunc"),
      direction: this.option("direction"),
      immediate: this.option("immediate"),
      immediateTimeout: this.option("immediateTimeout")
    };
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this.$element(), `.${DX_SWIPEABLE}`);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
      case "onStart":
      case "onUpdated":
      case "onEnd":
      case "onCancel":
      case "elastic":
      case "immediate":
      case "itemSizeFunc":
      case "direction":
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "rtlEnabled":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _useTemplates() {
    return false;
  }
};
getName(Swipeable, DX_SWIPEABLE);
var m_swipeable_default = Swipeable;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.selection.strategy.js
var CalendarSelectionStrategy = class {
  constructor(component) {
    this.calendar = component;
  }
  dateOption(optionName) {
    return this.calendar._dateOption(optionName);
  }
  dateValue(value2, e) {
    this.calendar._dateValue(value2, e);
  }
  skipNavigate() {
    this.calendar._skipNavigate = true;
  }
  updateAriaSelected(value2, previousValue) {
    this.calendar._updateAriaSelected(value2, previousValue);
    if (value2[0] && this.calendar.option("currentDate").getTime() === value2[0].getTime()) {
      this.calendar._updateAriaId(value2[0]);
    }
  }
  processValueChanged(value2, previousValue) {
    var _value, _previousValue;
    if (isDefined(value2) && !Array.isArray(value2)) {
      value2 = [value2];
    }
    if (isDefined(previousValue) && !Array.isArray(previousValue)) {
      previousValue = [previousValue];
    }
    value2 = (null === (_value = value2) || void 0 === _value ? void 0 : _value.map(((item) => this._convertToDate(item)))) || [];
    previousValue = (null === (_previousValue = previousValue) || void 0 === _previousValue ? void 0 : _previousValue.map(((item) => this._convertToDate(item)))) || [];
    this._updateViewsValue(value2);
    this.updateAriaSelected(value2, previousValue);
    if (!this._currentDateChanged) {
      this.calendar._initCurrentDate();
    }
    this._currentDateChanged = false;
  }
  _isDateDisabled(date) {
    const min = this.calendar._dateOption("min");
    const max = this.calendar._dateOption("max");
    const isLessThanMin = isDefined(min) && date < min && !date_default2.sameDate(min, date);
    const isBiggerThanMax = isDefined(max) && date > max && !date_default2.sameDate(max, date);
    return this.calendar._view.isDateDisabled(date) || isLessThanMin || isBiggerThanMax;
  }
  _getLowestDateInArray(dates) {
    if (dates.length) {
      return new Date(Math.min(...dates));
    }
  }
  _convertToDate(value2) {
    return this.calendar._convertToDate(value2);
  }
  _isMaxZoomLevel() {
    return this.calendar._isMaxZoomLevel();
  }
  _updateViewsOption(optionName, optionValue) {
    this.calendar._updateViewsOption(optionName, optionValue);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2);
  }
  _updateCurrentDate(value2) {
    this.calendar.option("currentDate", value2 ?? /* @__PURE__ */ new Date());
  }
  _shouldHandleWeekNumberClick() {
    const {
      selectionMode,
      selectWeekOnClick
    } = this.calendar.option();
    return selectWeekOnClick && "single" !== selectionMode;
  }
};
var m_calendar_selection_strategy_default = CalendarSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.multiple.selection.strategy.js
var CalendarMultiSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "MultiSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "multiple",
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const value2 = [...this.dateOption("value")];
    const alreadySelectedIndex = value2.findIndex(((date) => (null === date || void 0 === date ? void 0 : date.toDateString()) === selectedValue.toDateString()));
    if (alreadySelectedIndex > -1) {
      value2.splice(alreadySelectedIndex, 1);
    } else {
      value2.push(selectedValue);
    }
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    this.dateValue(value2, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this.dateOption("value"));
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const dates = this.dateOption("value").filter(Boolean);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", []);
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter(((date) => !this._isDateDisabled(date)));
    this.dateValue(selectedDates, event);
  }
};
var m_calendar_multiple_selection_strategy_default = CalendarMultiSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.navigator.js
var Navigator = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onClick: void 0,
      onCaptionClick: void 0,
      type: "normal",
      stylingMode: "outlined",
      text: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterial(),
      options: {
        type: "default",
        stylingMode: "text"
      }
    }, {
      device: () => isFluent(),
      options: {
        type: "normal",
        stylingMode: "text"
      }
    }]);
  }
  _init() {
    super._init();
    this._initActions();
  }
  _initActions() {
    this._clickAction = this._createActionByOption("onClick");
    this._captionClickAction = this._createActionByOption("onCaptionClick");
  }
  _initMarkup() {
    super._initMarkup();
    renderer_default(this.element()).addClass("dx-calendar-navigator");
    this._renderButtons();
    this._renderCaption();
  }
  _renderButtons() {
    const {
      rtlEnabled,
      type: type2,
      stylingMode,
      focusStateEnabled
    } = this.option();
    this._prevButton = this._createComponent(renderer_default("<div>"), button_default2, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronright" : "chevronleft",
      onClick: (e) => {
        var _this$_clickAction;
        null === (_this$_clickAction = this._clickAction) || void 0 === _this$_clickAction || _this$_clickAction.call(this, {
          direction: -1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $prevButton = renderer_default(this._prevButton.element()).addClass("dx-calendar-navigator-previous-view").addClass("dx-calendar-navigator-previous-month");
    this._nextButton = this._createComponent(renderer_default("<div>"), button_default2, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronleft" : "chevronright",
      onClick: (e) => {
        var _this$_clickAction2;
        null === (_this$_clickAction2 = this._clickAction) || void 0 === _this$_clickAction2 || _this$_clickAction2.call(this, {
          direction: 1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $nextButton = renderer_default(this._nextButton.element()).addClass("dx-calendar-navigator-next-view").addClass("dx-calendar-navigator-next-month");
    this._caption = this._createComponent(renderer_default("<div>").addClass("dx-calendar-caption-button"), button_default2, {
      focusStateEnabled,
      onClick: (e) => {
        var _this$_captionClickAc;
        null === (_this$_captionClickAc = this._captionClickAction) || void 0 === _this$_captionClickAc || _this$_captionClickAc.call(this, {
          event: e
        });
      },
      type: type2,
      stylingMode,
      template: (_, content) => {
        const {
          text
        } = this.option();
        const viewCaptionTexts = text.split(" - ");
        viewCaptionTexts.forEach(((captionText) => {
          renderer_default(content).append(renderer_default("<span>").addClass("dx-button-text").text(captionText));
        }));
      },
      integrationOptions: {}
    });
    const $caption = this._caption.$element();
    this.$element().append($prevButton).append($caption).append($nextButton);
  }
  _renderCaption() {
    var _this$_caption;
    const {
      text
    } = this.option();
    null === (_this$_caption = this._caption) || void 0 === _this$_caption || _this$_caption.option("text", text);
  }
  toggleButton(buttonPrefix, value2) {
    const buttonName = `_${buttonPrefix}Button`;
    const button = this[buttonName];
    if (button) {
      button.option("disabled", value2);
      button.$element().toggleClass("dx-calendar-disabled-navigator-link", value2);
    }
  }
  _optionChanged(args) {
    if ("text" === args.name) {
      this._renderCaption();
    } else {
      super._optionChanged(args);
    }
  }
};
var m_calendar_navigator_default = Navigator;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.range.selection.strategy.js
var CalendarRangeSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "RangeSelection";
  }
  getViewOptions() {
    const value2 = this._getValue();
    const range = this._getDaysInRange(value2[0], value2[1]);
    return {
      value: value2,
      range,
      selectionMode: "range",
      onCellHover: this._cellHoverHandler.bind(this),
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const [startDate, endDate] = this._getValue();
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    if (true === this.calendar.option("_allowChangeSelectionOrder")) {
      this.calendar._valueSelected = true;
      if ("startDate" === this.calendar.option("_currentSelection")) {
        if (this.calendar._convertToDate(selectedValue) > this.calendar._convertToDate(endDate)) {
          this.dateValue([selectedValue, null], e);
        } else {
          this.dateValue([selectedValue, endDate], e);
        }
      } else if (this.calendar._convertToDate(selectedValue) >= this.calendar._convertToDate(startDate)) {
        this.dateValue([startDate, selectedValue], e);
      } else {
        this.dateValue([selectedValue, null], e);
      }
    } else if (!startDate || endDate) {
      this.dateValue([selectedValue, null], e);
    } else {
      this.dateValue(startDate < selectedValue ? [startDate, selectedValue] : [selectedValue, startDate], e);
    }
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this._getValue());
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  processValueChanged(value2, previousValue) {
    super.processValueChanged(value2, previousValue);
    const range = this._getRange();
    this._updateViewsOption("range", range);
  }
  getDefaultCurrentDate() {
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    const value2 = this.dateOption("value");
    if (_allowChangeSelectionOrder) {
      if ("startDate" === _currentSelection && value2[0]) {
        return value2[0];
      }
      if ("endDate" === _currentSelection && value2[1]) {
        return value2[1];
      }
    }
    const dates = value2.filter(((value3) => value3));
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", [null, null]);
  }
  _getValue() {
    const value2 = this.dateOption("value");
    if (!value2.length) {
      return value2;
    }
    let [startDate, endDate] = value2;
    if (startDate && endDate && startDate > endDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    return [startDate, endDate];
  }
  _getRange() {
    const [startDate, endDate] = this._getValue();
    return this._getDaysInRange(startDate, endDate);
  }
  _getDaysInRange(startDate, endDate) {
    if (!startDate || !endDate) {
      return [];
    }
    const {
      currentDate,
      viewsCount
    } = this.calendar.option();
    const isAdditionalViewDate = this.calendar._isAdditionalViewDate(currentDate);
    const firstDateInViews = date_default2.getFirstMonthDate(currentDate, isAdditionalViewDate ? -2 : -1);
    const lastDateInViews = date_default2.getLastMonthDate(currentDate, isAdditionalViewDate ? 1 : viewsCount);
    const rangeStartDate = new Date(Math.max(firstDateInViews, startDate));
    const rangeEndDate = new Date(Math.min(lastDateInViews, endDate));
    return [...date_default2.getDatesOfInterval(rangeStartDate, rangeEndDate, 864e5), rangeEndDate];
  }
  _cellHoverHandler(e) {
    const isMaxZoomLevel = this._isMaxZoomLevel();
    const [startDate, endDate] = this._getValue();
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    if (isMaxZoomLevel) {
      const skipHoveredRange = _allowChangeSelectionOrder && "startDate" === _currentSelection;
      if (startDate && !endDate && !skipHoveredRange) {
        if (e.value > startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(startDate, e.value));
          return;
        }
      } else if (!startDate && endDate && !(_allowChangeSelectionOrder && "endDate" === _currentSelection)) {
        if (e.value < endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, endDate));
          return;
        }
      } else if (startDate && endDate) {
        if ("startDate" === _currentSelection && e.value < startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, startDate));
          return;
        }
        if ("endDate" === _currentSelection && e.value > endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(endDate, e.value));
          return;
        }
      }
      this._updateViewsOption("hoveredRange", []);
    }
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter(((date) => !this._isDateDisabled(date)));
    const value2 = selectedDates.length ? [selectedDates[0], selectedDates[selectedDates.length - 1]] : [null, null];
    this.dateValue(value2, event);
  }
};
var m_calendar_range_selection_strategy_default = CalendarRangeSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.single.selection.strategy.js
var CalendarSingleSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "SingleSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "single"
    };
  }
  selectValue(selectedValue, e) {
    this.skipNavigate();
    this.dateValue(selectedValue, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = [this.dateOption("value")]);
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const date = this.dateOption("value");
    if ("" === date) {
      return /* @__PURE__ */ new Date();
    }
    return date;
  }
  restoreValue() {
    this.calendar.option("value", null);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2[0]);
  }
};
var m_calendar_single_selection_strategy_default = CalendarSingleSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.base_view.js
var NOT_WEEK_CELL_SELECTOR = "td:not(.dx-calendar-week-number-cell)";
var CALENDAR_DXCLICK_EVENT_NAME = addNamespace(CLICK_EVENT_NAME, "dxCalendar");
var CALENDAR_DXHOVERSTART_EVENT_NAME = addNamespace(HOVERSTART, "dxCalendar");
var CURRENT_DATE_TEXT = {
  month: message_default.format("dxCalendar-currentDay"),
  year: message_default.format("dxCalendar-currentMonth"),
  decade: message_default.format("dxCalendar-currentYear"),
  century: message_default.format("dxCalendar-currentYearRange")
};
var SELECTION_MODE2 = {
  single: "single",
  multiple: "multiple",
  range: "range"
};
var BaseView = class extends widget_default {
  _getViewName() {
    return "base";
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      date: /* @__PURE__ */ new Date(),
      focusStateEnabled: false,
      cellTemplate: null,
      disabledDates: null,
      onCellClick: null,
      onCellHover: null,
      onWeekNumberClick: null,
      rowCount: 3,
      colCount: 4,
      allowValueSelection: true,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _initMarkup() {
    super._initMarkup();
    this._renderImpl();
  }
  _renderImpl() {
    this.$element().append(this._createTable());
    this._createDisabledDatesHandler();
    this._renderBody();
    this._renderContouredDate();
    this._renderValue();
    this._renderRange();
    this._renderEvents();
    this._updateTableAriaLabel();
  }
  _getLocalizedWidgetName() {
    const localizedWidgetName = message_default.format("dxCalendar-ariaWidgetName");
    return localizedWidgetName;
  }
  _getSingleModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const formattedDate = date_default.format(value2, "date");
    const selectedDatesText = message_default.format("dxCalendar-selectedDate", formattedDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  }
  _getRangeModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const [startDate, endDate] = value2;
    const formattedStartDate = date_default.format(startDate, "date");
    const formattedEndDate = date_default.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedDateRange", formattedStartDate, formattedEndDate) : message_default.format("dxCalendar-selectedDate", formattedStartDate ?? formattedEndDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  }
  _getMultipleModeAriaLabel() {
    const localizedWidgetName = this._getLocalizedWidgetName();
    const selectedRangesText = this._getMultipleRangesText();
    const ariaLabel = `${localizedWidgetName}. ${selectedRangesText}`;
    return ariaLabel;
  }
  _getMultipleRangesText() {
    const {
      value: value2
    } = this.option();
    const ranges = date_default2.getRangesByDates(value2.map(((date) => new Date(date))));
    if (ranges.length > 2) {
      const dateRangeCountText = message_default.format("dxCalendar-selectedDateRangeCount", ranges.length);
      return dateRangeCountText;
    }
    const selectedDatesText = message_default.format("dxCalendar-selectedDates");
    const rangesText = ranges.map(((range) => this._getRangeText(range))).join(", ");
    const result2 = `${selectedDatesText}: ${rangesText}`;
    return result2;
  }
  _getRangeText(range) {
    const [startDate, endDate] = range;
    const formattedStartDate = date_default.format(startDate, "date");
    const formattedEndDate = date_default.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedMultipleDateRange", formattedStartDate, formattedEndDate) : formattedStartDate;
    return selectedDatesText;
  }
  _getTableAriaLabel() {
    const {
      value: value2,
      selectionMode
    } = this.option();
    const isValueEmpty = !value2 || Array.isArray(value2) && !value2.filter(Boolean).length;
    if (isValueEmpty) {
      return this._getLocalizedWidgetName();
    }
    switch (selectionMode) {
      case SELECTION_MODE2.single:
        return this._getSingleModeAriaLabel();
      case SELECTION_MODE2.range:
        return this._getRangeModeAriaLabel();
      case SELECTION_MODE2.multiple:
        return this._getMultipleModeAriaLabel();
    }
  }
  _updateTableAriaLabel() {
    const label = this._getTableAriaLabel();
    this.setAria({
      label
    }, this._$table);
  }
  _createTable() {
    this._$table = renderer_default("<table>");
    this.setAria({
      role: "grid"
    }, this._$table);
    return this._$table;
  }
  _renderBody() {
    this.$body = renderer_default("<tbody>").appendTo(this._$table);
    const rowData = {
      cellDate: this._getFirstCellData(),
      prevCellDate: null
    };
    const {
      rowCount: rowsCount,
      colCount: colsCount
    } = this.option();
    for (let rowIndex = 0, rowCount = rowsCount; rowIndex < rowCount; rowIndex++) {
      rowData.row = this._createRow();
      for (let colIndex = 0, colCount = colsCount; colIndex < colCount; colIndex++) {
        this._renderCell(rowData, colIndex);
      }
      this._renderWeekNumberCell(rowData);
    }
  }
  _renderWeekNumberCell(rowData) {
  }
  _createRow() {
    const row = dom_adapter_default.createElement("tr");
    this.setAria("role", "row", renderer_default(row));
    this.$body.get(0).appendChild(row);
    return row;
  }
  _createCell(cellDate, cellIndex) {
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = this._getClassNameByDate(cellDate, cellIndex);
    cell.setAttribute("data-value", date_serialization_default.serializeDate(cellDate, date_default2.getShortDateFormat()));
    data(cell, "dxDateValueKey", cellDate);
    this.setAria({
      role: "gridcell",
      selected: false,
      label: this.getCellAriaLabel(cellDate)
    }, $cell);
    return {
      cell,
      $cell
    };
  }
  _renderCell(params, cellIndex) {
    const {
      cellDate,
      prevCellDate,
      row
    } = params;
    if (prevCellDate) {
      date_default2.fixTimezoneGap(prevCellDate, cellDate);
    }
    params.prevCellDate = cellDate;
    const {
      cell,
      $cell
    } = this._createCell(cellDate, cellIndex);
    const cellTemplate = this.option("cellTemplate");
    renderer_default(row).append(cell);
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell));
    } else {
      cell.innerHTML = this._getCellText(cellDate);
    }
    params.cellDate = this._getNextCellData(cellDate);
  }
  _getClassNameByDate(cellDate, cellIndex) {
    let className = "dx-calendar-cell";
    if (this._isTodayCell(cellDate)) {
      className += " dx-calendar-today";
    }
    if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
      className += " dx-calendar-empty-cell";
    }
    if (this._isOtherView(cellDate)) {
      className += " dx-calendar-other-view";
    }
    const {
      selectionMode
    } = this.option();
    if (selectionMode === SELECTION_MODE2.range) {
      if (0 === cellIndex) {
        className += " dx-calendar-cell-start-in-row";
      }
      const {
        colCount
      } = this.option();
      if (cellIndex === colCount - 1) {
        className += " dx-calendar-cell-end-in-row";
      }
      if (this._isStartDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-start";
      }
      if (this._isEndDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-end";
      }
    }
    return className;
  }
  _prepareCellTemplateData(cellDate, cellIndex, $cell) {
    const isDateCell = cellDate instanceof Date;
    const text = isDateCell ? this._getCellText(cellDate) : cellDate;
    const date = isDateCell ? cellDate : void 0;
    const view = this._getViewName();
    return {
      model: {
        text,
        date,
        view
      },
      container: getPublicElement($cell),
      index: cellIndex
    };
  }
  _renderEvents() {
    this._createCellClickAction();
    m_events_engine_default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
    m_events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, ((e) => {
      if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
        this._cellClickAction({
          event: e,
          value: renderer_default(e.currentTarget).data("dxDateValueKey")
        });
      }
    }));
    const {
      selectionMode
    } = this.option();
    m_events_engine_default.off(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME);
    if (selectionMode === SELECTION_MODE2.range) {
      this._createCellHoverAction();
      m_events_engine_default.on(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, ((e) => {
        if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
          this._cellHoverAction({
            event: e,
            value: renderer_default(e.currentTarget).data("dxDateValueKey")
          });
        }
      }));
    }
    if (selectionMode !== SELECTION_MODE2.single) {
      this._createWeekNumberCellClickAction();
      m_events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, ".dx-calendar-week-number-cell", ((e) => {
        const $row = renderer_default(e.currentTarget).closest("tr");
        const firstDateInRow = $row.find(".dx-calendar-cell").first().data("dxDateValueKey");
        const lastDateInRow = $row.find(".dx-calendar-cell").last().data("dxDateValueKey");
        const rowDates = [...date_default2.getDatesOfInterval(firstDateInRow, lastDateInRow, 864e5), lastDateInRow];
        this._weekNumberCellClickAction({
          event: e,
          rowDates
        });
      }));
    }
  }
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick");
  }
  _createCellHoverAction() {
    this._cellHoverAction = this._createActionByOption("onCellHover");
  }
  _createWeekNumberCellClickAction() {
    this._weekNumberCellClickAction = this._createActionByOption("onWeekNumberClick");
  }
  _createDisabledDatesHandler() {
    const {
      disabledDates
    } = this.option();
    this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || noop;
  }
  _getDefaultDisabledDatesHandler(disabledDates) {
    return noop;
  }
  _isTodayCell(cellDate) {
    class_default.abstract();
  }
  _isDateOutOfRange(cellDate) {
    class_default.abstract();
  }
  isDateDisabled(cellDate) {
    const dateParts = {
      date: cellDate,
      view: this._getViewName()
    };
    return this._disabledDatesHandler(dateParts);
  }
  _isOtherView(cellDate) {
    class_default.abstract();
  }
  _isStartDayOfMonth(cellDate) {
    class_default.abstract();
  }
  _isEndDayOfMonth(cellDate) {
    class_default.abstract();
  }
  _getCellText(cellDate) {
    class_default.abstract();
  }
  _getFirstCellData() {
    class_default.abstract();
  }
  _getNextCellData(date) {
    class_default.abstract();
  }
  _renderContouredDate(contouredDate) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    contouredDate = contouredDate || this.option("contouredDate");
    const $oldContouredCell = this._getContouredCell();
    const $newContouredCell = this._getCellByDate(contouredDate);
    $oldContouredCell.removeClass("dx-calendar-contoured-date");
    if (contouredDate) {
      $newContouredCell.addClass("dx-calendar-contoured-date");
    }
  }
  _getContouredCell() {
    return this._$table.find(".dx-calendar-contoured-date");
  }
  _renderValue() {
    if (!this.option("allowValueSelection")) {
      return;
    }
    let value2 = this.option("value");
    if (!Array.isArray(value2)) {
      value2 = [value2];
    }
    this._updateSelectedClass(value2);
  }
  _updateSelectedClass(value2) {
    var _this$_$selectedCells;
    if (this._isRangeMode() && !this._isMonthView()) {
      return;
    }
    null === (_this$_$selectedCells = this._$selectedCells) || void 0 === _this$_$selectedCells || _this$_$selectedCells.forEach((($cell) => {
      $cell.removeClass("dx-calendar-selected-date");
    }));
    this._$selectedCells = value2.map(((value3) => this._getCellByDate(value3)));
    this._$selectedCells.forEach((($cell) => {
      $cell.addClass("dx-calendar-selected-date");
    }));
  }
  _renderRange() {
    var _this$_$rangeCells, _this$_$hoveredRangeC, _this$_$rangeStartHov, _this$_$rangeEndHover, _this$_$rangeStartDat, _this$_$rangeEndDateC, _this$_$rangeStartDat2, _this$_$rangeEndDateC2;
    const {
      allowValueSelection,
      value: value2,
      range
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$rangeCells = this._$rangeCells) || void 0 === _this$_$rangeCells || _this$_$rangeCells.forEach((($cell) => {
      $cell.removeClass("dx-calendar-cell-in-range");
    }));
    null === (_this$_$hoveredRangeC = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC || _this$_$hoveredRangeC.forEach((($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    }));
    null === (_this$_$rangeStartHov = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov || _this$_$rangeStartHov.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover || _this$_$rangeEndHover.removeClass("dx-calendar-cell-range-hover-end");
    null === (_this$_$rangeStartDat = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat || _this$_$rangeStartDat.removeClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC || _this$_$rangeEndDateC.removeClass("dx-calendar-range-end-date");
    this._$rangeCells = range.map(((value3) => this._getCellByDate(value3)));
    this._$rangeStartDateCell = this._getCellByDate(value2[0]);
    this._$rangeEndDateCell = this._getCellByDate(value2[1]);
    this._$rangeCells.forEach((($cell) => {
      $cell.addClass("dx-calendar-cell-in-range");
    }));
    null === (_this$_$rangeStartDat2 = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat2 || _this$_$rangeStartDat2.addClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC2 = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC2 || _this$_$rangeEndDateC2.addClass("dx-calendar-range-end-date");
  }
  _renderHoveredRange() {
    var _this$_$hoveredRangeC2, _this$_$rangeStartHov2, _this$_$rangeEndHover2, _this$_$rangeStartHov3, _this$_$rangeEndHover3;
    const {
      allowValueSelection,
      hoveredRange
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$hoveredRangeC2 = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC2 || _this$_$hoveredRangeC2.forEach((($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    }));
    null === (_this$_$rangeStartHov2 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov2 || _this$_$rangeStartHov2.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover2 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover2 || _this$_$rangeEndHover2.removeClass("dx-calendar-cell-range-hover-end");
    this._$hoveredRangeCells = hoveredRange.map(((value2) => this._getCellByDate(value2)));
    this._$rangeStartHoverCell = this._getCellByDate(hoveredRange[0]);
    this._$rangeEndHoverCell = this._getCellByDate(hoveredRange[hoveredRange.length - 1]);
    this._$hoveredRangeCells.forEach((($cell) => {
      $cell.addClass("dx-calendar-cell-range-hover");
    }));
    null === (_this$_$rangeStartHov3 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov3 || _this$_$rangeStartHov3.addClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover3 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover3 || _this$_$rangeEndHover3.addClass("dx-calendar-cell-range-hover-end");
  }
  _isMonthView() {
    const {
      zoomLevel
    } = this.option();
    return "month" === zoomLevel;
  }
  _isRangeMode() {
    const {
      selectionMode
    } = this.option();
    return selectionMode === SELECTION_MODE2.range;
  }
  _getCurrentDateFormat() {
    return null;
  }
  getCellAriaLabel(date) {
    const viewName2 = this._getViewName();
    const isToday = this._isTodayCell(date);
    const format2 = this._getCurrentDateFormat();
    const dateRangeText = format2 ? date_default.format(date, format2) : this._getCellText(date);
    const ariaLabel = isToday ? `${dateRangeText}. ${CURRENT_DATE_TEXT[viewName2]}` : dateRangeText;
    return ariaLabel;
  }
  _getFirstAvailableDate() {
    let date = this.option("date");
    const min = this.option("min");
    date = date_default2.getViewFirstCellDate(this._getViewName(), date);
    return new Date(min && date < min ? min : date);
  }
  _getCellByDate(contouredDate) {
    class_default.abstract();
  }
  isBoundary(date) {
    class_default.abstract();
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "value":
        this._renderValue();
        this._updateTableAriaLabel();
        break;
      case "range":
        this._renderRange();
        break;
      case "hoveredRange":
        this._renderHoveredRange();
        break;
      case "contouredDate":
        this._renderContouredDate(value2);
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellHover":
        this._createCellHoverAction();
        break;
      case "min":
      case "max":
      case "disabledDates":
      case "cellTemplate":
      case "selectionMode":
        this._invalidate();
        break;
      case "_todayDate":
        this._renderBody();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_calendar_base_view_default = BaseView;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.views.js
var MonthView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "month";
  }
  _getCurrentDateFormat() {
    return "longdate";
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      firstDayOfWeek: 0,
      rowCount: 6,
      colCount: 7
    });
  }
  _renderImpl() {
    super._renderImpl();
    this._renderHeader();
  }
  _renderBody() {
    super._renderBody();
    this._$table.find(".dx-calendar-other-view").addClass("dx-calendar-other-month");
  }
  _renderFocusTarget() {
  }
  _renderHeader() {
    const $headerRow = renderer_default("<tr>");
    const $header = renderer_default("<thead>").append($headerRow);
    this._$table.prepend($header);
    const {
      colCount: columnsCount,
      showWeekNumbers
    } = this.option();
    for (let colIndex = 0, colCount = columnsCount; colIndex < colCount; colIndex++) {
      this._renderHeaderCell(colIndex, $headerRow);
    }
    if (showWeekNumbers) {
      this._renderWeekHeaderCell($headerRow);
    }
  }
  _renderHeaderCell(cellIndex, $headerRow) {
    const {
      firstDayOfWeek
    } = this.option();
    const {
      full: fullCaption,
      abbreviated: abbrCaption
    } = this._getDayCaption(firstDayOfWeek + cellIndex);
    const $cell = renderer_default("<th>").attr({
      scope: "col",
      abbr: fullCaption
    }).text(abbrCaption);
    $headerRow.append($cell);
  }
  _renderWeekHeaderCell($headerRow) {
    const $weekNumberHeaderCell = renderer_default("<th>").attr({
      scope: "col",
      abbr: "WeekNumber",
      class: "dx-week-number-header"
    });
    $headerRow.prepend($weekNumberHeaderCell);
  }
  _renderWeekNumberCell(rowData) {
    const {
      showWeekNumbers,
      cellTemplate,
      selectionMode,
      selectWeekOnClick
    } = this.option();
    if (!showWeekNumbers) {
      return;
    }
    const weekNumber = this._getWeekNumber(rowData.prevCellDate);
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = "dx-calendar-week-number-cell";
    if ("single" !== selectionMode && selectWeekOnClick) {
      $cell.addClass("dx-calendar-week-selection");
    }
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(weekNumber, -1, $cell));
    } else {
      cell.innerHTML = weekNumber;
    }
    rowData.row.prepend(cell);
    this.setAria({
      role: "gridcell",
      label: `Week ${weekNumber}`
    }, $cell);
  }
  _getWeekNumber(date) {
    const {
      weekNumberRule,
      firstDayOfWeek
    } = this.option();
    if ("auto" === weekNumberRule) {
      return date_default2.getWeekNumber(date, firstDayOfWeek, 1 === firstDayOfWeek ? "firstFourDays" : "firstDay");
    }
    return date_default2.getWeekNumber(date, firstDayOfWeek, weekNumberRule);
  }
  getNavigatorCaption() {
    const {
      date
    } = this.option();
    return date_default.format(date, "monthandyear");
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default2.sameDate(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const minDate = this.option("min");
    const maxDate = this.option("max");
    return !date_default2.dateInRange(cellDate, minDate, maxDate, "date");
  }
  _isOtherView(cellDate) {
    const {
      date
    } = this.option();
    return cellDate.getMonth() !== date.getMonth();
  }
  _isStartDayOfMonth(cellDate) {
    return date_default2.sameDate(cellDate, date_default2.getFirstMonthDate(this.option("date")));
  }
  _isEndDayOfMonth(cellDate) {
    return date_default2.sameDate(cellDate, date_default2.getLastMonthDate(this.option("date")));
  }
  _getCellText(cellDate) {
    return date_default.format(cellDate, "d");
  }
  _getDayCaption(day) {
    const {
      colCount: daysInWeek
    } = this.option();
    const dayIndex = day % daysInWeek;
    return {
      full: date_default.getDayNames()[dayIndex],
      abbreviated: date_default.getDayNames("abbreviated")[dayIndex]
    };
  }
  _getFirstCellData() {
    const {
      firstDayOfWeek
    } = this.option();
    const firstDay = date_default2.getFirstMonthDate(this.option("date"));
    let firstMonthDayOffset = firstDayOfWeek - firstDay.getDay();
    const {
      colCount: daysInWeek
    } = this.option();
    if (firstMonthDayOffset >= 0) {
      firstMonthDayOffset -= daysInWeek;
    }
    firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
    return firstDay;
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setDate(date.getDate() + 1);
    return date;
  }
  _getCellByDate(date) {
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(date, date_default2.getShortDateFormat())}']`);
  }
  isBoundary(date) {
    return date_default2.sameMonthAndYear(date, this.option("min")) || date_default2.sameMonthAndYear(date, this.option("max"));
  }
  _getDefaultDisabledDatesHandler(disabledDates) {
    return function(args) {
      const isDisabledDate = disabledDates.some(((item) => date_default2.sameDate(item, args.date)));
      if (isDisabledDate) {
        return true;
      }
    };
  }
};
var YearView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "year";
  }
  _getCurrentDateFormat() {
    return "monthandyear";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default2.sameMonthAndYear(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    return !date_default2.dateInRange(cellDate, date_default2.getFirstMonthDate(this.option("min")), date_default2.getLastMonthDate(this.option("max")));
  }
  _isOtherView() {
    return false;
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    return date_default.getMonthNames("abbreviated")[cellDate.getMonth()];
  }
  _getFirstCellData() {
    const {
      date: currentDate
    } = this.option();
    const data17 = new Date(currentDate);
    data17.setDate(1);
    data17.setMonth(0);
    return data17;
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setMonth(date.getMonth() + 1);
    return date;
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default2.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date
    } = this.option();
    return date_default.format(date, "yyyy");
  }
  isBoundary(date) {
    return date_default2.sameYear(date, this.option("min")) || date_default2.sameYear(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var DecadeView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "decade";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default2.sameYear(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const min = this.option("min");
    const max = this.option("max");
    return !date_default2.dateInRange(cellDate.getFullYear(), null === min || void 0 === min ? void 0 : min.getFullYear(), null === max || void 0 === max ? void 0 : max.getFullYear());
  }
  _isOtherView(cellDate) {
    const date = new Date(cellDate);
    date.setMonth(1);
    return !date_default2.sameDecade(date, this.option("date"));
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    return date_default.format(cellDate, "yyyy");
  }
  _getFirstCellData() {
    const year = date_default2.getFirstYearInDecade(this.option("date")) - 1;
    return date_default2.createDateWithFullYear(year, 0, 1);
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setFullYear(date.getFullYear() + 1);
    return date;
  }
  getNavigatorCaption() {
    const {
      date: currentDate
    } = this.option();
    const firstYearInDecade = date_default2.getFirstYearInDecade(currentDate);
    const startDate = new Date(currentDate);
    const endDate = new Date(currentDate);
    startDate.setFullYear(firstYearInDecade);
    endDate.setFullYear(firstYearInDecade + 9);
    return `${date_default.format(startDate, "yyyy")}-${date_default.format(endDate, "yyyy")}`;
  }
  _isValueOnCurrentView(currentDate, value2) {
    return date_default2.sameDecade(currentDate, value2);
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    foundDate.setMonth(0);
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default2.getShortDateFormat())}']`);
  }
  isBoundary(date) {
    return date_default2.sameDecade(date, this.option("min")) || date_default2.sameDecade(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var CenturyView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "century";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default2.sameDecade(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const decade = date_default2.getFirstYearInDecade(cellDate);
    const minDecade = date_default2.getFirstYearInDecade(this.option("min"));
    const maxDecade = date_default2.getFirstYearInDecade(this.option("max"));
    return !date_default2.dateInRange(decade, minDecade, maxDecade);
  }
  _isOtherView(cellDate) {
    const date = new Date(cellDate);
    date.setMonth(1);
    return !date_default2.sameCentury(date, this.option("date"));
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    const startDate = date_default.format(cellDate, "yyyy");
    const endDate = new Date(cellDate);
    endDate.setFullYear(endDate.getFullYear() + 9);
    return `${startDate} - ${date_default.format(endDate, "yyyy")}`;
  }
  _getFirstCellData() {
    const decade = date_default2.getFirstDecadeInCentury(this.option("date")) - 10;
    return date_default2.createDateWithFullYear(decade, 0, 1);
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setFullYear(date.getFullYear() + 10);
    return date;
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    foundDate.setMonth(0);
    foundDate.setFullYear(date_default2.getFirstYearInDecade(foundDate));
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default2.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date: currentDate
    } = this.option();
    const firstDecadeInCentury = date_default2.getFirstDecadeInCentury(currentDate);
    const startDate = new Date(currentDate);
    const endDate = new Date(currentDate);
    startDate.setFullYear(firstDecadeInCentury);
    endDate.setFullYear(firstDecadeInCentury + 99);
    return `${date_default.format(startDate, "yyyy")}-${date_default.format(endDate, "yyyy")}`;
  }
  isBoundary(date) {
    return date_default2.sameCentury(date, this.option("min")) || date_default2.sameCentury(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var m_calendar_views_default = {
  month: MonthView,
  year: YearView,
  decade: DecadeView,
  century: CenturyView
};

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.js
var CALENDAR_DXHOVEREND_EVENT_NAME = addNamespace(HOVEREND, "dxCalendar");
var LEVEL_COMPARE_MAP = {
  month: 3,
  year: 2,
  decade: 1,
  century: 0
};
var ZOOM_LEVEL = {
  MONTH: "month",
  YEAR: "year",
  DECADE: "decade",
  CENTURY: "century"
};
var SELECTION_STRATEGIES = {
  SingleSelection: m_calendar_single_selection_strategy_default,
  MultipleSelection: m_calendar_multiple_selection_strategy_default,
  RangeSelection: m_calendar_range_selection_strategy_default
};
var Calendar = class extends editor_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      currentDate: /* @__PURE__ */ new Date(),
      value: null,
      min: new Date(1e3, 0),
      max: new Date(3e3, 0),
      viewsCount: 1,
      zoomLevel: ZOOM_LEVEL.MONTH,
      maxZoomLevel: ZOOM_LEVEL.MONTH,
      minZoomLevel: ZOOM_LEVEL.CENTURY,
      selectionMode: "single",
      selectWeekOnClick: true,
      showTodayButton: false,
      todayButtonText: message_default.format("dxCalendar-todayButtonText"),
      showWeekNumbers: false,
      weekNumberRule: "auto",
      cellTemplate: "cell",
      disabledDates: null,
      onCellClick: null,
      onContouredChanged: null,
      skipFocusCheck: false,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      rightArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(1);
        } else {
          this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
        }
      },
      leftArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(-1);
        } else {
          this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
        }
      },
      upArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateUp();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
        }
      },
      downArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateDown();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
        }
      },
      home(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const min = this._dateOption("min");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default2.sameView(zoomLevel, currentDate, min) ? min : date_default2.getViewFirstCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      end(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const max = this._dateOption("max");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default2.sameView(zoomLevel, currentDate, max) ? max : date_default2.getViewLastCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      pageUp(e) {
        e.preventDefault();
        this._waitRenderView(-1 * this._getRtlCorrection());
      },
      pageDown(e) {
        e.preventDefault();
        this._waitRenderView(1 * this._getRtlCorrection());
      },
      tab() {
      },
      enter: this._enterKeyHandler
    });
  }
  _enterKeyHandler(e) {
    if (!this._isMaxZoomLevel()) {
      this._navigateDown();
    } else if (!this._view.isDateDisabled(this.option("currentDate"))) {
      const value2 = this._updateTimeComponent(this.option("currentDate"));
      this._selectionStrategy.selectValue(value2, e);
    }
  }
  _getSerializationFormat(optionName) {
    const value2 = this.option(optionName || "value");
    if (this.option("dateSerializationFormat")) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2) || "" === value2) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _convertToDate(value2) {
    return date_serialization_default.deserializeDate(value2);
  }
  _dateValue(value2, event) {
    if (event) {
      if ("keydown" === event.type) {
        const cellElement = this._view._getContouredCell().get(0);
        event.target = cellElement;
      }
      this._saveValueChangeEvent(event);
    }
    this._dateOption("value", value2);
  }
  _dateOption(optionName, optionValue) {
    const isArray2 = "value" === optionName && !this._isSingleMode();
    const value2 = this.option("value");
    if (1 === arguments.length) {
      return isArray2 ? (value2 ?? []).map(((value3) => this._convertToDate(value3))) : this._convertToDate(this.option(optionName));
    }
    const serializationFormat = this._getSerializationFormat(optionName);
    const serializedValue = isArray2 ? (null === optionValue || void 0 === optionValue ? void 0 : optionValue.map(((value3) => date_serialization_default.serializeDate(value3, serializationFormat)))) || [] : date_serialization_default.serializeDate(optionValue, serializationFormat);
    this.option(optionName, serializedValue);
  }
  _isSingleMode() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _shiftDate(zoomLevel, date, offset, reverse) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        date.setDate(date.getDate() + offset * reverse);
        break;
      case ZOOM_LEVEL.YEAR:
        date.setMonth(date.getMonth() + offset * reverse);
        break;
      case ZOOM_LEVEL.DECADE:
        date.setFullYear(date.getFullYear() + offset * reverse);
        break;
      case ZOOM_LEVEL.CENTURY:
        date.setFullYear(date.getFullYear() + 10 * offset * reverse);
    }
  }
  _moveCurrentDateByOffset(offset) {
    const baseDate = this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    this._shiftDate(zoomLevel, currentDate, offset, 1);
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    let isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
    let isDateForwardInRange = inRange(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
    const dateForward = new Date(currentDate);
    while (isDateForwardInRange) {
      if (!this._view.isDateDisabled(dateForward)) {
        currentDate = dateForward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, offset, 1);
      isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
      isDateForwardInRange = inRange(dateForward, minDate, maxDate) && isDateForwardInNeighborView;
    }
    if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
      const direction = offset > 0 ? 1 : -1;
      const isViewDisabled = 1 === direction ? this._isNextViewDisabled() : this._isPrevViewDisabled();
      if (!isViewDisabled) {
        this._waitRenderView(direction);
      } else {
        this._moveToClosestAvailableDate(currentDate);
      }
    } else {
      this._skipNavigate = true;
      this.option("currentDate", currentDate);
    }
  }
  _isNextViewDisabled() {
    return this._navigator._nextButton.option("disabled");
  }
  _isPrevViewDisabled() {
    return this._navigator._prevButton.option("disabled");
  }
  _areDatesInSameView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return date1.getMonth() === date2.getMonth();
      case ZOOM_LEVEL.YEAR:
        return date1.getYear() === date2.getYear();
      case ZOOM_LEVEL.DECADE:
        return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
      case ZOOM_LEVEL.CENTURY:
        return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100);
    }
  }
  _areDatesInNeighborView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return ((a, b) => {
          const abs2 = Math.abs(a - b);
          return Math.min(abs2, 12 - abs2);
        })(date1.getMonth(), date2.getMonth()) <= 1;
      case ZOOM_LEVEL.YEAR:
        return Math.abs(date1.getYear() - date2.getYear()) <= 1;
      case ZOOM_LEVEL.DECADE:
        return Math.abs(date1.getYear() - date2.getYear()) <= 10;
      case ZOOM_LEVEL.CENTURY:
        return Math.abs(date1.getYear() - date2.getYear()) <= 100;
    }
  }
  _moveToClosestAvailableDate() {
    let baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    const isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
    let isDateForwardAvailable = isCurrentDateAvailable;
    let isDateBackwardAvailable = isCurrentDateAvailable;
    let isDateForwardInStartView;
    let isDateBackwardInStartView;
    const dateForward = new Date(currentDate);
    const dateBackward = new Date(currentDate);
    do {
      if (isDateForwardAvailable) {
        currentDate = dateForward;
        break;
      }
      if (isDateBackwardAvailable) {
        currentDate = dateBackward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, 1, 1);
      this._shiftDate(zoomLevel, dateBackward, 1, -1);
      isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
      isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
      isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
      isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward);
    } while (isDateForwardInStartView || isDateBackwardInStartView);
    this.option("currentDate", currentDate);
  }
  _isDateNotAvailable(date) {
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    return !inRange(date, minDate, maxDate) || this._view.isDateDisabled(date);
  }
  _init() {
    super._init();
    this._activeStateUnit = ".dx-calendar-cell";
    this._initSelectionStrategy();
    this._correctZoomLevel();
    this._initCurrentDate();
    this._initActions();
  }
  _initSelectionStrategy() {
    const strategyName = this._getSelectionStrategyName();
    const strategy = SELECTION_STRATEGIES[strategyName];
    if (!this._selectionStrategy || this._selectionStrategy.NAME !== strategyName) {
      this._selectionStrategy = new strategy(this);
    }
  }
  _refreshSelectionStrategy() {
    this._initSelectionStrategy();
    this._selectionStrategy.restoreValue();
    this._refresh();
  }
  _getSelectionStrategyName() {
    const {
      selectionMode
    } = this.option();
    switch (selectionMode) {
      case "multiple":
        return "MultipleSelection";
      case "range":
        return "RangeSelection";
      default:
        return "SingleSelection";
    }
  }
  _correctZoomLevel() {
    const {
      minZoomLevel,
      maxZoomLevel,
      zoomLevel
    } = this.option();
    if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      return;
    }
    if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
      this.option("zoomLevel", maxZoomLevel);
    } else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      this.option("zoomLevel", minZoomLevel);
    }
  }
  _initCurrentDate() {
    const currentDate = this._getNormalizedDate(this._selectionStrategy.getDefaultCurrentDate()) ?? this._getNormalizedDate(this.option("currentDate"));
    this.option("currentDate", currentDate);
  }
  _getNormalizedDate(date) {
    date = date_default2.normalizeDate(date, this._getMinDate(), this._getMaxDate());
    return isDefined(date) ? this._getDate(date) : date;
  }
  _initActions() {
    this._cellClickAction = this._createActionByOption("onCellClick");
    this._onContouredChanged = this._createActionByOption("onContouredChanged");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      cell: new FunctionTemplate(((options2) => {
        const data17 = options2.model;
        renderer_default(options2.container).append(renderer_default("<span>").text(data17 && data17.text || String(data17)));
      }))
    });
    super._initTemplates();
  }
  _updateCurrentDate(date) {
    if (fx_default.isAnimating(this._$viewsWrapper)) {
      fx_default.stop(this._$viewsWrapper, true);
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    if (min > max) {
      this.option("currentDate", /* @__PURE__ */ new Date());
      return;
    }
    const normalizedDate = this._getNormalizedDate(date);
    if (date.getTime() !== normalizedDate.getTime()) {
      this.option("currentDate", new Date(normalizedDate));
      return;
    }
    let offset = this._getViewsOffset(this._view.option("date"), normalizedDate);
    if (0 !== offset && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
      offset = 0;
    }
    if (this._view && 0 !== offset && !this._suppressNavigation) {
      if (this._additionalView) {
        if (offset > 2 || offset < -1) {
          this._refreshViews();
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
          this._renderNavigator();
        } else if (1 === offset && this._skipNavigate) {
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
        } else {
          this._navigate(offset, normalizedDate);
        }
      } else {
        this._navigate(offset, normalizedDate);
      }
    } else {
      this._renderNavigator();
      this._setViewContoured(normalizedDate);
      this._updateAriaId(normalizedDate);
    }
    this._skipNavigate = false;
  }
  _isAdditionalViewDate(date) {
    if (!this._additionalView) {
      return false;
    }
    return date >= this._additionalView._getFirstAvailableDate();
  }
  _getActiveView(date) {
    return this._isAdditionalViewDate(date) ? this._additionalView : this._view;
  }
  _setViewContoured(date) {
    if (this.option("skipFocusCheck") || renderer_default(this._$viewsWrapper).is(":focus")) {
      var _this$_additionalView;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView = this._additionalView) || void 0 === _this$_additionalView || _this$_additionalView.option("contouredDate", null);
      const view = this._isAdditionalViewDate(date) ? this._additionalView : this._view;
      view.option("contouredDate", date);
    }
  }
  _getMinDate() {
    const _rangeMin = this.option("_rangeMin");
    if (_rangeMin) {
      return _rangeMin;
    }
    if (this.min) {
      return this.min;
    }
    this.min = this._dateOption("min") || new Date(1e3, 0);
    return this.min;
  }
  _getMaxDate() {
    const _rangeMax = this.option("_rangeMax");
    if (_rangeMax) {
      return _rangeMax;
    }
    if (this.max) {
      return this.max;
    }
    this.max = this._dateOption("max") || new Date(3e3, 0);
    return this.max;
  }
  _getViewsOffset(startDate, endDate) {
    const {
      zoomLevel
    } = this.option();
    if (zoomLevel === ZOOM_LEVEL.MONTH) {
      return this._getMonthsOffset(startDate, endDate);
    }
    let zoomCorrection;
    switch (zoomLevel) {
      case ZOOM_LEVEL.CENTURY:
        zoomCorrection = 100;
        break;
      case ZOOM_LEVEL.DECADE:
        zoomCorrection = 10;
        break;
      default:
        zoomCorrection = 1;
    }
    return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection);
  }
  _getMonthsOffset(startDate, endDate) {
    const yearOffset = endDate.getFullYear() - startDate.getFullYear();
    const monthOffset = endDate.getMonth() - startDate.getMonth();
    return 12 * yearOffset + monthOffset;
  }
  _waitRenderView(offset) {
    if (this._alreadyViewRender) {
      return;
    }
    this._alreadyViewRender = true;
    const date = this._getDateByOffset(offset * this._getRtlCorrection());
    this._moveToClosestAvailableDate(date);
    this._waitRenderViewTimeout = setTimeout((() => {
      this._alreadyViewRender = false;
    }));
  }
  _getRtlCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _getDateByOffset(offset, date) {
    date = this._getDate(date ?? this.option("currentDate"));
    const currentDay = date.getDate();
    const difference = date_default2.getDifferenceInMonth(this.option("zoomLevel")) * offset;
    date.setDate(1);
    date.setMonth(date.getMonth() + difference);
    const lastDay = date_default2.getLastMonthDate(date).getDate();
    date.setDate(currentDay > lastDay ? lastDay : currentDay);
    return date;
  }
  _focusTarget() {
    return this._$viewsWrapper;
  }
  _focusEventTarget() {
    return this.$element();
  }
  _initMarkup() {
    this._renderSubmitElement();
    const $element = this.$element();
    $element.addClass("dx-calendar");
    const {
      selectionMode
    } = this.option();
    $element.toggleClass("dx-calendar-range", "range" === selectionMode);
    this._renderBody();
    $element.append(this.$body);
    this._renderViews();
    this._renderNavigator();
    super._initMarkup();
    this._renderEvents();
    $element.prepend(this._navigator.$element());
    this._renderSwipeable();
    this._renderFooter();
    this._selectionStrategy.updateAriaSelected();
    this._updateAriaId();
    this._updateNavigatorLabels();
    this.setAria("role", "application");
    this._updateAriaLabelAndRole();
    this._moveToClosestAvailableDate();
  }
  _render() {
    super._render();
    this._setViewContoured(this.option("currentDate"));
  }
  _renderBody() {
    if (!this._$viewsWrapper) {
      this.$body = renderer_default("<div>").addClass("dx-calendar-body");
      this._$viewsWrapper = renderer_default("<div>").addClass("dx-calendar-views-wrapper");
      this.$body.append(this._$viewsWrapper);
    }
  }
  _updateAriaLabelAndRole() {
    const readOnly = this.option("readOnly");
    const $element = this.$element();
    const aria = {
      role: readOnly ? "group" : void 0,
      label: readOnly ? message_default.format("dxCalendar-readOnlyLabel") : void 0
    };
    this.setAria(aria, $element);
  }
  _setAriaReadonly() {
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._view]);
  }
  _renderViews() {
    const {
      zoomLevel
    } = this.option();
    this.$element().addClass(`dx-calendar-view-${zoomLevel}`);
    const {
      currentDate,
      viewsCount
    } = this.option();
    this.$element().toggleClass("dx-calendar-multiview", viewsCount > 1);
    this._view = this._renderSpecificView(currentDate);
    if (hasWindow()) {
      const beforeDate = this._getDateByOffset(-1, currentDate);
      this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
      const afterDate = this._getDateByOffset(viewsCount, currentDate);
      afterDate.setDate(1);
      this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
    }
    if (viewsCount > 1) {
      this._additionalView = this._renderSpecificView(this._getDateByOffset(1, currentDate));
    }
    this._translateViews();
  }
  _renderSpecificView(date) {
    const {
      zoomLevel
    } = this.option();
    const specificView = m_calendar_views_default[zoomLevel];
    const $view = renderer_default("<div>").appendTo(this._$viewsWrapper);
    const config2 = this._viewConfig(date);
    const view = this._createComponent($view, specificView, config2);
    return view;
  }
  _viewConfig(date) {
    let disabledDates = this.option("disabledDates");
    disabledDates = isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
    return _extends({}, this._selectionStrategy.getViewOptions(), {
      date,
      min: this._getMinDate(),
      max: this._getMaxDate(),
      firstDayOfWeek: this.option("firstDayOfWeek") ?? date_default.firstDayOfWeekIndex(),
      showWeekNumbers: this.option("showWeekNumbers"),
      selectWeekOnClick: this.option("selectWeekOnClick"),
      weekNumberRule: this.option("weekNumberRule"),
      zoomLevel: this.option("zoomLevel"),
      tabIndex: void 0,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      disabledDates,
      onCellClick: this._cellClickHandler.bind(this),
      cellTemplate: this._getTemplateByOption("cellTemplate"),
      allowValueSelection: this._isMaxZoomLevel(),
      _todayDate: this.option("_todayDate")
    });
  }
  _renderEvents() {
    m_events_engine_default.off(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME);
    const {
      selectionMode
    } = this.option();
    if ("range" === selectionMode) {
      m_events_engine_default.on(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME, null, (() => {
        this._updateViewsOption("hoveredRange", []);
      }));
    }
  }
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that
      });
      return func(params);
    };
  }
  _isViewAvailable(date) {
    const zoomLevel = this.option("zoomLevel");
    const min = date_default2.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
    const max = date_default2.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
    return date_default2.dateInRange(date, min, max);
  }
  _translateViews() {
    const {
      viewsCount
    } = this.option();
    move(this._view.$element(), {
      left: 0,
      top: 0
    });
    this._moveViewElement(this._beforeView, -1);
    this._moveViewElement(this._afterView, viewsCount);
    this._moveViewElement(this._additionalView, 1);
  }
  _moveViewElement(view, coefficient) {
    view && move(view.$element(), {
      left: this._getViewPosition(coefficient),
      top: 0
    });
  }
  _getViewPosition(coefficient) {
    const rtlCorrection = this.option("rtlEnabled") ? -1 : 1;
    return 100 * coefficient * rtlCorrection + "%";
  }
  _cellClickHandler(e) {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default2.getViewDown(zoomLevel);
    const isMaxZoomLevel = this._isMaxZoomLevel();
    if (nextView && !isMaxZoomLevel) {
      this._navigateDown(e.event.currentTarget);
    } else {
      var _this$_cellClickActio;
      const newValue = this._updateTimeComponent(e.value);
      this._selectionStrategy.selectValue(newValue, e.event);
      null === (_this$_cellClickActio = this._cellClickAction) || void 0 === _this$_cellClickActio || _this$_cellClickActio.call(this, e);
    }
  }
  _updateTimeComponent(date) {
    const result2 = new Date(date);
    const currentValue = this._dateOption("value");
    if (currentValue && this._isSingleMode()) {
      result2.setHours(currentValue.getHours());
      result2.setMinutes(currentValue.getMinutes());
      result2.setSeconds(currentValue.getSeconds());
      result2.setMilliseconds(currentValue.getMilliseconds());
    }
    return result2;
  }
  _isMaxZoomLevel() {
    return this.option("zoomLevel") === this.option("maxZoomLevel");
  }
  _navigateDown(cell) {
    const zoomLevel = this.option("zoomLevel");
    if (this._isMaxZoomLevel()) {
      return;
    }
    const nextView = date_default2.getViewDown(zoomLevel);
    if (!nextView) {
      return;
    }
    let newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
    if (cell) {
      newCurrentDate = renderer_default(cell).data("dxDateValueKey");
    }
    this._isOtherViewCellClicked = true;
    this.option("currentDate", newCurrentDate);
    this.option("zoomLevel", nextView);
    this._isOtherViewCellClicked = false;
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  }
  _renderNavigator() {
    if (!this._navigator) {
      this._navigator = new m_calendar_navigator_default(renderer_default("<div>"), this._navigatorConfig());
    }
    this._navigator.option("text", this._getViewsCaption(this._view, this._additionalView));
    this._updateButtonsVisibility();
  }
  _navigatorConfig() {
    const {
      focusStateEnabled,
      rtlEnabled
    } = this.option();
    return {
      text: this._getViewsCaption(this._view, this._additionalView),
      onClick: this._navigatorClickHandler.bind(this),
      onCaptionClick: this._navigateUp.bind(this),
      focusStateEnabled,
      rtlEnabled,
      tabIndex: void 0
    };
  }
  _navigatorClickHandler(e) {
    const {
      currentDate,
      viewsCount
    } = this.option();
    let offset = e.direction;
    if (viewsCount > 1) {
      const additionalViewActive = this._isAdditionalViewDate(currentDate);
      const shouldDoubleOffset = additionalViewActive && offset < 0 || !additionalViewActive && offset > 0;
      if (shouldDoubleOffset) {
        offset *= 2;
      }
    }
    const newCurrentDate = this._getDateByOffset(offset, currentDate);
    this._moveToClosestAvailableDate(newCurrentDate);
  }
  _navigateUp() {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default2.getViewUp(zoomLevel);
    if (!nextView || this._isMinZoomLevel(zoomLevel)) {
      return;
    }
    this.option("zoomLevel", nextView);
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  }
  _isMinZoomLevel(zoomLevel) {
    const min = this._getMinDate();
    const max = this._getMaxDate();
    return date_default2.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel;
  }
  _updateButtonsVisibility() {
    this._navigator.toggleButton("next", !isDefined(this._afterView));
    this._navigator.toggleButton("prev", !isDefined(this._beforeView));
  }
  _renderSwipeable() {
    if (!this._swipeable) {
      this._swipeable = this._createComponent(this.$element(), m_swipeable_default, {
        onStart: this._swipeStartHandler.bind(this),
        onUpdated: this._swipeUpdateHandler.bind(this),
        onEnd: this._swipeEndHandler.bind(this),
        itemSizeFunc: this._viewWidth.bind(this)
      });
    }
  }
  _swipeStartHandler(e) {
    fx_default.stop(this._$viewsWrapper, true);
    const {
      viewsCount
    } = this.option();
    this._toggleGestureCoverCursor("grabbing");
    e.event.maxLeftOffset = this._getRequiredView("next") ? 1 / viewsCount : 0;
    e.event.maxRightOffset = this._getRequiredView("prev") ? 1 / viewsCount : 0;
  }
  _toggleGestureCoverCursor(cursor) {
    renderer_default(".dx-gesture-cover").css("cursor", cursor);
  }
  _getRequiredView(name2) {
    let view;
    const isRtl = this.option("rtlEnabled");
    if ("next" === name2) {
      view = isRtl ? this._beforeView : this._afterView;
    } else if ("prev" === name2) {
      view = isRtl ? this._afterView : this._beforeView;
    }
    return view;
  }
  _swipeUpdateHandler(e) {
    const {
      offset
    } = e.event;
    move(this._$viewsWrapper, {
      left: offset * this._viewWidth(),
      top: 0
    });
    this._updateNavigatorCaption(offset);
  }
  _swipeEndHandler(e) {
    this._toggleGestureCoverCursor("auto");
    const {
      currentDate,
      rtlEnabled
    } = this.option();
    const {
      targetOffset
    } = e.event;
    const moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
    const isAdditionalViewActive = this._isAdditionalViewDate(currentDate);
    const shouldDoubleOffset = isAdditionalViewActive && (rtlEnabled ? -1 === moveOffset : 1 === moveOffset);
    if (0 === moveOffset) {
      this._animateWrapper(0, 250);
      return;
    }
    const offset = -moveOffset * this._getRtlCorrection() * (shouldDoubleOffset ? 2 : 1);
    let date = this._getDateByOffset(offset);
    if (this._isDateInInvalidRange(date)) {
      if (moveOffset >= 0) {
        date = new Date(this._getMinDate());
      } else {
        date = new Date(this._getMaxDate());
      }
    }
    this.option("currentDate", date);
  }
  _viewWidth() {
    if (!this._viewWidthValue) {
      const {
        viewsCount
      } = this.option();
      this._viewWidthValue = getWidth(this.$element()) / viewsCount;
    }
    return this._viewWidthValue;
  }
  _updateNavigatorCaption(offset) {
    offset *= this._getRtlCorrection();
    const {
      viewsCount
    } = this.option();
    const isMultiView = viewsCount > 1;
    let view;
    let additionalView;
    if (offset > 0.5 && this._beforeView) {
      view = this._beforeView;
      additionalView = isMultiView && this._view;
    } else if (offset < -0.5 && this._afterView) {
      view = isMultiView ? this._additionalView : this._afterView;
      additionalView = isMultiView ? this._afterView : null;
    } else {
      view = this._view;
      additionalView = isMultiView ? this._additionalView : null;
    }
    this._navigator.option("text", this._getViewsCaption(view, additionalView));
  }
  _getViewsCaption(view, additionalView) {
    let caption = view.getNavigatorCaption();
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1 && additionalView) {
      const additionalViewCaption = additionalView.getNavigatorCaption();
      caption = `${caption} - ${additionalViewCaption}`;
    }
    return caption;
  }
  _isDateInInvalidRange(date) {
    if (this._view.isBoundary(date)) {
      return;
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    const normalizedDate = date_default2.normalizeDate(date, min, max);
    return normalizedDate === min || normalizedDate === max;
  }
  _renderFooter() {
    const {
      showTodayButton,
      todayButtonText: text
    } = this.option();
    if (showTodayButton) {
      const $todayButton = this._createComponent(renderer_default("<div>"), button_default2, {
        focusStateEnabled: this.option("focusStateEnabled"),
        text,
        onClick: (args) => {
          this._toTodayView(args);
        },
        type: isFluent() ? "normal" : "default",
        stylingMode: isFluent() ? "outlined" : "text",
        integrationOptions: {}
      }).$element().addClass("dx-calendar-today-button");
      this._$footer = renderer_default("<div>").addClass("dx-calendar-footer").append($todayButton);
      this.$element().append(this._$footer);
    }
    this.$element().toggleClass("dx-calendar-with-footer", showTodayButton);
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(value2) {
    const dateValue = this._convertToDate(value2);
    this._getSubmitElement().val(date_serialization_default.serializeDate(dateValue, "yyyy-MM-dd"));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _animateShowView() {
    fx_default.stop(this._view.$element(), true);
    this._popAnimationView(this._view, 0.6, 1, 250);
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1) {
      fx_default.stop(this._additionalView.$element(), true);
      this._popAnimationView(this._additionalView, 0.6, 1, 250);
    }
  }
  _popAnimationView(view, from, to, duration) {
    return fx_default.animate(view.$element(), {
      type: "pop",
      from: {
        scale: from,
        opacity: from
      },
      to: {
        scale: to,
        opacity: to
      },
      duration
    });
  }
  _navigate(offset, value2) {
    if (0 !== offset && 1 !== Math.abs(offset) && this._isViewAvailable(value2)) {
      const newView = this._renderSpecificView(value2);
      if (offset > 0) {
        this._afterView && this._afterView.$element().remove();
        this._afterView = newView;
      } else {
        this._beforeView && this._beforeView.$element().remove();
        this._beforeView = newView;
      }
      this._translateViews();
    }
    const rtlCorrection = this._getRtlCorrection();
    const offsetSign = offset > 0 ? 1 : offset < 0 ? -1 : 0;
    const endPosition = -rtlCorrection * offsetSign * this._viewWidth();
    const viewsWrapperPosition = this._$viewsWrapper.position().left;
    if (viewsWrapperPosition !== endPosition) {
      if (this._preventViewChangeAnimation) {
        this._wrapperAnimationEndHandler(offset, value2);
      } else {
        this._animateWrapper(endPosition, 250).done(this._wrapperAnimationEndHandler.bind(this, offset, value2));
      }
    }
  }
  _animateWrapper(to, duration) {
    return fx_default.animate(this._$viewsWrapper, {
      type: "slide",
      from: {
        left: this._$viewsWrapper.position().left
      },
      to: {
        left: to
      },
      duration
    });
  }
  _getDate(value2) {
    return new Date(value2);
  }
  _toTodayView(args) {
    const today = /* @__PURE__ */ new Date();
    if (this._isMaxZoomLevel()) {
      this._selectionStrategy.selectValue(today, args.event);
      return;
    }
    this._preventViewChangeAnimation = true;
    this.option("zoomLevel", this.option("maxZoomLevel"));
    this._selectionStrategy.selectValue(today, args.event);
    this._animateShowView();
    this._preventViewChangeAnimation = false;
  }
  _wrapperAnimationEndHandler(offset, newDate) {
    this._rearrangeViews(offset);
    this._translateViews();
    this._resetLocation();
    this._renderNavigator();
    this._setViewContoured(newDate);
    this._updateAriaId(newDate);
    this._selectionStrategy.updateAriaSelected();
  }
  _rearrangeViews(offset) {
    var _this$viewToRemoveKey;
    if (0 === offset) {
      return;
    }
    const {
      viewsCount
    } = this.option();
    let viewOffset;
    let viewToCreateKey;
    let viewToRemoveKey;
    let viewBeforeCreateKey;
    let viewAfterRemoveKey;
    if (offset < 0) {
      viewOffset = 1;
      viewToCreateKey = "_beforeView";
      viewToRemoveKey = "_afterView";
      viewBeforeCreateKey = "_view";
      viewAfterRemoveKey = 1 === viewsCount ? "_view" : "_additionalView";
    } else {
      viewOffset = -1;
      viewToCreateKey = "_afterView";
      viewToRemoveKey = "_beforeView";
      viewBeforeCreateKey = 1 === viewsCount ? "_view" : "_additionalView";
      viewAfterRemoveKey = "_view";
    }
    if (!this[viewToCreateKey]) {
      return;
    }
    const destinationDate = this[viewToCreateKey].option("date");
    null === (_this$viewToRemoveKey = this[viewToRemoveKey]) || void 0 === _this$viewToRemoveKey || _this$viewToRemoveKey.$element().remove();
    this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset * viewsCount, destinationDate));
    this[viewAfterRemoveKey].$element().remove();
    if (1 === viewsCount) {
      this[viewAfterRemoveKey] = this[viewToCreateKey];
    } else {
      this[viewAfterRemoveKey] = this[viewBeforeCreateKey];
      this[viewBeforeCreateKey] = this[viewToCreateKey];
    }
    const dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
    this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null;
  }
  _resetLocation() {
    move(this._$viewsWrapper, {
      left: 0,
      top: 0
    });
  }
  _clean() {
    super._clean();
    this._clearViewWidthCache();
    delete this._$viewsWrapper;
    delete this._navigator;
    delete this._$footer;
  }
  _clearViewWidthCache() {
    delete this._viewWidthValue;
  }
  _disposeViews() {
    var _this$_beforeView, _this$_additionalView2, _this$_afterView;
    this._view.$element().remove();
    null === (_this$_beforeView = this._beforeView) || void 0 === _this$_beforeView || _this$_beforeView.$element().remove();
    null === (_this$_additionalView2 = this._additionalView) || void 0 === _this$_additionalView2 || _this$_additionalView2.$element().remove();
    null === (_this$_afterView = this._afterView) || void 0 === _this$_afterView || _this$_afterView.$element().remove();
    delete this._view;
    delete this._additionalView;
    delete this._beforeView;
    delete this._afterView;
    delete this._skipNavigate;
  }
  _dispose() {
    clearTimeout(this._waitRenderViewTimeout);
    super._dispose();
  }
  _refreshViews() {
    this._resetActiveState();
    this._disposeViews();
    this._renderViews();
  }
  _visibilityChanged() {
    this._translateViews();
  }
  _shouldSkipFocusEvent(event) {
    const {
      target,
      relatedTarget
    } = event;
    return renderer_default(target).parents(".dx-calendar").length && renderer_default(relatedTarget).parents(".dx-calendar").length;
  }
  _focusInHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      this._setViewContoured(this.option("currentDate"));
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    super._focusInHandler.apply(this, arguments);
    this._toggleFocusClass(true, this.$element());
  }
  _focusOutHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      var _this$_additionalView3;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView3 = this._additionalView) || void 0 === _this$_additionalView3 || _this$_additionalView3.option("contouredDate", null);
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    super._focusOutHandler.apply(this, arguments);
    this._toggleFocusClass(false, this.$element());
  }
  _updateViewsOption(optionName, newValue) {
    var _this$_additionalView4, _this$_beforeView2, _this$_afterView2;
    this._view.option(optionName, newValue);
    null === (_this$_additionalView4 = this._additionalView) || void 0 === _this$_additionalView4 || _this$_additionalView4.option(optionName, newValue);
    null === (_this$_beforeView2 = this._beforeView) || void 0 === _this$_beforeView2 || _this$_beforeView2.option(optionName, newValue);
    null === (_this$_afterView2 = this._afterView) || void 0 === _this$_afterView2 || _this$_afterView2.option(optionName, newValue);
  }
  _setViewsMinOption(min) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMin", this._convertToDate(min));
    this._updateViewsOption("min", this._getMinDate());
  }
  _setViewsMaxOption(max) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMax", this._convertToDate(max));
    this._updateViewsOption("max", this._getMaxDate());
  }
  _restoreViewsMinMaxOptions() {
    this._resetActiveState();
    this.option({
      _rangeMin: null,
      _rangeMax: null
    });
    this._updateViewsOption("min", this._getMinDate());
    this._updateViewsOption("max", this._getMaxDate());
  }
  _updateNavigatorLabels() {
    let {
      zoomLevel
    } = this.option();
    zoomLevel = zoomLevel.charAt(0).toUpperCase() + zoomLevel.slice(1);
    const captionButtonText = this._navigator._caption.option("text");
    const localizedPrevButtonLabel = message_default.format(`dxCalendar-previous${zoomLevel}ButtonLabel`);
    const localizedCaptionLabel = message_default.format(`dxCalendar-caption${zoomLevel}Label`);
    const localizedNextButtonLabel = message_default.format(`dxCalendar-next${zoomLevel}ButtonLabel`);
    this.setAria("label", localizedPrevButtonLabel, this._navigator._prevButton.$element());
    this.setAria("label", `${captionButtonText}. ${localizedCaptionLabel}`, this._navigator._caption.$element());
    this.setAria("label", localizedNextButtonLabel, this._navigator._nextButton.$element());
  }
  _updateAriaSelected(value2, previousValue) {
    previousValue.forEach(((item) => {
      this.setAria("selected", false, this._view._getCellByDate(item));
    }));
    value2.forEach(((item) => {
      this.setAria("selected", true, this._view._getCellByDate(item));
    }));
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1) {
      previousValue.forEach(((item) => {
        this.setAria("selected", false, this._additionalView._getCellByDate(item));
      }));
      value2.forEach(((item) => {
        this.setAria("selected", true, this._additionalView._getCellByDate(item));
      }));
    }
  }
  _updateAriaId(value2) {
    var _this$_onContouredCha;
    value2 = value2 ?? this.option("currentDate");
    const ariaId = `dx-${new guid_default()}`;
    const view = this._getActiveView(value2);
    const $newCell = view._getCellByDate(value2);
    this.setAria("id", ariaId, $newCell);
    this.setAria("activedescendant", ariaId);
    null === (_this$_onContouredCha = this._onContouredChanged) || void 0 === _this$_onContouredCha || _this$_onContouredCha.call(this, ariaId);
  }
  _suppressingNavigation(callback, args) {
    this._suppressNavigation = true;
    callback.apply(this, args);
    delete this._suppressNavigation;
  }
  _optionChanged(args) {
    const {
      value: value2,
      previousValue
    } = args;
    switch (args.name) {
      case "width":
        super._optionChanged(args);
        this._clearViewWidthCache();
        break;
      case "min":
      case "max":
        this.min = void 0;
        this.max = void 0;
        this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
        this._refreshViews();
        this._renderNavigator();
        break;
      case "selectionMode":
        this._refreshSelectionStrategy();
        this._initCurrentDate();
        break;
      case "selectWeekOnClick":
      case "_todayDate":
      case "showWeekNumbers":
      case "weekNumberRule":
        this._refreshViews();
        break;
      case "firstDayOfWeek":
        this._refreshViews();
        this._updateButtonsVisibility();
        break;
      case "focusStateEnabled":
      case "disabledDates":
      case "dateSerializationFormat":
      case "cellTemplate":
      case "showTodayButton":
      case "todayButtonText":
        this._invalidate();
        break;
      case "currentDate":
        this.setAria("id", void 0, this._view._getCellByDate(previousValue));
        this._updateCurrentDate(value2);
        break;
      case "zoomLevel":
        this.$element().removeClass(`dx-calendar-view-${previousValue}`);
        this._correctZoomLevel();
        this._refreshViews();
        this._renderNavigator();
        this._updateAriaId();
        this._updateNavigatorLabels();
        break;
      case "minZoomLevel":
      case "maxZoomLevel":
        this._correctZoomLevel();
        this._updateButtonsVisibility();
        break;
      case "value": {
        const isSameValue = date_default2.sameDatesArrays(value2, previousValue);
        if (!isSameValue) {
          this._selectionStrategy.processValueChanged(value2, previousValue);
        }
        this._setSubmitValue(value2);
        super._optionChanged(args);
        break;
      }
      case "viewsCount":
        this._refreshViews();
        this._renderNavigator();
        break;
      case "onCellClick":
        this._view.option("onCellClick", value2);
        break;
      case "onContouredChanged":
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
        break;
      case "readOnly":
        super._optionChanged(args);
        this._updateAriaLabelAndRole();
        break;
      case "skipFocusCheck":
        break;
      default:
        super._optionChanged(args);
    }
  }
  getContouredDate() {
    const {
      contouredDate
    } = this._view.option();
    return contouredDate;
  }
};
component_registrator_default("dxCalendar", Calendar);
var m_calendar_default = Calendar;

// node_modules/devextreme/esm/ui/calendar.js
var calendar_default = m_calendar_default;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.js
var DateBoxStrategy = class extends class_default.inherit({}) {
  ctor(dateBox) {
    this.dateBox = dateBox;
  }
  widgetOption(option) {
    var _this$_widget;
    return null === (_this$_widget = this._widget) || void 0 === _this$_widget ? void 0 : _this$_widget.option.apply(this._widget, arguments);
  }
  _renderWidget(element) {
    element = element || renderer_default("<div>");
    this._widget = this._createWidget(element);
    this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _createWidget(element) {
    const widgetName = this._getWidgetName();
    const widgetOptions = this._getWidgetOptions();
    return this.dateBox._createComponent(element, widgetName, widgetOptions);
  }
  _getWidgetOptions() {
    class_default.abstract();
  }
  _getWidgetName() {
    class_default.abstract();
  }
  getDefaultOptions() {
    return {
      mode: "text"
    };
  }
  getDisplayFormat(displayFormat) {
    class_default.abstract();
  }
  supportedKeys() {
  }
  getKeyboardListener() {
  }
  customizeButtons() {
  }
  getParsedText(text, format2) {
    const value2 = date_default.parse(text, format2);
    return value2 || date_default.parse(text);
  }
  renderInputMinMax() {
  }
  renderOpenedState() {
    this._updateValue();
  }
  popupConfig(popupConfig) {
    class_default.abstract();
  }
  _dimensionChanged() {
    var _this$_getPopup;
    null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
  }
  renderPopupContent() {
    const popup = this._getPopup();
    this._renderWidget();
    const $popupContent = popup.$content().parent();
    m_events_engine_default.off($popupContent, "mousedown");
    m_events_engine_default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this));
  }
  _preventFocusOnPopup(e) {
    e.preventDefault();
  }
  _getWidgetContainer() {
    return this._getPopup().$content();
  }
  _getPopup() {
    return this.dateBox._popup;
  }
  popupShowingHandler() {
  }
  popupHiddenHandler() {
  }
  _updateValue(preventDefaultValue) {
    var _this$_widget2;
    null === (_this$_widget2 = this._widget) || void 0 === _this$_widget2 || _this$_widget2.option("value", this.dateBoxValue());
  }
  useCurrentDateByDefault() {
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date();
  }
  textChangedHandler() {
  }
  renderValue() {
    if (this.dateBox.option("opened")) {
      this._updateValue();
    }
  }
  getValue() {
    return this._widget.option("value");
  }
  isAdaptivityChanged() {
    return false;
  }
  dispose() {
    const popup = this._getPopup();
    if (popup) {
      popup.$content().empty();
    }
  }
  dateBoxValue(value2, event) {
    if (arguments.length) {
      return this.dateBox.dateValue.apply(this.dateBox, arguments);
    }
    return this.dateBox.dateOption.apply(this.dateBox, ["value"]);
  }
};
var m_date_box_strategy_default = DateBoxStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar.js
var CalendarStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "Calendar";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      todayButtonText: this.dateBox.option("todayButtonText") ?? message_default.format("dxCalendar-todayButtonText")
    });
  }
  supportedKeys() {
    const homeEndHandler = function(e) {
      if (this.option("opened")) {
        e.preventDefault();
        return true;
      }
      return false;
    };
    return {
      rightArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      leftArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      enter: (function(e) {
        if (this.dateBox.option("opened")) {
          e.preventDefault();
          if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
            const viewValue = this._getContouredValue();
            const lastActionElement = this._lastActionElement;
            const shouldCloseDropDown = this._closeDropDownByEnter();
            if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
              this.dateBoxValue(viewValue, e);
            }
            shouldCloseDropDown && this.dateBox.close();
            this.dateBox._valueChangeEventHandler(e);
            return !shouldCloseDropDown;
          }
          return true;
        }
        this.dateBox._valueChangeEventHandler(e);
      }).bind(this),
      home: homeEndHandler,
      end: homeEndHandler
    };
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shortdate";
  }
  _closeDropDownByEnter() {
    return true;
  }
  _getWidgetName() {
    return calendar_default;
  }
  _getContouredValue() {
    return this._widget._view.option("contouredDate");
  }
  getKeyboardListener() {
    return this._widget;
  }
  _getWidgetOptions() {
    const {
      disabledDates,
      min,
      max,
      todayButtonText
    } = this.dateBox.option();
    return extend(this.dateBox.option("calendarOptions"), {
      value: this.dateBoxValue() || null,
      selectionMode: "single",
      dateSerializationFormat: null,
      min,
      max,
      onValueChanged: this._valueChangedHandler.bind(this),
      onCellClick: this._cellClickHandler.bind(this),
      disabledDates: isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
      onContouredChanged: this._refreshActiveDescendant.bind(this),
      skipFocusCheck: true,
      todayButtonText
    });
  }
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that.dateBox
      });
      return func(params);
    };
  }
  _refreshActiveDescendant(e) {
    this._lastActionElement = "calendar";
    this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _getTodayButtonConfig() {
    const buttonsLocation = this.dateBox.option("buttonsLocation");
    const isButtonsLocationDefault = "default" === buttonsLocation;
    const position2 = isButtonsLocationDefault ? ["bottom", "center"] : splitPair(buttonsLocation);
    const stylingMode = isMaterial() ? "text" : "outlined";
    return {
      widget: "dxButton",
      toolbar: position2[0],
      location: "after" === position2[1] ? "before" : position2[1],
      options: {
        onClick: (args) => {
          this._widget._toTodayView(args);
        },
        text: this.dateBox.option("todayButtonText"),
        elementAttr: {
          class: "dx-button-today"
        },
        stylingMode
      }
    };
  }
  _isCalendarVisible() {
    const {
      calendarOptions
    } = this.dateBox.option();
    return isEmptyObject(calendarOptions) || false !== calendarOptions.visible;
  }
  _getPopupToolbarItems(toolbarItems) {
    const useButtons = "useButtons" === this.dateBox.option("applyValueMode");
    const shouldRenderTodayButton = useButtons && this._isCalendarVisible();
    if (shouldRenderTodayButton) {
      const todayButton = this._getTodayButtonConfig();
      return [todayButton, ...toolbarItems];
    }
    return toolbarItems;
  }
  popupConfig(popupConfig) {
    return extend(true, popupConfig, {
      position: {
        collision: "flipfit flip"
      },
      width: "auto"
    });
  }
  _valueChangedHandler(e) {
    const {
      value: value2
    } = e;
    const prevValue = e.previousValue;
    if (date_default2.sameDate(value2, prevValue) && date_default2.sameHoursAndMinutes(value2, prevValue)) {
      return;
    }
    if ("instantly" === this.dateBox.option("applyValueMode")) {
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
  _updateValue(preventDefaultValue) {
    if (!this._widget) {
      return;
    }
    this._widget.option("value", this.dateBoxValue());
  }
  textChangedHandler() {
    this._lastActionElement = "input";
    if (this.dateBox.option("opened") && this._widget) {
      this._updateValue(true);
    }
  }
  _cellClickHandler(e) {
    const {
      dateBox
    } = this;
    if ("instantly" === dateBox.option("applyValueMode")) {
      dateBox.option("opened", false);
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
};
var m_date_box_strategy_calendar_default = CalendarStrategy;

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js
var ui_collection_widget_edit_default = m_collection_widget_edit_default;

// node_modules/devextreme/esm/__internal/ui/m_box.js
var MINSIZE_MAP = {
  row: "minWidth",
  col: "minHeight"
};
var MAXSIZE_MAP = {
  row: "maxWidth",
  col: "maxHeight"
};
var FLEX_JUSTIFY_CONTENT_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  "space-between": "space-between",
  "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
  row: "row",
  col: "column"
};
var setFlexProp = (element, prop, value2) => {
  value2 = normalizeStyleProp(prop, value2);
  element.style[styleProp(prop)] = value2;
  if (!hasWindow()) {
    if ("" === value2 || !isDefined(value2)) {
      return;
    }
    const cssName = dasherize(prop);
    const styleExpr = `${cssName}: ${value2};`;
    setStyle(element, styleExpr, false);
  }
};
var BoxItem = class extends item_default {
  _renderVisible(value2, oldValue) {
    super._renderVisible(value2);
    if (isDefined(oldValue)) {
      this._options.fireItemStateChangedAction({
        name: "visible",
        state: value2,
        oldState: oldValue
      });
    }
  }
};
var LayoutStrategy = class {
  constructor($element, option) {
    this._$element = $element;
    this._option = option;
  }
  renderBox() {
    this._$element.css({
      display: `${stylePropPrefix("flexDirection")}flex`
    });
    setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")]);
  }
  renderAlign() {
    this._$element.css({
      justifyContent: this._normalizedAlign()
    });
  }
  _normalizedAlign() {
    const align = this._option("align");
    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;
  }
  renderCrossAlign() {
    this._$element.css({
      alignItems: this._normalizedCrossAlign()
    });
  }
  _normalizedCrossAlign() {
    const crossAlign = this._option("crossAlign");
    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;
  }
  renderItems($items) {
    const flexPropPrefix = stylePropPrefix("flexDirection");
    const direction = this._option("direction");
    each($items, (function() {
      const $item = renderer_default(this);
      const item = $item.data("dxBoxItemData");
      $item.css({
        display: `${flexPropPrefix}flex`
      }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
      setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
      setFlexProp($item.get(0), "flexGrow", item.ratio);
      setFlexProp($item.get(0), "flexShrink", isDefined(item.shrink) ? item.shrink : 1);
      $item.children().each(((_, itemContent) => {
        renderer_default(itemContent).css({
          width: "auto",
          height: "auto",
          display: `${stylePropPrefix("flexDirection")}flex`,
          flexBasis: 0
        });
        setFlexProp(itemContent, "flexGrow", 1);
        setFlexProp(itemContent, "flexDirection", renderer_default(itemContent)[0].style.flexDirection || "column");
      }));
    }));
  }
};
var Box = class _Box extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      direction: "row",
      align: "start",
      crossAlign: "stretch",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      _queue: void 0
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _init() {
    super._init();
    this.$element().addClass("dx-box-flex");
    this._initLayout();
    this._initBoxQueue();
  }
  _initLayout() {
    this._layout = new LayoutStrategy(this.$element(), this.option.bind(this));
  }
  _initBoxQueue() {
    this._queue = this.option("_queue") || [];
  }
  _queueIsNotEmpty() {
    return this.option("_queue") ? false : !!this._queue.length;
  }
  _pushItemToQueue($item, config2) {
    this._queue.push({
      $item,
      config: config2
    });
  }
  _shiftItemFromQueue() {
    return this._queue.shift();
  }
  _initMarkup() {
    this.$element().addClass("dx-box");
    this._layout.renderBox();
    super._initMarkup();
    this._renderAlign();
    this._renderActions();
  }
  _renderActions() {
    this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
  }
  _renderAlign() {
    this._layout.renderAlign();
    this._layout.renderCrossAlign();
  }
  _renderItems(items) {
    super._renderItems(items);
    while (this._queueIsNotEmpty()) {
      const item = this._shiftItemFromQueue();
      this._createComponent(item.$item, _Box, extend({
        itemTemplate: this.option("itemTemplate"),
        itemHoldTimeout: this.option("itemHoldTimeout"),
        onItemHold: this.option("onItemHold"),
        onItemClick: this.option("onItemClick"),
        onItemContextMenu: this.option("onItemContextMenu"),
        onItemRendered: this.option("onItemRendered"),
        _queue: this._queue
      }, item.config));
    }
    this._layout.renderItems(this._itemElements());
  }
  _renderItemContent(args) {
    const $itemNode = args.itemData && args.itemData.node;
    if ($itemNode) {
      return this._renderItemContentByNode(args, $itemNode);
    }
    return super._renderItemContent(args);
  }
  _postprocessRenderItem(args) {
    const boxConfig = args.itemData.box;
    if (!boxConfig) {
      return;
    }
    this._pushItemToQueue(args.itemContent, boxConfig);
  }
  _createItemByTemplate(itemTemplate, args) {
    if (args.itemData.box) {
      return itemTemplate.source ? itemTemplate.source() : renderer_default();
    }
    return super._createItemByTemplate(itemTemplate, args);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if ("visible" === property) {
      this._onItemStateChanged({
        name: property,
        state: value2,
        oldState: false !== prevValue
      });
    }
    super._itemOptionChanged(item, property, value2);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "_queue":
      case "direction":
        this._invalidate();
        break;
      case "align":
        this._layout.renderAlign();
        break;
      case "crossAlign":
        this._layout.renderCrossAlign();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemOptions() {
    const options2 = super._itemOptions();
    options2.fireItemStateChangedAction = (e) => {
      this._onItemStateChanged(e);
    };
    return options2;
  }
};
Box.ItemClass = BoxItem;
component_registrator_default("dxBox", Box);
var m_box_default = Box;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_utils.js
var DATE_COMPONENTS = ["year", "day", "month", "day"];
var TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
var ONE_DAY = 864e5;
var ONE_YEAR = 31536e6;
var getStringFormat = function(format2) {
  const formatType = typeof format2;
  if ("string" === formatType) {
    return "format";
  }
  if ("object" === formatType && void 0 !== format2.type) {
    return format2.type;
  }
  return null;
};
var dateUtils = {
  SUPPORTED_FORMATS: ["date", "time", "datetime"],
  ONE_MINUTE: 6e4,
  ONE_DAY,
  ONE_YEAR,
  MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
  MAX_DATEVIEW_DEFAULT_DATE: (function() {
    const newDate = /* @__PURE__ */ new Date();
    return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59);
  })(),
  FORMATS_INFO: {
    date: {
      getStandardPattern: () => "yyyy-MM-dd",
      components: DATE_COMPONENTS
    },
    time: {
      getStandardPattern: () => "HH:mm",
      components: TIME_COMPONENTS
    },
    datetime: {
      getStandardPattern() {
        let standardPattern;
        !(function() {
          const $input = renderer_default("<input>").attr("type", "datetime");
          $input.val("2000-01-01T01:01Z");
          if ($input.val()) {
            standardPattern = "yyyy-MM-ddTHH:mmZ";
          }
        })();
        if (!standardPattern) {
          standardPattern = "yyyy-MM-ddTHH:mm:ssZ";
        }
        dateUtils.FORMATS_INFO.datetime.getStandardPattern = function() {
          return standardPattern;
        };
        return standardPattern;
      },
      components: [...DATE_COMPONENTS, ...TIME_COMPONENTS]
    },
    "datetime-local": {
      getStandardPattern: () => "yyyy-MM-ddTHH:mm:ss",
      components: [...DATE_COMPONENTS, "hours", "minutes", "seconds"]
    }
  },
  FORMATS_MAP: {
    date: "shortdate",
    time: "shorttime",
    datetime: "shortdateshorttime"
  },
  SUBMIT_FORMATS_MAP: {
    date: "date",
    time: "time",
    datetime: "datetime-local"
  },
  toStandardDateFormat(date, type2) {
    const pattern = dateUtils.FORMATS_INFO[type2].getStandardPattern();
    return date_serialization_default.serializeDate(date, pattern);
  },
  fromStandardDateFormat(text) {
    const date = date_serialization_default.dateParser(text);
    return isDate(date) ? date : void 0;
  },
  getMaxMonthDay: (year, month) => new Date(year, month + 1, 0).getDate(),
  mergeDates(oldValue, newValue, format2) {
    if (!newValue) {
      return newValue || null;
    }
    if (!oldValue || isNaN(oldValue.getTime())) {
      const now = /* @__PURE__ */ new Date(null);
      oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }
    const result2 = new Date(oldValue.valueOf());
    const formatInfo = dateUtils.FORMATS_INFO[format2];
    each(formatInfo.components, (function() {
      const componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
      result2[componentInfo.setter](newValue[componentInfo.getter]());
    }));
    return result2;
  },
  getLongestCaptionIndex(captionArray) {
    let longestIndex = 0;
    let longestCaptionLength = 0;
    let i;
    for (i = 0; i < captionArray.length; ++i) {
      if (captionArray[i].length > longestCaptionLength) {
        longestIndex = i;
        longestCaptionLength = captionArray[i].length;
      }
    }
    return longestIndex;
  },
  formatUsesMonthName: (format2) => date_default.formatUsesMonthName(format2),
  formatUsesDayName: (format2) => date_default.formatUsesDayName(format2),
  getLongestDate(format2, monthNames, dayNames) {
    const stringFormat = getStringFormat(format2);
    let month = 9;
    if (!stringFormat || dateUtils.formatUsesMonthName(stringFormat)) {
      month = dateUtils.getLongestCaptionIndex(monthNames);
    }
    const longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
    if (!stringFormat || dateUtils.formatUsesDayName(stringFormat)) {
      const date = longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames);
      longestDate.setDate(date);
    }
    return longestDate;
  },
  normalizeTime(date) {
    date.setSeconds(0);
    date.setMilliseconds(0);
  }
};
dateUtils.DATE_COMPONENTS_INFO = {
  year: {
    getter: "getFullYear",
    setter: "setFullYear",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setFullYear(value2);
      return date_default.format(formatDate, "yyyy");
    },
    startValue: void 0,
    endValue: void 0
  },
  day: {
    getter: "getDate",
    setter: "setDate",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setDate(value2);
      return date_default.format(formatDate, "d");
    },
    startValue: 1,
    endValue: void 0
  },
  month: {
    getter: "getMonth",
    setter: "setMonth",
    formatter: (value2) => date_default.getMonthNames()[value2],
    startValue: 0,
    endValue: 11
  },
  hours: {
    getter: "getHours",
    setter: "setHours",
    formatter: (value2) => date_default.format(new Date(0, 0, 0, value2), "hour"),
    startValue: 0,
    endValue: 23
  },
  minutes: {
    getter: "getMinutes",
    setter: "setMinutes",
    formatter: (value2) => date_default.format(new Date(0, 0, 0, 0, value2), "minute"),
    startValue: 0,
    endValue: 59
  },
  seconds: {
    getter: "getSeconds",
    setter: "setSeconds",
    formatter: (value2) => date_default.format(new Date(0, 0, 0, 0, 0, value2), "second"),
    startValue: 0,
    endValue: 59
  },
  milliseconds: {
    getter: "getMilliseconds",
    setter: "setMilliseconds",
    formatter: (value2) => date_default.format(new Date(0, 0, 0, 0, 0, 0, value2), "millisecond"),
    startValue: 0,
    endValue: 999
  }
};
var m_date_utils_default = dateUtils;

// node_modules/devextreme/esm/__internal/ui/date_box/m_time_view.js
var rotateArrow = function($arrow, angle, offset) {
  cssRotate($arrow, angle, offset);
};
var cssRotate = function($arrow, angle, offset) {
  $arrow.css("transform", `rotate(${angle}deg) translate(0,${offset}px)`);
};
var TimeView = class extends editor_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: new Date(Date.now()),
      use24HourFormat: true,
      _showClock: true,
      _arrowOffset: 5
    });
  }
  _getValue() {
    const {
      value: value2
    } = this.option();
    return value2 || /* @__PURE__ */ new Date();
  }
  _init() {
    super._init();
    this.$element().addClass("dx-timeview");
  }
  _render() {
    super._render();
    this._renderBox();
    this._updateTime();
  }
  _renderBox() {
    const $box = renderer_default("<div>").appendTo(this.$element());
    const items = [];
    if (this.option("_showClock")) {
      items.push({
        ratio: 1,
        shrink: 0,
        baseSize: "auto",
        template: this._renderClock.bind(this)
      });
    }
    items.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: this._renderField.bind(this)
    });
    this._createComponent($box, m_box_default, {
      height: "100%",
      width: "100%",
      direction: "col",
      items
    });
  }
  _renderClock(_, __, container) {
    this._$hourArrow = renderer_default("<div>").addClass("dx-timeview-hourarrow");
    this._$minuteArrow = renderer_default("<div>").addClass("dx-timeview-minutearrow");
    const $container = renderer_default(container);
    $container.addClass("dx-timeview-clock").append(this._$hourArrow).append(this._$minuteArrow);
    this.setAria("role", "presentation", $container);
  }
  _updateClock() {
    const time = this._getValue();
    const hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
    const minuteArrowAngle = time.getMinutes() / 60 * 360;
    rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
    rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"));
  }
  _getBoxItems(is12HourFormat) {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._hourBox.$element()
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: renderer_default("<div>").addClass("dx-timeview-time-separator").text(date_default.getTimeSeparator())
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._minuteBox.$element()
    }];
    if (is12HourFormat) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        template: () => this._format12.$element()
      });
    }
    return items;
  }
  _renderField() {
    const is12HourFormat = !this.option("use24HourFormat");
    this._createHourBox(is12HourFormat);
    this._createMinuteBox();
    if (is12HourFormat) {
      this._createFormat12Box();
    }
    return this._createComponent(renderer_default("<div>").addClass("dx-timeview-field"), m_box_default, {
      direction: "row",
      align: "center",
      crossAlign: "center",
      items: this._getBoxItems(is12HourFormat)
    }).$element();
  }
  _createHourBox(is12HourFormat) {
    this._hourBox = this._createComponent(renderer_default("<div>"), m_number_box_default, _extends({
      min: -1,
      max: is12HourFormat ? 13 : 24,
      value: this._getValue().getHours(),
      onValueChanged: this._onHourBoxValueChanged.bind(this),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts)
    }, this._getNumberBoxConfig()));
    this._hourBox.setAria("label", "hours");
  }
  _isPM() {
    return !this.option("use24HourFormat") && 1 === this._format12.option("value");
  }
  _onHourBoxValueChanged(_ref) {
    let {
      value: value2,
      component
    } = _ref;
    const currentValue = this._getValue();
    const newValue = new Date(currentValue);
    let newHours = this._convertMaxHourToMin(value2);
    component.option("value", newHours);
    if (this._isPM()) {
      newHours += 12;
    }
    newValue.setHours(newHours);
    m_date_utils_default.normalizeTime(newValue);
    this.option("value", newValue);
  }
  _convertMaxHourToMin(hours) {
    const maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
    return (maxHoursValue + hours) % maxHoursValue;
  }
  _createMinuteBox() {
    this._minuteBox = this._createComponent(renderer_default("<div>"), m_number_box_default, _extends({
      min: -1,
      max: 60,
      value: this._getValue().getMinutes(),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref2) => {
        let {
          value: value2,
          component
        } = _ref2;
        const newMinutes = (60 + value2) % 60;
        component.option("value", newMinutes);
        const time = new Date(this._getValue());
        time.setMinutes(newMinutes);
        m_date_utils_default.normalizeTime(time);
        this.option("value", time);
      }
    }, this._getNumberBoxConfig()));
    this._minuteBox.setAria("label", "minutes");
  }
  _createFormat12Box() {
    const periodNames = date_default.getPeriodNames();
    this._format12 = this._createComponent(renderer_default("<div>").addClass("dx-timeview-format12"), m_select_box_default, {
      items: [{
        value: -1,
        text: periodNames[0]
      }, {
        value: 1,
        text: periodNames[1]
      }],
      valueExpr: "value",
      displayExpr: "text",
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref3) => {
        let {
          value: value2
        } = _ref3;
        const hours = this._getValue().getHours();
        const time = new Date(this._getValue());
        const newHours = (hours + 12 * value2) % 24;
        time.setHours(newHours);
        this.option("value", time);
      },
      dropDownOptions: {
        container: this.$element()
      },
      value: this._getValue().getHours() >= 12 ? 1 : -1,
      stylingMode: this.option("stylingMode")
    });
    this._format12.setAria("label", "type");
  }
  _refreshFormat12() {
    if (this.option("use24HourFormat")) {
      return;
    }
    const value2 = this._getValue();
    const hours = value2.getHours();
    const isPM = hours >= 12;
    const newValue = isPM ? 1 : -1;
    this._silentEditorValueUpdate(this._format12, newValue);
  }
  _silentEditorValueUpdate(editor, value2) {
    if (editor) {
      editor._suppressValueChangeAction();
      editor.option("value", value2);
      editor._resumeValueChangeAction();
    }
  }
  _getNumberBoxConfig() {
    const {
      stylingMode
    } = this.option();
    return {
      showSpinButtons: true,
      displayValueFormatter: (value2) => (value2 < 10 ? "0" : "") + value2,
      stylingMode
    };
  }
  _normalizeHours(hours) {
    return this.option("use24HourFormat") ? hours : hours % 12 || 12;
  }
  _updateField() {
    const hours = this._normalizeHours(this._getValue().getHours());
    this._silentEditorValueUpdate(this._hourBox, hours);
    this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
    this._refreshFormat12();
  }
  _updateTime() {
    if (this.option("_showClock")) {
      this._updateClock();
    }
    this._updateField();
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._updateTime();
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._updateTime();
        super._optionChanged(args);
        break;
      case "_arrowOffset":
        break;
      case "use24HourFormat":
      case "_showClock":
      case "stylingMode":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxTimeView", TimeView);
var m_time_view_default = TimeView;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar_with_time.js
var window8 = getWindow();
var DATEBOX_TIMEVIEW_SIDE_CLASS = "dx-datebox-datetime-time-side";
var CalendarWithTimeStrategy = class extends m_date_box_strategy_calendar_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "CalendarWithTime";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      applyValueMode: "useButtons",
      buttonsLocation: "bottom after",
      "dropDownOptions.showTitle": false
    });
  }
  _closeDropDownByEnter() {
    return date_default2.sameDate(this._getContouredValue(), this.widgetOption("value"));
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shortdateshorttime";
  }
  _is24HourFormat() {
    return date_default.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
  }
  _getContouredValue() {
    const viewDate = super._getContouredValue();
    return this._updateDateTime(viewDate);
  }
  _renderWidget() {
    super._renderWidget();
    this._timeView = this.dateBox._createComponent(renderer_default("<div>"), m_time_view_default, {
      value: this.dateBoxValue(),
      _showClock: !this._isShrinkView(),
      use24HourFormat: this._is24HourFormat(),
      onValueChanged: this._valueChangedHandler.bind(this),
      stylingMode: this.dateBox.option("stylingMode")
    });
  }
  renderOpenedState() {
    super.renderOpenedState();
    const popup = this._getPopup();
    if (popup) {
      popup.$wrapper().toggleClass("dx-datebox-adaptivity-mode", this._isSmallScreen());
    }
    clearTimeout(this._repaintTimer);
    this._repaintTimer = setTimeout((() => {
      var _this$_getPopup;
      null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
    }), 0);
  }
  isAdaptivityChanged() {
    const isAdaptiveMode = this._isShrinkView();
    const currentAdaptiveMode = this._currentAdaptiveMode;
    if (isAdaptiveMode !== currentAdaptiveMode) {
      this._currentAdaptiveMode = isAdaptiveMode;
      return void 0 !== currentAdaptiveMode;
    }
    return super.isAdaptivityChanged();
  }
  _updateValue(preventDefaultValue) {
    let date = this.dateBoxValue();
    if (!date && !preventDefaultValue) {
      date = /* @__PURE__ */ new Date();
      m_date_utils_default.normalizeTime(date);
    }
    super._updateValue();
    if (this._timeView) {
      date && this._timeView.option("value", date);
      this._timeView.option("use24HourFormat", this._is24HourFormat());
    }
  }
  _isSmallScreen() {
    return getWidth(window8) <= 573;
  }
  _isShrinkView() {
    return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
  }
  _getBoxItems() {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "calendar"
    }];
    if (!this._isShrinkView()) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        name: "time"
      });
    }
    return items;
  }
  renderPopupContent() {
    super.renderPopupContent();
    this._currentAdaptiveMode = this._isShrinkView();
    const $popupContent = this._getPopup().$content();
    this._box = this.dateBox._createComponent(renderer_default("<div>").appendTo($popupContent), m_box_default, {
      direction: "row",
      crossAlign: "stretch",
      items: this._getBoxItems(),
      itemTemplate: (function(data17, i, element) {
        const $container = renderer_default("<div>");
        switch (data17.name) {
          case "calendar":
            $container.append(this._widget.$element());
            if (this._isShrinkView()) {
              this._timeView.$element().addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
              $container.append(this._timeView.$element());
            }
            break;
          case "time":
            $container.append(this._timeView.$element());
            renderer_default(element).addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
        }
        return $container;
      }).bind(this)
    });
  }
  popupConfig(popupConfig) {
    const calendarPopupConfig = super.popupConfig(popupConfig);
    return extend(calendarPopupConfig, {
      width: "auto"
    });
  }
  _preventFocusOnPopup(e) {
    if (!renderer_default(e.target).hasClass("dx-texteditor-input")) {
      super._preventFocusOnPopup.apply(this, arguments);
      if (!this.dateBox._hasFocusClass()) {
        this.dateBox.focus();
      }
    }
  }
  _updateDateTime(date) {
    const {
      value: time
    } = this._timeView.option();
    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    return date;
  }
  getValue() {
    let date = this._widget.option("value") ?? this._widget.getContouredDate();
    date = date ? new Date(date) : /* @__PURE__ */ new Date();
    return this._updateDateTime(date);
  }
  dispose() {
    clearTimeout(this._removeMinWidthTimer);
    clearTimeout(this._repaintTimer);
    super.dispose();
  }
};
var m_date_box_strategy_calendar_with_time_default = CalendarWithTimeStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/scroll_direction.js
var ScrollDirection = class {
  constructor(direction) {
    this.DIRECTION_HORIZONTAL = "horizontal";
    this.DIRECTION_VERTICAL = "vertical";
    this.DIRECTION_BOTH = "both";
    this.direction = direction ?? DIRECTION_VERTICAL;
  }
  get isHorizontal() {
    return this.direction === DIRECTION_HORIZONTAL || this.direction === DIRECTION_BOTH;
  }
  get isVertical() {
    return this.direction === DIRECTION_VERTICAL || this.direction === DIRECTION_BOTH;
  }
  get isBoth() {
    return this.direction === DIRECTION_BOTH;
  }
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/convert_location.js
function convertToLocation(location, direction) {
  if (isPlainObject(location)) {
    const left = ensureDefined(location.left, location.x);
    const top = ensureDefined(location.top, location.y);
    return {
      left: isDefined(left) ? left : void 0,
      top: isDefined(top) ? top : void 0
    };
  }
  const {
    isVertical,
    isHorizontal
  } = new ScrollDirection(direction);
  return {
    left: isHorizontal && isDefined(location) ? location : void 0,
    top: isVertical && isDefined(location) ? location : void 0
  };
}

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_view_roller.js
var DateViewRoller = class extends m_scrollable_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      showScrollbar: "never",
      useNative: false,
      selectedIndex: 0,
      bounceEnabled: false,
      items: [],
      showOnClick: false,
      onClick: null,
      onSelectedIndexChanged: null,
      scrollByContent: true
    });
  }
  _init() {
    super._init();
    this.option("onVisibilityChange", this._visibilityChangedHandler.bind(this));
    this.option("onEnd", this._endActionHandler.bind(this));
  }
  _render() {
    super._render();
    this._renderSelectedItemFrame();
    this.$element().addClass("dx-dateviewroller");
    this._renderContainerClick();
    this._renderItems();
    this._renderSelectedValue();
    this._renderItemsClick();
    this._renderWheelEvent();
    this._renderSelectedIndexChanged();
  }
  _renderSelectedIndexChanged() {
    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
  }
  _renderWheelEvent() {
    m_events_engine_default.on(renderer_default(this.container()), "dxmousewheel", ((e) => {
      this._isWheelScrolled = true;
    }));
  }
  _renderContainerClick() {
    if (!this.option("showOnClick")) {
      return;
    }
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    const clickAction = this._createActionByOption("onClick");
    m_events_engine_default.off(renderer_default(this.container()), eventName);
    m_events_engine_default.on(renderer_default(this.container()), eventName, ((e) => {
      clickAction({
        event: e
      });
    }));
  }
  _renderItems() {
    const items = this.option("items") || [];
    let $items = renderer_default();
    renderer_default(this.content()).empty();
    items.forEach(((item) => {
      $items = $items.add(renderer_default("<div>").addClass("dx-dateview-item").append(item));
    }));
    renderer_default(this.content()).append($items);
    this._$items = $items;
    this.update();
  }
  _renderSelectedItemFrame() {
    renderer_default("<div>").addClass("dx-dateview-item-selected-frame").append(renderer_default("<div>").addClass("dx-dateview-item-selected-border")).appendTo(renderer_default(this.container()));
  }
  _renderSelectedValue(selectedIndex) {
    const index = this._fitIndex(selectedIndex ?? this.option("selectedIndex"));
    this._moveTo({
      top: this._getItemPosition(index)
    });
    this._renderActiveStateItem();
  }
  _fitIndex(index) {
    const items = this.option("items") || [];
    const itemCount = items.length;
    if (index >= itemCount) {
      return itemCount - 1;
    }
    if (index < 0) {
      return 0;
    }
    return index;
  }
  _getItemPosition(index) {
    return Math.round(this._itemHeight() * index);
  }
  _renderItemsClick() {
    const itemSelector = this._getItemSelector();
    const eventName = addNamespace(CLICK_EVENT_NAME, this.NAME);
    m_events_engine_default.off(this.$element(), eventName, itemSelector);
    m_events_engine_default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this));
  }
  _getItemSelector() {
    return ".dx-dateview-item";
  }
  _itemClickHandler(e) {
    this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
  }
  _itemElementIndex(itemElement) {
    return this._itemElements().index(itemElement);
  }
  _itemElements() {
    return this.$element().find(this._getItemSelector());
  }
  _renderActiveStateItem() {
    const selectedIndex = this.option("selectedIndex");
    each(this._$items, (function(index) {
      renderer_default(this).toggleClass("dx-dateview-item-selected", selectedIndex === index);
    }));
  }
  _shouldScrollToNeighborItem() {
    return "desktop" === devices_default.real().deviceType && this._isWheelScrolled;
  }
  _moveTo(targetLocation) {
    const {
      top,
      left
    } = convertToLocation(targetLocation);
    const location = this.scrollOffset();
    const delta = {
      x: location.left - left,
      y: location.top - top
    };
    if (this._isVisible() && (delta.x || delta.y)) {
      this._prepareDirections(true);
      if (this._animation && !this._shouldScrollToNeighborItem()) {
        const that = this;
        fx_default.stop(renderer_default(this.content()));
        fx_default.animate(renderer_default(this.content()), {
          duration: 200,
          type: "slide",
          to: {
            top: Math.floor(delta.y)
          },
          complete() {
            resetPosition(renderer_default(that.content()));
            that.handleMove({
              delta
            });
          }
        });
        delete this._animation;
      } else {
        this.handleMove({
          delta
        });
      }
    }
  }
  _validate(e) {
    return this._moveIsAllowed(e);
  }
  _fitSelectedIndexInRange(index) {
    const itemsCount = this.option("items").length;
    return Math.max(Math.min(index, itemsCount - 1), 0);
  }
  _isInNullNeighborhood(x) {
    return -0.1 <= x && x <= 0.1;
  }
  _getSelectedIndexAfterScroll(currentSelectedIndex) {
    const locationTop = this.scrollOffset().top;
    const currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
    const dy = locationTop - currentSelectedIndexPosition;
    if (this._isInNullNeighborhood(dy)) {
      return currentSelectedIndex;
    }
    const direction = dy > 0 ? 1 : -1;
    const newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
    return newSelectedIndex;
  }
  _getNewSelectedIndex(currentSelectedIndex) {
    if (this._shouldScrollToNeighborItem()) {
      return this._getSelectedIndexAfterScroll(currentSelectedIndex);
    }
    this._animation = true;
    const ratio = this.scrollOffset().top / this._itemHeight();
    return Math.round(ratio);
  }
  _endActionHandler() {
    const currentSelectedIndex = this.option("selectedIndex");
    const newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
    if (newSelectedIndex === currentSelectedIndex) {
      this._renderSelectedValue(newSelectedIndex);
    } else {
      this.option("selectedIndex", newSelectedIndex);
    }
    this._isWheelScrolled = false;
  }
  _itemHeight() {
    const $item = this._$items.first();
    return getHeight($item);
  }
  _toggleActive(state) {
    this.$element().toggleClass("dx-state-active", state);
  }
  _isVisible() {
    return renderer_default(this.container()).is(":visible");
  }
  _fireSelectedIndexChanged(value2, previousValue) {
    var _this$_selectedIndexC;
    null === (_this$_selectedIndexC = this._selectedIndexChanged) || void 0 === _this$_selectedIndexC || _this$_selectedIndexC.call(this, {
      value: value2,
      previousValue,
      event: void 0
    });
  }
  _visibilityChanged(visible) {
    super._visibilityChanged(visible);
    this._visibilityChangedHandler(visible);
  }
  _visibilityChangedHandler(visible) {
    if (visible) {
      this._visibilityTimer = setTimeout((() => {
        this._renderSelectedValue(this.option("selectedIndex"));
      }));
    }
    this.toggleActiveState(false);
  }
  toggleActiveState(state) {
    this.$element().toggleClass("dx-dateviewroller-current", state);
  }
  _refreshSelectedIndex() {
    const selectedIndex = this.option("selectedIndex");
    const fitIndex = this._fitIndex(selectedIndex);
    if (fitIndex === selectedIndex) {
      this._renderActiveStateItem();
    } else {
      this.option("selectedIndex", fitIndex);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectedIndex":
        this._fireSelectedIndexChanged(args.value, args.previousValue);
        this._renderSelectedValue(args.value);
        break;
      case "items":
        this._renderItems();
        this._refreshSelectedIndex();
        break;
      case "onClick":
      case "showOnClick":
        this._renderContainerClick();
        break;
      case "onSelectedIndexChanged":
        this._renderSelectedIndexChanged();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    clearTimeout(this._visibilityTimer);
    super._dispose();
  }
};
component_registrator_default("dxDateViewRoller", DateViewRoller);
var m_date_view_roller_default = DateViewRoller;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_view.js
var TYPE = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var ROLLER_TYPE = {
  year: "year",
  month: "month",
  day: "day",
  hours: "hours"
};
var DateView = class extends editor_default {
  _valueOption() {
    const {
      value: value2
    } = this.option();
    const date = new Date(value2);
    return !value2 || isNaN(date) ? this._getDefaultDate() : date;
  }
  _getDefaultDate() {
    const date = /* @__PURE__ */ new Date();
    const {
      type: type2
    } = this.option();
    if (type2 === TYPE.date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    return date;
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      minDate: m_date_utils_default.MIN_DATEVIEW_DEFAULT_DATE,
      maxDate: m_date_utils_default.MAX_DATEVIEW_DEFAULT_DATE,
      type: TYPE.date,
      value: /* @__PURE__ */ new Date(),
      applyCompactClass: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (device) => "desktop" !== device.deviceType,
      options: {
        applyCompactClass: true
      }
    }]);
  }
  _render() {
    super._render();
    this.$element().addClass("dx-dateview");
    const {
      type: type2
    } = this.option();
    this._toggleFormatClasses(type2);
    this._toggleCompactClass();
  }
  _toggleFormatClasses(currentFormat, previousFormat) {
    this.$element().addClass(`dx-dateview-${currentFormat}`);
    previousFormat && this.$element().removeClass(`dx-dateview-${previousFormat}`);
  }
  _toggleCompactClass() {
    const {
      applyCompactClass
    } = this.option();
    this.$element().toggleClass("dx-dateview-compact", applyCompactClass);
  }
  _wrapper() {
    return this._$wrapper;
  }
  _renderContentImpl() {
    this._$wrapper = renderer_default("<div>").addClass("dx-dateview-wrapper");
    this._renderRollers();
    this._$wrapper.appendTo(this.$element());
  }
  _renderRollers() {
    if (!this._$rollersContainer) {
      this._$rollersContainer = renderer_default("<div>").addClass("dx-dateview-rollers");
    }
    this._$rollersContainer.empty();
    this._createRollerConfigs();
    this._rollers = {};
    const that = this;
    each(that._rollerConfigs, ((name2) => {
      const $roller = renderer_default("<div>").appendTo(that._$rollersContainer).addClass(`dx-dateviewroller-${that._rollerConfigs[name2].type}`);
      that._rollers[that._rollerConfigs[name2].type] = that._createComponent($roller, m_date_view_roller_default, {
        items: that._rollerConfigs[name2].displayItems,
        selectedIndex: that._rollerConfigs[name2].selectedIndex,
        showScrollbar: "never",
        scrollByContent: true,
        onStart(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2]);
        },
        onEnd(e) {
          const roller = e.component;
          roller._toggleActive(false);
        },
        onClick(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2]);
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
          roller._toggleActive(false);
        },
        onSelectedIndexChanged(e) {
          const roller = e.component;
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
        }
      });
    }));
    that._$rollersContainer.appendTo(that._wrapper());
  }
  _createRollerConfigs(type2) {
    const that = this;
    type2 = type2 || that.option("type");
    that._rollerConfigs = {};
    date_default.getFormatParts(m_date_utils_default.FORMATS_MAP[type2]).forEach(((partName) => {
      that._createRollerConfig(partName);
    }));
  }
  _createRollerConfig(componentName) {
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    const valueRange = this._calculateRollerConfigValueRange(componentName);
    const {
      startValue
    } = valueRange;
    const {
      endValue
    } = valueRange;
    const {
      formatter
    } = componentInfo;
    const curDate = this._getCurrentDate();
    const config2 = {
      type: componentName,
      setValue: componentInfo.setter,
      valueItems: [],
      displayItems: [],
      getIndex: (value2) => value2[componentInfo.getter]() - startValue
    };
    for (let i = startValue; i <= endValue; i++) {
      config2.valueItems.push(i);
      config2.displayItems.push(formatter(i, curDate));
    }
    config2.selectedIndex = config2.getIndex(curDate);
    this._rollerConfigs[componentName] = config2;
  }
  _setActiveRoller(currentRoller) {
    const activeRoller = currentRoller && this._rollers[currentRoller.type];
    each(this._rollers, (function() {
      this.toggleActiveState(this === activeRoller);
    }));
  }
  _updateRollersPosition() {
    const that = this;
    each(this._rollers, (function(type2) {
      const correctIndex = that._rollerConfigs[type2].getIndex(that._getCurrentDate());
      this.option("selectedIndex", correctIndex);
    }));
  }
  _setRollerState(roller, selectedIndex) {
    if (selectedIndex !== roller.selectedIndex) {
      const rollerValue = roller.valueItems[selectedIndex];
      const {
        setValue
      } = roller;
      let currentValue = new Date(this._getCurrentDate());
      let currentDate = currentValue.getDate();
      const minDate = this.option("minDate");
      const maxDate = this.option("maxDate");
      if (roller.type === ROLLER_TYPE.month) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
      } else if (roller.type === ROLLER_TYPE.year) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(rollerValue, currentValue.getMonth()));
      }
      currentValue.setDate(currentDate);
      currentValue[setValue](rollerValue);
      const normalizedDate = date_default2.normalizeDate(currentValue, minDate, maxDate);
      currentValue = m_date_utils_default.mergeDates(normalizedDate, currentValue, "time");
      currentValue = date_default2.normalizeDate(currentValue, minDate, maxDate);
      this.option("value", currentValue);
      roller.selectedIndex = selectedIndex;
    }
    if (roller.type === ROLLER_TYPE.year) {
      this._refreshRollers();
    }
    if (roller.type === ROLLER_TYPE.month) {
      this._refreshRoller(ROLLER_TYPE.day);
      this._refreshRoller(ROLLER_TYPE.hours);
    }
  }
  _refreshRoller(rollerType) {
    const roller = this._rollers[rollerType];
    if (roller) {
      this._createRollerConfig(rollerType);
      const rollerConfig = this._rollerConfigs[rollerType];
      if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
        roller.option({
          items: rollerConfig.displayItems,
          selectedIndex: rollerConfig.selectedIndex
        });
      }
    }
  }
  _getCurrentDate() {
    const curDate = this._valueOption();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    return date_default2.normalizeDate(curDate, minDate, maxDate);
  }
  _calculateRollerConfigValueRange(componentName) {
    const curDate = this._getCurrentDate();
    const {
      minDate,
      maxDate
    } = this.option();
    const minYear = date_default2.sameYear(curDate, minDate);
    const minMonth = minYear && curDate.getMonth() === minDate.getMonth();
    const maxYear = date_default2.sameYear(curDate, maxDate);
    const maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
    const minHour = minMonth && curDate.getDate() === minDate.getDate();
    const maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    let {
      startValue
    } = componentInfo;
    let {
      endValue
    } = componentInfo;
    if (componentName === ROLLER_TYPE.year) {
      startValue = minDate.getFullYear();
      endValue = maxDate.getFullYear();
    }
    if (componentName === ROLLER_TYPE.month) {
      if (minYear) {
        startValue = minDate.getMonth();
      }
      if (maxYear) {
        endValue = maxDate.getMonth();
      }
    }
    if (componentName === ROLLER_TYPE.day) {
      endValue = m_date_utils_default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
      if (minYear && minMonth) {
        startValue = minDate.getDate();
      }
      if (maxYear && maxMonth) {
        endValue = maxDate.getDate();
      }
    }
    if (componentName === ROLLER_TYPE.hours) {
      startValue = minHour ? minDate.getHours() : startValue;
      endValue = maxHour ? maxDate.getHours() : endValue;
    }
    return {
      startValue,
      endValue
    };
  }
  _refreshRollers() {
    this._refreshRoller(ROLLER_TYPE.month);
    this._refreshRoller(ROLLER_TYPE.day);
    this._refreshRoller(ROLLER_TYPE.hours);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "minDate":
      case "maxDate":
      case "type":
        this._renderRollers();
        this._toggleFormatClasses(args.value, args.previousValue);
        break;
      case "visible":
        super._optionChanged(args);
        if (args.value) {
          this._renderRollers();
        }
        break;
      case "value":
        this.option("value", this._valueOption());
        this._refreshRollers();
        this._updateRollersPosition();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clean() {
    super._clean();
    delete this._$rollersContainer;
  }
};
component_registrator_default("dxDateView", DateView);
var m_date_view_default = DateView;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.date_view.js
var window9 = getWindow();
var DateViewStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "DateView";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      openOnFieldClick: true,
      applyButtonText: message_default.format("OK"),
      "dropDownOptions.showTitle": true
    });
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || m_date_utils_default.FORMATS_MAP[this.dateBox.option("type")];
  }
  popupConfig(config2) {
    return {
      toolbarItems: this.dateBox._popupToolbarItemsConfig(),
      onInitialized: config2.onInitialized,
      defaultOptionsRules: [{
        device: {
          platform: "android"
        },
        options: {
          width: 333,
          height: 331
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          return "generic" === platform || "ios" === platform;
        },
        options: {
          width: "auto",
          height: "auto"
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          const {
            phone
          } = device;
          return "generic" === platform && phone;
        },
        options: {
          width: 333,
          maxWidth: "100%",
          maxHeight: "100%",
          height: "auto",
          position: {
            collision: "flipfit flip"
          }
        }
      }, {
        device: {
          platform: "ios",
          phone: true
        },
        options: {
          width: "100%",
          position: {
            my: "bottom",
            at: "bottom",
            of: window9
          }
        }
      }]
    };
  }
  _renderWidget() {
    if (inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
      if (this._widget) {
        this._widget.$element().remove();
        this._widget = null;
      }
      return;
    }
    const popup = this._getPopup();
    if (this._widget) {
      this._widget.option(this._getWidgetOptions());
    } else {
      const element = renderer_default("<div>").appendTo(popup.$content());
      this._widget = this._createWidget(element);
    }
    this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _getWidgetName() {
    return m_date_view_default;
  }
  renderOpenedState() {
    super.renderOpenedState();
    if (this._widget) {
      this._widget.option("value", this._widget._getCurrentDate());
    }
  }
  _getWidgetOptions() {
    return {
      value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
      type: this.dateBox.option("type"),
      minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
      maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * m_date_utils_default.ONE_YEAR),
      onDisposing: (function() {
        this._widget = null;
      }).bind(this)
    };
  }
};
var m_date_box_strategy_date_view_default = DateViewStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.list.js
var window10 = getWindow();
var BOUNDARY_VALUES = {
  min: new Date(0, 0, 0, 0, 0),
  max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "List";
  }
  supportedKeys() {
    return {
      space: noop,
      home: noop,
      end: noop
    };
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      applyValueMode: "instantly"
    });
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shorttime";
  }
  popupConfig(popupConfig) {
    return popupConfig;
  }
  getValue() {
    const selectedIndex = this._widget.option("selectedIndex");
    if (-1 === selectedIndex) {
      return this.dateBox.option("value");
    }
    const itemData = this._widgetItems[selectedIndex];
    return this._getDateByItemData(itemData);
  }
  useCurrentDateByDefault() {
    return true;
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date(null);
  }
  popupShowingHandler() {
    this.dateBox._dimensionChanged();
  }
  _renderWidget() {
    super._renderWidget();
    this._refreshItems();
  }
  _getWidgetName() {
    return list_light_default;
  }
  _getWidgetOptions() {
    return {
      itemTemplate: this._timeListItemTemplate.bind(this),
      onItemClick: this._listItemClickHandler.bind(this),
      tabIndex: -1,
      onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
      selectionMode: "single"
    };
  }
  _refreshActiveDescendant(e) {
    this.dateBox.setAria("activedescendant", "");
    this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _refreshItems() {
    this._widgetItems = this._getTimeListItems();
    this._widget.option("items", this._widgetItems);
  }
  renderOpenedState() {
    if (!this._widget) {
      return;
    }
    this._widget.option("focusedElement", null);
    this._setSelectedItemsByValue();
    if (this._widget.option("templatesRenderAsynchronously")) {
      this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this));
    } else {
      this._scrollToSelectedItem();
    }
  }
  dispose() {
    super.dispose();
    clearTimeout(this._asyncScrollTimeout);
  }
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._refreshItems();
    this._setSelectedItemsByValue();
    this._scrollToSelectedItem();
  }
  _setSelectedItemsByValue() {
    const value2 = this.dateBoxValue();
    const dateIndex = this._getDateIndex(value2);
    if (-1 === dateIndex) {
      this._widget.option("selectedItems", []);
    } else {
      this._widget.option("selectedIndex", dateIndex);
    }
  }
  _scrollToSelectedItem() {
    this._widget.scrollToItem(this._widget.option("selectedIndex"));
  }
  _getDateIndex(date) {
    let result2 = -1;
    for (let i = 0, n = this._widgetItems.length; i < n; i++) {
      if (this._areDatesEqual(date, this._widgetItems[i])) {
        result2 = i;
        break;
      }
    }
    return result2;
  }
  _areDatesEqual(first, second) {
    return isDate(first) && isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes();
  }
  _getTimeListItems() {
    let min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
    const max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
    const value2 = this.dateBox.dateOption("value") || null;
    let delta = max - min;
    const minutes = min.getMinutes() % this.dateBox.option("interval");
    if (delta < 0) {
      return [];
    }
    if (delta > m_date_utils_default.ONE_DAY) {
      delta = m_date_utils_default.ONE_DAY;
    }
    if (value2 - min < m_date_utils_default.ONE_DAY) {
      return this._getRangeItems(min, new Date(min), delta);
    }
    min = this._getBoundaryDate("min");
    min.setMinutes(minutes);
    if (value2 && Math.abs(value2 - max) < m_date_utils_default.ONE_DAY) {
      delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * m_date_utils_default.ONE_MINUTE;
    }
    return this._getRangeItems(min, new Date(min), delta);
  }
  _getRangeItems(startValue, currentValue, rangeDuration) {
    const rangeItems = [];
    const interval = this.dateBox.option("interval");
    while (currentValue - startValue <= rangeDuration) {
      rangeItems.push(new Date(currentValue));
      currentValue.setMinutes(currentValue.getMinutes() + interval);
    }
    return rangeItems;
  }
  _getBoundaryDate(boundary) {
    const boundaryValue = BOUNDARY_VALUES[boundary];
    const currentValue = new Date(ensureDefined(this.dateBox.dateOption("value"), 0));
    return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes());
  }
  _timeListItemTemplate(itemData) {
    const displayFormat = this.dateBox.option("displayFormat");
    return date_default.format(itemData, this.getDisplayFormat(displayFormat));
  }
  _listItemClickHandler(e) {
    if ("useButtons" === this.dateBox.option("applyValueMode")) {
      return;
    }
    const date = this._getDateByItemData(e.itemData);
    this.dateBox.option("opened", false);
    this.dateBoxValue(date, e.event);
  }
  _getDateByItemData(itemData) {
    let date = this.dateBox.option("value");
    const hours = itemData.getHours();
    const minutes = itemData.getMinutes();
    const seconds = itemData.getSeconds();
    const year = itemData.getFullYear();
    const month = itemData.getMonth();
    const day = itemData.getDate();
    if (date) {
      if (this.dateBox.option("dateSerializationFormat")) {
        date = date_serialization_default.deserializeDate(date);
      } else {
        date = new Date(date);
      }
      date.setHours(hours);
      date.setMinutes(minutes);
      date.setSeconds(seconds);
      date.setFullYear(year);
      date.setMonth(month);
      date.setDate(day);
    } else {
      date = new Date(year, month, day, hours, minutes, 0, 0);
    }
    return date;
  }
  getKeyboardListener() {
    return this._widget;
  }
  _updatePopupHeight() {
    var _this$dateBox$_timeLi;
    const dropDownOptionsHeight = getSizeValue(this.dateBox.option("dropDownOptions.height"));
    if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
      this.dateBox._setPopupOption("height", "auto");
      const popupHeight = getOuterHeight(this._widget.$element());
      const maxHeight = 0.45 * getHeight(window10);
      this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
    }
    null === (_this$dateBox$_timeLi = this.dateBox._timeList) || void 0 === _this$dateBox$_timeLi || _this$dateBox$_timeLi.updateDimensions();
  }
  getParsedText(text, format2) {
    let value2 = super.getParsedText(text, format2);
    if (value2) {
      value2 = m_date_utils_default.mergeDates(value2, /* @__PURE__ */ new Date(null), "date");
    }
    return value2;
  }
};
var m_date_box_strategy_list_default = ListStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.native.js
var NativeStrategy2 = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "Native";
  }
  popupConfig(popupConfig) {
    return _extends({}, popupConfig, {
      width: "auto"
    });
  }
  getParsedText(text) {
    if (!text) {
      return null;
    }
    if ("datetime" === this.dateBox.option("type")) {
      return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0]);
    }
    return m_date_utils_default.fromStandardDateFormat(text);
  }
  renderPopupContent() {
  }
  _getWidgetName() {
  }
  _getWidgetOptions() {
  }
  _getDateBoxType() {
    let {
      type: type2
    } = this.dateBox.option();
    if (!m_date_utils_default.SUPPORTED_FORMATS.includes(type2)) {
      type2 = "date";
    } else if ("datetime" === type2 && !inputType(type2)) {
      type2 = "datetime-local";
    }
    return type2;
  }
  customizeButtons() {
    const dropDownButton = this.dateBox.getButton("dropDown");
    if (devices_default.real().android && dropDownButton) {
      dropDownButton.on("click", (() => {
        this.dateBox._input().get(0).click();
      }));
    }
  }
  getDefaultOptions() {
    return {
      mode: this._getDateBoxType()
    };
  }
  getDisplayFormat(displayFormat) {
    const type2 = this._getDateBoxType();
    return displayFormat || m_date_utils_default.FORMATS_MAP[type2];
  }
  renderInputMinMax($input) {
    const type2 = this.dateBox.option("type");
    const format2 = {
      datetime: "yyyy-MM-ddTHH:mm:ss",
      date: "yyyy-MM-dd",
      time: "HH:mm:ss"
    }[type2] ?? "yyyy-MM-dd";
    $input.attr({
      min: date_serialization_default.serializeDate(this.dateBox.dateOption("min"), format2),
      max: date_serialization_default.serializeDate(this.dateBox.dateOption("max"), format2)
    });
  }
};
var m_date_box_strategy_native_default = NativeStrategy2;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.base.js
var window11 = getWindow();
var DX_INVALID_BADGE_CLASS2 = "dx-show-invalid-badge";
var DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var PICKER_TYPE = {
  calendar: "calendar",
  rollers: "rollers",
  list: "list",
  native: "native"
};
var TYPE2 = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var STRATEGY_NAME = {
  calendar: "Calendar",
  dateView: "DateView",
  native: "Native",
  calendarWithTime: "CalendarWithTime",
  list: "List"
};
var STRATEGY_CLASSES = {
  Calendar: m_date_box_strategy_calendar_default,
  DateView: m_date_box_strategy_date_view_default,
  Native: m_date_box_strategy_native_default,
  CalendarWithTime: m_date_box_strategy_calendar_with_time_default,
  List: m_date_box_strategy_list_default
};
var DateBox = class extends m_drop_down_editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), this._strategy.supportedKeys());
  }
  _renderButtonContainers() {
    super._renderButtonContainers.apply(this, arguments);
    this._strategy.customizeButtons();
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      type: "date",
      showAnalogClock: true,
      value: null,
      displayFormat: null,
      interval: 30,
      disabledDates: null,
      pickerType: PICKER_TYPE.calendar,
      invalidDateMessage: message_default.format("dxDateBox-validation-datetime"),
      dateOutOfRangeMessage: message_default.format("validation-range"),
      applyButtonText: message_default.format("OK"),
      adaptivityEnabled: false,
      calendarOptions: {},
      useHiddenSubmitElement: true,
      _showValidationIcon: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        "dropDownOptions.showTitle": true
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }, {
      device() {
        const realDevice2 = devices_default.real();
        const {
          platform
        } = realDevice2;
        return "ios" === platform || "android" === platform;
      },
      options: {
        pickerType: PICKER_TYPE.native
      }
    }, {
      device: {
        platform: "generic",
        deviceType: "desktop"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }]);
  }
  _initOptions(options2) {
    this._userOptions = extend({}, options2);
    super._initOptions(options2);
    this._updatePickerOptions();
  }
  _updatePickerOptions() {
    let {
      pickerType
    } = this.option();
    const {
      type: type2
    } = this.option();
    if (pickerType === PICKER_TYPE.list && (type2 === TYPE2.datetime || type2 === TYPE2.date)) {
      pickerType = PICKER_TYPE.calendar;
    }
    if (type2 === TYPE2.time && pickerType === PICKER_TYPE.calendar) {
      pickerType = PICKER_TYPE.list;
    }
    this._pickerType = pickerType;
    this._setShowDropDownButtonOption();
  }
  _setShowDropDownButtonOption() {
    const {
      platform
    } = devices_default.real();
    const isMozillaOnAndroid = "android" === platform && browser_default.mozilla;
    const isNativePickerType = this._isNativeType();
    let showDropDownButton = "generic" !== platform || !isNativePickerType;
    if (isNativePickerType && isMozillaOnAndroid) {
      showDropDownButton = false;
    }
    this.option({
      showDropDownButton
    });
  }
  _init() {
    this._initStrategy();
    this.option(extend({}, this._strategy.getDefaultOptions(), this._userOptions));
    delete this._userOptions;
    super._init();
  }
  _toLowerCaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.substr(1);
  }
  _initStrategy() {
    const strategyName = this._getStrategyName(this._getFormatType());
    const strategy = STRATEGY_CLASSES[strategyName];
    if (!(this._strategy && this._strategy.NAME === strategyName)) {
      this._strategy = new strategy(this);
    }
  }
  _getFormatType() {
    const currentType = this.option("type");
    const isTime = /h|m|s/g.test(currentType);
    const isDate2 = /d|M|Y/g.test(currentType);
    let type2 = "";
    if (isDate2) {
      type2 += TYPE2.date;
    }
    if (isTime) {
      type2 += TYPE2.time;
    }
    return type2;
  }
  _getStrategyName(type2) {
    const pickerType = this._pickerType;
    if (pickerType === PICKER_TYPE.rollers) {
      return STRATEGY_NAME.dateView;
    }
    if (pickerType === PICKER_TYPE.native) {
      return STRATEGY_NAME.native;
    }
    if (type2 === TYPE2.date) {
      return STRATEGY_NAME.calendar;
    }
    if (type2 === TYPE2.datetime) {
      return STRATEGY_NAME.calendarWithTime;
    }
    return STRATEGY_NAME.list;
  }
  _initMarkup() {
    this.$element().addClass("dx-datebox");
    super._initMarkup();
    this._refreshFormatClass();
    this._refreshPickerTypeClass();
    this._strategy.renderInputMinMax(this._input());
  }
  _render() {
    super._render();
    this._formatValidationIcon();
  }
  _renderDimensions() {
    super._renderDimensions();
    this.$element().toggleClass("dx-auto-width", !this.option("width"));
    this._updatePopupWidth();
    this._updatePopupHeight();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this._updatePopupHeight();
  }
  _updatePopupHeight() {
    if (this._popup) {
      var _this$_strategy$_upda, _this$_strategy;
      null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda || _this$_strategy$_upda.call(_this$_strategy);
    }
  }
  _refreshFormatClass() {
    const $element = this.$element();
    each(TYPE2, ((_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    }));
    const {
      type: type2
    } = this.option();
    $element.addClass(`dx-datebox-${type2}`);
  }
  _refreshPickerTypeClass() {
    const $element = this.$element();
    each(PICKER_TYPE, ((_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    }));
    $element.addClass(`dx-datebox-${this._pickerType}`);
  }
  _formatValidationIcon() {
    if (!hasWindow()) {
      return;
    }
    const inputElement = this._input().get(0);
    const isRtlEnabled = this.option("rtlEnabled");
    const clearButtonWidth = this._getClearButtonWidth();
    const longestElementDimensions = this._getLongestElementDimensions();
    const curWidth = parseFloat(window11.getComputedStyle(inputElement).width) - clearButtonWidth;
    const shouldHideValidationIcon = longestElementDimensions.width > curWidth;
    const {
      style
    } = inputElement;
    const {
      _showValidationIcon: showValidationIcon
    } = this.option();
    this.$element().toggleClass(DX_INVALID_BADGE_CLASS2, !shouldHideValidationIcon && showValidationIcon);
    if (shouldHideValidationIcon) {
      if (void 0 === this._storedPadding) {
        this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding;
      }
      isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0;
    } else {
      isRtlEnabled ? style.paddingLeft = `${this._storedPadding}px` : style.paddingRight = `${this._storedPadding}px`;
    }
  }
  _getClearButtonWidth() {
    let clearButtonWidth = 0;
    if (this._isClearButtonVisible() && "" === this._input().val()) {
      const clearButtonElement = this.$element().find(`.${DX_CLEAR_BUTTON_CLASS}`).get(0);
      clearButtonWidth = parseFloat(window11.getComputedStyle(clearButtonElement).width);
    }
    return clearButtonWidth;
  }
  _getLongestElementDimensions() {
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const longestValue = date_default.format(m_date_utils_default.getLongestDate(format2, date_default.getMonthNames(), date_default.getDayNames()), format2);
    const $input = this._input();
    const inputElement = $input.get(0);
    const $longestValueElement = createTextElementHiddenCopy($input, longestValue);
    const isPaddingStored = void 0 !== this._storedPadding;
    const storedPadding = !isPaddingStored ? 0 : this._storedPadding;
    $longestValueElement.appendTo(this.$element());
    const elementWidth = parseFloat(window11.getComputedStyle($longestValueElement.get(0)).width);
    const rightPadding = parseFloat(window11.getComputedStyle(inputElement).paddingRight);
    const leftPadding = parseFloat(window11.getComputedStyle(inputElement).paddingLeft);
    const necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
    $longestValueElement.remove();
    return {
      width: necessaryWidth,
      leftPadding,
      rightPadding
    };
  }
  _getKeyboardListeners() {
    var _this$_strategy2;
    return super._getKeyboardListeners().concat([null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 ? void 0 : _this$_strategy2.getKeyboardListener()]);
  }
  _renderPopup() {
    var _this$_popup;
    super._renderPopup();
    null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.$wrapper().addClass("dx-datebox-wrapper");
    this._renderPopupWrapper();
  }
  _getPopupToolbarItems() {
    var _this$_strategy$_getP, _this$_strategy3;
    const defaultItems = super._getPopupToolbarItems();
    return (null === (_this$_strategy$_getP = (_this$_strategy3 = this._strategy)._getPopupToolbarItems) || void 0 === _this$_strategy$_getP ? void 0 : _this$_strategy$_getP.call(_this$_strategy3, defaultItems)) ?? defaultItems;
  }
  _popupConfig() {
    const popupConfig = super._popupConfig();
    return _extends({}, this._strategy.popupConfig(popupConfig), {
      title: this._getPopupTitle(),
      dragEnabled: false
    });
  }
  _renderPopupWrapper() {
    if (!this._popup) {
      return;
    }
    const $element = this.$element();
    const classPostfixes = extend({}, TYPE2, PICKER_TYPE);
    each(classPostfixes, ((_, item) => {
      $element.removeClass(`dx-datebox-wrapper-${item}`);
    }));
    const {
      type: type2
    } = this.option();
    this._popup.$wrapper().addClass(`dx-datebox-wrapper-${type2}`).addClass(`dx-datebox-wrapper-${this._pickerType}`).addClass("dx-dropdowneditor-overlay");
  }
  _renderPopupContent() {
    super._renderPopupContent();
    this._strategy.renderPopupContent();
  }
  _popupShowingHandler() {
    super._popupShowingHandler();
    this._strategy.popupShowingHandler();
  }
  _popupShownHandler() {
    super._popupShownHandler();
    this._strategy.renderOpenedState();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler();
    this._strategy.renderOpenedState();
    this._strategy.popupHiddenHandler();
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._formatValidationIcon();
    }
  }
  _clearValueHandler(e) {
    this.option("text", "");
    super._clearValueHandler(e);
  }
  _readOnlyPropValue() {
    if (this._pickerType === PICKER_TYPE.rollers) {
      return true;
    }
    const {
      platform
    } = devices_default.real();
    const isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
    if (isCustomValueDisabled) {
      const {
        readOnly
      } = this.option();
      return readOnly;
    }
    return super._readOnlyPropValue();
  }
  _isClearButtonVisible() {
    return super._isClearButtonVisible() && !this._isNativeType();
  }
  _renderValue() {
    const value2 = this.dateOption("value");
    this.option("text", this._getDisplayedText(value2));
    this._strategy.renderValue();
    return super._renderValue();
  }
  _setSubmitValue() {
    const value2 = this.dateOption("value");
    const {
      type: type2,
      dateSerializationFormat
    } = this.option();
    const submitFormat = m_date_utils_default.SUBMIT_FORMATS_MAP[type2];
    const submitValue = dateSerializationFormat ? date_serialization_default.serializeDate(value2, dateSerializationFormat) : m_date_utils_default.toStandardDateFormat(value2, submitFormat);
    this._getSubmitElement().val(submitValue);
  }
  _getDisplayedText(value2) {
    const {
      mode
    } = this.option();
    let displayedText;
    if ("text" === mode) {
      const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
      displayedText = date_default.format(value2, displayFormat);
    } else {
      const format2 = this._getFormatByMode(mode);
      if (format2) {
        displayedText = date_default.format(value2, format2);
      } else {
        displayedText = m_date_utils_default.toStandardDateFormat(value2, mode);
      }
    }
    return displayedText;
  }
  _getFormatByMode(mode) {
    return inputType(mode) ? null : m_date_utils_default.FORMATS_MAP[mode];
  }
  _valueChangeEventHandler(e) {
    const {
      text,
      type: type2,
      validationError
    } = this.option();
    const currentValue = this.dateOption("value");
    if (text === this._getDisplayedText(currentValue)) {
      this._recallInternalValidation(currentValue, validationError);
      return;
    }
    const parsedDate = this._getParsedDate(text);
    const value2 = currentValue ?? this._getDateByDefault();
    const newValue = m_date_utils_default.mergeDates(value2, parsedDate, type2);
    const date = parsedDate && "time" === type2 ? newValue : parsedDate;
    if (this._applyInternalValidation(date).isValid) {
      const displayedText = this._getDisplayedText(newValue);
      if (value2 && newValue && value2.getTime() === newValue.getTime() && displayedText !== text) {
        this._renderValue();
      } else {
        this.dateValue(newValue, e);
      }
    }
  }
  _recallInternalValidation(value2, validationError) {
    if (!validationError || validationError.editorSpecific) {
      this._applyInternalValidation(value2);
      this._applyCustomValidation(value2);
    }
  }
  _getDateByDefault() {
    return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
  }
  _getParsedDate(text) {
    const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const parsedText = this._strategy.getParsedText(text, displayFormat);
    return parsedText ?? void 0;
  }
  _applyInternalValidation(value2) {
    const text = this.option("text");
    const hasText = !!text && null !== value2;
    const isDate2 = !!value2 && isDate(value2) && !isNaN(value2.getTime());
    const isDateInRange = isDate2 && date_default2.dateInRange(value2, this.dateOption("min"), this.dateOption("max"), this.option("type"));
    const isValid = !hasText && !value2 || isDateInRange;
    let validationMessage = "";
    const {
      invalidDateMessage,
      dateOutOfRangeMessage
    } = this.option();
    if (!isDate2) {
      validationMessage = invalidDateMessage;
    } else if (!isDateInRange) {
      validationMessage = dateOutOfRangeMessage;
    }
    this._updateInternalValidationState(isValid, validationMessage);
    return {
      isValid,
      isDate: isDate2
    };
  }
  _updateInternalValidationState(isValid, validationMessage) {
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: validationMessage
      }
    });
  }
  _applyCustomValidation(value2) {
    this.validationRequest.fire({
      editor: this,
      value: this._serializeDate(value2)
    });
  }
  _isValueChanged(newValue) {
    const oldValue = this.dateOption("value");
    const oldTime = oldValue && oldValue.getTime();
    const newTime = newValue && newValue.getTime();
    return oldTime !== newTime;
  }
  _isTextChanged(newValue) {
    const oldText = this.option("text");
    const newText = newValue && this._getDisplayedText(newValue) || "";
    return oldText !== newText;
  }
  _renderProps() {
    super._renderProps();
    this._input().attr("autocomplete", "off");
  }
  _renderOpenedState() {
    if (!this._isNativeType()) {
      super._renderOpenedState();
    }
    if (this._strategy.isAdaptivityChanged()) {
      this._refreshStrategy();
    }
  }
  _getPopupTitle() {
    const {
      placeholder
    } = this.option();
    if (placeholder) {
      return placeholder;
    }
    const {
      type: type2
    } = this.option();
    if (type2 === TYPE2.time) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleTime");
    }
    if (type2 === TYPE2.date || type2 === TYPE2.datetime) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleDate");
    }
    return "";
  }
  _refreshStrategy() {
    this._strategy.dispose();
    this._initStrategy();
    this.option(this._strategy.getDefaultOptions());
    this._refresh();
  }
  _applyButtonHandler(e) {
    const value2 = this._strategy.getValue();
    this.dateValue(value2, e.event);
    super._applyButtonHandler();
  }
  _dispose() {
    var _this$_strategy4;
    super._dispose();
    null === (_this$_strategy4 = this._strategy) || void 0 === _this$_strategy4 || _this$_strategy4.dispose();
  }
  _isNativeType() {
    return this._pickerType === PICKER_TYPE.native;
  }
  _updatePopupTitle() {
    var _this$_popup2;
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.option("title", this._getPopupTitle());
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showClearButton":
      case "buttons":
      case "isValid":
      case "readOnly":
        super._optionChanged.apply(this, arguments);
        this._formatValidationIcon();
        break;
      case "pickerType":
        this._updatePickerOptions();
        this._refreshStrategy();
        this._refreshPickerTypeClass();
        this._invalidate();
        break;
      case "type":
        this._updatePickerOptions();
        this._refreshStrategy();
        this._refreshFormatClass();
        this._renderPopupWrapper();
        this._formatValidationIcon();
        this._updateValue();
        break;
      case "placeholder":
        super._optionChanged.apply(this, arguments);
        this._updatePopupTitle();
        break;
      case "min":
      case "max": {
        const isValid = this.option("isValid");
        this._applyInternalValidation(this.dateOption("value"));
        if (!isValid) {
          this._applyCustomValidation(this.dateOption("value"));
        }
        this._invalidate();
        break;
      }
      case "dateSerializationFormat":
      case "interval":
      case "disabledDates":
      case "calendarOptions":
      case "todayButtonText":
        this._invalidate();
        break;
      case "displayFormat":
        this.option("text", this._getDisplayedText(this.dateOption("value")));
        this._renderInputValue();
        break;
      case "text":
        this._strategy.textChangedHandler(args.value);
        super._optionChanged.apply(this, arguments);
        break;
      case "showDropDownButton":
        this._formatValidationIcon();
        super._optionChanged.apply(this, arguments);
        break;
      case "invalidDateMessage":
      case "dateOutOfRangeMessage":
      case "adaptivityEnabled":
      case "showAnalogClock":
      case "_showValidationIcon":
        break;
      default:
        super._optionChanged.apply(this, arguments);
    }
  }
  _getSerializationFormat() {
    const {
      value: value2
    } = this.option();
    if (this.option("dateSerializationFormat") && config_default2().forceIsoDateParsing) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2) || "" === value2) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _updateValue(value2) {
    super._updateValue();
    this._applyInternalValidation(value2 ?? this.dateOption("value"));
  }
  dateValue(value2, dxEvent) {
    const isValueChanged = this._isValueChanged(value2);
    if (isValueChanged && dxEvent) {
      this._saveValueChangeEvent(dxEvent);
    }
    if (!isValueChanged) {
      const {
        text
      } = this.option();
      if (this._isTextChanged(value2)) {
        this._updateValue(value2);
      } else if ("" === text) {
        this._applyCustomValidation(value2);
      }
    }
    return this.dateOption("value", value2);
  }
  dateOption(optionName, value2) {
    if (1 === arguments.length) {
      return date_serialization_default.deserializeDate(this.option(optionName));
    }
    this.option(optionName, this._serializeDate(value2));
  }
  _serializeDate(date) {
    const serializationFormat = this._getSerializationFormat();
    return date_serialization_default.serializeDate(date, serializationFormat);
  }
  _clearValue() {
    const value2 = this.option("value");
    super._clearValue();
    if (null === value2) {
      this._applyCustomValidation(null);
    }
  }
  clear() {
    const value2 = this.option("value");
    super.clear();
    if (null === value2) {
      this._applyInternalValidation(null);
    }
  }
};
var m_date_box_base_default = DateBox;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.parts.js
var monthGetter = (date) => date.getMonth() + 1;
var monthSetter = (date, value2) => {
  const day = date.getDate();
  const monthLimits = getLimits("M", date);
  const newValue = fitIntoRange(parseInt(value2), monthLimits.min, monthLimits.max);
  date.setMonth(newValue - 1, 1);
  const {
    min,
    max
  } = getLimits("dM", date);
  const newDay = fitIntoRange(day, min, max);
  date.setDate(newDay);
};
var PATTERN_GETTERS = {
  a: (date) => date.getHours() < 12 ? 0 : 1,
  E: "getDay",
  y: "getFullYear",
  M: monthGetter,
  L: monthGetter,
  d: "getDate",
  H: "getHours",
  h: "getHours",
  m: "getMinutes",
  s: "getSeconds",
  S: "getMilliseconds",
  x: "getTimezoneOffset"
};
var PATTERN_SETTERS = extend({}, getPatternSetters(), {
  a: (date, value2) => {
    const hours = date.getHours();
    const current2 = hours >= 12;
    if (current2 === !!parseInt(value2)) {
      return;
    }
    date.setHours((hours + 12) % 24);
  },
  d: (date, value2) => {
    const lastDayInMonth = getLimits("dM", date).max;
    if (value2 > lastDayInMonth) {
      date.setMonth(date.getMonth() + 1);
    }
    date.setDate(value2);
  },
  h: (date, value2) => {
    const isPM = date.getHours() >= 12;
    date.setHours(+value2 % 12 + (isPM ? 12 : 0));
  },
  M: monthSetter,
  L: monthSetter,
  E: (date, value2) => {
    if (value2 < 0) {
      return;
    }
    date.setDate(date.getDate() - date.getDay() + parseInt(value2));
  },
  y: (date, value2) => {
    const currentYear = date.getFullYear();
    const valueLength = String(value2).length;
    const maxLimitLength = String(getLimits("y", date).max).length;
    const newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value2);
    date.setFullYear(newValue);
  },
  x: (date) => date
});
var getPatternGetter = (patternChar) => PATTERN_GETTERS[patternChar] || (() => patternChar);
var renderDateParts = (text, regExpInfo) => {
  const result2 = regExpInfo.regexp.exec(text);
  let start = 0;
  let end = 0;
  const sections = [];
  for (let i = 1; i < result2.length; i++) {
    start = end;
    end = start + result2[i].length;
    const pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
    const getter = getPatternGetter(pattern[0]);
    sections.push({
      index: i - 1,
      isStub: pattern === result2[i],
      caret: {
        start,
        end
      },
      pattern,
      text: result2[i],
      limits: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return getLimits(pattern[0], ...args);
      },
      setter: PATTERN_SETTERS[pattern[0]] || noop,
      getter
    });
  }
  return sections;
};
var getLimits = (pattern, date, forcedPattern) => {
  const limits = {
    y: {
      min: 0,
      max: 9999
    },
    M: {
      min: 1,
      max: 12
    },
    L: {
      min: 1,
      max: 12
    },
    d: {
      min: 1,
      max: 31
    },
    dM: {
      min: 1,
      max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
    },
    E: {
      min: 0,
      max: 6
    },
    H: {
      min: 0,
      max: 23
    },
    h: {
      min: 1,
      max: 12
    },
    m: {
      min: 0,
      max: 59
    },
    s: {
      min: 0,
      max: 59
    },
    S: {
      min: 0,
      max: 999
    },
    a: {
      min: 0,
      max: 1
    },
    x: {
      min: 0,
      max: 0
    }
  };
  return limits[forcedPattern || pattern] || limits.getAmPm;
};
var getDatePartIndexByPosition = (dateParts, position2) => {
  for (let i = 0; i < dateParts.length; i++) {
    const caretInGroup = dateParts[i].caret.end >= position2;
    if (!dateParts[i].isStub && caretInGroup) {
      return i;
    }
  }
  return null;
};

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.js
var DateBoxMask = class extends m_date_box_base_default {
  _supportedKeys() {
    const originalHandlers = super._supportedKeys();
    const callOriginalHandler = (e) => {
      const originalHandler = originalHandlers[normalizeKeyName(e)];
      return null === originalHandler || void 0 === originalHandler ? void 0 : originalHandler.apply(this, [e]);
    };
    const applyHandler = (e, maskHandler) => {
      if (this._shouldUseOriginalHandler(e)) {
        return callOriginalHandler.apply(this, [e]);
      }
      return maskHandler.apply(this, [e]);
    };
    return _extends({}, originalHandlers, {
      del: (e) => applyHandler(e, ((event) => {
        this._revertPart(1);
        this._isAllSelected() || event.preventDefault();
      })),
      backspace: (e) => applyHandler(e, ((event) => {
        this._revertPart(-1);
        this._isAllSelected() || event.preventDefault();
      })),
      home: (e) => applyHandler(e, ((event) => {
        this._selectFirstPart();
        event.preventDefault();
      })),
      end: (e) => applyHandler(e, ((event) => {
        this._selectLastPart();
        event.preventDefault();
      })),
      escape: (e) => applyHandler(e, (() => {
        this._revertChanges();
      })),
      enter: (e) => applyHandler(e, (() => {
        this._enterHandler();
      })),
      leftArrow: (e) => applyHandler(e, ((event) => {
        this._selectNextPart(-1);
        event.preventDefault();
      })),
      rightArrow: (e) => applyHandler(e, ((event) => {
        this._selectNextPart(1);
        event.preventDefault();
      })),
      upArrow: (e) => applyHandler(e, ((event) => {
        this._upDownArrowHandler(1);
        event.preventDefault();
      })),
      downArrow: (e) => applyHandler(e, ((event) => {
        this._upDownArrowHandler(-1);
        event.preventDefault();
      }))
    });
  }
  _shouldUseOriginalHandler(e) {
    const isNotDeletingInCalendar = this.option("opened") && e && !["backspace", "del"].includes(normalizeKeyName(e));
    return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey;
  }
  _upDownArrowHandler(step) {
    this._setNewDateIfEmpty();
    const originalValue = this._getActivePartValue(this._initialMaskValue);
    const currentValue = this._getActivePartValue();
    const delta = currentValue - originalValue;
    this._loadMaskValue(this._initialMaskValue);
    this._changePartValue(delta + step, true);
  }
  _changePartValue(step, lockOtherParts) {
    const activePartPattern = this._getActivePartProp("pattern");
    const isAmPmPartActive = /^a{1,5}$/.test(activePartPattern);
    if (isAmPmPartActive) {
      this._toggleAmPm();
    } else {
      this._partIncrease(step, lockOtherParts);
    }
  }
  _toggleAmPm() {
    const currentValue = this._getActivePartProp("text");
    const indexOfCurrentValue = default_date_names_default.getPeriodNames().indexOf(currentValue);
    const newValue = 1 ^ indexOfCurrentValue;
    this._setActivePartValue(newValue);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      useMaskBehavior: false,
      emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
    });
  }
  _isSingleCharKey(_ref) {
    let {
      originalEvent,
      alt
    } = _ref;
    const key = originalEvent.data || originalEvent.key;
    return "string" === typeof key && 1 === key.length && !alt && !isCommandKeyPressed(originalEvent);
  }
  _isSingleDigitKey(e) {
    var _e$originalEvent;
    const data17 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
    return 1 === (null === data17 || void 0 === data17 ? void 0 : data17.length) && parseInt(data17, 10);
  }
  _useBeforeInputEvent() {
    return devices_default.real().android;
  }
  _keyInputHandler(e, key) {
    const oldInputValue = this._input().val();
    this._processInputKey(key);
    e.preventDefault();
    const isValueChanged = oldInputValue !== this._input().val();
    isValueChanged && m_events_engine_default.trigger(this._input(), "input");
  }
  _keyboardHandler(e) {
    let {
      key
    } = e.originalEvent;
    const result2 = super._keyboardHandler(e);
    if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
      return result2;
    }
    if (browser_default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
      key = e.code.replace("Digit", "");
      this._processInputKey(key);
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    } else if (this._isSingleCharKey(e)) {
      this._keyInputHandler(e.originalEvent, key);
    }
    return result2;
  }
  _maskBeforeInputHandler(e) {
    this._maskInputHandler = null;
    const {
      inputType: inputType2
    } = e.originalEvent;
    if ("insertCompositionText" === inputType2) {
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    }
    const isBackwardDeletion = "deleteContentBackward" === inputType2;
    const isForwardDeletion = "deleteContentForward" === inputType2;
    if (isBackwardDeletion || isForwardDeletion) {
      const direction = isBackwardDeletion ? -1 : 1;
      this._maskInputHandler = () => {
        this._revertPart();
        this._selectNextPart(direction);
      };
    }
    if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
      return;
    }
    const key = e.originalEvent.data;
    this._keyInputHandler(e, key);
    return true;
  }
  _keyPressHandler(e) {
    const {
      originalEvent: event
    } = e;
    if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
      this._processInputKey(event.data);
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._selectNextPart();
    }
    super._keyPressHandler(e);
    if (this._maskInputHandler) {
      this._maskInputHandler();
      this._maskInputHandler = null;
    }
  }
  _processInputKey(key) {
    if (this._isAllSelected()) {
      this._activePartIndex = 0;
    }
    this._setNewDateIfEmpty();
    if (isNaN(parseInt(key))) {
      this._searchString(key);
    } else {
      this._searchNumber(key);
    }
  }
  _isAllSelected() {
    const caret3 = this._caret();
    const {
      text
    } = this.option();
    return caret3.end - caret3.start === text.length;
  }
  _getFormatPattern() {
    if (this._formatPattern) {
      return this._formatPattern;
    }
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const isLDMLPattern = isString(format2) && !date_default._getPatternByFormat(format2);
    if (isLDMLPattern) {
      this._formatPattern = format2;
    } else {
      this._formatPattern = getFormat2(((value2) => date_default.format(value2, format2)));
    }
    return this._formatPattern;
  }
  _setNewDateIfEmpty() {
    if (!this._maskValue) {
      const {
        type: type2
      } = this.option();
      const value2 = "time" === type2 ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
      this._maskValue = value2;
      this._initialMaskValue = value2;
      this._renderDateParts();
    }
  }
  _partLimitsReached(max) {
    const maxLimitLength = String(max).length;
    const formatLength = this._getActivePartProp("pattern").length;
    const isShortFormat = 1 === formatLength;
    const maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
    const isLengthExceeded = this._searchValue.length === maxSearchLength;
    const isValueOverflowed = parseInt(`${this._searchValue}0`) > max;
    return isLengthExceeded || isValueOverflowed;
  }
  _searchNumber(char) {
    const {
      max
    } = this._getActivePartLimits();
    const maxLimitLength = String(max).length;
    this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
    if (isNaN(this._searchValue)) {
      this._searchValue = char;
    }
    this._setActivePartValue(this._searchValue);
    if (this._partLimitsReached(max)) {
      this._selectNextPart(1);
    }
  }
  _searchString(char) {
    if (!isNaN(parseInt(this._getActivePartProp("text")))) {
      return;
    }
    const limits = this._getActivePartProp("limits")(this._maskValue);
    const startString = this._searchValue + char.toLowerCase();
    const endLimit = limits.max - limits.min;
    for (let i = 0; i <= endLimit; i++) {
      this._loadMaskValue(this._initialMaskValue);
      this._changePartValue(i + 1);
      if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
        this._searchValue = startString;
        return;
      }
    }
    this._setNewDateIfEmpty();
    if (this._searchValue) {
      this._clearSearchValue();
      this._searchString(char);
    }
  }
  _clearSearchValue() {
    this._searchValue = "";
  }
  _revertPart(direction) {
    if (!this._isAllSelected()) {
      const actual = this._getActivePartValue(this.option("emptyDateValue"));
      this._setActivePartValue(actual);
      this._selectNextPart(direction);
    }
    this._clearSearchValue();
  }
  _useMaskBehavior() {
    const {
      mode
    } = this.option();
    return this.option("useMaskBehavior") && "text" === mode;
  }
  _prepareRegExpInfo() {
    this._regExpInfo = getRegExpInfo(this._getFormatPattern(), date_default);
    const {
      regexp
    } = this._regExpInfo;
    const {
      source
    } = regexp;
    const {
      flags
    } = regexp;
    const quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
    const convertedSource = source.split(quantifierRegexp).map(((sourcePart) => quantifierRegexp.test(sourcePart) ? sourcePart : number_default.convertDigits(sourcePart, false))).join("");
    this._regExpInfo.regexp = new RegExp(convertedSource, flags);
  }
  _initMaskState() {
    this._activePartIndex = 0;
    this._formatPattern = null;
    this._prepareRegExpInfo();
    this._loadMaskValue();
  }
  _renderMask() {
    super._renderMask();
    this._detachMaskEvents();
    this._clearMaskState();
    if (this._useMaskBehavior()) {
      this._attachMaskEvents();
      this._initMaskState();
      this._renderDateParts();
    }
  }
  _renderDateParts() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this.option("text") || this._getDisplayedText(this._maskValue);
    if (text) {
      this._dateParts = renderDateParts(text, this._regExpInfo);
      if (!this._input().is(":hidden")) {
        this._selectNextPart();
      }
    }
  }
  _detachMaskEvents() {
    m_events_engine_default.off(this._input(), ".dateBoxMask");
  }
  _attachMaskEvents() {
    m_events_engine_default.on(this._input(), addNamespace("dxclick", "dateBoxMask"), this._maskClickHandler.bind(this));
    m_events_engine_default.on(this._input(), addNamespace("paste", "dateBoxMask"), this._maskPasteHandler.bind(this));
    m_events_engine_default.on(this._input(), addNamespace("drop", "dateBoxMask"), (() => {
      this._renderSelectedPart();
    }));
    m_events_engine_default.on(this._input(), addNamespace("compositionend", "dateBoxMask"), this._maskCompositionEndHandler.bind(this));
    if (this._useBeforeInputEvent()) {
      m_events_engine_default.on(this._input(), addNamespace("beforeinput", "dateBoxMask"), this._maskBeforeInputHandler.bind(this));
    }
  }
  _renderSelectedPart() {
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
  }
  _selectLastPart() {
    if (this.option("text")) {
      this._activePartIndex = this._dateParts.length;
      this._selectNextPart(-1);
    }
  }
  _selectFirstPart() {
    if (this.option("text") && this._dateParts) {
      this._activePartIndex = -1;
      this._selectNextPart(1);
    }
  }
  _hasMouseWheelHandler() {
    return true;
  }
  _onMouseWheel(e) {
    if (this._useMaskBehavior()) {
      this._partIncrease(e.delta > 0 ? 1 : -1, e);
    }
  }
  _selectNextPart() {
    let step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (!this.option("text") || this._disposed) {
      return;
    }
    if (step) {
      this._initialMaskValue = new Date(this._maskValue);
    }
    let index = fitIntoRange(this._activePartIndex + step, 0, this._dateParts.length - 1);
    if (this._dateParts[index].isStub) {
      const isBoundaryIndex = 0 === index && step < 0 || index === this._dateParts.length - 1 && step > 0;
      if (!isBoundaryIndex) {
        this._selectNextPart(step >= 0 ? step + 1 : step - 1);
        return;
      }
      index = this._activePartIndex;
    }
    if (this._activePartIndex !== index) {
      this._clearSearchValue();
    }
    this._activePartIndex = index;
    this._caret(this._getActivePartProp("caret"));
  }
  _getRealLimitsPattern() {
    if ("d" === this._getActivePartProp("pattern")[0]) {
      return "dM";
    }
  }
  _getActivePartLimits(lockOtherParts) {
    const limitFunction = this._getActivePartProp("limits");
    return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern());
  }
  _getActivePartValue(dateValue) {
    dateValue = dateValue || this._maskValue;
    const getter = this._getActivePartProp("getter");
    return isFunction(getter) ? getter(dateValue) : dateValue[getter]();
  }
  _addLeadingZeroes(value2) {
    const zeroes = /^0+/.exec(this._searchValue);
    const limits = this._getActivePartLimits();
    const maxLimitLength = String(limits.max).length;
    return ((zeroes && zeroes[0] || "") + String(value2)).substr(-maxLimitLength);
  }
  _setActivePartValue(value2, dateValue) {
    dateValue = dateValue || this._maskValue;
    const setter = this._getActivePartProp("setter");
    const limits = this._getActivePartLimits();
    value2 = inRange(value2, limits.min, limits.max) ? value2 : value2 % 10;
    value2 = this._addLeadingZeroes(fitIntoRange(value2, limits.min, limits.max));
    isFunction(setter) ? setter(dateValue, value2) : dateValue[setter](value2);
    this._renderDisplayText(this._getDisplayedText(dateValue));
    this._renderDateParts();
  }
  _getActivePartProp(property) {
    if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
      return;
    }
    return this._dateParts[this._activePartIndex][property];
  }
  _loadMaskValue() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
    this._maskValue = value2 && new Date(value2);
    this._initialMaskValue = value2 && new Date(value2);
  }
  _saveMaskValue() {
    const value2 = this._maskValue && new Date(this._maskValue);
    const {
      type: type2
    } = this.option();
    if (value2 && "date" === type2) {
      value2.setHours(0, 0, 0, 0);
    }
    this._initialMaskValue = new Date(value2);
    if (this._applyInternalValidation(value2).isValid) {
      this.dateOption("value", value2);
    }
  }
  _revertChanges() {
    this._loadMaskValue();
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._renderDateParts();
  }
  _renderDisplayText(text) {
    super._renderDisplayText(text);
    if (this._useMaskBehavior()) {
      this.option("text", text);
    }
  }
  _partIncrease(step, lockOtherParts) {
    this._setNewDateIfEmpty();
    const {
      max,
      min
    } = this._getActivePartLimits(lockOtherParts);
    let newValue = step + this._getActivePartValue();
    if (newValue > max) {
      newValue = this._applyLimits(newValue, {
        limitBase: min,
        limitClosest: max,
        max
      });
    } else if (newValue < min) {
      newValue = this._applyLimits(newValue, {
        limitBase: max,
        limitClosest: min,
        max
      });
    }
    this._setActivePartValue(newValue);
  }
  _applyLimits(newValue, _ref2) {
    let {
      limitBase,
      limitClosest,
      max
    } = _ref2;
    const delta = (newValue - limitClosest) % max;
    return delta ? limitBase + delta - 1 * sign(delta) : limitClosest;
  }
  _maskClickHandler() {
    this._loadMaskValue(this._maskValue);
    if (this.option("text")) {
      this._activePartIndex = getDatePartIndexByPosition(this._dateParts, this._caret().start);
      if (!this._isAllSelected()) {
        this._clearSearchValue();
        if (isDefined(this._activePartIndex)) {
          this._caret(this._getActivePartProp("caret"));
        } else {
          this._selectLastPart();
        }
      }
    }
  }
  _maskCompositionEndHandler(e) {
    this._input().val(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
    this._maskInputHandler = () => {
      this._renderSelectedPart();
    };
  }
  _maskPasteHandler(e) {
    const newText = this._replaceSelectedText(this.option("text"), this._caret(), clipboardText(e));
    const date = date_default.parse(newText, this._getFormatPattern());
    if (date && this._isDateValid(date)) {
      this._maskValue = date;
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._renderDateParts();
      this._selectNextPart();
    }
    e.preventDefault();
  }
  _isDateValid(date) {
    return isDate(date) && !isNaN(date);
  }
  _isValueDirty() {
    const value2 = this.dateOption("value");
    return (this._maskValue && this._maskValue.getTime()) !== (value2 && value2.getTime());
  }
  _fireChangeEvent() {
    this._clearSearchValue();
    if (this._isValueDirty()) {
      m_events_engine_default.trigger(this._input(), "change");
    }
  }
  _enterHandler() {
    this._fireChangeEvent();
    this._selectNextPart(1);
  }
  _focusOutHandler(e) {
    const shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
    if (shouldFireChangeEvent) {
      this._fireChangeEvent();
      super._focusOutHandler(e);
      this._selectFirstPart();
    } else {
      super._focusOutHandler(e);
    }
  }
  _valueChangeEventHandler(e) {
    const text = this.option("text");
    if (this._useMaskBehavior()) {
      this._saveValueChangeEvent(e);
      if (!text) {
        this._maskValue = null;
      } else if (null === this._maskValue) {
        this._loadMaskValue(text);
      }
      this._saveMaskValue();
    } else {
      super._valueChangeEventHandler(e);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "useMaskBehavior":
        this._renderMask();
        break;
      case "displayFormat":
      case "mode":
        super._optionChanged(args);
        this._renderMask();
        break;
      case "value":
        this._loadMaskValue();
        super._optionChanged(args);
        this._renderDateParts();
        break;
      case "emptyDateValue":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearMaskState() {
    this._clearSearchValue();
    delete this._dateParts;
    delete this._activePartIndex;
    delete this._maskValue;
  }
  clear() {
    this._clearMaskState();
    this._activePartIndex = 0;
    super.clear();
  }
  _clean() {
    super._clean();
    this._detachMaskEvents();
    this._clearMaskState();
  }
};
var m_date_box_mask_default = DateBoxMask;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.js
component_registrator_default("dxDateBox", m_date_box_mask_default);

// node_modules/devextreme/esm/ui/shared/ui.editor_factory_mixin.js
var {
  isWrapped
} = variable_wrapper_default;
var EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
var getResultConfig = function(config2, options2) {
  return extend(config2, {
    readOnly: options2.readOnly,
    placeholder: options2.placeholder,
    inputAttr: {
      id: options2.id,
      "aria-labelledby": options2["aria-labelledby"]
    },
    tabIndex: options2.tabIndex
  }, options2.editorOptions);
};
var checkEnterBug = function() {
  return browser_default.mozilla || devices_default.real().ios;
};
var getTextEditorConfig = function(options2) {
  const data17 = {};
  const isEnterBug = checkEnterBug();
  const sharedData = options2.sharedData || data17;
  return getResultConfig({
    placeholder: options2.placeholder,
    width: options2.width,
    value: options2.value,
    onValueChanged: function(e) {
      const needDelayedUpdate = "filterRow" === options2.parentType || "searchPanel" === options2.parentType;
      const isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
      const updateValue = function(e2, notFireEvent) {
        options2 && options2.setValue(e2.value, notFireEvent);
      };
      clearTimeout(data17.valueChangeTimeout);
      if (isInputOrKeyUpEvent && needDelayedUpdate) {
        sharedData.valueChangeTimeout = data17.valueChangeTimeout = setTimeout((function() {
          updateValue(e, data17.valueChangeTimeout !== sharedData.valueChangeTimeout);
        }), isDefined(options2.updateValueTimeout) ? options2.updateValueTimeout : 0);
      } else {
        updateValue(e);
      }
    },
    onKeyDown: function(e) {
      if (isEnterBug && "enter" === normalizeKeyName(e.event)) {
        m_events_engine_default.trigger(renderer_default(e.component._input()), "change");
      }
    },
    valueChangeEvent: "change" + ("filterRow" === options2.parentType ? " keyup input" : "")
  }, options2);
};
var prepareDateBox = function(options2) {
  options2.editorName = "dxDateBox";
  options2.editorOptions = getResultConfig({
    value: options2.value,
    onValueChanged: function(args) {
      options2.setValue(args.value);
    },
    onKeyDown: function(_ref) {
      let {
        component,
        event
      } = _ref;
      const useMaskBehavior = component.option("useMaskBehavior");
      if ((checkEnterBug() || useMaskBehavior) && "enter" === normalizeKeyName(event)) {
        component.blur();
        component.focus();
      }
    },
    displayFormat: options2.format,
    type: options2.dataType,
    dateSerializationFormat: null,
    width: "filterBuilder" === options2.parentType ? void 0 : "auto"
  }, options2);
};
var prepareTextBox = function(options2) {
  const config2 = getTextEditorConfig(options2);
  const isSearching = "searchPanel" === options2.parentType;
  if (options2.editorType && "dxTextBox" !== options2.editorType) {
    config2.value = options2.value;
  } else {
    config2.value = (value2 = options2.value, isDefined(value2) ? value2.toString() : "");
  }
  var value2;
  config2.valueChangeEvent += isSearching ? " keyup input search" : "";
  config2.mode = config2.mode || (isSearching ? "search" : "text");
  options2.editorName = "dxTextBox";
  options2.editorOptions = config2;
};
var prepareNumberBox = function(options2) {
  const config2 = getTextEditorConfig(options2);
  config2.value = isDefined(options2.value) ? options2.value : null;
  options2.editorName = "dxNumberBox";
  options2.editorOptions = config2;
};
var prepareBooleanEditor = function(options2) {
  if ("filterRow" === options2.parentType || "filterBuilder" === options2.parentType) {
    prepareLookupEditor(extend(options2, {
      lookup: {
        displayExpr: function(data17) {
          if (true === data17) {
            return options2.trueText || "true";
          } else if (false === data17) {
            return options2.falseText || "false";
          }
        },
        dataSource: [true, false]
      }
    }));
  } else {
    prepareCheckBox(options2);
  }
};
function watchLookupDataSource(options2) {
  if (options2.row && options2.row.watch && "dataRow" === options2.parentType) {
    const editorOptions = options2.editorOptions || {};
    options2.editorOptions = editorOptions;
    let selectBox;
    const onInitialized = editorOptions.onInitialized;
    editorOptions.onInitialized = function(e) {
      onInitialized && onInitialized.apply(this, arguments);
      selectBox = e.component;
      selectBox.on("disposing", stopWatch);
    };
    let dataSource;
    const stopWatch = options2.row.watch((() => {
      dataSource = options2.lookup.dataSource(options2.row);
      return dataSource && dataSource.filter;
    }), (() => {
      selectBox.option("dataSource", dataSource);
    }), ((row) => {
      options2.row = row;
    }));
  }
}
function prepareLookupEditor(options2) {
  const lookup = options2.lookup;
  let displayGetter;
  let dataSource;
  let postProcess;
  const isFilterRow = "filterRow" === options2.parentType;
  if (lookup) {
    displayGetter = compileGetter(lookup.displayExpr);
    dataSource = lookup.dataSource;
    if (isFunction(dataSource) && !isWrapped(dataSource)) {
      dataSource = dataSource(options2.row || {});
      watchLookupDataSource(options2);
    }
    if (isObject(dataSource) || Array.isArray(dataSource)) {
      dataSource = normalizeDataSourceOptions(dataSource);
      if (isFilterRow) {
        postProcess = dataSource.postProcess;
        dataSource.postProcess = function(items) {
          if (0 === this.pageIndex()) {
            items = items.slice(0);
            items.unshift(null);
          }
          if (postProcess) {
            return postProcess.call(this, items);
          }
          return items;
        };
      }
    }
    const allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
    options2.editorName = options2.editorType ?? "dxSelectBox";
    options2.editorOptions = getResultConfig({
      searchEnabled: true,
      value: options2.value,
      valueExpr: options2.lookup.valueExpr,
      searchExpr: options2.lookup.searchExpr || options2.lookup.displayExpr,
      allowClearing,
      showClearButton: allowClearing,
      displayExpr: function(data17) {
        if (null === data17) {
          return options2.showAllText;
        }
        return displayGetter(data17);
      },
      dataSource,
      onValueChanged: function(e) {
        const params = [e.value];
        !isFilterRow && params.push(e.component.option("text"));
        options2.setValue.apply(this, params);
      }
    }, options2);
  }
}
function prepareCheckBox(options2) {
  options2.editorName = "dxCheckBox";
  options2.editorOptions = getResultConfig({
    elementAttr: {
      id: options2.id
    },
    value: isDefined(options2.value) ? options2.value : void 0,
    hoverStateEnabled: !options2.readOnly,
    focusStateEnabled: !options2.readOnly,
    activeStateEnabled: false,
    onValueChanged: function(e) {
      options2.setValue && options2.setValue(e.value, e);
    }
  }, options2);
}
var createEditorCore = function(that, options2) {
  const $editorElement = renderer_default(options2.editorElement);
  if (options2.editorName && options2.editorOptions && $editorElement[options2.editorName]) {
    if ("dxCheckBox" === options2.editorName || "dxSwitch" === options2.editorName) {
      if (!options2.isOnForm) {
        $editorElement.addClass(that.addWidgetPrefix("checkbox-size"));
        $editorElement.parent().addClass(EDITOR_INLINE_BLOCK);
      }
    }
    that._createComponent($editorElement, options2.editorName, options2.editorOptions);
    if ("dxDateBox" === options2.editorName) {
      const dateBox = $editorElement.dxDateBox("instance");
      const defaultEnterKeyHandler = dateBox._supportedKeys().enter;
      dateBox.registerKeyHandler("enter", ((e) => {
        if (dateBox.option("opened")) {
          defaultEnterKeyHandler(e);
        }
        return true;
      }));
    }
    if ("dxTextArea" === options2.editorName) {
      $editorElement.dxTextArea("instance").registerKeyHandler("enter", (function(event) {
        if ("enter" === normalizeKeyName(event) && !event.ctrlKey && !event.shiftKey) {
          event.stopPropagation();
        }
      }));
    }
  }
};
var prepareCustomEditor = (options2) => {
  options2.editorName = options2.editorType;
  options2.editorOptions = getResultConfig({
    value: options2.value,
    onValueChanged: function(args) {
      options2.setValue(args.value);
    }
  }, options2);
};
var prepareEditor = (options2) => {
  const prepareDefaultEditor = {
    dxDateBox: prepareDateBox,
    dxCheckBox: prepareCheckBox,
    dxNumberBox: prepareNumberBox,
    dxTextBox: prepareTextBox
  };
  if (options2.lookup) {
    prepareLookupEditor(options2);
  } else if (options2.editorType) {
    (prepareDefaultEditor[options2.editorType] ?? prepareCustomEditor)(options2);
  } else {
    switch (options2.dataType) {
      case "date":
      case "datetime":
        prepareDateBox(options2);
        break;
      case "boolean":
        prepareBooleanEditor(options2);
        break;
      case "number":
        prepareNumberBox(options2);
        break;
      default:
        prepareTextBox(options2);
    }
  }
};
var EditorFactoryMixin = (Base) => class extends Base {
  createEditor($container, options2) {
    options2.cancel = false;
    options2.editorElement = getPublicElement($container);
    if (!isDefined(options2.tabIndex)) {
      options2.tabIndex = this.option("tabIndex");
    }
    prepareEditor(options2);
    this.executeAction("onEditorPreparing", options2);
    if (options2.cancel) {
      return;
    }
    if ("dataRow" === options2.parentType && !options2.isOnForm && !isDefined(options2.editorOptions.showValidationMark)) {
      options2.editorOptions.showValidationMark = false;
    }
    createEditorCore(this, options2);
    this.executeAction("onEditorPrepared", options2);
  }
};
var ui_editor_factory_mixin_default = EditorFactoryMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/editor_factory/m_editor_factory.js
var EDITOR_INLINE_BLOCK2 = "dx-editor-inline-block";
var MODULE_NAMESPACE = "dxDataGridEditorFactory";
var UPDATE_FOCUS_EVENTS = addNamespace([CLICK_EVENT_NAME, "focusin"].join(" "), MODULE_NAMESPACE);
var DX_HIDDEN = "dx-hidden";
var ViewControllerWithMixin = ui_editor_factory_mixin_default(m_modules_default.ViewController);
var EditorFactory = class extends ViewControllerWithMixin {
  init() {
    this.createAction("onEditorPreparing", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onEditorPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this._columnsResizerController = this.getController("columnsResizer");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsController = this.getController("columns");
    this._validatingController = this.getController("validating");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
    this._subscribedContainerRoot = this._getContainerRoot();
    m_events_engine_default.on(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
    this._attachContainerEventHandlers();
  }
  dispose() {
    clearTimeout(this._focusTimeoutID);
    clearTimeout(this._updateFocusTimeoutID);
    m_events_engine_default.off(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
  }
  _getFocusedElement($dataGridElement) {
    const rowSelector = this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus";
    const focusedElementSelector = ["td[tabindex]:focus", `${rowSelector}`, "input:focus", "button:focus", "textarea:focus", "div[tabindex]:focus", ".dx-lookup-field:focus", ".dx-checkbox:focus", ".dx-switch:focus", ".dx-dropdownbutton .dx-buttongroup:focus", ".dx-adaptive-item-text:focus"].join(",");
    const $focusedElement = $dataGridElement.find(focusedElementSelector);
    return this.elementIsInsideGrid($focusedElement) && $focusedElement;
  }
  _getFocusCellSelector() {
    return ".dx-row > td";
  }
  _updateFocusCore() {
    const $dataGridElement = this.component && this.component.$element();
    if ($dataGridElement) {
      let $focus = this._getFocusedElement($dataGridElement);
      if ($focus && $focus.length) {
        let isHideBorder;
        if (!$focus.hasClass("dx-cell-focus-disabled") && !$focus.hasClass("dx-row")) {
          const $focusCell = $focus.closest(`${this._getFocusCellSelector()}, .dx-cell-focus-disabled`);
          if ($focusCell.get(0) !== $focus.get(0)) {
            isHideBorder = this._needHideBorder($focusCell);
            $focus = $focusCell;
          }
        }
        if ($focus.length && !$focus.hasClass("dx-cell-focus-disabled")) {
          this.focus($focus, isHideBorder);
          return;
        }
      }
    }
    this.loseFocus();
  }
  _needHideBorder($element) {
    const rowsViewElement = this._rowsView.element();
    const isRowsView = $element.closest(rowsViewElement).length > 0;
    const isEditing = this._editingController.isEditing();
    return $element.hasClass(EDITOR_INLINE_BLOCK2) || isRowsView && !isEditing;
  }
  _updateFocus(e) {
    const that = this;
    const isFocusOverlay = e && e.event && renderer_default(e.event.target).hasClass(that.addWidgetPrefix("focus-overlay"));
    that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
    clearTimeout(that._updateFocusTimeoutID);
    that._updateFocusTimeoutID = setTimeout((() => {
      delete that._updateFocusTimeoutID;
      if (!that._isFocusOverlay) {
        that._updateFocusCore();
      }
      that._isFocusOverlay = false;
    }));
  }
  updateFocusOverlaySize($element, position2) {
    $element.hide();
    const location = position_default.calculate($element, extend({
      collision: "fit"
    }, position2));
    if (location.h.oversize > 0) {
      setOuterWidth($element, getOuterWidth($element) - location.h.oversize);
    }
    if (location.v.oversize > 0) {
      setOuterHeight($element, getOuterHeight($element) - location.v.oversize);
    }
    $element.show();
  }
  callbackNames() {
    return ["focused"];
  }
  getFocusOverlayContainer($focusedElement) {
    return $focusedElement.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getFocusOverlaySize($element) {
    const elementRect = getBoundingRect($element.get(0));
    return {
      width: elementRect.right - elementRect.left + 1,
      height: elementRect.bottom - elementRect.top + 1
    };
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (isHideBorder) {
      this._$focusOverlay.addClass(DX_HIDDEN);
    } else if ($element.length) {
      const align = browser_default.mozilla ? "right bottom" : "left top";
      const isFocusedCellInvalid = $element.hasClass(this.addWidgetPrefix("invalid"));
      const isFocusedCellModified = $element.hasClass("dx-cell-modified") && !isFocusedCellInvalid;
      const $content = this.getFocusOverlayContainer($element);
      const focusOverlaySize = this.getFocusOverlaySize($element);
      this._$focusOverlay.removeClass(DX_HIDDEN).toggleClass("dx-focused-cell-invalid", isFocusedCellInvalid).toggleClass("dx-focused-cell-modified", isFocusedCellModified).appendTo($content);
      setOuterHeight(this._$focusOverlay, focusOverlaySize.height);
      setOuterWidth(this._$focusOverlay, focusOverlaySize.width);
      const focusOverlayPosition = {
        precise: true,
        my: align,
        at: align,
        of: $element,
        boundary: $content.length && $content
      };
      this.updateFocusOverlaySize(this._$focusOverlay, focusOverlayPosition);
      position_default.setup(this._$focusOverlay, focusOverlayPosition);
      this._$focusOverlay.css("visibility", "visible");
    }
  }
  renderFocusOverlay($element, isHideBorder) {
    if (!m_utils_default.isElementInCurrentGrid(this, $element)) {
      return;
    }
    if (!this._$focusOverlay) {
      this._$focusOverlay = renderer_default("<div>").addClass(this.addWidgetPrefix("focus-overlay"));
    }
    this.updateFocusOverlay($element, isHideBorder);
  }
  focus($element, isHideBorder) {
    const that = this;
    if (void 0 === $element) {
      return that._$focusedElement;
    }
    if ($element) {
      if (!$element.is(that._$focusedElement)) {
        that._$focusedElement && that._$focusedElement.removeClass("dx-focused");
      }
      that._$focusedElement = $element;
      clearTimeout(that._focusTimeoutID);
      that._focusTimeoutID = setTimeout((() => {
        delete that._focusTimeoutID;
        that.renderFocusOverlay($element, isHideBorder);
        $element.addClass("dx-focused");
        that.focused.fire($element);
      }));
    }
  }
  refocus() {
    const $focus = this.focus();
    this.focus($focus);
  }
  resize() {
    const $focusedElement = this._$focusedElement;
    if ($focusedElement) {
      this.focus($focusedElement);
    }
  }
  loseFocus(skipValidator) {
    this._$focusedElement && this._$focusedElement.removeClass("dx-focused");
    this._$focusedElement = null;
    this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN);
  }
  _getContainerRoot() {
    var _this$component;
    const $container = null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component.$element();
    const root = dom_adapter_default.getRootNode(null === $container || void 0 === $container ? void 0 : $container.get(0));
    if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !root.host) {
      return dom_adapter_default.getDocument();
    }
    return root;
  }
  _attachContainerEventHandlers() {
    const that = this;
    const $container = that.component && that.component.$element();
    if ($container) {
      m_events_engine_default.on($container, addNamespace("keydown", MODULE_NAMESPACE), ((e) => {
        if ("tab" === normalizeKeyName(e)) {
          that._updateFocusHandler(e);
        }
      }));
    }
  }
  getFocusOverlay() {
    return this._$focusOverlay;
  }
  hasOverlayElements() {
    var _this$_$focusOverlay;
    return !!(null !== (_this$_$focusOverlay = this._$focusOverlay) && void 0 !== _this$_$focusOverlay && _this$_$focusOverlay.length) && !this._$focusOverlay.hasClass(DX_HIDDEN);
  }
};
var editorFactoryModule = {
  defaultOptions: () => ({}),
  controllers: {
    editorFactory: EditorFactory
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editor_factory.js
m_core_default.registerModule("editorFactory", editorFactoryModule);

// node_modules/devextreme/esm/__internal/ui/m_dialog.js
var window12 = getWindow();
var DEFAULT_BUTTON = {
  text: "OK",
  onClick: () => true
};
var getApplyButtonConfig = () => {
  if (isFluent()) {
    return {
      stylingMode: "contained",
      type: "default"
    };
  }
  return {};
};
var getCancelButtonConfig = () => {
  if (isFluent()) {
    return {
      stylingMode: "outlined",
      type: "default"
    };
  }
  return {};
};
var custom = function(options2) {
  const deferred = Deferred();
  options2 = options2 || {};
  const $element = renderer_default("<div>").addClass("dx-dialog").appendTo(value());
  const isMessageDefined = "message" in options2;
  const isMessageHtmlDefined = "messageHtml" in options2;
  if (isMessageDefined) {
    ui_errors_default.log("W1013");
  }
  const messageHtml = String(isMessageHtmlDefined ? options2.messageHtml : options2.message);
  const messageId = options2.title ? null : new guid_default();
  const $message = renderer_default("<div>").addClass("dx-dialog-message").html(messageHtml).attr("id", messageId);
  const popupToolbarItems = [];
  const popupInstance = new ui_popup_default($element, extend({
    title: options2.title ?? "",
    showTitle: ensureDefined(options2.showTitle, true),
    dragEnabled: ensureDefined(options2.dragEnabled, true),
    height: "auto",
    width: options2.width,
    showCloseButton: options2.showCloseButton || false,
    ignoreChildEvents: false,
    container: $element,
    visualContainer: window12,
    dragAndResizeArea: window12,
    onContentReady(args) {
      args.component.$content().addClass("dx-dialog-content").append($message);
      if (messageId) {
        args.component.$overlayContent().attr("aria-labelledby", messageId);
      }
    },
    onShowing(e) {
      e.component.bottomToolbar().addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button");
      m_dom_default.resetActiveElement();
    },
    onShown(e) {
      const $firstButton = e.component.bottomToolbar().find(".dx-button").first();
      m_events_engine_default.trigger($firstButton, "focus");
    },
    onHiding() {
      deferred.reject();
    },
    onHidden(_ref) {
      let {
        element
      } = _ref;
      renderer_default(element).remove();
    },
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    rtlEnabled: config_default2().rtlEnabled,
    position: {
      boundaryOffset: {
        h: 10,
        v: 0
      }
    }
  }, options2.popupOptions, {
    onHidden: (_ref2) => {
      var _options$popupOptions, _options$popupOptions2;
      let {
        element
      } = _ref2;
      renderer_default(element).remove();
      null === (_options$popupOptions = options2.popupOptions) || void 0 === _options$popupOptions || null === (_options$popupOptions2 = _options$popupOptions.onHidden) || void 0 === _options$popupOptions2 || _options$popupOptions2.call(_options$popupOptions, {
        element
      });
    }
  }));
  const buttonOptions = options2.buttons || [DEFAULT_BUTTON];
  buttonOptions.forEach(((options3) => {
    const action = new action_default(options3.onClick, {
      context: popupInstance
    });
    popupToolbarItems.push({
      toolbar: "bottom",
      location: devices_default.current().android ? "after" : "center",
      widget: "dxButton",
      options: _extends({}, options3, {
        onClick() {
          const result2 = action.execute(...arguments);
          hide(result2);
        }
      })
    });
  }));
  popupInstance.option("toolbarItems", popupToolbarItems);
  popupInstance.$wrapper().addClass("dx-dialog-wrapper");
  if (options2.position) {
    popupInstance.option("position", options2.position);
  }
  popupInstance.$wrapper().addClass("dx-dialog-root");
  function hide(value2) {
    deferred.resolve(value2);
    popupInstance.hide();
  }
  return {
    show: function() {
      if ("phone" === devices_default.real().deviceType) {
        const isPortrait = getHeight(window12) > getWidth(window12);
        const width = isPortrait ? "90%" : "60%";
        popupInstance.option({
          width
        });
      }
      popupInstance.show();
      return deferred.promise();
    },
    hide
  };
};
var confirm = function(messageHtml) {
  let title = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
  let showTitle = arguments.length > 2 ? arguments[2] : void 0;
  const options2 = isPlainObject(messageHtml) ? messageHtml : {
    title,
    messageHtml,
    showTitle,
    buttons: [_extends({
      text: message_default.format("Yes"),
      onClick: () => true
    }, getApplyButtonConfig()), _extends({
      text: message_default.format("No"),
      onClick: () => false
    }, getCancelButtonConfig())],
    dragEnabled: showTitle
  };
  return custom(options2).show();
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/const.js
var EDITOR_CELL_CLASS = "dx-editor-cell";
var ROW_CLASS = "dx-row";
var CELL_MODIFIED_CLASS = "dx-cell-modified";
var ROW_SELECTED_CLASS = "dx-selection";
var EDIT_FORM_CLASS = "edit-form";
var DATA_EDIT_DATA_INSERT_TYPE = "insert";
var DATA_EDIT_DATA_REMOVE_TYPE = "remove";
var EDITING_POPUP_OPTION_NAME = "editing.popup";
var EDITING_FORM_OPTION_NAME = "editing.form";
var EDITING_EDITROWKEY_OPTION_NAME = "editing.editRowKey";
var EDITING_EDITCOLUMNNAME_OPTION_NAME = "editing.editColumnName";
var TARGET_COMPONENT_NAME = "targetComponent";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var FOCUSABLE_ELEMENT_SELECTOR = `[tabindex]:not([disabled]), ${EDITORS_INPUT_SELECTOR}:not([disabled])`;
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_ROW = "row";
var EDIT_MODE_CELL = "cell";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_POPUP = "popup";
var FIRST_NEW_ROW_POSITION = "first";
var LAST_NEW_ROW_POSITION = "last";
var PAGE_BOTTOM_NEW_ROW_POSITION = "pageBottom";
var PAGE_TOP_NEW_ROW_POSITION = "pageTop";
var VIEWPORT_BOTTOM_NEW_ROW_POSITION = "viewportBottom";
var VIEWPORT_TOP_NEW_ROW_POSITION = "viewportTop";
var EDIT_MODES = ["batch", "row", "cell", "form", "popup"];
var ROW_BASED_MODES = ["row", "form", "popup"];
var CELL_BASED_MODES = ["batch", "cell"];
var REQUIRED_EDITOR_LABELLEDBY_MODES = ["batch", "row", "cell"];
var MODES_WITH_DELAYED_FOCUS = ["row", "form"];
var READONLY_CLASS = "readonly";
var LINK_CLASS = "dx-link";
var LINK_ICON_CLASS = "dx-link-icon";
var ROW_SELECTED = "dx-selection";
var EDIT_BUTTON_CLASS = "dx-edit-button";
var COMMAND_EDIT_CLASS = "dx-command-edit";
var COMMAND_EDIT_WITH_ICONS_CLASS = "dx-command-edit-with-icons";
var INSERT_INDEX = "__DX_INSERT_INDEX__";
var ROW_INSERTED = "dx-row-inserted";
var ROW_MODIFIED = "dx-row-modified";
var CELL_MODIFIED = "dx-cell-modified";
var EDITING_NAMESPACE = "dxDataGridEditing";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var DATA_EDIT_DATA_UPDATE_TYPE = "update";
var DEFAULT_START_EDIT_ACTION = "click";
var EDIT_LINK_CLASS = {
  save: "dx-link-save",
  cancel: "dx-link-cancel",
  edit: "dx-link-edit",
  undelete: "dx-link-undelete",
  delete: "dx-link-delete",
  add: "dx-link-add"
};
var EDIT_ICON_CLASS = {
  save: "save",
  cancel: "revert",
  edit: "edit",
  undelete: "revert",
  delete: "trash",
  add: "add"
};
var METHOD_NAMES = {
  edit: "editRow",
  delete: "deleteRow",
  undelete: "undeleteRow",
  save: "saveEditData",
  cancel: "cancelEditData",
  add: "addRowByRowIndex"
};
var ACTION_OPTION_NAMES = {
  add: "allowAdding",
  edit: "allowUpdating",
  delete: "allowDeleting"
};
var BUTTON_NAMES = ["edit", "save", "cancel", "delete", "undelete"];
var EDITING_CHANGES_OPTION_NAME = "editing.changes";
var FOCUS_OVERLAY_CLASS = "focus-overlay";
var ADD_ROW_BUTTON_CLASS = "addrow-button";
var DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
var DATA_ROW_CLASS = "dx-data-row";
var ROW_REMOVED = "dx-row-removed";
var FILTER_ROW_CLASS = "filter-row";
var isRenovatedScrollable = !!ui_scrollable_default.IS_RENOVATED_WIDGET;
var EDIT_FORM_ITEM_CLASS = "edit-form-item";
var EDIT_POPUP_CLASS = "edit-popup";
var EDIT_POPUP_FORM_CLASS = "edit-popup-form";
var FOCUSABLE_ELEMENT_CLASS = isRenovatedScrollable ? "dx-scrollable" : "dx-scrollable-container";
var BUTTON_CLASS = "dx-button";
var FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container";
var EDIT_ROW = "dx-edit-row";

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_utils.js
var createFailureHandler = function(deferred) {
  return function(arg) {
    const error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
    deferred.reject(error);
  };
};
var isEditingCell = function(isEditRow2, cellOptions) {
  return cellOptions.isEditing || isEditRow2 && cellOptions.column.allowEditing;
};
var isEditingOrShowEditorAlwaysDataCell = function(isEditRow2, cellOptions) {
  const isCommandCell = !!cellOptions.column.command;
  const isEditing = isEditingCell(isEditRow2, cellOptions);
  const isEditorCell2 = !isCommandCell && (isEditing || cellOptions.column.showEditorAlways);
  return "data" === cellOptions.rowType && isEditorCell2;
};
var getEditingTexts = (options2) => {
  const editingTexts = options2.component.option("editing.texts") || {};
  return {
    save: editingTexts.saveRowChanges,
    cancel: editingTexts.cancelRowChanges,
    edit: editingTexts.editRow,
    undelete: editingTexts.undeleteRow,
    delete: editingTexts.deleteRow,
    add: editingTexts.addRowToNode
  };
};
var generateNewRowTempKey = () => `_DX_KEY_${new guid_default()}`;
var isNewRowTempKey = (key) => "string" === typeof key && key.startsWith("_DX_KEY_") && 44 === key.length;
var getButtonIndex = (buttons, name2) => {
  let result2 = -1;
  buttons.some(((button, index) => {
    if (getButtonName(button) === name2) {
      result2 = index;
      return true;
    }
  }));
  return result2;
};
function getButtonName(button) {
  return isObject(button) ? button.name : button;
}
function isEditable($element) {
  return $element && ($element.is("input") || $element.is("textarea"));
}
var getEditorType = (item) => {
  var _column$formItem;
  const {
    column
  } = item;
  return item.isCustomEditorType ? item.editorType : null === (_column$formItem = column.formItem) || void 0 === _column$formItem ? void 0 : _column$formItem.editorType;
};
var forEachFormItems = (items, callBack) => {
  items.forEach(((item) => {
    if (item.items || item.tabs) {
      forEachFormItems(item.items || item.tabs, callBack);
    } else {
      callBack(item);
    }
  }));
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing.js
var EditingControllerImpl = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._validatingController = this.getController("validating");
    this._editorFactoryController = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsResizerController = this.getController("columnsResizer");
    this._errorHandlingController = this.getController("errorHandling");
    this._rowsView = this.getView("rowsView");
    this._headerPanelView = this.getView("headerPanel");
    this._lastOperation = null;
    this._changes = [];
    if (this._deferreds) {
      this._deferreds.forEach(((d) => {
        d.reject("cancel");
      }));
    }
    this._deferreds = [];
    if (!this._dataChangedHandler) {
      this._dataChangedHandler = this._handleDataChanged.bind(this);
      this._dataController.changed.add(this._dataChangedHandler);
    }
    if (!this._saveEditorHandler) {
      this.createAction("onInitNewRow", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserting", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserted", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditingStart", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdating", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdated", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceling", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceled", {
        excludeValidators: ["disabled", "readOnly"]
      });
    }
    this._updateEditColumn();
    this._updateEditButtons();
    if (!this._internalState) {
      this._internalState = /* @__PURE__ */ new Map();
    }
    this.component._optionsByReference[EDITING_EDITROWKEY_OPTION_NAME] = true;
    this.component._optionsByReference[EDITING_CHANGES_OPTION_NAME] = true;
  }
  getEditMode() {
    const editMode = this.option("editing.mode") ?? EDIT_MODE_ROW;
    if (EDIT_MODES.includes(editMode)) {
      return editMode;
    }
    return EDIT_MODE_ROW;
  }
  isCellBasedEditMode() {
    const editMode = this.getEditMode();
    return CELL_BASED_MODES.includes(editMode);
  }
  _getDefaultEditorTemplate() {
    return (container, options2) => {
      const $editor = renderer_default("<div>").appendTo(container);
      const editorOptions = extend({}, options2.column, {
        value: options2.value,
        setValue: options2.setValue,
        row: options2.row,
        parentType: "dataRow",
        width: null,
        readOnly: !options2.setValue,
        isOnForm: options2.isOnForm,
        id: options2.id
      });
      const needLabel = REQUIRED_EDITOR_LABELLEDBY_MODES.includes(this.getEditMode());
      if (needLabel) {
        editorOptions["aria-labelledby"] = options2.column.headerId;
      }
      this._editorFactoryController.createEditor($editor, editorOptions);
    };
  }
  _getNewRowPosition() {
    const newRowPosition = this.option("editing.newRowPosition");
    const scrollingMode = this.option("scrolling.mode");
    if ("virtual" === scrollingMode) {
      switch (newRowPosition) {
        case PAGE_TOP_NEW_ROW_POSITION:
          return VIEWPORT_TOP_NEW_ROW_POSITION;
        case PAGE_BOTTOM_NEW_ROW_POSITION:
          return VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        default:
          return newRowPosition;
      }
    }
    return newRowPosition;
  }
  getChanges() {
    return this.option(EDITING_CHANGES_OPTION_NAME);
  }
  getInsertRowCount() {
    const changes = this.option(EDITING_CHANGES_OPTION_NAME);
    return changes.filter(((change) => "insert" === change.type)).length;
  }
  resetChanges() {
    const changes = this.getChanges();
    const needReset = null === changes || void 0 === changes ? void 0 : changes.length;
    if (needReset) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, []);
      this._internalState.clear();
    }
  }
  _getInternalData(key) {
    return this._internalState.get(getKeyHash(key));
  }
  _addInternalData(params) {
    const internalData = this._getInternalData(params.key);
    if (internalData) {
      return extend(internalData, params);
    }
    this._internalState.set(getKeyHash(params.key), params);
    return params;
  }
  _getOldData(key) {
    var _this$_getInternalDat;
    return null === (_this$_getInternalDat = this._getInternalData(key)) || void 0 === _this$_getInternalDat ? void 0 : _this$_getInternalDat.oldData;
  }
  getUpdatedData(data17) {
    const key = this._dataController.keyOf(data17);
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (changes[editIndex]) {
      return createObjectWithChanges(data17, changes[editIndex].data);
    }
    return data17;
  }
  getInsertedData() {
    return this.getChanges().filter(((change) => change.data && change.type === DATA_EDIT_DATA_INSERT_TYPE)).map(((change) => change.data));
  }
  getRemovedData() {
    return this.getChanges().filter(((change) => this._getOldData(change.key) && change.type === DATA_EDIT_DATA_REMOVE_TYPE)).map(((change) => this._getOldData(change.key)));
  }
  _fireDataErrorOccurred(arg) {
    if ("cancel" === arg) {
      return;
    }
    const $popupContent = this.getPopupContent();
    this._dataController.dataErrorOccurred.fire(arg, $popupContent);
  }
  _needToCloseEditableCell($targetElement) {
  }
  _closeEditItem($targetElement) {
  }
  _handleDataChanged(args) {
  }
  _isDefaultButtonVisible(button, options2) {
    let result2 = true;
    switch (button.name) {
      case "delete":
        result2 = this.allowDeleting(options2);
        break;
      case "undelete":
        result2 = false;
    }
    return result2;
  }
  isPopupEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_POPUP;
  }
  _isButtonVisible(button, options2) {
    const {
      visible
    } = button;
    if (!isDefined(visible)) {
      return this._isDefaultButtonVisible(button, options2);
    }
    return isFunction(visible) ? visible.call(button, {
      component: options2.component,
      row: options2.row,
      column: options2.column
    }) : visible;
  }
  _isButtonDisabled(button, options2) {
    const {
      disabled
    } = button;
    return isFunction(disabled) ? disabled.call(button, {
      component: options2.component,
      row: options2.row,
      column: options2.column
    }) : !!disabled;
  }
  _getButtonConfig(button, options2) {
    const config2 = isObject(button) ? button : {};
    const buttonName = getButtonName(button);
    const editingTexts = getEditingTexts(options2);
    const methodName = METHOD_NAMES[buttonName];
    const editingOptions = this.option("editing");
    const actionName = ACTION_OPTION_NAMES[buttonName];
    const allowAction = actionName ? editingOptions[actionName] : true;
    return extend({
      name: buttonName,
      text: editingTexts[buttonName],
      cssClass: EDIT_LINK_CLASS[buttonName]
    }, {
      onClick: methodName && ((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        event.preventDefault();
        setTimeout((() => {
          options2.row && allowAction && this[methodName] && this[methodName](options2.row.rowIndex);
        }));
      })
    }, config2);
  }
  _getEditingButtons(options2) {
    let buttonIndex;
    const haveCustomButtons = !!options2.column.buttons;
    let buttons = (options2.column.buttons || []).slice();
    if (haveCustomButtons) {
      buttonIndex = getButtonIndex(buttons, "edit");
      if (buttonIndex >= 0) {
        if (getButtonIndex(buttons, "save") < 0) {
          buttons.splice(buttonIndex + 1, 0, "save");
        }
        if (getButtonIndex(buttons, "cancel") < 0) {
          buttons.splice(getButtonIndex(buttons, "save") + 1, 0, "cancel");
        }
      }
      buttonIndex = getButtonIndex(buttons, "delete");
      if (buttonIndex >= 0 && getButtonIndex(buttons, "undelete") < 0) {
        buttons.splice(buttonIndex + 1, 0, "undelete");
      }
    } else {
      buttons = BUTTON_NAMES.slice();
    }
    return buttons.map(((button) => this._getButtonConfig(button, options2)));
  }
  _renderEditingButtons($container, buttons, options2, change) {
    buttons.forEach(((button) => {
      if (this._isButtonVisible(button, options2)) {
        this._createButton($container, button, options2, change);
      }
    }));
  }
  _getEditCommandCellTemplate() {
    return (container, options2, change) => {
      const $container = renderer_default(container);
      if ("data" === options2.rowType) {
        const buttons = this._getEditingButtons(options2);
        this._renderEditingButtons($container, buttons, options2, change);
        if (options2.watch) {
          const dispose = options2.watch((() => buttons.map(((button) => ({
            visible: this._isButtonVisible(button, options2),
            disabled: this._isButtonDisabled(button, options2)
          })))), (() => {
            $container.empty();
            this._renderEditingButtons($container, buttons, options2);
          }));
          m_events_engine_default.on($container, removeEvent, dispose);
        }
      } else {
        m_utils_default.setEmptyText($container);
      }
    };
  }
  isRowBasedEditMode() {
    const editMode = this.getEditMode();
    return ROW_BASED_MODES.includes(editMode);
  }
  getFirstEditableColumnIndex() {
    let columnIndex;
    const visibleColumns = this._columnsController.getVisibleColumns();
    each(visibleColumns, ((index, column) => {
      if (column.allowEditing) {
        columnIndex = index;
        return false;
      }
    }));
    return columnIndex;
  }
  getFirstEditableCellInRow(rowIndex) {
    var _this$_rowsView;
    const columnIndex = this.getFirstEditableColumnIndex();
    return null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(rowIndex || 0, columnIndex);
  }
  getFocusedCellInRow(rowIndex) {
    return this.getFirstEditableCellInRow(rowIndex);
  }
  getIndexByKey(key, items) {
    return m_utils_default.getIndexByKey(key, items);
  }
  hasChanges(rowIndex) {
    const changes = this.getChanges();
    let result2 = false;
    for (let i = 0; i < (null === changes || void 0 === changes ? void 0 : changes.length); i++) {
      if (changes[i].type && (!isDefined(rowIndex) || this._dataController.getRowIndexByKey(changes[i].key) === rowIndex)) {
        result2 = true;
        break;
      }
    }
    return result2;
  }
  dispose() {
    super.dispose();
    clearTimeout(this._inputFocusTimeoutID);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
  }
  _silentOption(name2, value2) {
    if ("editing.changes" === name2) {
      this._changes = deepExtendArraySafe([], value2);
    }
    super._silentOption(name2, value2);
  }
  optionChanged(args) {
    if ("editing" === args.name) {
      const {
        fullName
      } = args;
      if (fullName === EDITING_EDITROWKEY_OPTION_NAME) {
        this._handleEditRowKeyChange(args);
      } else if (fullName === EDITING_CHANGES_OPTION_NAME) {
        const isEqual2 = equalByValue(args.value, this._changes, {
          maxDepth: 4
        });
        if (!isEqual2) {
          this._changes = deepExtendArraySafe([], args.value);
          this._handleChangesChange(args);
        }
      } else if (!args.handled) {
        this._columnsController.reinit();
        this.init();
        this.resetChanges();
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _handleEditRowKeyChange(args) {
    const rowIndex = this._dataController.getRowIndexByKey(args.value);
    const oldRowIndexCorrection = this._getEditRowIndexCorrection();
    const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
    if (isDefined(args.value)) {
      if (args.value !== args.previousValue) {
        this._editRowFromOptionChanged(rowIndex, oldRowIndex);
      }
    } else {
      this.cancelEditData();
    }
  }
  _handleChangesChange(args) {
    const dataController2 = this._dataController;
    const changes = args.value;
    if (!args.value.length && !args.previousValue.length) {
      return;
    }
    changes.forEach(((change) => {
      if ("insert" === change.type) {
        this._addInsertInfo(change);
      } else {
        var _dataController$items;
        const items = dataController2.getCachedStoreData() || (null === (_dataController$items = dataController2.items()) || void 0 === _dataController$items ? void 0 : _dataController$items.map(((item) => item.data)));
        const rowIndex = m_utils_default.getIndexByKey(change.key, items, dataController2.key());
        this._addInternalData({
          key: change.key,
          oldData: items[rowIndex]
        });
      }
    }));
    dataController2.updateItems({
      repaintChangesOnly: true,
      isLiveUpdate: false,
      isOptionChanged: true
    });
  }
  publicMethods() {
    return ["addRow", "deleteRow", "undeleteRow", "editRow", "saveEditData", "cancelEditData", "hasEditData"];
  }
  refresh() {
    if (!isDefined(this._pageIndex)) {
      return;
    }
    this._refreshCore.apply(this, arguments);
  }
  _refreshCore(params) {
  }
  isEditing() {
    const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
    return isEditRowKeyDefined;
  }
  isEditRow(rowIndex) {
    return false;
  }
  _setEditRowKey(value2, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITROWKEY_OPTION_NAME, value2);
    } else {
      this.option(EDITING_EDITROWKEY_OPTION_NAME, value2);
    }
    if (this._refocusEditCell) {
      this._refocusEditCell = false;
      this._focusEditingCell();
    }
  }
  getEditRowIndex() {
    return this._getVisibleEditRowIndex();
  }
  getEditFormRowIndex() {
    return -1;
  }
  isEditRowByIndex(rowIndex) {
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const isKeyEqual = isDefined(key) && equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key);
    if (isKeyEqual) {
      return this._getVisibleEditRowIndex() === rowIndex;
    }
    return isKeyEqual;
  }
  isEditCell(visibleRowIndex, columnIndex) {
    return this.isEditRowByIndex(visibleRowIndex) && this._getVisibleEditColumnIndex() === columnIndex;
  }
  getPopupContent() {
  }
  _isProcessedItem(item) {
    return false;
  }
  _getInsertRowIndex(items, change, isProcessedItems) {
    let result2 = -1;
    const dataController2 = this._dataController;
    const key = this._getInsertAfterOrBeforeKey(change);
    if (!isDefined(key) && 0 === items.length) {
      result2 = 0;
    } else if (isDefined(key)) {
      items.some(((item, index) => {
        const isProcessedItem = isProcessedItems || this._isProcessedItem(item);
        if (isObject(item)) {
          if (isProcessedItem || isDefined(item[INSERT_INDEX])) {
            if (equalByValue(item.key, key)) {
              result2 = index;
            }
          } else if (equalByValue(dataController2.keyOf(item), key)) {
            result2 = index;
          }
        }
        if (result2 >= 0) {
          const nextItem = items[result2 + 1];
          if (nextItem && ("detail" === nextItem.rowType || "detailAdaptive" === nextItem.rowType) && isDefined(change.insertAfterKey)) {
            return;
          }
          if (isDefined(change.insertAfterKey)) {
            result2 += 1;
          }
          return true;
        }
      }));
    }
    return result2;
  }
  _generateNewItem(key) {
    var _this$_getInternalDat2;
    const item = {
      key
    };
    const insertInfo = null === (_this$_getInternalDat2 = this._getInternalData(key)) || void 0 === _this$_getInternalDat2 ? void 0 : _this$_getInternalDat2.insertInfo;
    if (null !== insertInfo && void 0 !== insertInfo && insertInfo[INSERT_INDEX]) {
      item[INSERT_INDEX] = insertInfo[INSERT_INDEX];
    }
    return item;
  }
  _getLoadedRowIndex(items, change, isProcessedItems) {
    let loadedRowIndex = this._getInsertRowIndex(items, change, isProcessedItems);
    const dataController2 = this._dataController;
    if (loadedRowIndex < 0) {
      const newRowPosition = this._getNewRowPosition();
      const pageIndex = dataController2.pageIndex();
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      if (newRowPosition !== LAST_NEW_ROW_POSITION && 0 === pageIndex && !isDefined(insertAfterOrBeforeKey)) {
        loadedRowIndex = 0;
      } else if (newRowPosition === LAST_NEW_ROW_POSITION && dataController2.isLastPageLoaded()) {
        loadedRowIndex = items.length;
      }
    }
    return loadedRowIndex;
  }
  processItems(items, e) {
    const {
      changeType
    } = e;
    this.update(changeType);
    const changes = this.getChanges();
    changes.forEach(((change) => {
      var _this$_getInternalDat3;
      const isInsert = change.type === DATA_EDIT_DATA_INSERT_TYPE;
      if (!isInsert) {
        return;
      }
      let {
        key
      } = change;
      let insertInfo = null === (_this$_getInternalDat3 = this._getInternalData(key)) || void 0 === _this$_getInternalDat3 ? void 0 : _this$_getInternalDat3.insertInfo;
      if (!isDefined(key) || !isDefined(insertInfo)) {
        insertInfo = this._addInsertInfo(change);
        key = insertInfo.key;
      }
      const loadedRowIndex = this._getLoadedRowIndex(items, change);
      const item = this._generateNewItem(key);
      if (loadedRowIndex >= 0) {
        items.splice(loadedRowIndex, 0, item);
      }
    }));
    return items;
  }
  processDataItem(item, options2, generateDataValues) {
    const columns7 = options2.visibleColumns;
    const key = item.data[INSERT_INDEX] ? item.data.key : item.key;
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    item.isEditing = false;
    if (editIndex >= 0) {
      this._processDataItemCore(item, changes[editIndex], key, columns7, generateDataValues);
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    switch (type2) {
      case DATA_EDIT_DATA_INSERT_TYPE:
        item.isNewRow = true;
        item.key = key;
        item.data = data17;
        break;
      case DATA_EDIT_DATA_UPDATE_TYPE:
        item.modified = true;
        item.oldData = item.data;
        item.data = createObjectWithChanges(item.data, data17);
        item.modifiedValues = generateDataValues(data17, columns7, true);
        break;
      case DATA_EDIT_DATA_REMOVE_TYPE:
        item.removed = true;
    }
  }
  _initNewRow(options2) {
    this.executeAction("onInitNewRow", options2);
    if (options2.promise) {
      const deferred = new Deferred();
      when(fromPromise(options2.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail(((arg) => this._fireDataErrorOccurred(arg)));
      return deferred;
    }
  }
  _createInsertInfo() {
    const insertInfo = {};
    insertInfo[INSERT_INDEX] = this._getInsertIndex();
    return insertInfo;
  }
  _addInsertInfo(change, parentKey) {
    var _this$_getInternalDat4;
    let insertInfo;
    change.key = this.getChangeKeyValue(change);
    const {
      key
    } = change;
    insertInfo = null === (_this$_getInternalDat4 = this._getInternalData(key)) || void 0 === _this$_getInternalDat4 ? void 0 : _this$_getInternalDat4.insertInfo;
    if (!isDefined(insertInfo)) {
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      insertInfo = this._createInsertInfo();
      if (!isDefined(insertAfterOrBeforeKey)) {
        this._setInsertAfterOrBeforeKey(change, parentKey);
      }
    }
    this._addInternalData({
      insertInfo,
      key
    });
    return {
      insertInfo,
      key
    };
  }
  getChangeKeyValue(change) {
    if (isDefined(change.key)) {
      return change.key;
    }
    const keyExpr = this._dataController.key();
    let keyValue;
    if (change.data && keyExpr && !Array.isArray(keyExpr)) {
      keyValue = change.data[keyExpr];
    }
    if (!isDefined(keyValue)) {
      keyValue = generateNewRowTempKey();
    }
    return keyValue;
  }
  _setInsertAfterOrBeforeKey(change, parentKey) {
    const rowsView18 = this.getView("rowsView");
    const dataController2 = this._dataController;
    const allItems = dataController2.items(true);
    const newRowPosition = this._getNewRowPosition();
    switch (newRowPosition) {
      case FIRST_NEW_ROW_POSITION:
      case LAST_NEW_ROW_POSITION:
        break;
      case PAGE_TOP_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertBeforeKey = allItems[0].key;
        }
        break;
      case PAGE_BOTTOM_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertAfterKey = allItems[allItems.length - 1].key;
        }
        break;
      default: {
        const isViewportBottom = newRowPosition === VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        let visibleItemIndex = isViewportBottom ? null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getBottomVisibleItemIndex() : null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getTopVisibleItemIndex();
        const row = dataController2.getVisibleRows()[visibleItemIndex];
        if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
          visibleItemIndex++;
        }
        const insertKey = dataController2.getKeyByRowIndex(visibleItemIndex);
        if (isDefined(insertKey)) {
          change.insertBeforeKey = insertKey;
        }
      }
    }
  }
  _getInsertIndex() {
    let maxInsertIndex = 0;
    this.getChanges().forEach(((editItem) => {
      var _this$_getInternalDat5;
      const insertInfo = null === (_this$_getInternalDat5 = this._getInternalData(editItem.key)) || void 0 === _this$_getInternalDat5 ? void 0 : _this$_getInternalDat5.insertInfo;
      if (isDefined(insertInfo) && editItem.type === DATA_EDIT_DATA_INSERT_TYPE && insertInfo[INSERT_INDEX] > maxInsertIndex) {
        maxInsertIndex = insertInfo[INSERT_INDEX];
      }
    }));
    return maxInsertIndex + 1;
  }
  _getInsertAfterOrBeforeKey(insertChange) {
    return insertChange.insertAfterKey ?? insertChange.insertBeforeKey;
  }
  _getPageIndexToInsertRow() {
    const newRowPosition = this._getNewRowPosition();
    const dataController2 = this._dataController;
    const pageIndex = dataController2.pageIndex();
    const lastPageIndex = dataController2.pageCount() - 1;
    if (newRowPosition === FIRST_NEW_ROW_POSITION && 0 !== pageIndex) {
      return 0;
    }
    if (newRowPosition === LAST_NEW_ROW_POSITION && pageIndex !== lastPageIndex) {
      return lastPageIndex;
    }
    return -1;
  }
  addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    if (!store) {
      dataController2.fireError("E1052", this.component.NAME);
      return new Deferred().reject();
    }
    return this._addRow(parentKey);
  }
  _addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    const key = store && store.key();
    const param = {
      data: {}
    };
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const deferred = new Deferred();
    this.refresh({
      allowCancelEditing: true
    });
    if (!this._allowRowAdding()) {
      when(this._navigateToNewRow(oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      return deferred.promise();
    }
    if (!key) {
      param.data.__KEY__ = String(new guid_default());
    }
    when(this._initNewRow(param, parentKey)).done((() => {
      if (this._allowRowAdding()) {
        when(this._addRowCore(param.data, parentKey, oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      } else {
        deferred.reject("cancel");
      }
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _allowRowAdding(params) {
    const insertIndex = this._getInsertIndex();
    if (insertIndex > 1) {
      return false;
    }
    return true;
  }
  _addRowCore(data17, parentKey, initialOldEditRowIndex) {
    const change = {
      data: data17,
      type: DATA_EDIT_DATA_INSERT_TYPE
    };
    const editRowIndex = this._getVisibleEditRowIndex();
    const insertInfo = this._addInsertInfo(change, parentKey);
    const {
      key
    } = insertInfo;
    this._setEditRowKey(key, true);
    this._addChange(change);
    return this._navigateToNewRow(initialOldEditRowIndex, change, editRowIndex);
  }
  _navigateToNewRow(oldEditRowIndex, change, editRowIndex) {
    const d = new Deferred();
    const dataController2 = this._dataController;
    editRowIndex = editRowIndex ?? -1;
    change = change ?? this.getChanges().filter(((c) => c.type === DATA_EDIT_DATA_INSERT_TYPE))[0];
    if (!change) {
      return d.reject("cancel").promise();
    }
    const pageIndexToInsertRow = this._getPageIndexToInsertRow();
    let rowIndex = this._getLoadedRowIndex(dataController2.items(), change, true);
    const navigateToRowByKey = (key) => {
      var _this$_focusControlle;
      when(null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.navigateToRow(key)).done((() => {
        rowIndex = dataController2.getRowIndexByKey(change.key);
        d.resolve();
      }));
    };
    const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
    if (pageIndexToInsertRow >= 0) {
      dataController2.pageIndex(pageIndexToInsertRow).done((() => {
        navigateToRowByKey(change.key);
      })).fail(d.reject);
    } else if (rowIndex < 0 && isDefined(insertAfterOrBeforeKey)) {
      navigateToRowByKey(insertAfterOrBeforeKey);
    } else {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, editRowIndex, rowIndex]
      });
      rowIndex = dataController2.getRowIndexByKey(change.key);
      if (rowIndex < 0) {
        navigateToRowByKey(change.key);
      } else {
        d.resolve();
      }
    }
    d.done((() => {
      var _this$_rowsView2;
      null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.waitAsyncTemplates(true).done((() => {
        this._showAddedRow(rowIndex);
        this._afterInsertRow(change.key);
      }));
    }));
    return d.promise();
  }
  _showAddedRow(rowIndex) {
    this._focusFirstEditableCellInRow(rowIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
  }
  _focusFirstEditableCellInRow(rowIndex) {
    var _this$_keyboardNaviga;
    const dataController2 = this._dataController;
    const key = dataController2.getKeyByRowIndex(rowIndex);
    const $firstCell = this.getFirstEditableCellInRow(rowIndex);
    null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga || _this$_keyboardNaviga.focus($firstCell);
    this.option("focusedRowKey", key);
    this._editCellInProgress = true;
    this._delayedInputFocus($firstCell, (() => {
      rowIndex = dataController2.getRowIndexByKey(key);
      this._editCellInProgress = false;
      this._beforeFocusElementInRow(rowIndex);
    }));
  }
  _isEditingStart(options2) {
    this.executeAction("onEditingStart", options2);
    return options2.cancel;
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
  }
  _getVisibleEditColumnIndex() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    if (!isDefined(editColumnName)) {
      return -1;
    }
    return this._columnsController.getVisibleColumnIndex(editColumnName);
  }
  _setEditColumnNameByIndex(index, silent) {
    var _visibleColumns$index;
    const visibleColumns = this._columnsController.getVisibleColumns();
    this._setEditColumnName(null === (_visibleColumns$index = visibleColumns[index]) || void 0 === _visibleColumns$index ? void 0 : _visibleColumns$index.name, silent);
  }
  _setEditColumnName(name2, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
    } else {
      this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
    }
  }
  _resetEditColumnName() {
    this._setEditColumnName(null, true);
  }
  _getEditColumn() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    return this._getColumnByName(editColumnName);
  }
  _getColumnByName(name2) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let editColumn;
    isDefined(name2) && visibleColumns.some(((column) => {
      if (column.name === name2) {
        editColumn = column;
        return true;
      }
    }));
    return editColumn;
  }
  _getVisibleEditRowIndex(columnName) {
    const dataController2 = this._dataController;
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const rowIndex = dataController2.getRowIndexByKey(editRowKey);
    if (-1 === rowIndex) {
      return rowIndex;
    }
    return rowIndex + this._getEditRowIndexCorrection(columnName);
  }
  _getEditRowIndexCorrection(columnName) {
    const editColumn = columnName ? this._getColumnByName(columnName) : this._getEditColumn();
    const isColumnHidden = "adaptiveHidden" === (null === editColumn || void 0 === editColumn ? void 0 : editColumn.visibleWidth);
    return isColumnHidden ? 1 : 0;
  }
  _resetEditRowKey() {
    this._refocusEditCell = false;
    this._setEditRowKey(null, true);
  }
  _resetEditIndices() {
    this._resetEditColumnName();
    this._resetEditRowKey();
  }
  editRow(rowIndex) {
    const dataController2 = this._dataController;
    const items = dataController2.items();
    const item = items[rowIndex];
    const params = {
      data: item && item.data,
      cancel: false
    };
    const oldRowIndex = this._getVisibleEditRowIndex();
    if (!item) {
      return;
    }
    if (rowIndex === oldRowIndex) {
      return true;
    }
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (!item.isNewRow) {
      params.key = item.key;
    }
    if (this._isEditingStart(params)) {
      return;
    }
    this.resetChanges();
    this.init();
    this._resetEditColumnName();
    this._pageIndex = dataController2.pageIndex();
    this._addInternalData({
      key: item.key,
      oldData: item.oldData ?? item.data
    });
    this._setEditRowKey(item.key);
  }
  _editRowFromOptionChanged(rowIndex, oldRowIndex) {
    const rowIndices = [oldRowIndex, rowIndex];
    this._beforeUpdateItems(rowIndices, rowIndex, oldRowIndex);
    this._editRowFromOptionChangedCore(rowIndices, rowIndex);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex, preventRendering) {
    this._needFocusEditor = true;
    this._dataController.updateItems({
      changeType: "update",
      rowIndices,
      cancel: preventRendering
    });
  }
  _focusEditorIfNeed() {
  }
  _showEditPopup(rowIndex, repaintForm) {
  }
  _repaintEditPopup() {
  }
  _getEditPopupHiddenHandler() {
    return (e) => {
      if (this.isEditing()) {
        this.cancelEditData();
      }
    };
  }
  _getPopupEditFormTemplate(rowIndex) {
  }
  _getSaveButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.saveRowChanges"),
      onClick: this.saveEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "contained";
      buttonConfig.type = "default";
    }
    return buttonConfig;
  }
  _getCancelButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.cancelRowChanges"),
      onClick: this.cancelEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "outlined";
    }
    return buttonConfig;
  }
  _removeInternalData(key) {
    this._internalState.delete(getKeyHash(key));
  }
  _updateInsertAfterOrBeforeKeys(changes, index) {
    const removeChange = changes[index];
    changes.forEach(((change) => {
      if (change.type === DATA_EDIT_DATA_INSERT_TYPE) {
        const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
        if (equalByValue(insertAfterOrBeforeKey, removeChange.key)) {
          change[isDefined(change.insertAfterKey) ? "insertAfterKey" : "insertBeforeKey"] = this._getInsertAfterOrBeforeKey(removeChange);
        }
      }
    }));
  }
  _removeChange(index) {
    if (index >= 0) {
      const changes = [...this.getChanges()];
      const {
        key
      } = changes[index];
      this._removeInternalData(key);
      this._updateInsertAfterOrBeforeKeys(changes, index);
      changes.splice(index, 1);
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
      if (equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key)) {
        this._resetEditIndices();
      }
    }
  }
  executeOperation(deferred, func) {
    this._lastOperation && this._lastOperation.reject();
    this._lastOperation = deferred;
    this.waitForDeferredOperations().done((() => {
      if ("rejected" === deferred.state()) {
        return;
      }
      func();
      this._lastOperation = null;
    })).fail((() => {
      deferred.reject();
      this._lastOperation = null;
    }));
  }
  waitForDeferredOperations() {
    return when(...this._deferreds);
  }
  _processCanceledEditingCell() {
  }
  _repaintEditCell(column, oldColumn, oldEditRowIndex) {
    if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
      this._editCellInProgress = true;
      this._needFocusEditor = true;
      this._editorFactoryController.loseFocus();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, this._getVisibleEditRowIndex()]
      });
    } else if (column !== oldColumn) {
      this._needFocusEditor = true;
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: []
      });
    }
  }
  _delayedInputFocus($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
    const inputFocus = () => {
      if (beforeFocusCallback) {
        beforeFocusCallback();
      }
      if ($cell) {
        const $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();
        m_utils_default.focusAndSelectElement(this, $focusableElement);
      }
      this._beforeFocusCallback = null;
    };
    if (devices_default.real().ios || devices_default.real().android) {
      inputFocus();
    } else {
      if (this._beforeFocusCallback) {
        this._beforeFocusCallback();
      }
      clearTimeout(this._inputFocusTimeoutID);
      if (callBeforeFocusCallbackAlways) {
        this._beforeFocusCallback = beforeFocusCallback;
      }
      this._inputFocusTimeoutID = setTimeout(inputFocus);
    }
  }
  _focusEditingCell(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
    const editColumnIndex = this._getVisibleEditColumnIndex();
    $editCell = $editCell || this._rowsView && this._rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
    if ($editCell) {
      this._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways);
    }
  }
  deleteRow(rowIndex) {
    this._checkAndDeleteRow(rowIndex);
  }
  _checkAndDeleteRow(rowIndex) {
    const editingOptions = this.option("editing");
    const editingTexts = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.texts;
    const confirmDelete = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.confirmDelete;
    const confirmDeleteMessage = null === editingTexts || void 0 === editingTexts ? void 0 : editingTexts.confirmDeleteMessage;
    const item = this._dataController.items()[rowIndex];
    const allowDeleting = !this.isEditing() || item.isNewRow;
    if (item && allowDeleting) {
      if (!confirmDelete || !confirmDeleteMessage) {
        this._deleteRowCore(rowIndex);
      } else {
        const confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;
        const showDialogTitle = isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
        confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(((confirmResult) => {
          if (confirmResult) {
            this._deleteRowCore(rowIndex);
          }
        }));
      }
    }
  }
  _deleteRowCore(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const key = item && item.key;
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    this.refresh();
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (editIndex >= 0) {
      if (changes[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
        this._removeChange(editIndex);
      } else {
        this._addChange({
          key,
          type: DATA_EDIT_DATA_REMOVE_TYPE
        });
      }
    } else {
      this._addChange({
        key,
        oldData: item.data,
        type: DATA_EDIT_DATA_REMOVE_TYPE
      });
    }
    return this._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    return this.saveEditData();
  }
  undeleteRow(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const key = item && item.key;
    const changes = this.getChanges();
    if (item) {
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const {
          data: data17
        } = changes[editIndex];
        if (isEmptyObject(data17)) {
          this._removeChange(editIndex);
        } else {
          this._addChange({
            key,
            type: DATA_EDIT_DATA_UPDATE_TYPE
          });
        }
        dataController2.updateItems({
          changeType: "update",
          rowIndices: [oldEditRowIndex, rowIndex]
        });
      }
    }
  }
  _fireOnSaving() {
    const onSavingParams = {
      cancel: false,
      promise: null,
      changes: [...this.getChanges()]
    };
    this.executeAction("onSaving", onSavingParams);
    const d = new Deferred();
    when(fromPromise(onSavingParams.promise)).done((() => {
      d.resolve(onSavingParams);
    })).fail(((arg) => {
      createFailureHandler(d);
      this._fireDataErrorOccurred(arg);
      d.resolve({
        cancel: true
      });
    }));
    return d;
  }
  _executeEditingAction(actionName, params, func) {
    if (this.component._disposed) {
      return null;
    }
    const deferred = new Deferred();
    this.executeAction(actionName, params);
    when(fromPromise(params.cancel)).done(((cancel) => {
      if (cancel) {
        setTimeout((() => {
          deferred.resolve("cancel");
        }));
      } else {
        func(params).done(deferred.resolve).fail(createFailureHandler(deferred));
      }
    })).fail(createFailureHandler(deferred));
    return deferred;
  }
  _processChanges(deferreds, results, dataChanges, changes) {
    const store = this._dataController.store();
    each(changes, ((index, change) => {
      const oldData = this._getOldData(change.key);
      const {
        data: data17,
        type: type2
      } = change;
      const changeCopy = _extends({}, change);
      let deferred;
      let params;
      if (this._beforeSaveEditData(change, index)) {
        return;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          params = {
            data: oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowRemoving", params, (() => store.remove(change.key).done(((key) => {
            dataChanges.push({
              type: "remove",
              key
            });
          }))));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          params = {
            data: data17,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowInserting", params, (() => store.insert(params.data).done(((data18, key) => {
            if (isDefined(key)) {
              changeCopy.key = key;
            }
            if (data18 && isObject(data18) && data18 !== params.data) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "insert",
              data: data18,
              index: 0
            });
          }))));
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          params = {
            newData: data17,
            oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowUpdating", params, (() => store.update(change.key, params.newData).done(((data18, key) => {
            if (data18 && isObject(data18) && data18 !== params.newData) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "update",
              key,
              data: data18
            });
          }))));
      }
      changes[index] = changeCopy;
      if (deferred) {
        const doneDeferred = new Deferred();
        deferred.always(((data18) => {
          results.push({
            key: change.key,
            result: data18
          });
        })).always(doneDeferred.resolve);
        deferreds.push(doneDeferred.promise());
      }
    }));
  }
  _processRemoveIfError(changes, editIndex) {
    const change = changes[editIndex];
    if ((null === change || void 0 === change ? void 0 : change.type) === DATA_EDIT_DATA_REMOVE_TYPE) {
      if (editIndex >= 0) {
        changes.splice(editIndex, 1);
      }
    }
    return true;
  }
  _processRemove(changes, editIndex, cancel) {
    const change = changes[editIndex];
    if (!cancel || !change || change.type === DATA_EDIT_DATA_REMOVE_TYPE) {
      return this._processRemoveCore(changes, editIndex, !cancel || !change);
    }
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (editIndex >= 0) {
      changes.splice(editIndex, 1);
    }
    return true;
  }
  _processSaveEditDataResult(results) {
    let hasSavedData = false;
    const originalChanges = this.getChanges();
    const changes = [...originalChanges];
    const changesLength = changes.length;
    for (let i = 0; i < results.length; i++) {
      const arg = results[i].result;
      const cancel = "cancel" === arg;
      const editIndex = m_utils_default.getIndexByKey(results[i].key, changes);
      const change = changes[editIndex];
      const isError = arg && arg instanceof Error;
      if (isError) {
        if (change) {
          this._addInternalData({
            key: change.key,
            error: arg
          });
        }
        this._fireDataErrorOccurred(arg);
        if (this._processRemoveIfError(changes, editIndex)) {
          break;
        }
      } else if (this._processRemove(changes, editIndex, cancel)) {
        hasSavedData = !cancel;
        const removedChangeIndex = m_utils_default.getIndexByKey(results[i].key, originalChanges);
        this._updateInsertAfterOrBeforeKeys(originalChanges, removedChangeIndex);
      }
    }
    if (changes.length < changesLength) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    }
    return hasSavedData;
  }
  _fireSaveEditDataEvents(changes) {
    each(changes, ((_, _ref) => {
      let {
        data: data17,
        key,
        type: type2
      } = _ref;
      const internalData = this._addInternalData({
        key
      });
      const params = {
        key,
        data: data17
      };
      if (internalData.error) {
        params.error = internalData.error;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          this.executeAction("onRowRemoved", extend({}, params, {
            data: internalData.oldData
          }));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          this.executeAction("onRowInserted", params);
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          this.executeAction("onRowUpdated", params);
      }
    }));
    this.executeAction("onSaved", {
      changes
    });
  }
  saveEditData() {
    const deferred = new Deferred();
    this.waitForDeferredOperations().done((() => {
      if (this.isSaving()) {
        this._resolveAfterSave(deferred);
        return;
      }
      when(this._beforeSaveEditData()).done(((cancel) => {
        if (cancel) {
          this._resolveAfterSave(deferred, {
            cancel
          });
          return;
        }
        this._saving = true;
        this._saveEditDataInner().always((() => {
          this._saving = false;
          if (this._refocusEditCell) {
            this._focusEditingCell();
          }
        })).done(deferred.resolve).fail(deferred.reject);
      })).fail(deferred.reject);
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _resolveAfterSave(deferred) {
    let {
      cancel,
      error
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    when(this._afterSaveEditData(cancel)).done((() => {
      deferred.resolve(error);
    })).fail(deferred.reject);
  }
  _saveEditDataInner() {
    const result2 = new Deferred();
    const results = [];
    const deferreds = [];
    const dataChanges = [];
    const dataSource = this._dataController.dataSource();
    when(this._fireOnSaving()).done(((_ref2) => {
      let {
        cancel,
        changes
      } = _ref2;
      if (cancel) {
        return result2.resolve().promise();
      }
      this._processChanges(deferreds, results, dataChanges, changes);
      if (deferreds.length) {
        this._refocusEditCell = true;
        null === dataSource || void 0 === dataSource || dataSource.beginLoading();
        when(...deferreds).done((() => {
          if (this._processSaveEditDataResult(results)) {
            this._endSaving(dataChanges, changes, result2);
          } else {
            null === dataSource || void 0 === dataSource || dataSource.endLoading();
            result2.resolve();
          }
        })).fail(((error) => {
          null === dataSource || void 0 === dataSource || dataSource.endLoading();
          result2.resolve(error);
        }));
        return result2.always((() => {
          this._refocusEditCell = true;
        })).promise();
      }
      this._cancelSaving(result2);
    })).fail(result2.reject);
    return result2.promise();
  }
  _beforeEndSaving(changes) {
    this._resetEditIndices();
  }
  _endSaving(dataChanges, changes, deferred) {
    const dataSource = this._dataController.dataSource();
    this._beforeEndSaving(changes);
    null === dataSource || void 0 === dataSource || dataSource.endLoading();
    this._refreshDataAfterSave(dataChanges, changes, deferred);
  }
  _cancelSaving(result2) {
    this.executeAction("onSaved", {
      changes: []
    });
    this._resolveAfterSave(result2);
  }
  _refreshDataAfterSave(dataChanges, changes, deferred) {
    const dataController2 = this._dataController;
    const refreshMode = this.option("editing.refreshMode");
    const isFullRefresh = "reshape" !== refreshMode && "repaint" !== refreshMode;
    if (!isFullRefresh) {
      dataController2.push(dataChanges);
    }
    when(dataController2.refresh({
      selection: isFullRefresh,
      reload: isFullRefresh,
      load: "reshape" === refreshMode,
      changesOnly: this.option("repaintChangesOnly")
    })).always((() => {
      this._fireSaveEditDataEvents(changes);
    })).done((() => {
      this._resolveAfterSave(deferred);
    })).fail(((error) => {
      this._resolveAfterSave(deferred, {
        error
      });
    }));
  }
  isSaving() {
    return this._saving;
  }
  _updateEditColumn() {
    const isEditColumnVisible = this._isEditColumnVisible();
    const useIcons = this.option("editing.useIcons");
    const cssClass = COMMAND_EDIT_CLASS + (useIcons ? ` ${COMMAND_EDIT_WITH_ICONS_CLASS}` : "");
    this._columnsController.addCommandColumn({
      type: "buttons",
      command: "edit",
      visible: isEditColumnVisible,
      cssClass,
      width: "auto",
      alignment: "center",
      cellTemplate: this._getEditCommandCellTemplate(),
      fixedPosition: "right"
    });
    this._columnsController.columnOption("command:edit", {
      visible: isEditColumnVisible,
      cssClass
    });
  }
  _isEditColumnVisible() {
    const editingOptions = this.option("editing");
    return editingOptions.allowDeleting;
  }
  _isEditButtonDisabled() {
    const hasChanges = this.hasChanges();
    const isEditRowDefined = isDefined(this.option("editing.editRowKey"));
    return !(isEditRowDefined || hasChanges);
  }
  _updateEditButtons() {
    const isButtonDisabled = this._isEditButtonDisabled();
    if (this._headerPanelView) {
      this._headerPanelView.setToolbarItemDisabled("saveButton", isButtonDisabled);
      this._headerPanelView.setToolbarItemDisabled("revertButton", isButtonDisabled);
    }
  }
  _applyModified($element, options2) {
    $element && $element.addClass(CELL_MODIFIED);
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
  }
  cancelEditData() {
    const changes = this.getChanges();
    const params = {
      cancel: false,
      changes
    };
    this.executeAction("onEditCanceling", params);
    if (!params.cancel) {
      this._cancelEditDataCore();
      this.executeAction("onEditCanceled", {
        changes
      });
    }
  }
  _cancelEditDataCore() {
    const rowIndex = this._getVisibleEditRowIndex();
    this._beforeCancelEditData();
    this.init();
    this.resetChanges();
    this._resetEditColumnName();
    this._resetEditRowKey();
    this._afterCancelEditData(rowIndex);
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    dataController2.updateItems({
      repaintChangesOnly: this.option("repaintChangesOnly")
    });
  }
  _hideEditPopup() {
  }
  hasEditData() {
    return this.hasChanges();
  }
  update(changeType) {
    const dataController2 = this._dataController;
    if (dataController2 && this._pageIndex !== dataController2.pageIndex()) {
      if ("refresh" === changeType) {
        this.refresh({
          isPageChanged: true
        });
      }
      this._pageIndex = dataController2.pageIndex();
    }
    this._updateEditButtons();
  }
  _getRowIndicesForCascadeUpdating(row, skipCurrentRow) {
    return skipCurrentRow ? [] : [row.rowIndex];
  }
  addDeferred(deferred) {
    if (!this._deferreds.includes(deferred)) {
      this._deferreds.push(deferred);
      deferred.always((() => {
        const index = this._deferreds.indexOf(deferred);
        if (index >= 0) {
          this._deferreds.splice(index, 1);
        }
      }));
    }
  }
  _prepareChange(options2, value2, text) {
    var _options$row;
    const newData = {};
    const oldData = null === (_options$row = options2.row) || void 0 === _options$row ? void 0 : _options$row.data;
    const rowKey = options2.key;
    const deferred = new Deferred();
    if (void 0 !== rowKey) {
      options2.value = value2;
      const setCellValueResult = fromPromise(options2.column.setCellValue(newData, value2, extend(true, {}, oldData), text));
      setCellValueResult.done((() => {
        deferred.resolve({
          data: newData,
          key: rowKey,
          oldData,
          type: DATA_EDIT_DATA_UPDATE_TYPE
        });
      })).fail(createFailureHandler(deferred)).fail(((arg) => this._fireDataErrorOccurred(arg)));
      if (isDefined(text) && options2.column.displayValueMap) {
        options2.column.displayValueMap[value2] = text;
      }
      this._updateRowValues(options2);
      this.addDeferred(deferred);
    }
    return deferred;
  }
  _updateRowValues(options2) {
    if (options2.values) {
      const dataController2 = this._dataController;
      const rowIndex = dataController2.getRowIndexByKey(options2.key);
      const row = dataController2.getVisibleRows()[rowIndex];
      if (row) {
        options2.row.values = row.values;
        options2.values = row.values;
      }
      options2.values[options2.columnIndex] = options2.value;
    }
  }
  updateFieldValue(options2, value2, text, forceUpdateRow) {
    const rowKey = options2.key;
    const deferred = new Deferred();
    if (void 0 === rowKey) {
      this._dataController.fireError("E1043");
    }
    if (options2.column.setCellValue) {
      this._prepareChange(options2, value2, text).done(((params) => {
        when(this._applyChange(options2, params, forceUpdateRow)).always((() => {
          deferred.resolve();
        }));
      }));
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _focusPreviousEditingCellIfNeed(options2) {
    if (this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex)) {
      this._focusEditingCell();
      this._updateEditRow(options2.row, true);
      return true;
    }
  }
  _needUpdateRow(column) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    if (!column) {
      column = this._getEditColumn();
    }
    const isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;
    const isCustomCalculateCellValue = visibleColumns.some(((visibleColumn) => visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue));
    return isCustomSetCellValue || isCustomCalculateCellValue;
  }
  _applyChange(options2, params, forceUpdateRow) {
    const changeOptions = _extends({}, options2, {
      forceUpdateRow
    });
    this._addChange(params, changeOptions);
    this._updateEditButtons();
    return this._applyChangeCore(options2, changeOptions.forceUpdateRow);
  }
  _applyChangeCore(options2, forceUpdateRow) {
    const isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
    const {
      row
    } = options2;
    if (row) {
      if (forceUpdateRow || isCustomSetCellValue) {
        this._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
      } else if (row.update) {
        row.update();
      }
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    this._dataController.updateItems({
      changeType: "update",
      rowIndices: this._getRowIndicesForCascadeUpdating(row, skipCurrentRow)
    });
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (forceUpdateRow) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      this._updateRowWithDelay(row, isCustomSetCellValue);
    }
  }
  _updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue) {
    this._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);
    this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
    if (!forceUpdateRow) {
      this._focusEditingCell();
    }
  }
  _updateRowWithDelay(row, isCustomSetCellValue) {
    const deferred = new Deferred();
    this.addDeferred(deferred);
    setTimeout((() => {
      var _this$_editForm;
      const elementContainer = (null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm ? void 0 : _this$_editForm.element()) || this.component.$element().get(0);
      const $focusedElement = renderer_default(dom_adapter_default.getActiveElement(elementContainer));
      const columnIndex = this._rowsView.getCellIndex($focusedElement, row.rowIndex);
      let focusedElement = $focusedElement.get(0);
      const selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._updateEditRowCore(row, false, isCustomSetCellValue);
      this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
      if (columnIndex >= 0) {
        const $focusedItem = this._rowsView._getCellElement(row.rowIndex, columnIndex);
        this._delayedInputFocus($focusedItem, (() => {
          setTimeout((() => {
            var _this$component$$elem;
            focusedElement = dom_adapter_default.getActiveElement(null === (_this$component$$elem = this.component.$element()) || void 0 === _this$component$$elem ? void 0 : _this$component$$elem.get(0));
            if (selectionRange.selectionStart >= 0) {
              m_utils_default.setSelectionRange(focusedElement, selectionRange);
            }
          }));
        }));
      }
      deferred.resolve();
    }));
  }
  _validateEditFormAfterUpdate() {
  }
  _addChange(changeParams, options2) {
    var _this$getChanges;
    const row = null === options2 || void 0 === options2 ? void 0 : options2.row;
    const changes = [...this.getChanges()];
    let index = m_utils_default.getIndexByKey(changeParams.key, changes);
    if (index < 0) {
      index = changes.length;
      this._addInternalData({
        key: changeParams.key,
        oldData: changeParams.oldData
      });
      delete changeParams.oldData;
      changes.push(changeParams);
    }
    const change = _extends({}, changes[index]);
    if (change) {
      if (changeParams.data) {
        change.data = createObjectWithChanges(change.data, changeParams.data);
      }
      if ((!change.type || !changeParams.data) && changeParams.type) {
        change.type = changeParams.type;
      }
      if (row) {
        row.oldData = this._getOldData(row.key);
        row.data = createObjectWithChanges(row.data, changeParams.data);
      }
    }
    changes[index] = change;
    this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    if (options2 && change !== (null === (_this$getChanges = this.getChanges()) || void 0 === _this$getChanges ? void 0 : _this$getChanges[index])) {
      options2.forceUpdateRow = true;
    }
    return change;
  }
  _getFormEditItemTemplate(cellOptions, column) {
    return column.editCellTemplate || this._getDefaultEditorTemplate();
  }
  getColumnTemplate(options2) {
    const {
      column
    } = options2;
    const rowIndex = options2.row && options2.row.rowIndex;
    let template;
    const isRowMode = this.isRowBasedEditMode();
    const isRowEditing = this.isEditRow(rowIndex);
    const isCellEditing = this.isEditCell(rowIndex, options2.columnIndex);
    let editingStartOptions;
    if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options2.rowType || "detailAdaptive" === options2.rowType) && !column.command) {
      const allowUpdating = this.allowUpdating(options2);
      if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowEditing || !isRowMode)) {
        if (column.showEditorAlways && !isRowMode) {
          editingStartOptions = {
            cancel: false,
            key: options2.row.isNewRow ? void 0 : options2.row.key,
            data: options2.row.data,
            column
          };
          this._isEditingStart(editingStartOptions);
        }
        if (!editingStartOptions || !editingStartOptions.cancel) {
          options2.setValue = (value2, text) => {
            this.updateFieldValue(options2, value2, text);
          };
        }
      }
      template = column.editCellTemplate || this._getDefaultEditorTemplate();
    } else if ("detail" === column.command && "detail" === options2.rowType && isRowEditing) {
      template = null === this || void 0 === this ? void 0 : this.getEditFormTemplate(options2);
    }
    return template;
  }
  _createButton($container, button, options2, change) {
    let icon = EDIT_ICON_CLASS[button.name];
    const useIcons = this.option("editing.useIcons");
    const useLegacyColumnButtonTemplate = this.option("useLegacyColumnButtonTemplate");
    let $button = renderer_default("<a>").attr("href", "#").addClass(LINK_CLASS).addClass(button.cssClass);
    if (button.template && useLegacyColumnButtonTemplate) {
      this._rowsView.renderTemplate($container, button.template, options2, true);
    } else {
      if (button.template) {
        $button = renderer_default("<span>").addClass(button.cssClass);
      } else if (useIcons && icon || button.icon) {
        icon = button.icon || icon;
        const iconType = getImageSourceType(icon);
        if ("image" === iconType || "svg" === iconType) {
          $button = getImageContainer(icon).addClass(button.cssClass);
        } else {
          $button.addClass(`dx-icon${"dxIcon" === iconType ? "-" : " "}${icon}`).attr("title", button.text);
        }
        $button.addClass(LINK_ICON_CLASS);
        $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);
        const localizationName = this.getButtonLocalizationNames()[button.name];
        localizationName && $button.attr("aria-label", message_default.format(localizationName));
      } else {
        $button.text(button.text);
      }
      if (isDefined(button.hint)) {
        $button.attr("title", button.hint);
      }
      if (this._isButtonDisabled(button, options2)) {
        $button.addClass("dx-state-disabled");
      } else if (!button.template || button.onClick) {
        m_events_engine_default.on($button, addNamespace("click", EDITING_NAMESPACE), this.createAction(((e) => {
          var _button$onClick;
          null === (_button$onClick = button.onClick) || void 0 === _button$onClick || _button$onClick.call(button, extend({}, e, {
            row: options2.row,
            column: options2.column
          }));
          e.event.preventDefault();
          e.event.stopPropagation();
        })));
      }
      $container.append($button);
      if (button.template) {
        options2.renderAsync = false;
        this._rowsView.renderTemplate($button, button.template, options2, true, change);
      }
    }
  }
  getButtonLocalizationNames() {
    return {
      edit: "dxDataGrid-editingEditRow",
      save: "dxDataGrid-editingSaveRowChanges",
      delete: "dxDataGrid-editingDeleteRow",
      undelete: "dxDataGrid-editingUndeleteRow",
      cancel: "dxDataGrid-editingCancelRowChanges"
    };
  }
  prepareButtonItem(headerPanel8, name2, methodName, sortIndex) {
    const editingTexts = this.option("editing.texts") ?? {};
    const titleButtonTextByClassNames = {
      revert: editingTexts.cancelAllChanges,
      save: editingTexts.saveAllChanges,
      addRow: editingTexts.addRow
    };
    const className = {
      revert: "cancel",
      save: "save",
      addRow: "addrow"
    }[name2];
    const hintText = titleButtonTextByClassNames[name2];
    const isButtonDisabled = ("save" === className || "cancel" === className) && this._isEditButtonDisabled();
    return {
      widget: "dxButton",
      options: {
        onInitialized: (e) => {
          renderer_default(e.element).addClass(headerPanel8._getToolbarButtonClass(`${EDIT_BUTTON_CLASS} ${this.addWidgetPrefix(className)}-button`));
        },
        icon: `edit-button-${className}`,
        disabled: isButtonDisabled,
        onClick: () => {
          setTimeout((() => {
            this[methodName]();
          }));
        },
        text: hintText,
        hint: hintText
      },
      showText: "inMenu",
      name: `${name2}Button`,
      location: "after",
      locateInMenu: "auto",
      sortIndex
    };
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = [];
    if (editingOptions.allowAdding) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "addRow", "addRow", 20));
    }
    return buttonItems;
  }
  highlightDataCell($cell, params) {
    this.shouldHighlightCell(params) && $cell.addClass(CELL_MODIFIED);
  }
  _afterInsertRow(key) {
  }
  _beforeSaveEditData(change) {
    if (change && !isDefined(change.key) && isDefined(change.type)) {
      return true;
    }
  }
  _afterSaveEditData() {
  }
  _beforeCancelEditData() {
  }
  _allowEditAction(actionName, options2) {
    let allowEditAction = this.option(`editing.${actionName}`);
    if (isFunction(allowEditAction)) {
      allowEditAction = allowEditAction({
        component: this.component,
        row: options2.row
      });
    }
    return allowEditAction;
  }
  allowUpdating(options2, eventName) {
    const startEditAction = this.option("editing.startEditAction") ?? DEFAULT_START_EDIT_ACTION;
    const needCallback = arguments.length > 1 ? startEditAction === eventName || "down" === eventName : true;
    return needCallback && this._allowEditAction("allowUpdating", options2);
  }
  allowDeleting(options2) {
    return this._allowEditAction("allowDeleting", options2);
  }
  isCellModified(parameters) {
    var _parameters$row, _parameters$row2;
    const {
      columnIndex
    } = parameters;
    let modifiedValue = null === parameters || void 0 === parameters || null === (_parameters$row = parameters.row) || void 0 === _parameters$row || null === (_parameters$row = _parameters$row.modifiedValues) || void 0 === _parameters$row ? void 0 : _parameters$row[columnIndex];
    if (null !== parameters && void 0 !== parameters && null !== (_parameters$row2 = parameters.row) && void 0 !== _parameters$row2 && _parameters$row2.isNewRow) {
      modifiedValue = parameters.value;
    }
    return void 0 !== modifiedValue;
  }
  isNewRowInEditMode() {
    const visibleEditRowIndex = this._getVisibleEditRowIndex();
    const rows = this._dataController.items();
    return visibleEditRowIndex >= 0 ? rows[visibleEditRowIndex].isNewRow : false;
  }
  _isRowDeleteAllowed() {
  }
  _prepareEditCell(parameters) {
    return false;
  }
  shouldHighlightCell(parameters) {
    const cellModified = this.isCellModified(parameters);
    return cellModified && parameters.column.setCellValue && (this.getEditMode() !== EDIT_MODE_ROW || !parameters.row.isEditing);
  }
};
var dataControllerEditingExtenderMixin = (Base) => class extends Base {
  reload(full, repaintChangesOnly) {
    !repaintChangesOnly && this._editingController.refresh();
    return super.reload.apply(this, arguments);
  }
  repaintRows() {
    if (this._editingController.isSaving()) {
      return;
    }
    return super.repaintRows.apply(this, arguments);
  }
  _updateEditRow(items) {
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const editRowIndex = m_utils_default.getIndexByKey(editRowKey, items);
    const editItem = items[editRowIndex];
    if (editItem) {
      var _this$_updateEditItem;
      editItem.isEditing = true;
      null === (_this$_updateEditItem = this._updateEditItem) || void 0 === _this$_updateEditItem || _this$_updateEditItem.call(this, editItem);
    }
  }
  _updateItemsCore(change) {
    super._updateItemsCore(change);
    this._updateEditRow(this.items(true));
  }
  _applyChangeUpdate(change) {
    this._updateEditRow(change.items);
    super._applyChangeUpdate(change);
  }
  _applyChangesOnly(change) {
    this._updateEditRow(change.items);
    super._applyChangesOnly(change);
  }
  _processItems(items, change) {
    items = this._editingController.processItems(items, change);
    return super._processItems(items, change);
  }
  _processDataItem(dataItem, options2) {
    this._editingController.processDataItem(dataItem, options2, this.generateDataValues);
    return super._processDataItem(dataItem, options2);
  }
  _processItem(item, options2) {
    item = super._processItem(item, options2);
    if (item.isNewRow) {
      options2.dataIndex--;
      delete item.dataIndex;
    }
    return item;
  }
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    const cell = oldRow.cells && oldRow.cells[columnIndex];
    const isEditing = this._editingController && this._editingController.isEditCell(visibleRowIndex, columnIndex);
    if (isLiveUpdate && isEditing) {
      return false;
    }
    if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
  needToRefreshOnDataSourceChange(args) {
    const isParasiteChange = Array.isArray(args.value) && args.value === args.previousValue && this._editingController.isSaving();
    return !isParasiteChange;
  }
  _handleDataSourceChange(args) {
    const result2 = super._handleDataSourceChange(args);
    const changes = this.option("editing.changes");
    const dataSource = args.value;
    if (Array.isArray(dataSource) && changes.length) {
      const dataSourceKeys = dataSource.map(((item) => this.keyOf(item)));
      const newChanges = changes.filter(((change) => "insert" === change.type || dataSourceKeys.some(((key) => equalByValue(change.key, key)))));
      if (newChanges.length !== changes.length) {
        this.option("editing.changes", newChanges);
      }
      const editRowKey = this.option("editing.editRowKey");
      const isEditNewItem = newChanges.some(((change) => "insert" === change.type && equalByValue(editRowKey, change.key)));
      if (!isEditNewItem && dataSourceKeys.every(((key) => !equalByValue(editRowKey, key)))) {
        this.option("editing.editRowKey", null);
      }
    }
    return result2;
  }
};
var rowsView3 = (Base) => class extends Base {
  getCellIndex($cell, rowIndex) {
    if (!$cell.is("td") && rowIndex >= 0) {
      const $cellElements = this.getCellElements(rowIndex);
      let cellIndex = -1;
      each($cellElements, ((index, cellElement) => {
        if (renderer_default(cellElement).find($cell).length) {
          cellIndex = index;
        }
      }));
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  publicMethods() {
    return super.publicMethods().concat(["cellValue"]);
  }
  _getCellTemplate(options2) {
    const template = this._editingController.getColumnTemplate(options2);
    return template || super._getCellTemplate(options2);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isRowRemoved = !!row.removed;
      const isRowInserted = !!row.isNewRow;
      const isRowModified = !!row.modified;
      isRowInserted && $row.addClass(ROW_INSERTED);
      isRowModified && $row.addClass(ROW_MODIFIED);
      if (isRowInserted || isRowRemoved) {
        $row.removeClass(ROW_SELECTED);
      }
    }
    return $row;
  }
  _getColumnIndexByElement($element) {
    let $tableElement = $element.closest("table");
    const $tableElements = this.getTableElements();
    while ($tableElement.length && !$tableElements.filter($tableElement).length) {
      $element = $tableElement.closest("td");
      $tableElement = $element.closest("table");
    }
    return this._getColumnIndexByElementCore($element);
  }
  _getColumnIndexByElementCore($element) {
    const $targetElement = $element.closest(`.${ROW_CLASS}> td:not(.dx-master-detail-cell)`);
    return this.getCellIndex($targetElement);
  }
  _editCellByClick(e, eventName) {
    const editingController = this._editingController;
    const $targetElement = renderer_default(e.event.target);
    const columnIndex = this._getColumnIndexByElement($targetElement);
    const row = this._dataController.items()[e.rowIndex];
    const allowUpdating = editingController.allowUpdating({
      row
    }, eventName) || row && row.isNewRow;
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    const isEditedCell = editingController.isEditCell(e.rowIndex, columnIndex);
    const allowEditing = allowUpdating && column && (column.allowEditing || isEditedCell);
    const startEditAction = this.option("editing.startEditAction") || "click";
    const isShowEditorAlways = column && column.showEditorAlways;
    if (isEditedCell) {
      return true;
    }
    if ("down" === eventName) {
      if (devices_default.real().ios || devices_default.real().android) {
        m_dom_default.resetActiveElement();
      }
      return isShowEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex);
    }
    if ("click" === eventName && "dblClick" === startEditAction && this._pointerDownTarget === $targetElement.get(0)) {
      const isError = false;
      const withoutSaveEditData = null === row || void 0 === row ? void 0 : row.isNewRow;
      editingController.closeEditCell(isError, withoutSaveEditData);
    }
    if (allowEditing && eventName === startEditAction) {
      return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex);
    }
  }
  _rowPointerDown(e) {
    this._pointerDownTarget = e.event.target;
    this._pointerDownTimeout = setTimeout((() => {
      this._editCellByClick(e, "down");
    }));
  }
  _rowClickTreeListHack(e) {
    super._rowClick.apply(this, arguments);
  }
  _rowClick(e) {
    const isEditForm2 = renderer_default(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS));
    e.event[TARGET_COMPONENT_NAME] = this.component;
    if (!this._editCellByClick(e, "click") && !isEditForm2) {
      super._rowClick.apply(this, arguments);
    }
  }
  _rowDblClickTreeListHack(e) {
    super._rowDblClick.apply(this, arguments);
  }
  _rowDblClick(e) {
    if (!this._editCellByClick(e, "dblClick")) {
      super._rowDblClick.apply(this, arguments);
    }
  }
  _cellPrepared($cell, parameters) {
    var _parameters$column;
    const editingController = this._editingController;
    const isCommandCell = !!parameters.column.command;
    const isEditableCell = parameters.setValue;
    const isEditRow2 = editingController.isEditRow(parameters.rowIndex);
    const isEditing = isEditingCell(isEditRow2, parameters);
    if (isEditingOrShowEditorAlwaysDataCell(isEditRow2, parameters)) {
      const {
        alignment
      } = parameters.column;
      $cell.toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
      if (alignment) {
        $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", alignment);
      }
    }
    if (isEditing) {
      this._editCellPrepared($cell);
    }
    const hasTemplate3 = !!(null !== (_parameters$column = parameters.column) && void 0 !== _parameters$column && _parameters$column.cellTemplate);
    if (parameters.column && !isCommandCell && (!hasTemplate3 || editingController.shouldHighlightCell(parameters))) {
      editingController.highlightDataCell($cell, parameters);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _getCellOptions(options2) {
    const cellOptions = super._getCellOptions(options2);
    const {
      columnIndex,
      row
    } = options2;
    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
    cellOptions.removed = row.removed;
    if (row.modified) {
      cellOptions.modified = void 0 !== row.modifiedValues[columnIndex];
    }
    return cellOptions;
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    super._setCellAriaAttributes($cell, cellOptions, options2);
    if (cellOptions.removed) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaDeletedCell"), $cell);
    }
    if (cellOptions.modified) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaModifiedCell"), $cell);
    }
    const isEditableCell = cellOptions.column.allowEditing && !cellOptions.removed && !cellOptions.modified && "data" === cellOptions.rowType && cellOptions.column.calculateCellValue === cellOptions.column.defaultCalculateCellValue && this._editingController.isCellBasedEditMode();
    if (isEditableCell) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaEditableCell"), $cell);
    }
  }
  _createCell(options2) {
    const $cell = super._createCell(options2);
    const isEditRow2 = this._editingController.isEditRow(options2.rowIndex);
    isEditingOrShowEditorAlwaysDataCell(isEditRow2, options2) && $cell.addClass(EDITOR_CELL_CLASS);
    return $cell;
  }
  cellValue(rowIndex, columnIdentifier, value2, text) {
    const cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
    if (cellOptions) {
      if (void 0 === value2) {
        return cellOptions.value;
      }
      this._editingController.updateFieldValue(cellOptions, value2, text, true);
    }
  }
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._pointerDownTimeout);
  }
  _renderCore() {
    super._renderCore.apply(this, arguments);
    return this.waitAsyncTemplates(true).done((() => {
      this._editingController._focusEditorIfNeed();
    }));
  }
  _editCellPrepared() {
  }
  _formItemPrepared() {
  }
};
var headerPanel3 = (Base) => class extends Base {
  optionChanged(args) {
    const {
      fullName
    } = args;
    switch (args.name) {
      case "editing": {
        const excludedOptions = [EDITING_POPUP_OPTION_NAME, EDITING_CHANGES_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME];
        const shouldInvalidate = fullName && !excludedOptions.some(((optionName) => optionName === fullName));
        shouldInvalidate && this._invalidate();
        super.optionChanged(args);
        break;
      }
      case "useLegacyColumnButtonTemplate":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const editButtonItems = this._editingController.prepareEditButtons(this);
    return editButtonItems.concat(items);
  }
};
var editingModule = {
  defaultOptions: () => ({
    editing: {
      mode: "row",
      refreshMode: "full",
      newRowPosition: VIEWPORT_TOP_NEW_ROW_POSITION,
      allowAdding: false,
      allowUpdating: false,
      allowDeleting: false,
      useIcons: false,
      selectTextOnEditStart: false,
      confirmDelete: true,
      texts: {
        editRow: message_default.format("dxDataGrid-editingEditRow"),
        saveAllChanges: message_default.format("dxDataGrid-editingSaveAllChanges"),
        saveRowChanges: message_default.format("dxDataGrid-editingSaveRowChanges"),
        cancelAllChanges: message_default.format("dxDataGrid-editingCancelAllChanges"),
        cancelRowChanges: message_default.format("dxDataGrid-editingCancelRowChanges"),
        addRow: message_default.format("dxDataGrid-editingAddRow"),
        deleteRow: message_default.format("dxDataGrid-editingDeleteRow"),
        undeleteRow: message_default.format("dxDataGrid-editingUndeleteRow"),
        confirmDeleteMessage: message_default.format("dxDataGrid-editingConfirmDeleteMessage"),
        confirmDeleteTitle: ""
      },
      form: {
        colCount: 2
      },
      popup: {},
      startEditAction: "click",
      editRowKey: null,
      editColumnName: null,
      changes: []
    },
    useLegacyColumnButtonTemplate: false
  }),
  controllers: {
    editing: EditingControllerImpl
  },
  extenders: {
    controllers: {
      data: dataControllerEditingExtenderMixin
    },
    views: {
      rowsView: rowsView3,
      headerPanel: headerPanel3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_editing.js
var data4 = (Base) => class extends dataControllerEditingExtenderMixin(Base) {
  _changeRowExpandCore(key) {
    const editingController = this._editingController;
    if (Array.isArray(key)) {
      editingController && editingController.refresh();
    }
    return super._changeRowExpandCore.apply(this, arguments);
  }
};
m_core_default.registerModule("editing", _extends({}, editingModule, {
  extenders: _extends({}, editingModule.extenders, {
    controllers: _extends({}, editingModule.extenders.controllers, {
      data: data4
    })
  })
}));

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_row_based.js
var editingControllerExtender = (Base) => class extends Base {
  isRowEditMode() {
    return this.getEditMode() === EDIT_MODE_ROW;
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    if (this.isRowBasedEditMode() && rowIndex >= 0) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [rowIndex, rowIndex + 1]
      });
    } else {
      super._afterCancelEditData(rowIndex);
    }
  }
  _isDefaultButtonVisible(button, options2) {
    const isRowMode = this.isRowBasedEditMode();
    const isPopupEditMode = this.isPopupEditMode();
    const isEditRow2 = !isPopupEditMode && options2.row && equalByValue(options2.row.key, this.option(EDITING_EDITROWKEY_OPTION_NAME));
    if (isRowMode) {
      switch (button.name) {
        case "edit":
          return !isEditRow2 && this.allowUpdating(options2);
        case "delete":
          return super._isDefaultButtonVisible(button, options2) && !isEditRow2;
        case "save":
        case "cancel":
          return isEditRow2;
        default:
          return super._isDefaultButtonVisible(button, options2);
      }
    }
    return super._isDefaultButtonVisible(button, options2);
  }
  isEditRow(rowIndex) {
    return this.isRowBasedEditMode() && this.isEditRowByIndex(rowIndex);
  }
  _cancelSaving(result2) {
    if (this.isRowBasedEditMode()) {
      if (!this.hasChanges()) {
        this._cancelEditDataCore();
      }
    }
    super._cancelSaving(result2);
  }
  _refreshCore(params) {
    const {
      allowCancelEditing
    } = params ?? {};
    if (this.isRowBasedEditMode()) {
      const hasUpdateChanges = this.getChanges().filter(((it) => "update" === it.type)).length > 0;
      this.init();
      allowCancelEditing && hasUpdateChanges && this._cancelEditDataCore();
    }
    super._refreshCore(params);
  }
  _isEditColumnVisible() {
    const result2 = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    const isRowEditMode = this.isRowEditMode();
    const isVisibleInRowEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
    return result2 || isRowEditMode && isVisibleInRowEditMode;
  }
  _focusEditorIfNeed() {
    const editMode = this.getEditMode();
    if (this._needFocusEditor) {
      if (MODES_WITH_DELAYED_FOCUS.includes(editMode)) {
        const $editingCell = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
        this._delayedInputFocus($editingCell, (() => {
          $editingCell && this.component.focus($editingCell);
        }));
      }
      this._needFocusEditor = false;
    }
  }
};
var data5 = (Base) => class extends Base {
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (this._editingController.isRowBasedEditMode() && oldItem.isEditing !== newItem.isEditing) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView4 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isEditRow2 = editingController.isEditRow(row.rowIndex);
      if (isEditRow2) {
        $row.addClass(EDIT_ROW);
        $row.removeClass(ROW_SELECTED_CLASS);
        if ("detail" === row.rowType) {
          $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS));
        }
      }
    }
    return $row;
  }
  _update(change) {
    super._update(change);
    if ("updateSelection" === change.changeType) {
      this.getTableElements().children("tbody").children(`.${EDIT_ROW}`).removeClass(ROW_SELECTED_CLASS);
    }
  }
};
var editingRowBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender,
      data: data5
    },
    views: {
      rowsView: rowsView4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_row_based.js
m_core_default.registerModule("editingRowBased", editingRowBasedModule);

// node_modules/devextreme/esm/__internal/ui/m_validation_summary.js
var ITEM_CLASS4 = "dx-validationsummary-item";
var ITEM_DATA_KEY2 = "dx-validationsummary-item-data";
var ValidationSummary = class extends m_collection_widget_edit_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      focusStateEnabled: false,
      noDataText: null
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  }
  _init() {
    super._init();
    this._initGroupRegistration();
  }
  _initGroupRegistration() {
    const $element = this.$element();
    const {
      validationGroup
    } = this.option();
    const group = validationGroup || m_validation_engine_default.findGroup($element, this._modelByElement($element));
    const groupConfig = m_validation_engine_default.addGroup(group, true);
    this._unsubscribeGroup();
    this._groupWasInit = true;
    this._validationGroup = group;
    this.groupSubscription = this._groupValidationHandler.bind(this);
    groupConfig.on("validated", this.groupSubscription);
  }
  _unsubscribeGroup() {
    const groupConfig = m_validation_engine_default.getGroupConfig(this._validationGroup);
    null === groupConfig || void 0 === groupConfig || groupConfig.off("validated", this.groupSubscription);
  }
  _getOrderedItems(validators, items) {
    let orderedItems = [];
    each(validators, ((_, validator) => {
      const foundItems = grep(items, ((item) => {
        if (item.validator === validator) {
          return true;
        }
      }));
      if (foundItems.length) {
        orderedItems = orderedItems.concat(foundItems);
      }
    }));
    return orderedItems;
  }
  _groupValidationHandler(params) {
    const items = this._getOrderedItems(params.validators, map(params.brokenRules, ((rule) => ({
      text: rule.message,
      validator: rule.validator,
      index: rule.index
    }))));
    this.validators = params.validators;
    each(this.validators, ((_, validator) => {
      if (validator._validationSummary !== this) {
        let handler = this._itemValidationHandler.bind(this);
        const disposingHandler = function() {
          validator.off("validated", handler);
          validator._validationSummary = null;
          handler = null;
        };
        validator.on("validated", handler);
        validator.on("disposing", disposingHandler);
        validator._validationSummary = this;
      }
    }));
    this.option("items", items);
  }
  _itemValidationHandler(_ref) {
    let {
      isValid,
      validator,
      brokenRules
    } = _ref;
    let {
      items
    } = this.option();
    let itemsChanged = false;
    let itemIndex = 0;
    while (itemIndex < items.length) {
      const item = items[itemIndex];
      if (item.validator === validator) {
        const foundRule = grep(brokenRules || [], ((rule) => rule.index === item.index))[0];
        if (isValid || !foundRule) {
          items.splice(itemIndex, 1);
          itemsChanged = true;
          continue;
        }
        if (foundRule.message !== item.text) {
          item.text = foundRule.message;
          itemsChanged = true;
        }
      }
      itemIndex++;
    }
    each(brokenRules, ((_, rule) => {
      const foundItem = grep(items, ((item) => item.validator === validator && item.index === rule.index))[0];
      if (!foundItem) {
        items.push({
          text: rule.message,
          validator,
          index: rule.index
        });
        itemsChanged = true;
      }
    }));
    if (itemsChanged) {
      items = this._getOrderedItems(this.validators, items);
      this.option("items", items);
    }
  }
  _initMarkup() {
    this.$element().addClass("dx-validationsummary");
    super._initMarkup();
  }
  _optionChanged(args) {
    if ("validationGroup" === args.name) {
      this._initGroupRegistration();
    } else {
      super._optionChanged(args);
    }
  }
  _itemClass() {
    return ITEM_CLASS4;
  }
  _itemDataKey() {
    return ITEM_DATA_KEY2;
  }
  _postprocessRenderItem(params) {
    m_events_engine_default.on(params.itemElement, "click", (() => {
      var _params$itemData$vali, _params$itemData$vali2;
      null === (_params$itemData$vali = params.itemData.validator) || void 0 === _params$itemData$vali || null === (_params$itemData$vali2 = _params$itemData$vali.focus) || void 0 === _params$itemData$vali2 || _params$itemData$vali2.call(_params$itemData$vali);
    }));
  }
  _dispose() {
    super._dispose();
    this._unsubscribeGroup();
  }
  refreshValidationGroup() {
    this._initGroupRegistration();
  }
};
component_registrator_default("dxValidationSummary", ValidationSummary);
var m_validation_summary_default = ValidationSummary;

// node_modules/devextreme/esm/__internal/ui/validation/m_default_adapter.js
var DefaultAdapter = class extends class_default.inherit({}) {
  ctor(editor, validator) {
    this.editor = editor;
    this.validator = validator;
    this.validationRequestsCallbacks = [];
    const handler = (args) => {
      this.validationRequestsCallbacks.forEach(((item) => item(args)));
    };
    editor.validationRequest.add(handler);
    editor.on("disposing", (() => {
      editor.validationRequest.remove(handler);
    }));
  }
  getValue() {
    return this.editor.option("value");
  }
  getCurrentValidationError() {
    return this.editor.option("validationError");
  }
  bypass() {
    return this.editor.option("disabled");
  }
  applyValidationResults(params) {
    this.editor.option({
      validationErrors: params.brokenRules,
      validationStatus: params.status
    });
  }
  reset() {
    this.editor.clear();
  }
  focus() {
    this.editor.focus();
  }
};
var m_default_adapter_default = DefaultAdapter;

// node_modules/devextreme/esm/__internal/ui/m_validator.js
var Validator = class extends dom_component_default {
  _initOptions(options2) {
    super._initOptions.apply(this, arguments);
    this.option(m_validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      validationRules: []
    });
  }
  _init() {
    super._init();
    this._initGroupRegistration();
    this.focused = callbacks_default();
    this._initAdapter();
    this._validationInfo = {
      result: null,
      deferred: null,
      skipValidation: false
    };
  }
  _initGroupRegistration() {
    const group = this._findGroup();
    if (!this._groupWasInit) {
      this.on("disposing", ((args) => {
        m_validation_engine_default.removeRegisteredValidator(args.component._validationGroup, args.component);
      }));
    }
    if (!this._groupWasInit || this._validationGroup !== group) {
      m_validation_engine_default.removeRegisteredValidator(this._validationGroup, this);
      this._groupWasInit = true;
      this._validationGroup = group;
      m_validation_engine_default.registerValidatorInGroup(group, this);
    }
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  }
  _getEditor() {
    const element = this.$element()[0];
    return data(element, "dx-validation-target");
  }
  _initAdapter() {
    const dxStandardEditor = this._getEditor();
    let {
      adapter
    } = this.option();
    if (!adapter) {
      if (dxStandardEditor) {
        var _adapter;
        adapter = new m_default_adapter_default(dxStandardEditor, this);
        null === (_adapter = adapter) || void 0 === _adapter || null === (_adapter = _adapter.validationRequestsCallbacks) || void 0 === _adapter || _adapter.push(((args) => {
          var _this$_validationInfo;
          if (null !== (_this$_validationInfo = this._validationInfo) && void 0 !== _this$_validationInfo && _this$_validationInfo.skipValidation) {
            return;
          }
          this.validate(args);
        }));
        this.option("adapter", adapter);
        return;
      }
      throw ui_errors_default.Error("E0120");
    }
    const callbacks = adapter.validationRequestsCallbacks;
    if (callbacks) {
      callbacks.push(((args) => {
        this.validate(args);
      }));
    }
  }
  _toggleRTLDirection(isRtl) {
    var _adapter$editor;
    const {
      adapter
    } = this.option();
    const rtlEnabled = (null === adapter || void 0 === adapter || null === (_adapter$editor = adapter.editor) || void 0 === _adapter$editor ? void 0 : _adapter$editor.option("rtlEnabled")) ?? isRtl;
    super._toggleRTLDirection(rtlEnabled);
  }
  _initMarkup() {
    this.$element().addClass("dx-validator");
    super._initMarkup();
  }
  _render() {
    super._render();
    this._toggleAccessibilityAttributes();
  }
  _toggleAccessibilityAttributes() {
    const dxStandardEditor = this._getEditor();
    if (dxStandardEditor) {
      const rules = this.option("validationRules") || [];
      const isRequired = rules.some(((_ref) => {
        let {
          type: type2
        } = _ref;
        return "required" === type2;
      })) || null;
      if (dxStandardEditor.isInitialized()) {
        dxStandardEditor.setAria("required", isRequired);
      }
      dxStandardEditor.option("_onMarkupRendered", (() => {
        dxStandardEditor.setAria("required", isRequired);
      }));
    }
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._initGroupRegistration();
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "validationGroup":
        this._initGroupRegistration();
        return;
      case "validationRules":
        this._resetValidationRules();
        this._toggleAccessibilityAttributes();
        void 0 !== this.option("isValid") && this.validate();
        return;
      case "adapter":
        this._initAdapter();
        break;
      case "isValid":
      case "validationStatus":
        this.option(m_validation_engine_default.synchronizeValidationOptions(args, this.option()));
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getValidationRules() {
    if (!this._validationRules) {
      this._validationRules = map(this.option("validationRules"), ((rule, index) => extend({}, rule, {
        validator: this,
        index
      })));
    }
    return this._validationRules;
  }
  _findGroup() {
    const $element = this.$element();
    const {
      validationGroup
    } = this.option();
    return validationGroup || m_validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _resetValidationRules() {
    delete this._validationRules;
  }
  validate(args) {
    var _adapter$bypass, _adapter$getValue, _adapter$getCurrentVa, _this$_validationInfo2, _result$complete;
    const {
      adapter,
      name: name2
    } = this.option();
    const bypass = null === adapter || void 0 === adapter || null === (_adapter$bypass = adapter.bypass) || void 0 === _adapter$bypass ? void 0 : _adapter$bypass.call(adapter);
    const value2 = args && void 0 !== args.value ? args.value : null === adapter || void 0 === adapter || null === (_adapter$getValue = adapter.getValue) || void 0 === _adapter$getValue ? void 0 : _adapter$getValue.call(adapter);
    const currentError = null === adapter || void 0 === adapter || null === (_adapter$getCurrentVa = adapter.getCurrentValidationError) || void 0 === _adapter$getCurrentVa ? void 0 : _adapter$getCurrentVa.call(adapter);
    const rules = this._getValidationRules();
    const currentResult = null === (_this$_validationInfo2 = this._validationInfo) || void 0 === _this$_validationInfo2 ? void 0 : _this$_validationInfo2.result;
    if (currentResult && "pending" === currentResult.status && currentResult.value === value2) {
      return extend({}, currentResult);
    }
    let result2;
    if (bypass) {
      result2 = {
        isValid: true,
        status: "valid"
      };
    } else if (null !== currentError && void 0 !== currentError && currentError.editorSpecific) {
      currentError.validator = this;
      result2 = {
        isValid: false,
        status: "invalid",
        brokenRule: currentError,
        brokenRules: [currentError]
      };
    } else {
      result2 = m_validation_engine_default.validate(value2, rules, name2);
    }
    result2.id = new guid_default().toString();
    this._applyValidationResult(result2, adapter);
    null === (_result$complete = result2.complete) || void 0 === _result$complete || _result$complete.then(((res) => {
      if (res.id === this._validationInfo.result.id) {
        this._applyValidationResult(res, adapter);
      }
    }));
    return extend({}, this._validationInfo.result);
  }
  reset() {
    const {
      adapter
    } = this.option();
    const result2 = {
      id: null,
      isValid: true,
      brokenRule: null,
      brokenRules: null,
      pendingRules: null,
      status: "valid",
      complete: null
    };
    this._validationInfo.skipValidation = true;
    adapter.reset();
    this._validationInfo.skipValidation = false;
    this._resetValidationRules();
    this._applyValidationResult(result2, adapter);
  }
  _updateValidationResult(result2) {
    if (!this._validationInfo.result || this._validationInfo.result.id !== result2.id) {
      const complete = this._validationInfo.deferred && this._validationInfo.result.complete;
      this._validationInfo.result = extend({}, result2, {
        complete
      });
    } else {
      for (const prop in result2) {
        if ("id" !== prop && "complete" !== prop) {
          this._validationInfo.result[prop] = result2[prop];
        }
      }
    }
  }
  _applyValidationResult(result2, adapter) {
    const validatedAction = this._createActionByOption("onValidated", {
      excludeValidators: ["readOnly"]
    });
    result2.validator = this;
    this._updateValidationResult(result2);
    adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
    this.option({
      validationStatus: this._validationInfo.result.status
    });
    if ("pending" === this._validationInfo.result.status) {
      if (!this._validationInfo.deferred) {
        this._validationInfo.deferred = Deferred();
        this._validationInfo.result.complete = this._validationInfo.deferred.promise();
      }
      this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
      return;
    }
    if ("pending" !== this._validationInfo.result.status) {
      validatedAction(result2);
      if (this._validationInfo.deferred) {
        this._validationInfo.deferred.resolve(result2);
        this._validationInfo.deferred = null;
      }
    }
  }
  focus() {
    const {
      adapter
    } = this.option();
    adapter && adapter.focus && adapter.focus();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidator", Validator);
var m_validator_default = Validator;

// node_modules/devextreme/esm/__internal/ui/m_validation_group.js
var ValidationGroup = class extends dom_component_default2 {
  _getDefaultOptions() {
    return super._getDefaultOptions();
  }
  _init() {
    super._init();
    m_validation_engine_default.addGroup(this, false);
  }
  _initMarkup() {
    const $element = this.$element();
    $element.addClass("dx-validationgroup");
    $element.find(".dx-validator").each(((_, validatorContainer) => {
      m_validator_default.getInstance(renderer_default(validatorContainer))._initGroupRegistration();
    }));
    $element.find(".dx-validationsummary").each(((_, summaryContainer) => {
      m_validation_summary_default.getInstance(renderer_default(summaryContainer)).refreshValidationGroup();
    }));
    super._initMarkup();
  }
  validate() {
    return m_validation_engine_default.validateGroup(this);
  }
  reset() {
    return m_validation_engine_default.resetGroup(this);
  }
  _dispose() {
    m_validation_engine_default.removeGroup(this);
    this.$element().removeClass("dx-validationgroup");
    super._dispose();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidationGroup", ValidationGroup);

// node_modules/devextreme/esm/ui/box.js
var box_default = m_box_default;

// node_modules/devextreme/esm/__internal/ui/m_responsive_box.js
var SCREEN_SIZE_CLASS_PREFIX = "dx-responsivebox-screen-";
var ResponsiveBox = class extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      rows: [],
      cols: [],
      screenByWidth: null,
      singleColumnScreen: "",
      height: "100%",
      width: "100%",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onLayoutChanged: null
    });
  }
  _init() {
    if (!this.option("screenByWidth")) {
      this._options.silent("screenByWidth", defaultScreenFactorFunc);
    }
    super._init();
    this._initLayoutChangedAction();
  }
  _initLayoutChangedAction() {
    this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _initMarkup() {
    super._initMarkup();
    this.$element().addClass("dx-responsivebox");
  }
  _renderItems() {
    this._setScreenSize();
    this._screenItems = this._itemsByScreen();
    this._prepareGrid();
    this._spreadItems();
    this._layoutItems();
    this._linkNodeToItem();
  }
  _itemOptionChanged(item) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    this._refreshItem($item, item);
    this._clearItemNodeTemplates();
    this._update(true);
  }
  _setScreenSize() {
    const currentScreen = this._getCurrentScreen();
    this._removeScreenSizeClass();
    this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
    this.option("currentScreenFactor", currentScreen);
  }
  _removeScreenSizeClass() {
    const {
      currentScreenFactor
    } = this.option();
    if (currentScreenFactor) {
      this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor);
    }
  }
  _prepareGrid() {
    const grid = this._grid = [];
    this._prepareRowsAndCols();
    each(this._rows, (() => {
      const row = [];
      grid.push(row);
      each(this._cols, (() => {
        row.push(this._createEmptyCell());
      }));
    }));
  }
  getSingleColumnRows() {
    const {
      rows
    } = this.option();
    const screenItemsLength = this._screenItems.length;
    if (null !== rows && void 0 !== rows && rows.length) {
      const filteredRows = this._filterByScreen(rows);
      const result2 = [];
      for (let i = 0; i < screenItemsLength; i++) {
        const sizeConfig = this._defaultSizeConfig();
        if (i < filteredRows.length && isDefined(filteredRows[i].shrink)) {
          sizeConfig.shrink = filteredRows[i].shrink;
        }
        result2.push(sizeConfig);
      }
      return result2;
    }
    return this._defaultSizeConfig(screenItemsLength);
  }
  _prepareRowsAndCols() {
    if (this._isSingleColumnScreen()) {
      this._prepareSingleColumnScreenItems();
      this._rows = this.getSingleColumnRows();
      this._cols = this._defaultSizeConfig(1);
    } else {
      this._rows = this._sizesByScreen(this.option("rows"));
      this._cols = this._sizesByScreen(this.option("cols"));
    }
  }
  _isSingleColumnScreen() {
    const {
      singleColumnScreen,
      rows,
      cols
    } = this.option();
    return this._screenRegExp().test(singleColumnScreen) || !(null !== rows && void 0 !== rows && rows.length) || !(null !== cols && void 0 !== cols && cols.length);
  }
  _prepareSingleColumnScreenItems() {
    this._screenItems.sort(((item1, item2) => item1.location.row - item2.location.row || item1.location.col - item2.location.col));
    each(this._screenItems, ((index, item) => {
      extend(item.location, {
        row: index,
        col: 0,
        rowspan: 1,
        colspan: 1
      });
    }));
  }
  _sizesByScreen(sizeConfigs) {
    return map(this._filterByScreen(sizeConfigs), ((sizeConfig) => extend(this._defaultSizeConfig(), sizeConfig)));
  }
  _createDefaultSizeConfig() {
    return {
      ratio: 1,
      baseSize: 0,
      minSize: 0,
      maxSize: 0
    };
  }
  _defaultSizeConfig(size) {
    const defaultSizeConfig = this._createDefaultSizeConfig();
    if (!arguments.length) {
      return defaultSizeConfig;
    }
    const result2 = [];
    for (let i = 0; i < size; i++) {
      result2.push(defaultSizeConfig);
    }
    return result2;
  }
  _filterByScreen(items) {
    const screenRegExp = this._screenRegExp();
    return grep(items, ((item) => !item.screen || screenRegExp.test(item.screen)));
  }
  _screenRegExp() {
    const screen = this._getCurrentScreen();
    return new RegExp(`(^|\\s)${screen}($|\\s)`, "i");
  }
  _getCurrentScreen() {
    const width = this._screenWidth();
    const {
      screenByWidth
    } = this.option();
    return null === screenByWidth || void 0 === screenByWidth ? void 0 : screenByWidth(width);
  }
  _screenWidth() {
    return hasWindow() ? getWidth(getWindow()) : 1920;
  }
  _createEmptyCell() {
    return {
      item: {},
      location: {
        colspan: 1,
        rowspan: 1
      }
    };
  }
  _spreadItems() {
    each(this._screenItems, ((_, itemInfo) => {
      const location = itemInfo.location || {};
      const itemCol = location.col;
      const itemRow = location.row;
      const row = this._grid[itemRow];
      const itemCell = null === row || void 0 === row ? void 0 : row[itemCol];
      this._occupyCells(itemCell, itemInfo);
    }));
  }
  _itemsByScreen() {
    const {
      items
    } = this.option();
    return null === items || void 0 === items ? void 0 : items.reduce(((result2, item) => {
      let locations = item.location || {};
      locations = isPlainObject(locations) ? [locations] : locations;
      this._filterByScreen(locations).forEach(((location) => {
        result2.push({
          item,
          location: extend({
            rowspan: 1,
            colspan: 1
          }, location)
        });
      }));
      return result2;
    }), []);
  }
  _occupyCells(itemCell, itemInfo) {
    if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
      return;
    }
    extend(itemCell, itemInfo);
    this._markSpanningCell(itemCell);
  }
  _isItemCellOccupied(itemCell, itemInfo) {
    if (!isEmptyObject(itemCell.item)) {
      return true;
    }
    let result2 = false;
    this._loopOverSpanning(itemInfo.location, ((cell) => {
      result2 = result2 || !isEmptyObject(cell.item);
    }));
    return result2;
  }
  _loopOverSpanning(location, callback) {
    const rowEnd = location.row + location.rowspan - 1;
    const colEnd = location.col + location.colspan - 1;
    const boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
    const boundColEnd = Math.min(colEnd, this._cols.length - 1);
    location.rowspan -= rowEnd - boundRowEnd;
    location.colspan -= colEnd - boundColEnd;
    for (let rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
      for (let colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
        if (rowIndex !== location.row || colIndex !== location.col) {
          callback(this._grid[rowIndex][colIndex]);
        }
      }
    }
  }
  _markSpanningCell(itemCell) {
    this._loopOverSpanning(itemCell.location, ((cell) => {
      extend(cell, {
        item: itemCell.item,
        spanningCell: itemCell
      });
    }));
  }
  _linkNodeToItem() {
    each(this._itemElements(), ((_, itemNode) => {
      const $item = renderer_default(itemNode);
      const item = $item.data("dxBoxItemData");
      if (!item.box) {
        item.node = $item.children();
      }
    }));
  }
  _layoutItems() {
    const rowsCount = this._grid.length;
    const colsCount = rowsCount && this._grid[0].length;
    if (!rowsCount && !colsCount) {
      return;
    }
    const result2 = this._layoutBlock({
      direction: "col",
      row: {
        start: 0,
        end: rowsCount - 1
      },
      col: {
        start: 0,
        end: colsCount - 1
      }
    });
    const rootBox = this._prepareBoxConfig(result2.box || {
      direction: "row",
      items: [extend(result2, {
        ratio: 1
      })]
    });
    extend(rootBox, this._rootBoxConfig(rootBox.items));
    this._$root = renderer_default("<div>").appendTo(this._itemContainer());
    this._createComponent(this._$root, box_default, rootBox);
  }
  _rootBoxConfig(items) {
    const rootItems = each(items, ((index, item) => {
      this._needApplyAutoBaseSize(item) && extend(item, {
        baseSize: "auto"
      });
    }));
    const {
      itemHoldTimeout
    } = this.option();
    return {
      width: "100%",
      height: "100%",
      items: rootItems,
      itemTemplate: this._getTemplateByOption("itemTemplate"),
      itemHoldTimeout,
      onItemHold: this._createActionByOption("onItemHold"),
      onItemClick: this._createActionByOption("onItemClick"),
      onItemContextMenu: this._createActionByOption("onItemContextMenu"),
      onItemRendered: this._createActionByOption("onItemRendered")
    };
  }
  _needApplyAutoBaseSize(item) {
    return !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize);
  }
  _prepareBoxConfig(config2) {
    return extend(config2 || {}, {
      crossAlign: "stretch",
      onItemStateChanged: this.option("onItemStateChanged")
    });
  }
  _layoutBlock(options2) {
    if (this._isSingleItem(options2)) {
      return this._itemByCell(options2.row.start, options2.col.start);
    }
    return this._layoutDirection(options2);
  }
  _isSingleItem(options2) {
    const firstCellLocation = this._grid[options2.row.start][options2.col.start].location;
    const isItemRowSpanned = options2.row.end - options2.row.start === firstCellLocation.rowspan - 1;
    const isItemColSpanned = options2.col.end - options2.col.start === firstCellLocation.colspan - 1;
    return isItemRowSpanned && isItemColSpanned;
  }
  _itemByCell(rowIndex, colIndex) {
    const itemCell = this._grid[rowIndex][colIndex];
    return itemCell.spanningCell ? null : itemCell.item;
  }
  _layoutDirection(options2) {
    const items = [];
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    let block;
    while (block = this._nextBlock(options2)) {
      if (this._isBlockIndivisible(options2.prevBlockOptions, block)) {
        throw ui_errors_default.Error("E1025");
      }
      const item = this._layoutBlock({
        direction: crossDirection,
        row: block.row,
        col: block.col,
        prevBlockOptions: options2
      });
      if (item) {
        extend(item, this._blockSize(block, crossDirection));
        items.push(item);
      }
      options2[crossDirection].start = block[crossDirection].end + 1;
    }
    return {
      box: this._prepareBoxConfig({
        direction,
        items
      })
    };
  }
  _isBlockIndivisible(options2, block) {
    return options2 && options2.col.start === block.col.start && options2.col.end === block.col.end && options2.row.start === block.row.start && options2.row.end === block.row.end;
  }
  _crossDirection(direction) {
    return "col" === direction ? "row" : "col";
  }
  _nextBlock(options2) {
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    const startIndex = options2[direction].start;
    const endIndex = options2[direction].end;
    const crossStartIndex = options2[crossDirection].start;
    if (crossStartIndex > options2[crossDirection].end) {
      return null;
    }
    let crossSpan = 1;
    for (let crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
      let lineCrossSpan = 1;
      for (let index = startIndex; index <= endIndex; index++) {
        const cell = this._cellByDirection(direction, index, crossIndex);
        lineCrossSpan = Math.max(lineCrossSpan, cell.location[`${crossDirection}span`]);
      }
      const lineCrossEndIndex = crossIndex + lineCrossSpan;
      const crossEndIndex = crossStartIndex + crossSpan;
      if (lineCrossEndIndex > crossEndIndex) {
        crossSpan += lineCrossEndIndex - crossEndIndex;
      }
    }
    const result2 = {};
    result2[direction] = {
      start: startIndex,
      end: endIndex
    };
    result2[crossDirection] = {
      start: crossStartIndex,
      end: crossStartIndex + crossSpan - 1
    };
    return result2;
  }
  _cellByDirection(direction, index, crossIndex) {
    return "col" === direction ? this._grid[crossIndex][index] : this._grid[index][crossIndex];
  }
  _blockSize(block, direction) {
    const defaultMinSize = "row" === direction ? "auto" : 0;
    const sizeConfigs = "row" === direction ? this._rows : this._cols;
    const result2 = extend(this._createDefaultSizeConfig(), {
      ratio: 0
    });
    for (let index = block[direction].start; index <= block[direction].end; index++) {
      const sizeConfig = sizeConfigs[index];
      result2.ratio += sizeConfig.ratio;
      result2.baseSize += sizeConfig.baseSize;
      result2.minSize += sizeConfig.minSize;
      result2.maxSize += sizeConfig.maxSize;
      if (isDefined(sizeConfig.shrink)) {
        result2.shrink = sizeConfig.shrink;
      }
    }
    result2.minSize = result2.minSize ? result2.minSize : defaultMinSize;
    result2.maxSize = result2.maxSize ? result2.maxSize : "auto";
    this._isSingleColumnScreen() && (result2.baseSize = "auto");
    return result2;
  }
  _update(forceRemoveRoot) {
    var _this$_layoutChangedA;
    const $existingRoot = this._$root;
    this._renderItems();
    if ($existingRoot) {
      if (forceRemoveRoot) {
        $existingRoot.remove();
      } else {
        $existingRoot.detach();
        this._saveAssistantRoot($existingRoot);
      }
    }
    null === (_this$_layoutChangedA = this._layoutChangedAction) || void 0 === _this$_layoutChangedA || _this$_layoutChangedA.call(this);
  }
  _saveAssistantRoot($root) {
    this._assistantRoots = this._assistantRoots || [];
    this._assistantRoots.push($root);
  }
  _dispose() {
    this._clearItemNodeTemplates();
    this._cleanUnusedRoots();
    super._dispose.apply(this, arguments);
  }
  _cleanUnusedRoots() {
    if (!this._assistantRoots) {
      return;
    }
    each(this._assistantRoots, ((_, item) => {
      renderer_default(item).remove();
    }));
  }
  _clearItemNodeTemplates() {
    each(this.option("items"), (function() {
      delete this.node;
    }));
  }
  _attachClickEvent() {
  }
  _optionChanged(args) {
    switch (args.name) {
      case "rows":
      case "cols":
      case "screenByWidth":
      case "singleColumnScreen":
        this._clearItemNodeTemplates();
        this._invalidate();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._update();
        break;
      case "onLayoutChanged":
        this._initLayoutChangedAction();
        break;
      case "itemTemplate":
        this._clearItemNodeTemplates();
        super._optionChanged(args);
        break;
      case "currentScreenFactor":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dimensionChanged() {
    if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
      this._update();
    }
  }
  repaint() {
    this._update();
  }
};
component_registrator_default("dxResponsiveBox", ResponsiveBox);
var m_responsive_box_default = ResponsiveBox;

// node_modules/devextreme/esm/__internal/ui/form/components/m_button_item.js
function renderButtonItem(_ref) {
  let {
    item,
    $parent,
    rootElementCssClassList,
    validationGroup,
    createComponentCallback
  } = _ref;
  const $rootElement = renderer_default("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass("dx-field-button-item").css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
  $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
  const $button = renderer_default("<div>").appendTo($rootElement);
  return {
    $rootElement,
    buttonInstance: createComponentCallback($button, "dxButton", extend({
      validationGroup
    }, item.buttonOptions))
  };
}
function convertAlignmentToTextAlign(horizontalAlignment) {
  return isDefined(horizontalAlignment) ? horizontalAlignment : "right";
}
function convertAlignmentToJustifyContent(verticalAlignment) {
  switch (verticalAlignment) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_empty_item.js
function renderEmptyItem(_ref) {
  let {
    $parent,
    rootElementCssClassList
  } = _ref;
  return renderer_default("<div>").addClass("dx-field-empty-item").html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
}

// node_modules/devextreme/esm/ui/validator.js
var validator_default = m_validator_default;

// node_modules/devextreme/esm/__internal/ui/form/constants.js
var FORM_CLASS = "dx-form";
var FORM_GROUP_CLASS = "dx-form-group";
var FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
var FORM_GROUP_CUSTOM_CAPTION_CLASS = "dx-form-group-custom-caption";
var FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
var FIELD_ITEM_CLASS = "dx-field-item";
var LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
var FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
var FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
var FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
var FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
var ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
var FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
var FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
var FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
var FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
var FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
var GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
var GROUP_COL_COUNT_ATTR = "group-col-count";
var FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
var FORM_UNDERLINED_CLASS = "dx-form-styling-mode-underlined";
var SIMPLE_ITEM_TYPE = "simple";

// node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.utils.js
var EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_MULTIPLE_INPUT_FIELDS = ["dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_SPECIFIC_LABELS = ["dxRangeSlider", "dxSlider"];
var EDITORS_WITHOUT_LABELS = ["dxCalendar", "dxCheckBox", "dxHtmlEditor", "dxRadioGroup", "dxRangeSlider", "dxSlider", "dxSwitch"];
var DROP_DOWN_EDITORS = ["dxSelectBox", "dxDropDownBox", "dxTagBox", "dxLookup", "dxAutocomplete", "dxColorBox", "dxDateBox", "dxDateRangeBox"];
function convertToRenderFieldItemOptions(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    item,
    template,
    labelTemplate,
    name: name2,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorValue,
    canAssignUndefinedValueToEditor,
    editorValidationBoundary,
    editorStylingMode,
    showColonAfterLabel,
    managerLabelLocation,
    itemId,
    managerMarkOptions,
    labelMode,
    onLabelTemplateRendered
  } = _ref;
  const isRequired = isDefined(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
  const isSimpleItem = item.itemType === SIMPLE_ITEM_TYPE;
  const helpID = item.helpText ? `dx-${new guid_default()}` : null;
  const labelOptions = _convertToLabelOptions({
    item,
    id: itemId,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation: managerLabelLocation,
    formLabelMode: labelMode,
    labelTemplate,
    onLabelTemplateRendered
  });
  const needRenderLabel = labelOptions.visible && (labelOptions.text || labelOptions.labelTemplate && isSimpleItem);
  const {
    location: labelLocation,
    labelID
  } = labelOptions;
  const labelNeedBaselineAlign = "top" !== labelLocation && ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"].includes(item.editorType);
  const editorOptions = _convertToEditorOptions({
    $parent,
    editorType: item.editorType,
    editorValue,
    defaultEditorName: item.dataField,
    canAssignUndefinedValueToEditor,
    externalEditorOptions: item.editorOptions,
    editorInputId: itemId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode: labelMode,
    labelText: labelOptions.textWithoutColon,
    labelMark: labelOptions.markOptions.showRequiredMark ? String.fromCharCode(160) + labelOptions.markOptions.requiredMark : ""
  });
  const needRenderOptionalMarkAsHelpText = labelOptions.markOptions.showOptionalMark && !labelOptions.visible && "hidden" !== editorOptions.labelMode && !isDefined(item.helpText);
  const helpText = needRenderOptionalMarkAsHelpText ? labelOptions.markOptions.optionalMark : item.helpText;
  return {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    item,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorOptions
  };
}
function getLabelMarkText(_ref2) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  if (!showRequiredMark && !showOptionalMark) {
    return "";
  }
  return String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark);
}
function convertToLabelMarkOptions(_ref3, isRequired) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref3;
  return {
    showRequiredMark: showRequiredMark && isRequired,
    requiredMark,
    showOptionalMark: showOptionalMark && !isRequired,
    optionalMark
  };
}
function getDropDownEditorOptions($parent, editorType, editorInputId) {
  const isDropDownEditor = DROP_DOWN_EDITORS.includes(editorType);
  if (!isDropDownEditor) {
    return {};
  }
  return {
    onPopupInitialized: (_ref4) => {
      let {
        component,
        popup
      } = _ref4;
      const openOnFieldClick = component.option("openOnFieldClick");
      const initialHideOnOutsideClick = popup.option("hideOnOutsideClick");
      if (openOnFieldClick && isFunction(initialHideOnOutsideClick)) {
        const hideOnOutsideClick = (e) => {
          const $target = renderer_default(e.target);
          const $label = $parent.find(`label[for="${editorInputId}"]`);
          const isLabelClicked = !!$target.closest($label).length;
          return !isLabelClicked && initialHideOnOutsideClick(e);
        };
        component.option("dropDownOptions", {
          hideOnOutsideClick
        });
        popup.option({
          hideOnOutsideClick
        });
      }
    }
  };
}
function _convertToEditorOptions(_ref5) {
  let {
    $parent,
    editorType,
    defaultEditorName,
    editorValue,
    canAssignUndefinedValueToEditor,
    externalEditorOptions,
    editorInputId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode,
    labelText,
    labelMark
  } = _ref5;
  const editorOptionsWithValue = {};
  if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
    editorOptionsWithValue.value = editorValue;
  }
  if (EDITORS_WITH_ARRAY_VALUE.includes(editorType)) {
    editorOptionsWithValue.value = editorOptionsWithValue.value || [];
  }
  let labelMode = null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.labelMode;
  if (!isDefined(labelMode)) {
    labelMode = "outside" === formLabelMode ? "hidden" : formLabelMode;
  }
  const stylingMode = (null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.stylingMode) || editorStylingMode;
  const useSpecificLabelOptions = EDITORS_WITH_SPECIFIC_LABELS.includes(editorType);
  const dropDownEditorOptions = getDropDownEditorOptions($parent, editorType, editorInputId);
  const result2 = extend(true, editorOptionsWithValue, externalEditorOptions, dropDownEditorOptions, {
    inputAttr: {
      id: editorInputId
    },
    validationBoundary: editorValidationBoundary,
    stylingMode,
    label: useSpecificLabelOptions ? null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.label : labelText,
    labelMode,
    labelMark
  });
  if (externalEditorOptions) {
    if (result2.dataSource) {
      result2.dataSource = externalEditorOptions.dataSource;
    }
    if (result2.items) {
      result2.items = externalEditorOptions.items;
    }
  }
  if (defaultEditorName) {
    if (EDITORS_WITH_MULTIPLE_INPUT_FIELDS.includes(editorType)) {
      if ("dxRangeSlider" === editorType) {
        if (!result2.startName) {
          result2.startName = `${defaultEditorName}Start`;
        }
        if (!result2.endName) {
          result2.endName = `${defaultEditorName}End`;
        }
      }
      if ("dxDateRangeBox" === editorType) {
        if (!result2.startDateName) {
          result2.startDateName = `${defaultEditorName}Start`;
        }
        if (!result2.endDateName) {
          result2.endDateName = `${defaultEditorName}End`;
        }
      }
      return result2;
    }
    if (!result2.name) {
      result2.name = defaultEditorName;
    }
  }
  return result2;
}
function _hasRequiredRuleInSet(rules) {
  let hasRequiredRule;
  if (null !== rules && void 0 !== rules && rules.length) {
    each(rules, ((index, rule) => {
      if ("required" === rule.type) {
        hasRequiredRule = true;
        return false;
      }
    }));
  }
  return hasRequiredRule;
}
function _convertToLabelOptions(_ref6) {
  let {
    item,
    id,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation,
    labelTemplate,
    formLabelMode,
    onLabelTemplateRendered
  } = _ref6;
  const isEditorWithoutLabels = EDITORS_WITHOUT_LABELS.includes(item.editorType);
  const labelOptions = extend({
    showColon: showColonAfterLabel,
    location: labelLocation,
    id,
    visible: "outside" === formLabelMode || isEditorWithoutLabels && "hidden" !== formLabelMode,
    isRequired
  }, item ? item.label : {}, {
    markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired),
    labelTemplate,
    onLabelTemplateRendered
  });
  if (["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor", "dxDateRangeBox"].includes(item.editorType)) {
    labelOptions.labelID = `dx-label-${new guid_default()}`;
  }
  if (!labelOptions.text && item.dataField) {
    labelOptions.text = captionize(item.dataField);
  }
  if (labelOptions.text) {
    labelOptions.textWithoutColon = labelOptions.text;
    labelOptions.text += labelOptions.showColon ? ":" : "";
  }
  return labelOptions;
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_label.js
function renderLabel(_ref) {
  let {
    text,
    id,
    location,
    alignment,
    labelID = null,
    markOptions = {},
    labelTemplate,
    labelTemplateData,
    onLabelTemplateRendered
  } = _ref;
  if ((!isDefined(text) || text.length <= 0) && !isDefined(labelTemplate)) {
    return null;
  }
  const $label = renderer_default("<label>").addClass(`${FIELD_ITEM_LABEL_CLASS} dx-field-item-label-location-${location}`).attr("for", id).attr("id", labelID).css("textAlign", alignment);
  const $labelContainer = renderer_default("<span>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS);
  let $labelContent = renderer_default("<span>").addClass("dx-field-item-label-text").text(text);
  if (labelTemplate) {
    $labelContent = renderer_default("<div>").addClass("dx-field-item-custom-label-content");
    labelTemplateData.text = text;
    labelTemplate.render({
      container: getPublicElement($labelContent),
      model: labelTemplateData,
      onRendered() {
        null === onLabelTemplateRendered || void 0 === onLabelTemplateRendered || onLabelTemplateRendered();
      }
    });
  }
  return $label.append($labelContainer.append($labelContent, _renderLabelMark(markOptions)));
}
function _renderLabelMark(markOptions) {
  const markText = getLabelMarkText(markOptions);
  if ("" === markText) {
    return null;
  }
  return renderer_default("<span>").addClass(markOptions.showRequiredMark ? "dx-field-item-required-mark" : "dx-field-item-optional-mark").text(markText);
}
function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = `${labelsSelector} > .${FIELD_ITEM_LABEL_CLASS}:not(.dx-field-item-label-location-top) > .${FIELD_ITEM_LABEL_CONTENT_CLASS}`;
  const $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
  let labelWidth;
  let i;
  let maxWidth = 0;
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    labelWidth = getLabelWidthByHTML($FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i]);
    if (labelWidth > maxWidth) {
      maxWidth = labelWidth;
    }
  }
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = `${maxWidth}px`;
  }
}
function getLabelWidthByHTML(labelContent) {
  let result2 = 0;
  const itemsCount = labelContent.children.length;
  for (let i = 0; i < itemsCount; i++) {
    const child = labelContent.children[i];
    result2 += child.offsetWidth;
  }
  return result2;
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_field_item.js
function renderFieldItem(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    formLabelLocation,
    item,
    editorOptions,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    requiredMessageTemplate,
    validationGroup
  } = _ref;
  const $rootElement = renderer_default("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
  $rootElement.addClass(isRequired ? "dx-field-item-required" : "dx-field-item-optional");
  if (isSimpleItem) {
    $rootElement.addClass("dx-flex-layout");
  }
  if (isSimpleItem && labelNeedBaselineAlign) {
    $rootElement.addClass("dx-field-item-label-align");
  }
  const $fieldEditorContainer = renderer_default("<div>");
  $fieldEditorContainer.data("dx-form-item", item);
  $fieldEditorContainer.addClass(FIELD_ITEM_CONTENT_CLASS).addClass("dx-field-item-content-location-" + {
    right: "left",
    left: "right",
    top: "bottom"
  }[formLabelLocation]);
  let $label = null;
  if (needRenderLabel) {
    if (labelOptions.labelTemplate) {
      labelOptions.labelTemplateData = getTemplateData(item, editorOptions, formOrLayoutManager);
    }
    $label = renderLabel(labelOptions);
  }
  if ($label) {
    const {
      editorType
    } = item;
    $rootElement.append($label);
    if ("top" === labelLocation || "left" === labelLocation) {
      $rootElement.append($fieldEditorContainer);
    }
    if ("right" === labelLocation) {
      $rootElement.prepend($fieldEditorContainer);
    }
    if ("top" === labelLocation) {
      $rootElement.addClass("dx-label-v-align");
    } else {
      $rootElement.addClass("dx-label-h-align");
    }
    if ("dxCheckBox" === editorType || "dxSwitch" === editorType) {
      m_events_engine_default.on($label, CLICK_EVENT_NAME, (() => {
        m_events_engine_default.trigger($fieldEditorContainer.children(), CLICK_EVENT_NAME);
      }));
    }
    const toggleControls = ["dxCheckBox", "dxSwitch", "dxRadioGroup"];
    const isToggleControls = toggleControls.includes(editorType);
    const labelAlignment = labelOptions.alignment;
    const isLabelAlignmentLeft = "left" === labelAlignment || !labelAlignment;
    const hasNotTemplate = !template;
    const isLabelOnTop = "top" === labelLocation;
    if (hasNotTemplate && isToggleControls && isLabelOnTop && isLabelAlignmentLeft) {
      $fieldEditorContainer.addClass("dx-toggle-controls-paddings");
    }
  } else {
    $rootElement.append($fieldEditorContainer);
  }
  let widgetInstance;
  if (template) {
    template.render({
      container: getPublicElement($fieldEditorContainer),
      model: getTemplateData(item, editorOptions, formOrLayoutManager),
      onRendered() {
        const $validationTarget2 = getValidationTarget($fieldEditorContainer);
        const validationTargetInstance2 = tryGetValidationTargetInstance($validationTarget2);
        subscribeWrapperInvalidClassToggle(validationTargetInstance2);
      }
    });
  } else {
    const $div = renderer_default("<div>").appendTo($fieldEditorContainer);
    try {
      widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
      widgetInstance.setAria("describedby", helpID);
      if (labelID) {
        widgetInstance.setAria("labelledby", labelID);
      }
      widgetInstance.setAria("required", isRequired);
    } catch (e) {
      ui_errors_default.log("E1035", e.message);
    }
  }
  const $validationTarget = getValidationTarget($fieldEditorContainer);
  const validationTargetInstance = $validationTarget && $validationTarget.data("dx-validation-target");
  if (validationTargetInstance) {
    const isItemHaveCustomLabel = item.label && item.label.text;
    const itemName = isItemHaveCustomLabel ? null : name2;
    const fieldName = isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);
    let validationRules;
    if (isSimpleItem) {
      if (item.validationRules) {
        validationRules = item.validationRules;
      } else {
        const requiredMessage = format(requiredMessageTemplate, fieldName || "");
        validationRules = item.isRequired ? [{
          type: "required",
          message: requiredMessage
        }] : null;
      }
    }
    if (Array.isArray(validationRules) && validationRules.length) {
      createComponentCallback($validationTarget, validator_default, {
        validationRules,
        validationGroup,
        dataGetter: () => ({
          formItem: item
        })
      });
    }
    subscribeWrapperInvalidClassToggle(validationTargetInstance);
  }
  if (helpText && isSimpleItem) {
    const $editorParent = $fieldEditorContainer.parent();
    $editorParent.append(renderer_default("<div>").addClass("dx-field-item-content-wrapper").append($fieldEditorContainer).append(renderer_default("<div>").addClass("dx-field-item-help-text").attr("id", helpID).text(helpText)));
  }
  return {
    $fieldEditorContainer,
    $rootElement,
    widgetInstance
  };
}
function getValidationTarget($fieldEditorContainer) {
  const $editor = $fieldEditorContainer.children().first();
  return $editor.hasClass("dx-template-wrapper") ? $editor.children().first() : $editor;
}
function tryGetValidationTargetInstance($validationTarget) {
  var _$validationTarget$pa;
  return (null === $validationTarget || void 0 === $validationTarget ? void 0 : $validationTarget.data("dx-validation-target")) || (null === $validationTarget || void 0 === $validationTarget || null === (_$validationTarget$pa = $validationTarget.parent) || void 0 === _$validationTarget$pa || null === (_$validationTarget$pa = _$validationTarget$pa.call($validationTarget)) || void 0 === _$validationTarget$pa ? void 0 : _$validationTarget$pa.data("dx-validation-target"));
}
function subscribeWrapperInvalidClassToggle(validationTargetInstance) {
  if (validationTargetInstance && isMaterialBased()) {
    const wrapperClass = ".dx-field-item-content-wrapper";
    const toggleInvalidClass = (_ref2) => {
      let {
        element,
        component
      } = _ref2;
      const {
        isValid,
        validationMessageMode
      } = component.option();
      renderer_default(element).parents(wrapperClass).toggleClass("dx-invalid", false === isValid && (component._isFocused() || "always" === validationMessageMode));
    };
    validationTargetInstance.on("optionChanged", ((e) => {
      if ("isValid" !== e.name) {
        return;
      }
      toggleInvalidClass(e);
    }));
    validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass);
  }
}
function getTemplateData(item, editorOptions, formOrLayoutManager) {
  return {
    dataField: item.dataField,
    editorType: item.editorType,
    editorOptions,
    component: formOrLayoutManager,
    name: item.name
  };
}

// node_modules/devextreme/esm/__internal/ui/form/m_form.items_runtime_info.js
var FormItemsRunTimeInfo = class {
  constructor() {
    this._map = {};
  }
  _findWidgetInstance(condition) {
    let result2;
    each(this._map, ((guid, _ref) => {
      let {
        widgetInstance,
        item
      } = _ref;
      if (condition(item)) {
        result2 = widgetInstance;
        return false;
      }
    }));
    return result2;
  }
  _findFieldByCondition(callback, valueExpr) {
    let result2;
    each(this._map, ((key, value2) => {
      if (callback(value2)) {
        result2 = "guid" === valueExpr ? key : value2[valueExpr];
        return false;
      }
    }));
    return result2;
  }
  clear() {
    this._map = {};
  }
  removeItemsByItems(itemsRunTimeInfo) {
    each(itemsRunTimeInfo.getItems(), ((guid) => this.removeItemByKey(guid)));
  }
  removeItemByKey(key) {
    delete this._map[key];
  }
  add(options2) {
    const key = options2.guid || new guid_default();
    this._map[key] = options2;
    return key;
  }
  addItemsOrExtendFrom(itemsRunTimeInfo) {
    itemsRunTimeInfo.each(((key, itemRunTimeInfo) => {
      if (this._map[key]) {
        if (itemRunTimeInfo.widgetInstance) {
          this._map[key].widgetInstance = itemRunTimeInfo.widgetInstance;
        }
        this._map[key].$itemContainer = itemRunTimeInfo.$itemContainer;
      } else {
        this.add({
          item: itemRunTimeInfo.item,
          widgetInstance: itemRunTimeInfo.widgetInstance,
          guid: key,
          $itemContainer: itemRunTimeInfo.$itemContainer
        });
      }
    }));
  }
  extendRunTimeItemInfoByKey(key, options2) {
    if (this._map[key]) {
      this._map[key] = extend(this._map[key], options2);
    }
  }
  findWidgetInstanceByItem(item) {
    return this._findWidgetInstance(((storedItem) => storedItem === item));
  }
  findGroupOrTabLayoutManagerByPath(targetPath) {
    return this._findFieldByCondition(((_ref2) => {
      let {
        path
      } = _ref2;
      return path === targetPath;
    }), "layoutManager");
  }
  findKeyByPath(targetPath) {
    return this._findFieldByCondition(((_ref3) => {
      let {
        path
      } = _ref3;
      return path === targetPath;
    }), "guid");
  }
  findWidgetInstanceByName(name2) {
    return this._findWidgetInstance(((item) => name2 === item.name));
  }
  findWidgetInstanceByDataField(dataField) {
    return this._findWidgetInstance(((item) => dataField === (isString(item) ? item : item.dataField)));
  }
  findItemContainerByItem(item) {
    for (const key in this._map) {
      if (this._map[key].item === item) {
        return this._map[key].$itemContainer;
      }
    }
    return null;
  }
  findItemIndexByItem(targetItem) {
    return this._findFieldByCondition(((_ref4) => {
      let {
        item
      } = _ref4;
      return item === targetItem;
    }), "itemIndex");
  }
  findPreparedItemByItem(item) {
    return this._findFieldByCondition(((_ref5) => {
      let {
        item: currentItem
      } = _ref5;
      return currentItem === item;
    }), "preparedItem");
  }
  getItems() {
    return this._map;
  }
  each(handler) {
    each(this._map, ((key, itemRunTimeInfo) => {
      handler(key, itemRunTimeInfo);
    }));
  }
  removeItemsByPathStartWith(path) {
    const keys = Object.keys(this._map);
    const filteredKeys = keys.filter(((key) => {
      if (this._map[key].path) {
        return this._map[key].path.indexOf(path, 0) > -1;
      }
      return false;
    }));
    filteredKeys.forEach(((key) => this.removeItemByKey(key)));
  }
};

// node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.js
var LayoutManager = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      layoutData: {},
      readOnly: false,
      colCount: 1,
      labelLocation: "left",
      onFieldDataChanged: null,
      onEditorEnterKey: null,
      customizeItem: null,
      alignItemLabels: true,
      minColWidth: 200,
      showRequiredMark: true,
      screenByWidth: null,
      showOptionalMark: false,
      requiredMark: "*",
      labelMode: "outside",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage")
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      layoutData: true,
      validationGroup: true
    });
  }
  _init() {
    const layoutData = this.option("layoutData");
    super._init();
    this._itemWatchers = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._updateReferencedOptions(layoutData);
    this._initDataAndItems(layoutData);
  }
  _dispose() {
    super._dispose();
    this._cleanItemWatchers();
  }
  _initDataAndItems(initialData) {
    this._syncDataWithItems();
    this._updateItems(initialData);
  }
  _syncDataWithItems() {
    const layoutData = this.option("layoutData");
    const userItems = this.option("items");
    if (isDefined(userItems)) {
      userItems.forEach(((item) => {
        if (item.dataField && void 0 === this._getDataByField(item.dataField)) {
          let value2;
          if (item.editorOptions) {
            value2 = item.editorOptions.value;
          }
          if (isDefined(value2) || item.dataField in layoutData) {
            this._updateFieldValue(item.dataField, value2);
          }
        }
      }));
    }
  }
  _getDataByField(dataField) {
    return dataField ? this.option(`layoutData.${dataField}`) : null;
  }
  _isCheckboxUndefinedStateEnabled(_ref) {
    let {
      allowIndeterminateState,
      editorType,
      dataField
    } = _ref;
    if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
      const nameParts = ["layoutData", ...dataField.split(".")];
      const propertyName = nameParts.pop();
      const layoutData = this.option(nameParts.join("."));
      return layoutData && propertyName in layoutData;
    }
    return false;
  }
  _updateFieldValue(dataField, value2) {
    const layoutData = this.option("layoutData");
    let newValue = value2;
    if (!variable_wrapper_default.isWrapped(layoutData[dataField]) && isDefined(dataField)) {
      this.option(`layoutData.${dataField}`, newValue);
    } else if (variable_wrapper_default.isWritableWrapped(layoutData[dataField])) {
      newValue = isFunction(newValue) ? newValue() : newValue;
      layoutData[dataField](newValue);
    }
    this._triggerOnFieldDataChanged({
      dataField,
      value: newValue
    });
  }
  _triggerOnFieldDataChanged(args) {
    this._createActionByOption("onFieldDataChanged")(args);
  }
  _updateItems(layoutData) {
    const that = this;
    const userItems = this.option("items");
    const isUserItemsExist = isDefined(userItems);
    const {
      customizeItem
    } = this.option();
    const items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
    if (isDefined(items)) {
      const processedItems = [];
      each(items, ((index, item) => {
        if (that._isAcceptableItem(item)) {
          item = that._processItem(item);
          customizeItem && customizeItem(item);
          if (isObject(item) && false !== variable_wrapper_default.unwrap(item.visible)) {
            processedItems.push(item);
          }
        }
      }));
      if (!that._itemWatchers.length || !isUserItemsExist) {
        that._updateItemWatchers(items);
      }
      this._setItems(processedItems);
      this._sortItems();
    }
  }
  _cleanItemWatchers() {
    this._itemWatchers.forEach(((dispose) => {
      dispose();
    }));
    this._itemWatchers = [];
  }
  _updateItemWatchers(items) {
    const that = this;
    const watch = that._getWatch();
    items.forEach(((item) => {
      if (isObject(item) && isDefined(item.visible) && isFunction(watch)) {
        that._itemWatchers.push(watch((() => variable_wrapper_default.unwrap(item.visible)), (() => {
          that._updateItems(that.option("layoutData"));
          that.repaint();
        }), {
          skipImmediate: true
        }));
      }
    }));
  }
  _generateItemsByData(layoutData) {
    const result2 = [];
    if (isDefined(layoutData)) {
      each(layoutData, ((dataField) => {
        result2.push({
          dataField
        });
      }));
    }
    return result2;
  }
  _isAcceptableItem(item) {
    const itemField = item.dataField || item;
    const itemData = this._getDataByField(itemField);
    return !(isFunction(itemData) && !variable_wrapper_default.isWrapped(itemData));
  }
  _processItem(item) {
    if ("string" === typeof item) {
      item = {
        dataField: item
      };
    }
    if ("object" === typeof item && !item.itemType) {
      item.itemType = SIMPLE_ITEM_TYPE;
    }
    if (!isDefined(item.editorType) && isDefined(item.dataField)) {
      const value2 = this._getDataByField(item.dataField);
      item.editorType = isDefined(value2) ? this._getEditorTypeByDataType(type(value2)) : "dxTextBox";
    }
    if ("dxCheckBox" === item.editorType) {
      item.allowIndeterminateState = item.allowIndeterminateState ?? true;
    }
    return item;
  }
  _getEditorTypeByDataType(dataType) {
    switch (dataType) {
      case "number":
        return "dxNumberBox";
      case "date":
        return "dxDateBox";
      case "boolean":
        return "dxCheckBox";
      default:
        return "dxTextBox";
    }
  }
  _sortItems() {
    normalizeIndexes(this._items, "visibleIndex");
    this._sortIndexes();
  }
  _sortIndexes() {
    this._items.sort(((itemA, itemB) => {
      const indexA = itemA.visibleIndex;
      const indexB = itemB.visibleIndex;
      let result2;
      if (indexA > indexB) {
        result2 = 1;
      } else if (indexA < indexB) {
        result2 = -1;
      } else {
        result2 = 0;
      }
      return result2;
    }));
  }
  _initMarkup() {
    this._itemsRunTimeInfo.clear();
    this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);
    super._initMarkup();
    this._renderResponsiveBox();
  }
  _renderResponsiveBox() {
    const that = this;
    const templatesInfo = [];
    if (that._items && that._items.length) {
      const colCount = that._getColCount();
      const $container = renderer_default("<div>").appendTo(that.$element());
      that._prepareItemsWithMerging(colCount);
      const layoutItems = that._generateLayoutItems();
      that._responsiveBox = that._createComponent($container, m_responsive_box_default, that._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
      if (!hasWindow()) {
        that._renderTemplates(templatesInfo);
      }
    }
  }
  _itemStateChangedHandler(e) {
    this._refresh();
  }
  _renderTemplates(templatesInfo) {
    const that = this;
    let itemsWithLabelTemplateCount = 0;
    templatesInfo.forEach(((_ref2) => {
      var _item$label;
      let {
        item
      } = _ref2;
      if (null !== item && void 0 !== item && null !== (_item$label = item.label) && void 0 !== _item$label && _item$label.template) {
        itemsWithLabelTemplateCount++;
      }
    }));
    each(templatesInfo, ((index, info) => {
      switch (info.itemType) {
        case "empty":
          renderEmptyItem(info);
          break;
        case "button":
          that._renderButtonItem(info);
          break;
        default:
          that._renderFieldItem(info, itemsWithLabelTemplateCount);
      }
    }));
  }
  _getResponsiveBoxConfig(layoutItems, colCount, templatesInfo) {
    const that = this;
    const colCountByScreen = that.option("colCountByScreen");
    const xsColCount = colCountByScreen && colCountByScreen.xs;
    return {
      onItemStateChanged: this._itemStateChangedHandler.bind(this),
      onLayoutChanged() {
        const {
          onLayoutChanged
        } = that.option();
        const isSingleColumnMode = that.isSingleColumnMode();
        if (onLayoutChanged) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
          onLayoutChanged(isSingleColumnMode);
        }
      },
      onContentReady(e) {
        if (hasWindow()) {
          that._renderTemplates(templatesInfo);
        }
        if (that.option("onLayoutChanged")) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));
        }
      },
      itemTemplate(e, itemData, itemElement) {
        if (!e.location) {
          return;
        }
        const $itemElement = renderer_default(itemElement);
        const itemRenderedCountInPreviousRows = e.location.row * colCount;
        const item = that._items[e.location.col + itemRenderedCountInPreviousRows];
        if (!item) {
          return;
        }
        const itemCssClassList = [item.cssClass];
        $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
        if (0 === e.location.row) {
          itemCssClassList.push("dx-first-row");
        }
        if (0 === e.location.col) {
          itemCssClassList.push("dx-first-col");
        }
        if (item.itemType === SIMPLE_ITEM_TYPE && that.option("isRoot")) {
          $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);
        }
        const isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
        const rowsCount = that._getRowsCount();
        const isLastRow = e.location.row === rowsCount - 1;
        if (isLastColumn) {
          itemCssClassList.push("dx-last-col");
        }
        if (isLastRow) {
          itemCssClassList.push("dx-last-row");
        }
        if ("empty" !== item.itemType) {
          itemCssClassList.push(FIELD_ITEM_CLASS);
          itemCssClassList.push(that.option("cssItemClass"));
          if (isDefined(item.col)) {
            itemCssClassList.push(`dx-col-${item.col}`);
          }
        }
        templatesInfo.push({
          itemType: item.itemType,
          item,
          $parent: $itemElement,
          rootElementCssClassList: itemCssClassList
        });
      },
      cols: that._generateRatio(colCount),
      rows: that._generateRatio(that._getRowsCount(), true),
      dataSource: layoutItems,
      screenByWidth: that.option("screenByWidth"),
      singleColumnScreen: xsColCount ? false : "xs"
    };
  }
  _getColCount() {
    let {
      colCount
    } = this.option();
    const colCountByScreen = this.option("colCountByScreen");
    if (colCountByScreen) {
      const {
        form
      } = this.option();
      let screenFactor = null === form || void 0 === form ? void 0 : form.getTargetScreenFactor();
      if (!screenFactor) {
        screenFactor = hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
      }
      colCount = colCountByScreen[screenFactor] || colCount;
    }
    if ("auto" === colCount) {
      if (this._cashedColCount) {
        return this._cashedColCount;
      }
      this._cashedColCount = colCount = this._getMaxColCount();
    }
    return colCount < 1 ? 1 : colCount;
  }
  _getMaxColCount() {
    if (!hasWindow()) {
      return 1;
    }
    const minColWidth = this.option("minColWidth");
    const width = getWidth(this.$element());
    const itemsCount = this._items.length;
    const maxColCount = Math.floor(width / minColWidth) || 1;
    return itemsCount < maxColCount ? itemsCount : maxColCount;
  }
  isCachedColCountObsolete() {
    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
  }
  _prepareItemsWithMerging(colCount) {
    const items = this._items.slice(0);
    let item;
    let itemsMergedByCol;
    let result2 = [];
    let j;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      result2.push(item);
      if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
        item.col = this._getColByIndex(result2.length - 1, colCount);
      }
      if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
        itemsMergedByCol = [];
        for (j = 0; j < item.colSpan - 1; j++) {
          itemsMergedByCol.push({
            merged: true
          });
        }
        result2 = result2.concat(itemsMergedByCol);
      } else {
        delete item.colSpan;
      }
    }
    this._setItems(result2);
  }
  _getColByIndex(index, colCount) {
    return index % colCount;
  }
  _setItems(items) {
    this._items = items;
    this._cashedColCount = null;
  }
  _generateLayoutItems() {
    const items = this._items;
    const colCount = this._getColCount();
    const result2 = [];
    let item;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      if (!item.merged) {
        const generatedItem = {
          location: {
            row: parseInt(i / colCount),
            col: this._getColByIndex(i, colCount)
          }
        };
        if (isDefined(item.disabled)) {
          generatedItem.disabled = item.disabled;
        }
        if (isDefined(item.visible)) {
          generatedItem.visible = item.visible;
        }
        if (isDefined(item.colSpan)) {
          generatedItem.location.colspan = item.colSpan;
        }
        if (isDefined(item.rowSpan)) {
          generatedItem.location.rowspan = item.rowSpan;
        }
        result2.push(generatedItem);
      }
    }
    return result2;
  }
  _renderEmptyItem($container) {
    renderEmptyItem({
      $container
    });
  }
  _renderButtonItem(_ref3) {
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref3;
    const {
      $rootElement,
      buttonInstance
    } = renderButtonItem({
      item,
      $parent,
      rootElementCssClassList,
      validationGroup: this.option("validationGroup"),
      createComponentCallback: this._createComponent.bind(this)
    });
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance: buttonInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  }
  _renderFieldItem(_ref4, itemsWithLabelTemplateCount) {
    var _item$label2;
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref4;
    const editorValue = this._getDataByField(item.dataField);
    let canAssignUndefinedValueToEditor = false;
    if (void 0 === editorValue) {
      const {
        allowIndeterminateState,
        editorType,
        dataField
      } = item;
      canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
        allowIndeterminateState,
        editorType,
        dataField
      });
    }
    const name2 = item.dataField || item.name;
    const formOrLayoutManager = this._getFormOrThis();
    const {
      form
    } = this.option();
    const {
      $fieldEditorContainer,
      widgetInstance,
      $rootElement
    } = renderFieldItem(convertToRenderFieldItemOptions({
      $parent,
      rootElementCssClassList,
      item,
      name: name2,
      editorValue,
      canAssignUndefinedValueToEditor,
      formOrLayoutManager: this._getFormOrThis(),
      createComponentCallback: this._createComponent.bind(this),
      formLabelLocation: this.option("labelLocation"),
      requiredMessageTemplate: this.option("requiredMessage"),
      validationGroup: this.option("validationGroup"),
      editorValidationBoundary: this.option("validationBoundary"),
      editorStylingMode: null === form || void 0 === form ? void 0 : form.option("stylingMode"),
      showColonAfterLabel: this.option("showColonAfterLabel"),
      managerLabelLocation: this.option("labelLocation"),
      template: item.template ? this._getTemplate(item.template) : null,
      labelTemplate: null !== (_item$label2 = item.label) && void 0 !== _item$label2 && _item$label2.template ? this._getTemplate(item.label.template) : null,
      itemId: null === form || void 0 === form ? void 0 : form.getItemID(name2),
      managerMarkOptions: this._getMarkOptions(),
      labelMode: this.option("labelMode"),
      onLabelTemplateRendered: () => {
        this._incTemplateRenderedCallCount();
        if (this._shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, itemsWithLabelTemplateCount)) {
          formOrLayoutManager._alignLabels(this, this.isSingleColumnMode(formOrLayoutManager));
        }
      }
    }));
    const {
      onFieldItemRendered
    } = this.option();
    null === onFieldItemRendered || void 0 === onFieldItemRendered || onFieldItemRendered();
    if (widgetInstance && item.dataField) {
      this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer);
    }
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  }
  _incTemplateRenderedCallCount() {
    this._labelTemplateRenderedCallCount = (this._labelTemplateRenderedCallCount ?? 0) + 1;
  }
  _shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, totalItemsWithLabelTemplate) {
    return formOrLayoutManager.option("templatesRenderAsynchronously") && this._labelTemplateRenderedCallCount === totalItemsWithLabelTemplate;
  }
  _getMarkOptions() {
    return {
      showRequiredMark: this.option("showRequiredMark"),
      requiredMark: this.option("requiredMark"),
      showOptionalMark: this.option("showOptionalMark"),
      optionalMark: this.option("optionalMark")
    };
  }
  _getFormOrThis() {
    const {
      form
    } = this.option();
    return form || this;
  }
  _bindDataField(editorInstance, dataField, editorType, $container) {
    const formOrThis = this._getFormOrThis();
    editorInstance.on("enterKey", ((args) => {
      formOrThis._createActionByOption("onEditorEnterKey")(extend(args, {
        dataField
      }));
    }));
    this._createWatcher(editorInstance, $container, dataField);
    this.linkEditorToDataField(editorInstance, dataField);
  }
  _createWatcher(editorInstance, $container, dataField) {
    const that = this;
    const watch = that._getWatch();
    if (!isFunction(watch)) {
      return;
    }
    const dispose = watch((() => that._getDataByField(dataField)), (() => {
      const fieldValue = that._getDataByField(dataField);
      if ("dxTagBox" === editorInstance.NAME) {
        const editorValue = editorInstance.option("value");
        if (fieldValue !== editorValue && (function(array1, array2) {
          if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length) {
            return false;
          }
          for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        })(fieldValue, editorValue)) {
          return;
        }
      }
      editorInstance.option("value", fieldValue);
    }), {
      deep: true,
      skipImmediate: true
    }, {
      createWatcherDataField: dataField
    });
    m_events_engine_default.on($container, removeEvent, dispose);
  }
  _getWatch() {
    if (!isDefined(this._watch)) {
      const {
        form: formInstance
      } = this.option();
      this._watch = formInstance && formInstance.option("integrationOptions.watchMethod");
    }
    return this._watch;
  }
  _createComponent($editor, type2, editorOptions) {
    const readOnlyState = this.option("readOnly");
    let hasEditorReadOnly = Object.hasOwn(editorOptions, "readOnly");
    const instance = super._createComponent($editor, type2, _extends({}, editorOptions, {
      readOnly: !hasEditorReadOnly ? readOnlyState : editorOptions.readOnly
    }));
    let isChangeByForm = false;
    instance.on("optionChanged", ((args) => {
      if ("readOnly" === args.name && !isChangeByForm) {
        hasEditorReadOnly = true;
      }
    }));
    this.on("optionChanged", ((args) => {
      if ("readOnly" === args.name && !hasEditorReadOnly) {
        isChangeByForm = true;
        instance.option(args.name, args.value);
        isChangeByForm = false;
      }
    }));
    return instance;
  }
  _generateRatio(count, isAutoSize) {
    const result2 = [];
    let ratio;
    let i;
    for (i = 0; i < count; i++) {
      ratio = {
        ratio: 1
      };
      if (isAutoSize) {
        ratio.baseSize = "auto";
      }
      result2.push(ratio);
    }
    return result2;
  }
  _getRowsCount() {
    return Math.ceil(this._items.length / this._getColCount());
  }
  _updateReferencedOptions(newLayoutData) {
    const layoutData = this.option("layoutData");
    if (isObject(layoutData)) {
      Object.getOwnPropertyNames(layoutData).forEach(((property) => delete this._optionsByReference[`layoutData.${property}`]));
    }
    if (isObject(newLayoutData)) {
      Object.getOwnPropertyNames(newLayoutData).forEach(((property) => this._optionsByReference[`layoutData.${property}`] = true));
    }
  }
  _clearWidget(instance) {
    this._disableEditorValueChangedHandler = true;
    instance.clear();
    this._disableEditorValueChangedHandler = false;
    instance.option("isValid", true);
  }
  _optionChanged(args) {
    if (0 === args.fullName.search("layoutData.")) {
      return;
    }
    switch (args.name) {
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "alignItemLabels":
      case "labelLocation":
      case "labelMode":
      case "requiredMessage":
        this._invalidate();
        break;
      case "layoutData":
        this._updateReferencedOptions(args.value);
        if (this.option("items")) {
          if (!isEmptyObject(args.value)) {
            this._itemsRunTimeInfo.each(((_, itemRunTimeInfo) => {
              if (isDefined(itemRunTimeInfo.item)) {
                const {
                  dataField
                } = itemRunTimeInfo.item;
                if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {
                  const valueGetter = compileGetter(dataField);
                  const dataValue = valueGetter(args.value);
                  const {
                    allowIndeterminateState,
                    editorType
                  } = itemRunTimeInfo.item;
                  if (void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled({
                    allowIndeterminateState,
                    editorType,
                    dataField
                  })) {
                    itemRunTimeInfo.widgetInstance.option("value", dataValue);
                  } else {
                    this._clearWidget(itemRunTimeInfo.widgetInstance);
                  }
                }
              }
            }));
          }
        } else {
          this._initDataAndItems(args.value);
          this._invalidate();
        }
        break;
      case "items":
        this._cleanItemWatchers();
        this._initDataAndItems(args.value);
        this._invalidate();
        break;
      case "customizeItem":
        this._updateItems(this.option("layoutData"));
        this._invalidate();
        break;
      case "colCount":
      case "colCountByScreen":
        this._resetColCount();
        break;
      case "minColWidth": {
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._resetColCount();
        }
        break;
      }
      case "readOnly":
      case "onFieldDataChanged":
        break;
      case "width": {
        super._optionChanged(args);
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._resetColCount();
        }
        break;
      }
      default:
        super._optionChanged(args);
    }
  }
  _resetColCount() {
    this._cashedColCount = null;
    this._invalidate();
  }
  linkEditorToDataField(editorInstance, dataField) {
    this.on("optionChanged", ((args) => {
      if (args.fullName === `layoutData.${dataField}`) {
        editorInstance._setOptionWithoutOptionChange("value", args.value);
      }
    }));
    editorInstance.on("valueChanged", ((args) => {
      const isValueReferenceType = isObject(args.value) || Array.isArray(args.value);
      if (!this._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
        this._updateFieldValue(dataField, args.value);
      }
    }));
  }
  _dimensionChanged() {
    const {
      colCount
    } = this.option();
    if ("auto" === colCount && this.isCachedColCountObsolete()) {
      this._eventsStrategy.fireEvent("autoColCountChanged");
    }
  }
  updateData(data17, value2) {
    const that = this;
    if (isObject(data17)) {
      each(data17, ((dataField, fieldValue) => {
        that._updateFieldValue(dataField, fieldValue);
      }));
    } else if ("string" === typeof data17) {
      that._updateFieldValue(data17, value2);
    }
  }
  getEditor(field) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);
  }
  isSingleColumnMode(component) {
    const responsiveBox = this._responsiveBox || component;
    if (responsiveBox) {
      return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen");
    }
  }
  getItemsRunTimeInfo() {
    return this._itemsRunTimeInfo;
  }
};
component_registrator_default("dxLayoutManager", LayoutManager);

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js
var ui_collection_widget_live_update_default = m_collection_widget_live_update_default;

// node_modules/devextreme/esm/__internal/ui/multi_view/m_multi_view.animation.js
var _translator = {
  move($element, position2) {
    move($element, {
      left: position2
    });
  }
};
var animation = {
  moveTo($element, position2, duration, completeAction) {
    fx_default.animate($element, {
      type: "slide",
      to: {
        left: position2
      },
      duration,
      complete: completeAction
    });
  },
  complete($element) {
    fx_default.stop($element, true);
  }
};

// node_modules/devextreme/esm/__internal/ui/m_multi_view.js
var toNumber2 = (value2) => +value2;
var position = ($element) => locate($element).left;
var MultiView = class extends ui_collection_widget_live_update_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      pageUp: noop,
      pageDown: noop
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectedIndex: 0,
      swipeEnabled: true,
      animationEnabled: true,
      loop: false,
      deferRendering: true,
      loopItemFocus: false,
      selectOnFocus: true,
      selectionMode: "single",
      selectionRequired: true,
      selectByClick: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _itemClass() {
    return "dx-multiview-item";
  }
  _itemDataKey() {
    return "dxMultiViewItemData";
  }
  _itemContainer() {
    return this._$itemContainer;
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _itemWidth() {
    if (!this._itemWidthValue) {
      this._itemWidthValue = getWidth(this._$wrapper);
    }
    return this._itemWidthValue;
  }
  _clearItemWidthCache() {
    delete this._itemWidthValue;
  }
  _itemsCount() {
    return this.option("items").length;
  }
  _isAllItemsHidden() {
    const {
      items
    } = this.option();
    return items.every(((_, index) => !this._isItemVisible(index)));
  }
  _normalizeIndex(index, direction) {
    let loop = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
    const count = this._itemsCount();
    if (this._isAllItemsHidden()) {
      return;
    }
    if (index < 0) {
      index += count;
    }
    if (index >= count) {
      index -= count;
    }
    const step = direction > 0 ? -1 : 1;
    const lastNotLoopedIndex = -1 === step ? 0 : count - 1;
    while (!this._isItemVisible(index) && (loop || index !== lastNotLoopedIndex)) {
      index = (index + step + count) % count;
    }
    return index;
  }
  _getRTLSignCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _init() {
    super._init.apply(this, arguments);
    this._activeStateUnit = ".dx-multiview-item";
    const $element = this.$element();
    $element.addClass("dx-multiview");
    this._$wrapper = renderer_default("<div>").addClass("dx-multiview-wrapper");
    this._$wrapper.appendTo($element);
    this._$itemContainer = renderer_default("<div>").addClass("dx-multiview-item-container");
    this._$itemContainer.appendTo(this._$wrapper);
    this.option("loopItemFocus", this.option("loop"));
    this._findBoundaryIndices();
    this._initSwipeable();
  }
  _ensureSelectedItemIsVisible() {
    const {
      loop,
      selectedIndex: currentSelectedIndex
    } = this.option();
    if (this._isItemVisible(currentSelectedIndex)) {
      return;
    }
    if (this._isAllItemsHidden()) {
      this.option("selectedIndex", 0);
      return;
    }
    const direction = -1 * this._getRTLSignCorrection();
    let newSelectedIndex = this._normalizeIndex(currentSelectedIndex, direction, loop);
    if (newSelectedIndex === currentSelectedIndex) {
      newSelectedIndex = this._normalizeIndex(currentSelectedIndex, -direction, loop);
    }
    this.option("selectedIndex", newSelectedIndex);
  }
  _initMarkup() {
    this._deferredItems = [];
    super._initMarkup();
    this._ensureSelectedItemIsVisible();
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
    this._setElementAria();
    this._setItemsAria();
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    super._afterItemElementDeleted($item, deletedActionArgs);
    if (this._deferredItems) {
      this._deferredItems.splice(deletedActionArgs.itemIndex, 1);
    }
  }
  _beforeItemElementInserted(change) {
    super._beforeItemElementInserted.apply(this, arguments);
    if (this._deferredItems) {
      this._deferredItems.splice(change.index, 0, null);
    }
  }
  _executeItemRenderAction(index, itemData, itemElement) {
    index = (this.option("items") || []).indexOf(itemData);
    super._executeItemRenderAction(index, itemData, itemElement);
  }
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const that = this;
    const deferred = Deferred();
    deferred.done((() => {
      const $itemContent = super._renderItemContent.call(that, args);
      renderContentDeferred.resolve($itemContent);
    }));
    this._deferredItems[args.index] = deferred;
    this.option("deferRendering") || deferred.resolve();
    return renderContentDeferred.promise();
  }
  _render() {
    super._render();
    deferRender((() => {
      const selectedItemIndices = this._getSelectedItemIndices();
      this._updateItems(selectedItemIndices[0]);
    }));
  }
  _getElementAria() {
    return {
      role: "group",
      roledescription: message_default.format("dxMultiView-elementAriaRoleDescription"),
      label: message_default.format("dxMultiView-elementAriaLabel")
    };
  }
  _setElementAria() {
    const aria = this._getElementAria();
    this.setAria(aria, this.$element());
  }
  _setItemsAria() {
    const $itemElements = this._itemElements();
    const itemsCount = this._itemsCount();
    $itemElements.each(((itemIndex, item) => {
      const aria = this._getItemAria({
        itemIndex,
        itemsCount
      });
      this.setAria(aria, renderer_default(item));
    }));
  }
  _getItemAria(args) {
    const {
      itemIndex,
      itemsCount
    } = args;
    const aria = {
      role: "group",
      roledescription: message_default.format("dxMultiView-itemAriaRoleDescription"),
      label: message_default.format("dxMultiView-itemAriaLabel", itemIndex + 1, itemsCount)
    };
    return aria;
  }
  _updateItems(selectedIndex, newIndex) {
    this._updateItemsPosition(selectedIndex, newIndex);
    this._updateItemsVisibility(selectedIndex, newIndex);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments);
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
  }
  _updateItemsPosition(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    const positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
    const $selectedItem = $itemElements.eq(selectedIndex);
    _translator.move($selectedItem, 0);
    if (isDefined(newIndex)) {
      _translator.move($itemElements.eq(newIndex), 100 * positionSign + "%");
    }
  }
  _isItemVisible(index) {
    var _this$option$index;
    return (null === (_this$option$index = this.option("items")[index]) || void 0 === _this$option$index ? void 0 : _this$option$index.visible) ?? true;
  }
  _updateItemsVisibility(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    $itemElements.each(((itemIndex, item) => {
      const $item = renderer_default(item);
      const isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
      if (!isHidden) {
        this._renderSpecificItem(itemIndex);
      }
      $item.toggleClass("dx-multiview-item-hidden", isHidden);
      this.setAria("hidden", isHidden || void 0, $item);
    }));
  }
  _renderSpecificItem(index) {
    const $item = this._itemElements().eq(index);
    const hasItemContent = $item.find(this._itemContentClass()).length > 0;
    if (isDefined(index) && !hasItemContent) {
      this._deferredItems[index].resolve();
      triggerResizeEvent($item);
    }
  }
  _refreshItem($item, item) {
    super._refreshItem($item, item);
    this._updateItemsVisibility(this.option("selectedIndex"));
  }
  _setAriaSelectionAttribute() {
  }
  _updateSelection(addedSelection, removedSelection) {
    const newIndex = addedSelection[0];
    const prevIndex = removedSelection[0];
    animation.complete(this._$itemContainer);
    this._updateItems(prevIndex, newIndex);
    const animationDirection = this._animationDirection(newIndex, prevIndex);
    this._animateItemContainer(animationDirection * this._itemWidth(), (() => {
      _translator.move(this._$itemContainer, 0);
      this._updateItems(newIndex);
      getWidth(this._$itemContainer);
    }));
  }
  _animateItemContainer(position2, completeCallback) {
    const duration = this.option("animationEnabled") ? 200 : 0;
    animation.moveTo(this._$itemContainer, position2, duration, completeCallback);
  }
  _animationDirection(newIndex, prevIndex) {
    const containerPosition = position(this._$itemContainer);
    const indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
    const isSwipePresent = 0 !== containerPosition;
    const directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
    return sign(directionSignVariable);
  }
  _getSwipeDisabledState() {
    return !this.option("swipeEnabled") || this._itemsCount() <= 1;
  }
  _initSwipeable() {
    this._createComponent(this.$element(), m_swipeable_default, {
      disabled: this._getSwipeDisabledState(),
      elastic: false,
      itemSizeFunc: this._itemWidth.bind(this),
      onStart: (args) => this._swipeStartHandler(args.event),
      onUpdated: (args) => this._swipeUpdateHandler(args.event),
      onEnd: (args) => this._swipeEndHandler(args.event)
    });
  }
  _findBoundaryIndices() {
    const items = this.option("items");
    let firstIndex;
    let lastIndex;
    items.forEach(((item, index) => {
      const isDisabled = Boolean(null === item || void 0 === item ? void 0 : item.disabled);
      const isVisible = this._isItemVisible(index);
      if (!isDisabled && isVisible) {
        firstIndex ?? (firstIndex = index);
        lastIndex = index;
      }
    }));
    this._boundaryIndices = {
      firstAvailableIndex: firstIndex ?? 0,
      lastAvailableIndex: lastIndex ?? items.length - 1,
      firstTrueIndex: 0,
      lastTrueIndex: items.length - 1
    };
  }
  _swipeStartHandler(e) {
    animation.complete(this._$itemContainer);
    const selectedIndex = this.option("selectedIndex");
    const loop = this.option("loop");
    const {
      firstAvailableIndex,
      lastAvailableIndex
    } = this._boundaryIndices;
    const rtl = this.option("rtlEnabled");
    e.maxLeftOffset = toNumber2(loop || (rtl ? selectedIndex > firstAvailableIndex : selectedIndex < lastAvailableIndex));
    e.maxRightOffset = toNumber2(loop || (rtl ? selectedIndex < lastAvailableIndex : selectedIndex > firstAvailableIndex));
  }
  _swipeUpdateHandler(e) {
    const {
      offset
    } = e;
    const swipeDirection = sign(offset) * this._getRTLSignCorrection();
    const selectedIndex = this.option("selectedIndex");
    const newIndex = this._normalizeIndex(selectedIndex - swipeDirection, swipeDirection);
    if (selectedIndex === newIndex) {
      return;
    }
    _translator.move(this._$itemContainer, offset * this._itemWidth());
    this._updateItems(selectedIndex, newIndex);
  }
  _findNextAvailableIndex(index, offset) {
    const {
      items,
      loop
    } = this.option();
    const {
      firstAvailableIndex,
      lastAvailableIndex,
      firstTrueIndex,
      lastTrueIndex
    } = this._boundaryIndices;
    const isFirstActive = [firstTrueIndex, firstAvailableIndex].includes(index);
    const isLastActive = [lastTrueIndex, lastAvailableIndex].includes(index);
    if (loop) {
      if (isFirstActive && offset < 0) {
        return lastAvailableIndex;
      }
      if (isLastActive && offset > 0) {
        return firstAvailableIndex;
      }
    }
    for (let i = index + offset; i >= firstAvailableIndex && i <= lastAvailableIndex; i += offset) {
      const isDisabled = Boolean(items[i].disabled);
      const isVisible = this._isItemVisible(i);
      if (!isDisabled && isVisible) {
        return i;
      }
    }
    return index;
  }
  _postprocessSwipe(args) {
  }
  _swipeEndHandler(e) {
    const targetOffset = e.targetOffset * this._getRTLSignCorrection();
    if (targetOffset) {
      const newSelectedIndex = this._findNextAvailableIndex(this.option("selectedIndex"), -targetOffset);
      this.selectItem(newSelectedIndex).fail((() => {
        this._animateItemContainer(0, noop);
      })).done((() => {
        this._postprocessSwipe({
          swipedTabsIndex: newSelectedIndex
        });
      }));
      const $selectedElement = this.itemElements().filter(".dx-item-selected");
      this.option("focusStateEnabled") && this.option("focusedElement", getPublicElement($selectedElement));
    } else {
      this._animateItemContainer(0, noop);
    }
  }
  _getItemFocusLoopSignCorrection() {
    return this._itemFocusLooped ? -1 : 1;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments);
    this._itemFocusLooped = false;
  }
  _prevItem($items) {
    const $result = super._prevItem.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.last());
    return $result;
  }
  _nextItem($items) {
    const $result = super._nextItem.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.first());
    return $result;
  }
  _dimensionChanged() {
    this._clearItemWidthCache();
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._dimensionChanged();
    }
  }
  _updateSwipeDisabledState() {
    const disabled = this._getSwipeDisabledState();
    m_swipeable_default.getInstance(this.$element()).option("disabled", disabled);
  }
  _dispose() {
    delete this._boundaryIndices;
    super._dispose();
  }
  _itemOptionChanged(item, property) {
    super._itemOptionChanged(...arguments);
    const {
      selectedItem
    } = this.option();
    if ("visible" === property && item === selectedItem) {
      this._ensureSelectedItemIsVisible();
    }
  }
  _optionChanged(args) {
    const {
      value: value2
    } = args;
    switch (args.name) {
      case "loop":
        this.option("loopItemFocus", value2);
        break;
      case "animationEnabled":
        break;
      case "swipeEnabled":
        this._updateSwipeDisabledState();
        break;
      case "deferRendering":
        this._invalidate();
        break;
      case "items":
        this._updateSwipeDisabledState();
        this._findBoundaryIndices();
        super._optionChanged(args);
        break;
      case "selectedIndex":
        if (this._isItemVisible(value2)) {
          super._optionChanged(args);
        } else {
          this._ensureSelectedItemIsVisible();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxMultiView", MultiView);
var m_multi_view_default = MultiView;

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_scroll_left_max.js
function getScrollLeftMax(element) {
  return element.scrollWidth - element.clientWidth;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_scroll_top_max.js
function getScrollTopMax(element) {
  return element.scrollHeight - element.clientHeight;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_boundary_props.js
function isReachedLeft(scrollOffsetLeft, epsilon) {
  return Math.round(scrollOffsetLeft) <= epsilon;
}
function isReachedRight(element, scrollOffsetLeft, epsilon) {
  return Math.round(getScrollLeftMax(element) - scrollOffsetLeft) <= epsilon;
}
function isReachedTop(scrollOffsetTop, epsilon) {
  return Math.round(scrollOffsetTop) <= epsilon;
}
function isReachedBottom(element, scrollOffsetTop, pocketHeight, epsilon) {
  return Math.round(getScrollTopMax(element) - scrollOffsetTop - pocketHeight) <= epsilon;
}

// node_modules/devextreme/esm/__internal/ui/tabs/constants.js
var TABS_EXPANDED_CLASS = "dx-tabs-expanded";

// node_modules/devextreme/esm/__internal/ui/tabs/item.js
var TabsItem = class extends item_default {
  _renderWatchers() {
    super._renderWatchers();
    this._startWatcher("badge", this._renderBadge.bind(this));
  }
  _renderBadge(badge) {
    this._$element.children(".dx-badge").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-tabs-item-badge").addClass("dx-badge").text(badge);
    this._$element.append($badge);
  }
};
var item_default2 = TabsItem;

// node_modules/devextreme/esm/__internal/ui/tabs/tabs.js
var TABS_ORIENTATION_CLASS = {
  vertical: "dx-tabs-vertical",
  horizontal: "dx-tabs-horizontal"
};
var INDICATOR_POSITION_CLASS = {
  top: "dx-tab-indicator-position-top",
  right: "dx-tab-indicator-position-right",
  bottom: "dx-tab-indicator-position-bottom",
  left: "dx-tab-indicator-position-left"
};
var TABS_ICON_POSITION_CLASS = {
  top: "dx-tabs-icon-position-top",
  end: "dx-tabs-icon-position-end",
  bottom: "dx-tabs-icon-position-bottom",
  start: "dx-tabs-icon-position-start"
};
var TABS_STYLING_MODE_CLASS = {
  primary: "dx-tabs-styling-mode-primary",
  secondary: "dx-tabs-styling-mode-secondary"
};
var ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var INDICATOR_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var SCROLLABLE_DIRECTION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE = {
  primary: "primary",
  secondary: "secondary"
};
var Tabs = class extends ui_collection_widget_live_update_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      showNavButtons: true,
      scrollByContent: true,
      scrollingEnabled: true,
      selectionMode: "single",
      orientation: ORIENTATION.horizontal,
      iconPosition: ICON_POSITION.start,
      stylingMode: STYLING_MODE.primary,
      activeStateEnabled: true,
      selectionRequired: false,
      selectOnFocus: true,
      loopItemFocus: false,
      useInkRipple: false,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _itemAttributes: {
        role: "tab"
      },
      _indicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" !== devices_default.real().deviceType,
      options: {
        showNavButtons: false
      }
    }, {
      device: {
        deviceType: "desktop"
      },
      options: {
        scrollByContent: false
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        iconPosition: ICON_POSITION.top,
        stylingMode: STYLING_MODE.secondary
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true,
        selectOnFocus: false,
        iconPosition: ICON_POSITION.top
      }
    }]);
  }
  _init() {
    const {
      orientation,
      stylingMode,
      scrollingEnabled
    } = this.option();
    const indicatorPosition = this._getIndicatorPosition();
    super._init();
    this._activeStateUnit = ".dx-tab";
    this.setAria("role", "tablist");
    this.$element().addClass("dx-tabs");
    this._toggleScrollingEnabledClass(scrollingEnabled);
    this._toggleOrientationClass(orientation);
    this._toggleIndicatorPositionClass(indicatorPosition);
    this._toggleIconPositionClass();
    this._toggleStylingModeClass(stylingMode);
    this._renderWrapper();
    this._renderMultiple();
    this._feedbackHideTimeout = 100;
  }
  _prepareDefaultItemTemplate(data17, $container) {
    const text = isPlainObject(data17) ? null === data17 || void 0 === data17 ? void 0 : data17.text : data17;
    if (isDefined(text)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.text(text);
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.text(text);
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
    if (isDefined(data17.html)) {
      $container.html(data17.html);
    }
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate((($container, data17) => {
        this._prepareDefaultItemTemplate(data17, $container);
        const $iconElement = getImageContainer(data17.icon);
        if ($iconElement) {
          $iconElement.prependTo($container);
        }
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }), ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _itemClass() {
    return "dx-tab";
  }
  _selectedItemClass() {
    return "dx-tab-selected";
  }
  _itemDataKey() {
    return "dxTabData";
  }
  _initMarkup() {
    super._initMarkup();
    if (this.option("useInkRipple")) {
      this._renderInkRipple();
    }
    this.$element().addClass("dx-overflow-hidden");
  }
  _postProcessRenderItems() {
    this._renderScrolling();
  }
  _renderScrolling() {
    const removeClasses = ["dx-tabs-stretched", TABS_EXPANDED_CLASS, "dx-overflow-hidden"];
    this.$element().removeClass(removeClasses.join(" "));
    if (this.option("scrollingEnabled") && this._isItemsSizeExceeded()) {
      if (!this._scrollable) {
        this._renderScrollable();
        this._renderNavButtons();
      }
      const scrollable = this.getScrollable();
      null === scrollable || void 0 === scrollable || scrollable.update();
      if (this.option("rtlEnabled")) {
        const maxLeftOffset = getScrollLeftMax(renderer_default(this.getScrollable().container()).get(0));
        null === scrollable || void 0 === scrollable || scrollable.scrollTo({
          left: maxLeftOffset
        });
      }
      this._updateNavButtonsState();
      const {
        selectedItem
      } = this.option();
      this._scrollToItem(selectedItem);
    }
    if (!(this.option("scrollingEnabled") && this._isItemsSizeExceeded())) {
      this._cleanScrolling();
      if (this._needStretchItems()) {
        this.$element().addClass("dx-tabs-stretched");
      }
      this.$element().removeClass("dx-tabs-nav-buttons").addClass(TABS_EXPANDED_CLASS);
    }
  }
  _isVertical() {
    const {
      orientation
    } = this.option();
    return orientation === ORIENTATION.vertical;
  }
  _isItemsSizeExceeded() {
    const isVertical = this._isVertical();
    const isItemsSizeExceeded = isVertical ? this._isItemsHeightExceeded() : this._isItemsWidthExceeded();
    return isItemsSizeExceeded;
  }
  _isItemsWidthExceeded() {
    const $visibleItems = this._getVisibleItems();
    const tabItemTotalWidth = this._getSummaryItemsSize("width", $visibleItems, true);
    const elementWidth = getWidth(this.$element());
    if ([tabItemTotalWidth, elementWidth].includes(0)) {
      return false;
    }
    const isItemsWidthExceeded = tabItemTotalWidth > elementWidth - 1;
    return isItemsWidthExceeded;
  }
  _isItemsHeightExceeded() {
    const $visibleItems = this._getVisibleItems();
    const itemsHeight = this._getSummaryItemsSize("height", $visibleItems, true);
    const elementHeight = getHeight(this.$element());
    const isItemsHeightExceeded = itemsHeight - 1 > elementHeight;
    return isItemsHeightExceeded;
  }
  _needStretchItems() {
    const $visibleItems = this._getVisibleItems();
    const elementWidth = getWidth(this.$element());
    const itemsWidth = [];
    each($visibleItems, ((_, item) => {
      itemsWidth.push(getOuterWidth(item, true));
    }));
    const maxTabItemWidth = Math.max.apply(null, itemsWidth);
    const requireWidth = elementWidth / $visibleItems.length;
    const needStretchItems = maxTabItemWidth > requireWidth + 1;
    return needStretchItems;
  }
  _cleanNavButtons() {
    if (!this._leftButton || !this._rightButton) {
      return;
    }
    this._leftButton.$element().remove();
    this._rightButton.$element().remove();
    this._leftButton = null;
    this._rightButton = null;
  }
  _cleanScrolling() {
    if (!this._scrollable) {
      return;
    }
    this._$wrapper.appendTo(this.$element());
    this._scrollable.$element().remove();
    this._scrollable = null;
    this._cleanNavButtons();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _getPointerEvent() {
    return m_pointer_default.up;
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState($element, value2, e);
    if (!this._inkRipple) {
      return;
    }
    const config2 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config2);
    } else {
      this._inkRipple.hideWave(config2);
    }
  }
  _renderMultiple() {
    const {
      selectionMode
    } = this.option();
    if ("multiple" === selectionMode) {
      this.option("selectOnFocus", false);
    }
  }
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-tabs-wrapper");
    this.$element().append(this._$wrapper);
  }
  _itemContainer() {
    return this._$wrapper;
  }
  _getScrollableDirection() {
    const isVertical = this._isVertical();
    const scrollableDirection = isVertical ? SCROLLABLE_DIRECTION.vertical : SCROLLABLE_DIRECTION.horizontal;
    return scrollableDirection;
  }
  _updateScrollable() {
    if (this.getScrollable()) {
      this._cleanScrolling();
    }
    this._renderScrolling();
  }
  _renderScrollable() {
    const $itemContainer = this.$element().wrapInner(renderer_default("<div>").addClass("dx-tabs-scrollable")).children();
    this._scrollable = this._createComponent($itemContainer, m_scrollable_default, {
      direction: this._getScrollableDirection(),
      showScrollbar: "never",
      useKeyboard: false,
      useNative: false,
      scrollByContent: this.option("scrollByContent"),
      onScroll: () => {
        this._updateNavButtonsState();
      }
    });
    this.$element().append(this._scrollable.$element());
  }
  _scrollToItem(item) {
    if (!this._scrollable) {
      return;
    }
    const $item = this._editStrategy.getItemElement(item);
    this._scrollable.scrollToElement($item);
  }
  _itemPointerHandler(e) {
    this._handleItemFocus(e);
  }
  _itemPointerUpHandler(e) {
    super._itemPointerHandler(e);
  }
  _renderNavButtons() {
    const {
      showNavButtons,
      rtlEnabled
    } = this.option();
    this.$element().toggleClass("dx-tabs-nav-buttons", showNavButtons);
    if (!showNavButtons) {
      return;
    }
    this._leftButton = this._createNavButton(-30, rtlEnabled ? "chevronnext" : "chevronprev");
    const $leftButton = this._leftButton.$element();
    $leftButton.addClass("dx-tabs-nav-button-left");
    this.$element().prepend($leftButton);
    this._rightButton = this._createNavButton(30, rtlEnabled ? "chevronprev" : "chevronnext");
    const $rightButton = this._rightButton.$element();
    $rightButton.addClass("dx-tabs-nav-button-right");
    this.$element().append($rightButton);
  }
  _updateNavButtonsAriaDisabled() {
    const buttons = [this._leftButton, this._rightButton];
    buttons.forEach(((button) => {
      null === button || void 0 === button || button.$element().attr({
        "aria-disabled": null
      });
    }));
  }
  _updateNavButtonsState() {
    const isVertical = this._isVertical();
    const scrollable = this.getScrollable();
    if (isVertical) {
      var _this$_leftButton, _this$_rightButton;
      null === (_this$_leftButton = this._leftButton) || void 0 === _this$_leftButton || _this$_leftButton.option("disabled", isReachedTop(scrollable.scrollTop(), 1));
      null === (_this$_rightButton = this._rightButton) || void 0 === _this$_rightButton || _this$_rightButton.option("disabled", isReachedBottom(renderer_default(scrollable.container()).get(0), scrollable.scrollTop(), 0, 1));
    } else {
      var _this$_leftButton2, _this$_rightButton2;
      null === (_this$_leftButton2 = this._leftButton) || void 0 === _this$_leftButton2 || _this$_leftButton2.option("disabled", isReachedLeft(scrollable.scrollLeft(), 1));
      null === (_this$_rightButton2 = this._rightButton) || void 0 === _this$_rightButton2 || _this$_rightButton2.option("disabled", isReachedRight(renderer_default(scrollable.container()).get(0), scrollable.scrollLeft(), 1));
    }
    this._updateNavButtonsAriaDisabled();
  }
  _updateScrollPosition(offset, duration) {
    var _this$_scrollable, _this$_scrollable2;
    null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable || _this$_scrollable.update();
    null === (_this$_scrollable2 = this._scrollable) || void 0 === _this$_scrollable2 || _this$_scrollable2.scrollBy(offset / duration);
  }
  _createNavButton(offset, icon) {
    const holdAction = this._createAction((() => {
      this._holdInterval = setInterval((() => {
        this._updateScrollPosition(offset, 5);
      }), 5);
    }));
    const holdEventName = addNamespace(m_hold_default.name, "dxNavButton");
    const pointerUpEventName = addNamespace(m_pointer_default.up, "dxNavButton");
    const pointerOutEventName = addNamespace(m_pointer_default.out, "dxNavButton");
    const navButton = this._createComponent(renderer_default("<div>").addClass("dx-tabs-nav-button"), button_default2, {
      focusStateEnabled: false,
      icon,
      integrationOptions: {},
      elementAttr: {
        role: null,
        "aria-label": null,
        "aria-disabled": null
      },
      onClick: () => {
        this._updateScrollPosition(offset, 1);
      }
    });
    const $navButton = navButton.$element();
    m_events_engine_default.on($navButton, holdEventName, {
      timeout: 300
    }, ((e) => {
      holdAction({
        event: e
      });
    }));
    m_events_engine_default.on($navButton, pointerUpEventName, (() => {
      this._clearInterval();
    }));
    m_events_engine_default.on($navButton, pointerOutEventName, (() => {
      this._clearInterval();
    }));
    return navButton;
  }
  _clearInterval() {
    if (this._holdInterval) {
      clearInterval(this._holdInterval);
    }
  }
  _updateSelection(addedSelection) {
    if (this._scrollable) {
      return this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]));
    }
    return;
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._dimensionChanged();
    }
  }
  _dimensionChanged() {
    this._renderScrolling();
  }
  _enterKeyHandler(e) {
    const {
      focusedElement
    } = this.option();
    super._enterKeyHandler(e);
    this.option("focusedElement", focusedElement);
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    if ("single" === selectionMode && this.isItemSelected(e.currentTarget)) {
      return;
    }
    super._itemSelectHandler(e);
  }
  _clean() {
    this._cleanScrolling();
    super._clean();
  }
  _toggleTabsVerticalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.vertical, value2);
  }
  _toggleTabsHorizontalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.horizontal, value2);
  }
  _getIndicatorPositionClass(indicatorPosition) {
    return INDICATOR_POSITION_CLASS[indicatorPosition];
  }
  _getIndicatorPosition() {
    const {
      _indicatorPosition,
      rtlEnabled
    } = this.option();
    if (_indicatorPosition) {
      return _indicatorPosition;
    }
    const isVertical = this._isVertical();
    if (rtlEnabled) {
      return isVertical ? INDICATOR_POSITION.left : INDICATOR_POSITION.bottom;
    }
    return isVertical ? INDICATOR_POSITION.right : INDICATOR_POSITION.bottom;
  }
  _toggleIndicatorPositionClass(indicatorPosition) {
    const newClass = this._getIndicatorPositionClass(indicatorPosition);
    this._toggleElementClasses(INDICATOR_POSITION_CLASS, newClass);
  }
  _toggleScrollingEnabledClass(scrollingEnabled) {
    this.$element().toggleClass("dx-tabs-scrolling-enabled", Boolean(scrollingEnabled));
  }
  _toggleOrientationClass(orientation) {
    const isVertical = orientation === ORIENTATION.vertical;
    this._toggleTabsVerticalClass(isVertical);
    this._toggleTabsHorizontalClass(!isVertical);
  }
  _getTabsIconPositionClass() {
    const {
      iconPosition
    } = this.option();
    switch (iconPosition) {
      case ICON_POSITION.top:
        return TABS_ICON_POSITION_CLASS.top;
      case ICON_POSITION.end:
        return TABS_ICON_POSITION_CLASS.end;
      case ICON_POSITION.bottom:
        return TABS_ICON_POSITION_CLASS.bottom;
      default:
        return TABS_ICON_POSITION_CLASS.start;
    }
  }
  _toggleIconPositionClass() {
    const newClass = this._getTabsIconPositionClass();
    this._toggleElementClasses(TABS_ICON_POSITION_CLASS, newClass);
  }
  _toggleStylingModeClass(value2) {
    const newClass = TABS_STYLING_MODE_CLASS[value2 ?? "primary"];
    this._toggleElementClasses(TABS_STYLING_MODE_CLASS, newClass);
  }
  _toggleElementClasses(classMap, newClass) {
    for (const key in classMap) {
      this.$element().removeClass(classMap[key]);
    }
    this.$element().addClass(newClass);
  }
  _toggleFocusedDisabledNextClass(currentIndex, isNextDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-next-tab", isNextDisabled);
  }
  _toggleFocusedDisabledPrevClass(currentIndex, isPrevDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-prev-tab", isPrevDisabled);
  }
  _toggleFocusedDisabledClasses(value2) {
    const {
      selectedIndex: currentIndex
    } = this.option();
    this._itemElements().removeClass("dx-focused-disabled-next-tab").removeClass("dx-focused-disabled-prev-tab");
    const prevItemIndex = currentIndex - 1;
    const nextItemIndex = currentIndex + 1;
    const nextFocusedIndex = renderer_default(value2).index();
    const isNextDisabled = this._itemElements().eq(nextItemIndex).hasClass("dx-state-disabled");
    const isPrevDisabled = this._itemElements().eq(prevItemIndex).hasClass("dx-state-disabled");
    const shouldNextClassBeSetted = isNextDisabled && nextFocusedIndex === nextItemIndex;
    const shouldPrevClassBeSetted = isPrevDisabled && nextFocusedIndex === prevItemIndex;
    this._toggleFocusedDisabledNextClass(currentIndex, shouldNextClassBeSetted);
    this._toggleFocusedDisabledPrevClass(currentIndex, shouldPrevClassBeSetted);
  }
  _updateFocusedElement() {
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    const itemElements = this._itemElements();
    if (focusStateEnabled && itemElements.length) {
      const selectedItem = itemElements.get(selectedIndex);
      this.option({
        focusedElement: selectedItem
      });
    }
  }
  _optionChanged(args) {
    var _this$_scrollable3;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useInkRipple":
      case "scrollingEnabled":
        this._toggleScrollingEnabledClass(value2);
        this._invalidate();
        break;
      case "showNavButtons":
      case "badgeExpr":
        this._invalidate();
        break;
      case "scrollByContent":
        null === (_this$_scrollable3 = this._scrollable) || void 0 === _this$_scrollable3 || _this$_scrollable3.option(name2, value2);
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "selectionMode":
        this._renderMultiple();
        super._optionChanged(args);
        break;
      case "focusedElement":
        this._toggleFocusedDisabledClasses(value2);
        super._optionChanged(args);
        this._scrollToItem(value2);
        break;
      case "rtlEnabled": {
        super._optionChanged(args);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "orientation": {
        this._toggleOrientationClass(value2);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        if (hasWindow()) {
          this._updateScrollable();
        }
        break;
      }
      case "iconPosition":
        this._toggleIconPositionClass();
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "stylingMode":
        this._toggleStylingModeClass(value2);
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "_indicatorPosition": {
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
        super._optionChanged(args);
        this._updateFocusedElement();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _afterItemElementInserted() {
    super._afterItemElementInserted();
    this._planPostRenderActions();
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    super._afterItemElementDeleted($item, deletedActionArgs);
    this._renderScrolling();
  }
  getScrollable() {
    return this._scrollable;
  }
};
Tabs.ItemClass = item_default2;
component_registrator_default("dxTabs", Tabs);
var tabs_default = Tabs;

// node_modules/devextreme/esm/__internal/ui/tab_panel/item.js
var TabPanelItem = class extends item_default {
  _renderWatchers() {
    this._startWatcher("badge", noop);
    super._renderWatchers();
  }
};

// node_modules/devextreme/esm/__internal/ui/tab_panel/tab_panel.js
var TABPANEL_TABS_POSITION_CLASS = {
  top: "dx-tabpanel-tabs-position-top",
  right: "dx-tabpanel-tabs-position-right",
  bottom: "dx-tabpanel-tabs-position-bottom",
  left: "dx-tabpanel-tabs-position-left"
};
var TABS_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var TABS_INDICATOR_POSITION_BY_TABS_POSITION = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var TABS_ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION2 = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE2 = {
  primary: "primary",
  secondary: "secondary"
};
var TabPanel = class extends m_multi_view_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTitleTemplate: "title",
      hoverStateEnabled: true,
      selectOnFocus: false,
      showNavButtons: false,
      scrollByContent: true,
      scrollingEnabled: true,
      tabsPosition: TABS_POSITION.top,
      iconPosition: ICON_POSITION2.start,
      stylingMode: STYLING_MODE2.primary,
      onTitleClick: null,
      onTitleHold: null,
      onTitleRendered: null,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _tabsIndicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !m_support_default.touch,
      options: {
        swipeEnabled: false
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        animationEnabled: false
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        stylingMode: STYLING_MODE2.secondary
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        iconPosition: ICON_POSITION2.top
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-tabpanel");
    this._toggleTabPanelTabsPositionClass();
  }
  _getElementAria() {
    return {
      role: "tabpanel"
    };
  }
  _getItemAria() {
    return {
      role: "tabpanel"
    };
  }
  _initMarkup() {
    super._initMarkup();
    this._createTitleActions();
    this._renderLayout();
  }
  _prepareTabsItemTemplate(data17, $container) {
    const $iconElement = getImageContainer(null === data17 || void 0 === data17 ? void 0 : data17.icon);
    if ($iconElement) {
      $container.append($iconElement);
    }
    const title = isPlainObject(data17) ? null === data17 || void 0 === data17 ? void 0 : data17.title : data17;
    if (isDefined(title) && !isPlainObject(title)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.append(dom_adapter_default.createTextNode(title));
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.append(dom_adapter_default.createTextNode(title));
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      title: new BindableTemplate((($container, data17) => {
        this._prepareTabsItemTemplate(data17, $container);
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }), ["title", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _createTitleActions() {
    this._createTitleClickAction();
    this._createTitleHoldAction();
    this._createTitleRenderedAction();
  }
  _createTitleClickAction() {
    this._titleClickAction = this._createActionByOption("onTitleClick");
  }
  _createTitleHoldAction() {
    this._titleHoldAction = this._createActionByOption("onTitleHold");
  }
  _createTitleRenderedAction() {
    this._titleRenderedAction = this._createActionByOption("onTitleRendered");
  }
  _renderLayout() {
    if (this._tabs) {
      return;
    }
    const $element = this.$element();
    this._$tabContainer = renderer_default("<div>").addClass("dx-tabpanel-tabs").appendTo($element);
    const $tabs = renderer_default("<div>").appendTo(this._$tabContainer);
    this._tabs = this._createComponent($tabs, tabs_default, this._tabConfig());
    this._$container = renderer_default("<div>").addClass("dx-tabpanel-container").appendTo($element);
    this._$container.append(this._$wrapper);
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    if (focusStateEnabled && isDefined(selectedIndex)) {
      const selectedItem = this._tabs.itemElements().get(selectedIndex);
      if (selectedItem) {
        this._tabs.option({
          focusedElement: selectedItem
        });
      }
    }
  }
  _refreshActiveDescendant() {
    if (!this._tabs) {
      return;
    }
    const tabs = this._tabs;
    const tabItems = tabs.itemElements();
    const $activeTab = renderer_default(tabItems[tabs.option("selectedIndex")]);
    const id = this.getFocusedItemId();
    this.setAria("controls", void 0, renderer_default(tabItems));
    this.setAria("controls", id, $activeTab);
  }
  _getTabsIndicatorPosition() {
    const {
      _tabsIndicatorPosition,
      tabsPosition
    } = this.option();
    return _tabsIndicatorPosition ?? TABS_INDICATOR_POSITION_BY_TABS_POSITION[tabsPosition ?? TABS_POSITION.top];
  }
  _tabConfig() {
    const tabsIndicatorPosition = this._getTabsIndicatorPosition();
    const {
      focusStateEnabled,
      hoverStateEnabled,
      repaintChangesOnly,
      tabIndex,
      selectedIndex,
      badgeExpr,
      itemHoldTimeout,
      items,
      scrollingEnabled,
      scrollByContent,
      showNavButtons,
      loop,
      iconPosition,
      stylingMode
    } = this.option();
    return {
      selectOnFocus: true,
      focusStateEnabled,
      hoverStateEnabled,
      repaintChangesOnly,
      tabIndex,
      selectedIndex,
      badgeExpr,
      onItemClick: this._titleClickAction.bind(this),
      onItemHold: this._titleHoldAction.bind(this),
      itemHoldTimeout,
      onSelectionChanging: (e) => {
        const newTabsSelectedItemData = e.addedItems[0];
        const newTabsSelectedIndex = this._getIndexByItemData(newTabsSelectedItemData);
        const selectingResult = this.selectItem(newTabsSelectedIndex);
        const promiseState = selectingResult.state();
        if ("pending" !== promiseState) {
          e.cancel = "rejected" === promiseState;
          return;
        }
        e.cancel = new Promise(((resolve) => {
          selectingResult.done((() => {
            resolve(false);
          })).fail((() => {
            resolve(true);
          }));
        }));
      },
      onSelectionChanged: () => {
        this._refreshActiveDescendant();
      },
      onItemRendered: this._titleRenderedAction.bind(this),
      itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
      items,
      noDataText: null,
      scrollingEnabled,
      scrollByContent,
      showNavButtons,
      itemTemplateProperty: "tabTemplate",
      loopItemFocus: loop,
      selectionRequired: true,
      onOptionChanged: (args) => {
        if ("focusedElement" === args.name) {
          if (args.value) {
            const $value = renderer_default(args.value);
            const $newItem = this._itemElements().eq($value.index());
            this.option("focusedElement", getPublicElement($newItem));
          } else {
            this.option("focusedElement", args.value);
          }
        }
      },
      onFocusIn: (args) => {
        this._focusInHandler(args.event);
      },
      onFocusOut: (args) => {
        if (!this._isFocusOutHandlerExecuting) {
          this._focusOutHandler(args.event);
        }
      },
      orientation: this._getTabsOrientation(),
      iconPosition,
      stylingMode,
      _itemAttributes: {
        class: "dx-tabpanel-tab"
      },
      _indicatorPosition: tabsIndicatorPosition
    };
  }
  _renderFocusTarget() {
    this._focusTarget().attr("tabIndex", -1);
  }
  _getTabsOrientation() {
    const {
      tabsPosition
    } = this.option();
    if ([TABS_POSITION.right, TABS_POSITION.left].includes(tabsPosition)) {
      return TABS_ORIENTATION.vertical;
    }
    return TABS_ORIENTATION.horizontal;
  }
  _getTabPanelTabsPositionClass() {
    const {
      tabsPosition
    } = this.option();
    switch (tabsPosition) {
      case TABS_POSITION.right:
        return TABPANEL_TABS_POSITION_CLASS.right;
      case TABS_POSITION.bottom:
        return TABPANEL_TABS_POSITION_CLASS.bottom;
      case TABS_POSITION.left:
        return TABPANEL_TABS_POSITION_CLASS.left;
      case TABS_POSITION.top:
      default:
        return TABPANEL_TABS_POSITION_CLASS.top;
    }
  }
  _toggleTabPanelTabsPositionClass() {
    for (const key in TABPANEL_TABS_POSITION_CLASS) {
      this.$element().removeClass(TABPANEL_TABS_POSITION_CLASS[key]);
    }
    const newClass = this._getTabPanelTabsPositionClass();
    this.$element().addClass(newClass);
  }
  _updateTabsOrientation() {
    const orientation = this._getTabsOrientation();
    this._setTabsOption("orientation", orientation);
  }
  _toggleWrapperFocusedClass(isFocused) {
    this._toggleFocusClass(isFocused, this._$wrapper);
  }
  _toggleDisabledFocusedClass(isFocused) {
    this._focusTarget().toggleClass("dx-disabled-focused-tab", isFocused);
  }
  _updateFocusState(e, isFocused) {
    super._updateFocusState(e, isFocused);
    const isTabsTarget = e.target === this._tabs._focusTarget().get(0);
    const isMultiViewTarget = e.target === this._focusTarget().get(0);
    if (isTabsTarget) {
      this._toggleFocusClass(isFocused, this._focusTarget());
    }
    if (isTabsTarget || isMultiViewTarget) {
      const isDisabled = this._isDisabled(this.option("focusedElement"));
      this._toggleWrapperFocusedClass(isFocused && !isDisabled);
      this._toggleDisabledFocusedClass(isFocused && isDisabled);
    }
    if (isMultiViewTarget) {
      this._toggleFocusClass(isFocused, this._tabs.$element());
      this._toggleFocusClass(isFocused, this._tabs.option("focusedElement"));
    }
  }
  _focusOutHandler(e) {
    this._isFocusOutHandlerExecuting = true;
    super._focusOutHandler(e);
    this._tabs._focusOutHandler(e);
    this._isFocusOutHandlerExecuting = false;
  }
  _setTabsOption(name2, value2) {
    if (this._tabs) {
      this._tabs.option(name2, value2);
    }
  }
  _postprocessSwipe(args) {
    this._setTabsOption("selectedIndex", args.swipedTabsIndex);
  }
  _visibilityChanged(visible) {
    if (visible) {
      this._tabs._dimensionChanged();
    }
  }
  registerKeyHandler(key, handler) {
    super.registerKeyHandler(key, handler);
    if (this._tabs) {
      this._tabs.registerKeyHandler(key, handler);
    }
  }
  repaint() {
    super.repaint();
    this._tabs.repaint();
  }
  _updateTabsIndicatorPosition() {
    const value2 = this._getTabsIndicatorPosition();
    this._setTabsOption("_indicatorPosition", value2);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      fullName
    } = args;
    switch (name2) {
      case "dataSource":
      default:
        super._optionChanged(args);
        break;
      case "items":
        this._setTabsOption(name2, this.option(name2));
        if (!this.option("repaintChangesOnly")) {
          this._tabs.repaint();
        }
        super._optionChanged(args);
        break;
      case "width":
        super._optionChanged(args);
        this._tabs.repaint();
        break;
      case "selectedIndex":
      case "selectedItem": {
        this._setTabsOption(fullName, value2);
        super._optionChanged(args);
        const {
          focusStateEnabled
        } = this.option();
        if (true === focusStateEnabled) {
          const selectedIndex = this.option("selectedIndex");
          const selectedTabContent = this._itemElements().eq(selectedIndex);
          this.option("focusedElement", getPublicElement(selectedTabContent));
        }
        break;
      }
      case "itemHoldTimeout":
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setTabsOption(fullName, value2);
        super._optionChanged(args);
        break;
      case "scrollingEnabled":
      case "scrollByContent":
      case "showNavButtons":
        this._setTabsOption(fullName, value2);
        break;
      case "focusedElement": {
        const id = value2 ? renderer_default(value2).index() : value2;
        const newItem = value2 && this._tabs ? this._tabs._itemElements().eq(id) : value2;
        this._setTabsOption("focusedElement", getPublicElement(newItem));
        if (value2) {
          const isDisabled = this._isDisabled(value2);
          this._toggleWrapperFocusedClass(!isDisabled);
          this._toggleDisabledFocusedClass(isDisabled);
        }
        super._optionChanged(args);
        break;
      }
      case "itemTitleTemplate":
        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
        break;
      case "onTitleClick":
        this._createTitleClickAction();
        this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
        break;
      case "onTitleHold":
        this._createTitleHoldAction();
        this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
        break;
      case "onTitleRendered":
        this._createTitleRenderedAction();
        this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
        break;
      case "loop":
        this._setTabsOption("loopItemFocus", value2);
        super._optionChanged(args);
        break;
      case "badgeExpr":
        this._invalidate();
        break;
      case "tabsPosition":
        this._toggleTabPanelTabsPositionClass();
        this._updateTabsIndicatorPosition();
        this._updateTabsOrientation();
        break;
      case "iconPosition":
        this._setTabsOption("iconPosition", value2);
        break;
      case "stylingMode":
        this._setTabsOption("stylingMode", value2);
        break;
      case "_tabsIndicatorPosition":
        this._setTabsOption("_indicatorPosition", value2);
    }
  }
};
TabPanel.ItemClass = TabPanelItem;
component_registrator_default("dxTabPanel", TabPanel);
var tab_panel_default = TabPanel;

// node_modules/devextreme/esm/ui/tab_panel.js
var tab_panel_default2 = tab_panel_default;

// node_modules/devextreme/esm/__internal/ui/form/m_form.item_option_action.js
var ItemOptionAction = class {
  constructor(options2) {
    this._options = options2;
    this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
  }
  findInstance() {
    return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
  }
  findItemContainer() {
    return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
  }
  findPreparedItem() {
    return this._itemsRunTimeInfo.findPreparedItemByItem(this._options.item);
  }
  tryExecute() {
    class_default.abstract();
  }
};

// node_modules/devextreme/esm/__internal/ui/form/m_form.utils.js
var createItemPathByIndex = (index, isTabs) => `${isTabs ? "tabs" : "items"}[${index}]`;
var concatPaths = (path1, path2) => {
  if (isDefined(path1) && isDefined(path2)) {
    return `${path1}.${path2}`;
  }
  return path1 || path2;
};
var getTextWithoutSpaces = (text) => text ? text.replace(/\s/g, "") : void 0;
var isEqualToDataFieldOrNameOrTitleOrCaption = (item, fieldName) => {
  if (item) {
    return item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName;
  }
  return false;
};
var getFullOptionName = (path, optionName) => `${path}.${optionName}`;
var getOptionNameFromFullName = (fullName) => {
  const parts = fullName.split(".");
  return parts[parts.length - 1].replace(/\[\d+]/, "");
};
var tryGetTabPath = (fullPath) => {
  const pathParts = fullPath.split(".");
  const resultPathParts = [...pathParts];
  for (let i = pathParts.length - 1; i >= 0; i--) {
    if (isFullPathContainsTabs(pathParts[i])) {
      return resultPathParts.join(".");
    }
    resultPathParts.splice(i, 1);
  }
  return "";
};
var isFullPathContainsTabs = (fullPath) => fullPath.indexOf("tabs") > -1;
var getItemPath = (items, item, isTabs) => {
  const index = items.indexOf(item);
  if (index > -1) {
    return createItemPathByIndex(index, isTabs);
  }
  for (let i = 0; i < items.length; i++) {
    const targetItem = items[i];
    const tabOrGroupItems = targetItem.tabs || targetItem.items;
    if (tabOrGroupItems) {
      const itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
      if (itemPath) {
        return concatPaths(createItemPathByIndex(i, isTabs), itemPath);
      }
    }
  }
};
function convertToLayoutManagerOptions(_ref) {
  let {
    form,
    $formElement,
    formOptions,
    items,
    validationGroup,
    extendedLayoutManagerOptions,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered
  } = _ref;
  const baseOptions = {
    form,
    items,
    $formElement,
    validationGroup,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered,
    validationBoundary: formOptions.scrollingEnabled ? $formElement : void 0,
    scrollingEnabled: formOptions.scrollingEnabled,
    showRequiredMark: formOptions.showRequiredMark,
    showOptionalMark: formOptions.showOptionalMark,
    requiredMark: formOptions.requiredMark,
    optionalMark: formOptions.optionalMark,
    requiredMessage: formOptions.requiredMessage,
    screenByWidth: formOptions.screenByWidth,
    layoutData: formOptions.formData,
    labelLocation: formOptions.labelLocation,
    customizeItem: formOptions.customizeItem,
    minColWidth: formOptions.minColWidth,
    showColonAfterLabel: formOptions.showColonAfterLabel,
    onEditorEnterKey: formOptions.onEditorEnterKey,
    labelMode: formOptions.labelMode
  };
  const result2 = extend(baseOptions, {
    isRoot: extendedLayoutManagerOptions.isRoot,
    colCount: extendedLayoutManagerOptions.colCount,
    alignItemLabels: extendedLayoutManagerOptions.alignItemLabels,
    cssItemClass: extendedLayoutManagerOptions.cssItemClass,
    colCountByScreen: extendedLayoutManagerOptions.colCountByScreen,
    onLayoutChanged: extendedLayoutManagerOptions.onLayoutChanged,
    width: extendedLayoutManagerOptions.width
  });
  return result2;
}

// node_modules/devextreme/esm/__internal/ui/form/m_form.item_options_actions.js
var WidgetOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      value: value2
    } = this._options;
    const instance = this.findInstance();
    if (instance) {
      instance.option(value2);
      return true;
    }
    return false;
  }
};
var TabOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        optionName,
        item,
        value: value2
      } = this._options;
      const itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
      if (itemIndex >= 0) {
        tabPanel.option(getFullOptionName(`items[${itemIndex}]`, optionName), value2);
        return true;
      }
    }
    return false;
  }
};
var SimpleItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    return false;
  }
};
var GroupItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    const preparedItem = this.findPreparedItem();
    if (null != preparedItem && preparedItem._prepareGroupItemTemplate && preparedItem._renderGroupContentTemplate) {
      preparedItem._prepareGroupItemTemplate(this._options.item.template);
      preparedItem._renderGroupContentTemplate();
      return true;
    }
    return false;
  }
};
var TabsOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        value: value2
      } = this._options;
      tabPanel.option("dataSource", value2);
      return true;
    }
    return false;
  }
};
var ValidationRulesItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      item
    } = this._options;
    const instance = this.findInstance();
    const validator = instance && data(instance.$element()[0], "dxValidator");
    if (validator && item) {
      const filterRequired = (item2) => "required" === item2.type;
      const oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
      const newContainsRequired = (item.validationRules || []).some(filterRequired);
      if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
        validator.option("validationRules", item.validationRules);
        return true;
      }
    }
    return false;
  }
};
var CssClassItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const $itemContainer = this.findItemContainer();
    const {
      previousValue,
      value: value2
    } = this._options;
    if ($itemContainer) {
      $itemContainer.removeClass(previousValue).addClass(value2);
      return true;
    }
    return false;
  }
};
var tryCreateItemOptionAction = (optionName, itemActionOptions) => {
  switch (optionName) {
    case "editorOptions":
    case "buttonOptions":
      return new WidgetOptionItemOptionAction(itemActionOptions);
    case "validationRules":
      return new ValidationRulesItemOptionAction(itemActionOptions);
    case "cssClass":
      return new CssClassItemOptionAction(itemActionOptions);
    case "badge":
    case "disabled":
    case "icon":
    case "tabTemplate":
    case "title":
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    case "tabs":
      return new TabsOptionItemOptionAction(itemActionOptions);
    case "template": {
      var _itemActionOptions$it, _itemActionOptions$it2;
      const itemType = (null === itemActionOptions || void 0 === itemActionOptions || null === (_itemActionOptions$it = itemActionOptions.item) || void 0 === _itemActionOptions$it ? void 0 : _itemActionOptions$it.itemType) ?? (null === (_itemActionOptions$it2 = itemActionOptions.itemsRunTimeInfo.findPreparedItemByItem(null === itemActionOptions || void 0 === itemActionOptions ? void 0 : itemActionOptions.item)) || void 0 === _itemActionOptions$it2 ? void 0 : _itemActionOptions$it2.itemType);
      if ("simple" === itemType) {
        return new SimpleItemTemplateChangedAction(itemActionOptions);
      }
      if ("group" === itemType) {
        return new GroupItemTemplateChangedAction(itemActionOptions);
      }
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    }
    default:
      return null;
  }
};
var m_form_item_options_actions_default = tryCreateItemOptionAction;

// node_modules/devextreme/esm/__internal/ui/form/m_form.js
var ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
var Form = class extends widget_default {
  _init() {
    super._init();
    this._dirtyFields = /* @__PURE__ */ new Set();
    this._cachedColCountOptions = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._groupsColCount = [];
    this._attachSyncSubscriptions();
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      formID: `dx-${new guid_default()}`,
      formData: {},
      colCount: 1,
      screenByWidth: defaultScreenFactorFunc,
      labelLocation: "left",
      readOnly: false,
      onFieldDataChanged: null,
      customizeItem: null,
      onEditorEnterKey: null,
      minColWidth: 200,
      alignItemLabels: true,
      alignItemLabelsInAllGroups: true,
      alignRootItemLabels: true,
      showColonAfterLabel: true,
      showRequiredMark: true,
      showOptionalMark: false,
      requiredMark: "*",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage"),
      showValidationSummary: false,
      scrollingEnabled: false,
      stylingMode: config_default2().editorStylingMode,
      labelMode: "outside",
      isDirty: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        labelLocation: "top"
      }
    }, {
      device: () => isMaterial(),
      options: {
        showColonAfterLabel: false
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      formData: true,
      validationGroup: true
    });
  }
  _getGroupColCount($element) {
    return parseInt($element.attr(GROUP_COL_COUNT_ATTR));
  }
  _applyLabelsWidthByCol($container, index) {
    let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    let labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
    const fieldItemClass = options2.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index;
    const cssExcludeTabbedSelector = options2.excludeTabbed ? `:not(.${FIELD_ITEM_TAB_CLASS})` : "";
    setLabelWidthByMaxLabelWidth($container, `.${fieldItemClass}${cssExcludeTabbedSelector}`, labelMarkOptions);
  }
  _applyLabelsWidth($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
    colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
    const applyLabelsOptions = {
      excludeTabbed,
      inOneColumn
    };
    let i;
    for (i = 0; i < colCount; i++) {
      this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions);
    }
  }
  _getGroupElementsInColumn($container, columnIndex, colCount) {
    const cssColCountSelector = isDefined(colCount) ? `.${GROUP_COL_COUNT_CLASS}${colCount}` : "";
    const groupSelector = `.${FORM_FIELD_ITEM_COL_CLASS}${columnIndex} > .${FIELD_ITEM_CONTENT_CLASS} > .${FORM_GROUP_CLASS}${cssColCountSelector}`;
    return $container.find(groupSelector);
  }
  _applyLabelsWidthWithGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const {
      alignRootItemLabels
    } = this.option();
    if (true === alignRootItemLabels) {
      const $rootSimpleItems = $container.find(`.${ROOT_SIMPLE_ITEM_CLASS}`);
      for (let colIndex = 0; colIndex < colCount; colIndex++) {
        this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions);
      }
    }
    const alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
    if (alignItemLabelsInAllGroups) {
      this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions);
    } else {
      const $groups = this.$element().find(`.${FORM_GROUP_CLASS}`);
      let i;
      for (i = 0; i < $groups.length; i++) {
        this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions);
      }
    }
  }
  _applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const applyLabelsOptions = {
      excludeTabbed
    };
    let colIndex;
    let groupsColIndex;
    let groupColIndex;
    let $groupsByCol;
    for (colIndex = 0; colIndex < colCount; colIndex++) {
      $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
      this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
      for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
        $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
        const groupColCount = this._getGroupColCount($groupsByCol);
        for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
          this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions);
        }
      }
    }
  }
  _labelLocation() {
    const {
      labelLocation
    } = this.option();
    return labelLocation;
  }
  _alignLabelsInColumn(_ref) {
    let {
      layoutManager,
      inOneColumn,
      $container,
      excludeTabbed,
      items
    } = _ref;
    if (!hasWindow() || "top" === this._labelLocation()) {
      return;
    }
    const labelMarkOptions = convertToLabelMarkOptions(layoutManager._getMarkOptions());
    if (inOneColumn) {
      this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions);
    } else if (this._checkGrouping(items)) {
      this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions);
    } else {
      this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions);
    }
  }
  _prepareFormData() {
    if (!isDefined(this.option("formData"))) {
      this.option("formData", {});
    }
  }
  _setStylingModeClass() {
    const {
      stylingMode
    } = this.option();
    if ("underlined" === stylingMode) {
      this.$element().addClass(FORM_UNDERLINED_CLASS);
    }
  }
  _initMarkup() {
    validation_engine_default.addGroup(this._getValidationGroup(), false);
    this._clearCachedInstances();
    this._prepareFormData();
    this.$element().addClass(FORM_CLASS);
    this._setStylingModeClass();
    super._initMarkup();
    this.setAria("role", "form", this.$element());
    if (this.option("scrollingEnabled")) {
      this._renderScrollable();
    }
    this._renderLayout();
    this._renderValidationSummary();
    this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor();
    this._attachResizeObserverSubscription();
  }
  _attachResizeObserverSubscription() {
    if (hasWindow()) {
      const formRootElement = this.$element().get(0);
      resize_observer_default.unobserve(formRootElement);
      resize_observer_default.observe(formRootElement, (() => {
        this._resizeHandler();
      }));
    }
  }
  _resizeHandler() {
    if (this._cachedLayoutManagers.length) {
      each(this._cachedLayoutManagers, ((_, layoutManager) => {
        var _layoutManager$option;
        null === (_layoutManager$option = layoutManager.option("onLayoutChanged")) || void 0 === _layoutManager$option || _layoutManager$option(layoutManager.isSingleColumnMode());
      }));
    }
  }
  _getCurrentScreenFactor() {
    return hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
  }
  _clearCachedInstances() {
    this._itemsRunTimeInfo.clear();
    this._cachedLayoutManagers = [];
  }
  _alignLabels(layoutManager, inOneColumn) {
    this._alignLabelsInColumn({
      $container: this.$element(),
      layoutManager,
      excludeTabbed: true,
      items: this.option("items"),
      inOneColumn
    });
    triggerResizeEvent(this.$element().find(`.${TOOLBAR_CLASS}`));
  }
  _clean() {
    this._clearValidationSummary();
    super._clean();
    this._groupsColCount = [];
    this._cachedColCountOptions = [];
    this._lastMarkupScreenFactor = void 0;
    resize_observer_default.unobserve(this.$element().get(0));
  }
  _renderScrollable() {
    const useNativeScrolling = this.option("useNativeScrolling");
    this._scrollable = new m_scrollable_default(this.$element(), {
      useNative: !!useNativeScrolling,
      useSimulatedScrollbar: !useNativeScrolling,
      useKeyboard: false,
      direction: "both",
      bounceEnabled: false
    });
  }
  _getContent() {
    var _this$_scrollable;
    return this.option("scrollingEnabled") ? renderer_default(null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable ? void 0 : _this$_scrollable.content()) : this.$element();
  }
  _clearValidationSummary() {
    var _this$_$validationSum;
    null === (_this$_$validationSum = this._$validationSummary) || void 0 === _this$_$validationSum || _this$_$validationSum.remove();
    this._$validationSummary = void 0;
    this._validationSummary = void 0;
  }
  _renderValidationSummary() {
    this._clearValidationSummary();
    if (this.option("showValidationSummary")) {
      this._$validationSummary = renderer_default("<div>").addClass(FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
      this._validationSummary = this._$validationSummary.dxValidationSummary({
        validationGroup: this._getValidationGroup()
      }).dxValidationSummary("instance");
    }
  }
  _prepareItems(items, parentIsTabbedItem, currentPath, isTabs) {
    if (items) {
      const result2 = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        const path = concatPaths(currentPath, createItemPathByIndex(i, isTabs));
        const itemRunTimeInfo = {
          item,
          itemIndex: i,
          path
        };
        const guid = this._itemsRunTimeInfo.add(itemRunTimeInfo);
        if (isString(item)) {
          item = {
            dataField: item
          };
        }
        if (isObject(item)) {
          const preparedItem = _extends({}, item);
          itemRunTimeInfo.preparedItem = preparedItem;
          preparedItem.guid = guid;
          this._tryPrepareGroupItemCaption(preparedItem);
          this._tryPrepareGroupItem(preparedItem);
          this._tryPrepareTabbedItem(preparedItem, path);
          this._tryPrepareItemTemplate(preparedItem);
          if (parentIsTabbedItem) {
            preparedItem.cssItemClass = FIELD_ITEM_TAB_CLASS;
          }
          if (preparedItem.items) {
            preparedItem.items = this._prepareItems(preparedItem.items, parentIsTabbedItem, path);
          }
          result2.push(preparedItem);
        } else {
          result2.push(item);
        }
      }
      return result2;
    }
  }
  _tryPrepareGroupItemCaption(item) {
    if ("group" === item.itemType) {
      item._prepareGroupCaptionTemplate = (captionTemplate) => {
        if (item.captionTemplate) {
          item.groupCaptionTemplate = this._getTemplate(captionTemplate);
        }
        item.captionTemplate = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupCaptionTemplate(item.captionTemplate);
    }
  }
  _tryPrepareGroupItem(item) {
    if ("group" === item.itemType) {
      item.alignItemLabels = ensureDefined(item.alignItemLabels, true);
      item._prepareGroupItemTemplate = (itemTemplate) => {
        if (item.template) {
          item.groupContentTemplate = this._getTemplate(itemTemplate);
        }
        item.template = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupItemTemplate(item.template);
    }
  }
  _tryPrepareTabbedItem(item, path) {
    if ("tabbed" === item.itemType) {
      item.template = this._itemTabbedTemplate.bind(this, item);
      item.tabs = this._prepareItems(item.tabs, true, path, true);
    }
  }
  _tryPrepareItemTemplate(item) {
    if (item.template) {
      item.template = this._getTemplate(item.template);
    }
  }
  _checkGrouping(items) {
    if (items) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if ("group" === item.itemType) {
          return true;
        }
      }
    }
  }
  _renderLayout() {
    const that = this;
    let items = that.option("items");
    const $content = that._getContent();
    items = that._prepareItems(items);
    that._rootLayoutManager = that._renderLayoutManager($content, this._createLayoutManagerOptions(items, {
      isRoot: true,
      colCount: that.option("colCount"),
      alignItemLabels: that.option("alignItemLabels"),
      screenByWidth: this.option("screenByWidth"),
      colCountByScreen: this.option("colCountByScreen"),
      onLayoutChanged(inOneColumn) {
        that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn);
      },
      onContentReady(e) {
        that._alignLabels(e.component, e.component.isSingleColumnMode());
      }
    }));
  }
  _tryGetItemsForTemplate(item) {
    return item.items || [];
  }
  _itemTabbedTemplate(item, e, $container) {
    const $tabPanel = renderer_default("<div>").appendTo($container);
    const tabPanelOptions = extend({}, item.tabPanelOptions, {
      dataSource: item.tabs,
      onItemRendered: (args) => {
        var _item$tabPanelOptions, _item$tabPanelOptions2;
        null === (_item$tabPanelOptions = item.tabPanelOptions) || void 0 === _item$tabPanelOptions || null === (_item$tabPanelOptions2 = _item$tabPanelOptions.onItemRendered) || void 0 === _item$tabPanelOptions2 || _item$tabPanelOptions2.call(_item$tabPanelOptions, args);
        triggerShownEvent(args.itemElement);
      },
      itemTemplate: (itemData, e2, container) => {
        const $container2 = renderer_default(container);
        const alignItemLabels = ensureDefined(itemData.alignItemLabels, true);
        const layoutManager = this._renderLayoutManager($container2, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(itemData), {
          colCount: itemData.colCount,
          alignItemLabels,
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: itemData.colCountByScreen,
          cssItemClass: itemData.cssItemClass,
          onLayoutChanged: (inOneColumn) => {
            this._alignLabelsInColumn({
              $container: $container2,
              layoutManager,
              items: itemData.items,
              inOneColumn
            });
          }
        }));
        if (this._itemsRunTimeInfo) {
          this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
            layoutManager
          });
        }
        if (alignItemLabels) {
          this._alignLabelsInColumn({
            $container: $container2,
            layoutManager,
            items: itemData.items,
            inOneColumn: layoutManager.isSingleColumnMode()
          });
        }
      }
    });
    const tryUpdateTabPanelInstance = (items, instance) => {
      if (Array.isArray(items)) {
        items.forEach(((item2) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item2.guid, {
          widgetInstance: instance
        })));
      }
    };
    const tabPanel = this._createComponent($tabPanel, tab_panel_default2, tabPanelOptions);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
    tabPanel.on("optionChanged", ((e2) => {
      if ("dataSource" === e2.fullName) {
        tryUpdateTabPanelInstance(e2.value, e2.component);
      }
    }));
    tryUpdateTabPanelInstance([{
      guid: item.guid
    }, ...item.tabs ?? []], tabPanel);
  }
  _itemGroupCaptionTemplate(item, $group, id) {
    if (item.groupCaptionTemplate) {
      const $captionTemplate = renderer_default("<div>").addClass(FORM_GROUP_CUSTOM_CAPTION_CLASS).attr("id", id).appendTo($group);
      item._renderGroupCaptionTemplate = () => {
        const data17 = {
          component: this,
          caption: item.caption,
          name: item.name
        };
        item.groupCaptionTemplate.render({
          model: data17,
          container: getPublicElement($captionTemplate)
        });
      };
      item._renderGroupCaptionTemplate();
      return;
    }
    if (item.caption) {
      renderer_default("<span>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).attr("id", id).appendTo($group);
    }
  }
  _itemGroupContentTemplate(item, $group) {
    const $groupContent = renderer_default("<div>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
    if (item.groupContentTemplate) {
      item._renderGroupContentTemplate = () => {
        $groupContent.empty();
        const data17 = {
          formData: this.option("formData"),
          component: this
        };
        item.groupContentTemplate.render({
          model: data17,
          container: getPublicElement($groupContent)
        });
      };
      item._renderGroupContentTemplate();
    } else {
      var _this$_itemsRunTimeIn;
      const layoutManager = this._renderLayoutManager($groupContent, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(item), {
        colCount: item.colCount,
        colCountByScreen: item.colCountByScreen,
        alignItemLabels: item.alignItemLabels,
        cssItemClass: item.cssItemClass
      }));
      null === (_this$_itemsRunTimeIn = this._itemsRunTimeInfo) || void 0 === _this$_itemsRunTimeIn || _this$_itemsRunTimeIn.extendRunTimeItemInfoByKey(item.guid, {
        layoutManager
      });
      const colCount = layoutManager._getColCount();
      if (!this._groupsColCount.includes(colCount)) {
        this._groupsColCount.push(colCount);
      }
      $group.addClass(GROUP_COL_COUNT_CLASS + colCount);
      $group.attr(GROUP_COL_COUNT_ATTR, colCount);
    }
  }
  _itemGroupTemplate(item, options2, $container) {
    const {
      id
    } = options2.editorOptions.inputAttr;
    const $group = renderer_default("<div>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $group);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
    this._itemGroupCaptionTemplate(item, $group, id);
    this._itemGroupContentTemplate(item, $group);
  }
  _createLayoutManagerOptions(items, extendedLayoutManagerOptions) {
    return convertToLayoutManagerOptions({
      form: this,
      formOptions: this.option(),
      $formElement: this.$element(),
      items,
      validationGroup: this._getValidationGroup(),
      extendedLayoutManagerOptions,
      onFieldDataChanged: (args) => {
        if (!this._isDataUpdating) {
          this._triggerOnFieldDataChanged(args);
        }
      },
      onContentReady: (args) => {
        var _extendedLayoutManage;
        this._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
        null === (_extendedLayoutManage = extendedLayoutManagerOptions.onContentReady) || void 0 === _extendedLayoutManage || _extendedLayoutManage.call(extendedLayoutManagerOptions, args);
      },
      onDisposing: (_ref2) => {
        let {
          component
        } = _ref2;
        const nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
        this._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo);
      },
      onFieldItemRendered: () => {
        var _this$_validationSumm;
        null === (_this$_validationSumm = this._validationSummary) || void 0 === _this$_validationSumm || _this$_validationSumm.refreshValidationGroup();
      }
    });
  }
  _renderLayoutManager($parent, layoutManagerOptions) {
    const baseColCountByScreen = {
      lg: layoutManagerOptions.colCount,
      md: layoutManagerOptions.colCount,
      sm: layoutManagerOptions.colCount,
      xs: 1
    };
    this._cachedColCountOptions.push({
      colCountByScreen: extend(baseColCountByScreen, layoutManagerOptions.colCountByScreen)
    });
    const $element = renderer_default("<div>");
    $element.appendTo($parent);
    const instance = this._createComponent($element, "dxLayoutManager", layoutManagerOptions);
    instance.on("autoColCountChanged", (() => {
      this._clearAutoColCountChangedTimeout();
      this.autoColCountChangedTimeoutId = setTimeout((() => !this._disposed && this._refresh()), 0);
    }));
    this._cachedLayoutManagers.push(instance);
    return instance;
  }
  _getValidationGroup() {
    return this.option("validationGroup") || this;
  }
  _createComponent($element, type2, config2) {
    config2 = config2 || {};
    this._extendConfig(config2, {
      readOnly: this.option("readOnly")
    });
    return super._createComponent($element, type2, config2);
  }
  _attachSyncSubscriptions() {
    const that = this;
    that.on("optionChanged", ((args) => {
      const optionFullName = args.fullName;
      if ("formData" === optionFullName) {
        if (!isDefined(args.value)) {
          that._options.silent("formData", args.value = {});
        }
        that._triggerOnFieldDataChangedByDataSet(args.value);
      }
      if (that._cachedLayoutManagers.length) {
        each(that._cachedLayoutManagers, ((index, layoutManager) => {
          if ("formData" === optionFullName) {
            that._isDataUpdating = true;
            layoutManager.option("layoutData", args.value);
            that._isDataUpdating = false;
          }
          if ("readOnly" === args.name || "disabled" === args.name) {
            layoutManager.option(optionFullName, args.value);
          }
        }));
      }
    }));
  }
  _optionChanged(args) {
    const splitFullName = args.fullName.split(".");
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("items") && this._itemsOptionChangedHandler(args)) {
      return;
    }
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("formData") && this._formDataOptionChangedHandler(args)) {
      return;
    }
    this._defaultOptionChangedHandler(args);
  }
  _defaultOptionChangedHandler(args) {
    switch (args.name) {
      case "formData":
        if (!this.option("items")) {
          this._invalidate();
        } else if (isEmptyObject(args.value)) {
          this._clear();
        }
        break;
      case "onFieldDataChanged":
      case "alignRootItemLabels":
      case "readOnly":
      case "isDirty":
        break;
      case "items":
      case "colCount":
      case "onEditorEnterKey":
      case "labelLocation":
      case "labelMode":
      case "alignItemLabels":
      case "showColonAfterLabel":
      case "customizeItem":
      case "alignItemLabelsInAllGroups":
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "requiredMessage":
      case "scrollingEnabled":
      case "formID":
      case "colCountByScreen":
      case "screenByWidth":
      case "stylingMode":
        this._invalidate();
        break;
      case "showValidationSummary":
        this._renderValidationSummary();
        break;
      case "minColWidth": {
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._invalidate();
        }
        break;
      }
      case "width":
        super._optionChanged(args);
        this._rootLayoutManager.option(args.name, args.value);
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
        break;
      case "validationGroup":
        validation_engine_default.removeGroup(args.previousValue || this);
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemsOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const itemPath = this._getItemPath(nameParts);
    const item = this.option(itemPath);
    const optionNameWithoutPath = args.fullName.replace(`${itemPath}.`, "");
    const simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
    const itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
    let result2 = this._tryExecuteItemOptionAction(itemAction) || this._tryChangeLayoutManagerItemOption(args.fullName, value2);
    if (!result2 && item) {
      this._changeItemOption(item, optionNameWithoutPath, value2);
      const items = this._generateItemsFromData(this.option("items"));
      this.option("items", items);
      result2 = true;
    }
    return result2;
  }
  _formDataOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const dataField = nameParts.slice(1).join(".");
    const editor = this.getEditor(dataField);
    if (editor) {
      editor.option("value", value2);
    } else {
      this._triggerOnFieldDataChanged({
        dataField,
        value: value2
      });
    }
    return true;
  }
  _tryCreateItemOptionAction(optionName, item, value2, previousValue, itemPath) {
    if ("tabs" === optionName) {
      this._itemsRunTimeInfo.removeItemsByPathStartWith(`${itemPath}.tabs`);
      value2 = this._prepareItems(value2, true, itemPath, true);
    }
    return m_form_item_options_actions_default(optionName, {
      item,
      value: value2,
      previousValue,
      itemsRunTimeInfo: this._itemsRunTimeInfo
    });
  }
  _tryExecuteItemOptionAction(action) {
    return null === action || void 0 === action ? void 0 : action.tryExecute();
  }
  _updateValidationGroupAndSummaryIfNeeded(fullName) {
    const optionName = getOptionNameFromFullName(fullName);
    if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.includes(optionName)) {
      validation_engine_default.addGroup(this._getValidationGroup(), false);
      if (this.option("showValidationSummary")) {
        var _this$_validationSumm2;
        null === (_this$_validationSumm2 = this._validationSummary) || void 0 === _this$_validationSumm2 || _this$_validationSumm2.refreshValidationGroup();
      }
    }
  }
  _setLayoutManagerItemOption(layoutManager, optionName, value2, path) {
    if (this._updateLockCount > 0) {
      !layoutManager._updateLockCount && layoutManager.beginUpdate();
      const key = this._itemsRunTimeInfo.findKeyByPath(path);
      this.postponedOperations.add(key, (() => {
        !layoutManager._disposed && layoutManager.endUpdate();
        return Deferred().resolve();
      }));
    }
    const contentReadyHandler = (e) => {
      e.component.off("contentReady", contentReadyHandler);
      if (isFullPathContainsTabs(path)) {
        const tabPath = tryGetTabPath(path);
        const tabLayoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(tabPath);
        if (tabLayoutManager) {
          this._alignLabelsInColumn({
            items: tabLayoutManager.option("items"),
            layoutManager: tabLayoutManager,
            $container: tabLayoutManager.$element(),
            inOneColumn: tabLayoutManager.isSingleColumnMode()
          });
        }
      } else {
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
      }
    };
    layoutManager.on("contentReady", contentReadyHandler);
    layoutManager.option(optionName, value2);
    this._updateValidationGroupAndSummaryIfNeeded(optionName);
  }
  _tryChangeLayoutManagerItemOption(fullName, value2) {
    const nameParts = fullName.split(".");
    const optionName = getOptionNameFromFullName(fullName);
    if ("items" === optionName && nameParts.length > 1) {
      const itemPath = this._getItemPath(nameParts);
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
        const items = this._prepareItems(value2, false, itemPath);
        this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
        return true;
      }
    } else if (nameParts.length > 2) {
      const endPartIndex = nameParts.length - 2;
      const itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        const fullOptionName = getFullOptionName(nameParts[endPartIndex], optionName);
        if ("editorType" === optionName) {
          if (layoutManager.option(fullOptionName) !== value2) {
            return false;
          }
        }
        if ("visible" === optionName) {
          const formItems = this.option(getFullOptionName(itemPath, "items"));
          if (null !== formItems && void 0 !== formItems && formItems.length) {
            const layoutManagerItems = layoutManager.option("items");
            formItems.forEach(((item, index) => {
              const layoutItem = layoutManagerItems[index];
              layoutItem.visibleIndex = item.visibleIndex;
            }));
          }
        }
        this._setLayoutManagerItemOption(layoutManager, fullOptionName, value2, itemPath);
        return true;
      }
    }
    return false;
  }
  _tryChangeLayoutManagerItemOptions(itemPath, options2) {
    let result2;
    this.beginUpdate();
    each(options2, ((optionName, optionValue) => {
      result2 = this._tryChangeLayoutManagerItemOption(getFullOptionName(itemPath, optionName), optionValue);
      if (!result2) {
        return false;
      }
    }));
    this.endUpdate();
    return result2;
  }
  _getItemPath(nameParts) {
    let itemPath = nameParts[0];
    let i;
    for (i = 1; i < nameParts.length; i++) {
      if (-1 !== nameParts[i].search(/items\[\d+]|tabs\[\d+]/)) {
        itemPath += `.${nameParts[i]}`;
      } else {
        break;
      }
    }
    return itemPath;
  }
  _triggerOnFieldDataChanged(args) {
    this._updateIsDirty(args.dataField);
    this._createActionByOption("onFieldDataChanged")(args);
  }
  _triggerOnFieldDataChangedByDataSet(data17) {
    if (data17 && isObject(data17)) {
      Object.keys(data17).forEach(((key) => {
        this._triggerOnFieldDataChanged({
          dataField: key,
          value: data17[key]
        });
      }));
    }
  }
  _updateFieldValue(dataField, value2) {
    if (isDefined(this.option("formData"))) {
      const editor = this.getEditor(dataField);
      this.option(`formData.${dataField}`, value2);
      if (editor) {
        const editorValue = editor.option("value");
        if (editorValue !== value2) {
          editor.option("value", value2);
        }
      }
    }
  }
  _generateItemsFromData(items) {
    const formData = this.option("formData");
    const result2 = [];
    if (!items && isDefined(formData)) {
      each(formData, ((dataField) => {
        result2.push({
          dataField
        });
      }));
    }
    if (items) {
      each(items, ((index, item) => {
        if (isObject(item)) {
          result2.push(item);
        } else {
          result2.push({
            dataField: item
          });
        }
      }));
    }
    return result2;
  }
  _getItemByField(field, items) {
    const that = this;
    const fieldParts = isObject(field) ? field : that._getFieldParts(field);
    const {
      fieldName
    } = fieldParts;
    const {
      fieldPath
    } = fieldParts;
    let resultItem;
    if (items.length) {
      each(items, ((index, item) => {
        const {
          itemType
        } = item;
        if (fieldPath.length) {
          const path = fieldPath.slice();
          item = that._getItemByFieldPath(path, fieldName, item);
        } else if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
          const subItemsField = that._getSubItemField(itemType);
          item.items = that._generateItemsFromData(item.items);
          item = that._getItemByField({
            fieldName,
            fieldPath
          }, item[subItemsField]);
        }
        if (isEqualToDataFieldOrNameOrTitleOrCaption(item, fieldName)) {
          resultItem = item;
          return false;
        }
      }));
    }
    return resultItem;
  }
  _getFieldParts(field) {
    let fieldName = field;
    let separatorIndex = fieldName.indexOf(".");
    const resultPath = [];
    while (-1 !== separatorIndex) {
      resultPath.push(fieldName.substr(0, separatorIndex));
      fieldName = fieldName.substr(separatorIndex + 1);
      separatorIndex = fieldName.indexOf(".");
    }
    return {
      fieldName,
      fieldPath: resultPath.reverse()
    };
  }
  _getItemByFieldPath(path, fieldName, item) {
    const that = this;
    const {
      itemType
    } = item;
    const subItemsField = that._getSubItemField(itemType);
    const isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
    let result2;
    do {
      if (isItemWithSubItems) {
        const name2 = item.name || item.caption || item.title;
        const isGroupWithName = isDefined(name2);
        const nameWithoutSpaces = getTextWithoutSpaces(name2);
        let pathNode;
        item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
        if (isGroupWithName) {
          pathNode = path.pop();
        }
        if (!path.length) {
          result2 = that._getItemByField(fieldName, item[subItemsField]);
          if (result2) {
            break;
          }
        }
        if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
          if (path.length) {
            result2 = that._searchItemInEverySubItem(path, fieldName, item[subItemsField]);
          }
        }
      } else {
        break;
      }
    } while (path.length && !isDefined(result2));
    return result2;
  }
  _getSubItemField(itemType) {
    return "tabbed" === itemType ? "tabs" : "items";
  }
  _searchItemInEverySubItem(path, fieldName, items) {
    const that = this;
    let result2;
    each(items, ((index, groupItem) => {
      result2 = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
      if (result2) {
        return false;
      }
    }));
    if (!result2) {
      result2 = false;
    }
    return result2;
  }
  _changeItemOption(item, option, value2) {
    if (isObject(item)) {
      item[option] = value2;
    }
  }
  _dimensionChanged() {
    const currentScreenFactor = this._getCurrentScreenFactor();
    if (this._lastMarkupScreenFactor !== currentScreenFactor) {
      if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
        this._targetScreenFactor = currentScreenFactor;
        this._refresh();
        this._targetScreenFactor = void 0;
      }
      this._lastMarkupScreenFactor = currentScreenFactor;
    }
  }
  _isColCountChanged(oldScreenSize, newScreenSize) {
    let isChanged = false;
    each(this._cachedColCountOptions, ((index, item) => {
      if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
        isChanged = true;
        return false;
      }
    }));
    return isChanged;
  }
  _refresh() {
    const editorSelector = `.${TEXTEDITOR_CLASS}.${FOCUSED_STATE_CLASS}:not(.${DROP_DOWN_EDITOR_CLASS}) .${TEXTEDITOR_INPUT_CLASS}`;
    m_events_engine_default.trigger(this.$element().find(editorSelector), "change");
    super._refresh();
  }
  _updateIsDirty(dataField) {
    const editor = this.getEditor(dataField);
    if (!editor) {
      return;
    }
    if (editor.option("isDirty")) {
      this._dirtyFields.add(dataField);
    } else {
      this._dirtyFields.delete(dataField);
    }
    this.option("isDirty", !!this._dirtyFields.size);
  }
  updateRunTimeInfoForEachEditor(editorAction) {
    this._itemsRunTimeInfo.each(((_, itemRunTimeInfo) => {
      const {
        widgetInstance
      } = itemRunTimeInfo;
      if (isDefined(widgetInstance) && editor_default2.isEditor(widgetInstance)) {
        editorAction(widgetInstance);
      }
    }));
  }
  _clear() {
    this.updateRunTimeInfoForEachEditor(((editor) => {
      editor.clear();
      editor.option("isValid", true);
    }));
    validation_engine_default.resetGroup(this._getValidationGroup());
  }
  _updateData(data17, value2, isComplexData) {
    const that = this;
    const _data = isComplexData ? value2 : data17;
    if (isObject(_data)) {
      each(_data, ((dataField, fieldValue) => {
        that._updateData(isComplexData ? `${data17}.${dataField}` : dataField, fieldValue, isObject(fieldValue));
      }));
    } else if (isString(data17)) {
      that._updateFieldValue(data17, value2);
    }
  }
  registerKeyHandler(key, handler) {
    super.registerKeyHandler(key, handler);
    this._itemsRunTimeInfo.each(((_, itemRunTimeInfo) => {
      if (isDefined(itemRunTimeInfo.widgetInstance)) {
        itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler);
      }
    }));
  }
  _focusTarget() {
    return this.$element().find(`.${FIELD_ITEM_CONTENT_CLASS} [tabindex]`).first();
  }
  _visibilityChanged() {
    this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
  }
  _clearAutoColCountChangedTimeout() {
    if (this.autoColCountChangedTimeoutId) {
      clearTimeout(this.autoColCountChangedTimeoutId);
      this.autoColCountChangedTimeoutId = void 0;
    }
  }
  _dispose() {
    this._clearAutoColCountChangedTimeout();
    validation_engine_default.removeGroup(this._getValidationGroup());
    super._dispose();
  }
  clear() {
    this._clear();
  }
  resetValues() {
    this._clear();
  }
  reset(editorsData) {
    this.updateRunTimeInfoForEachEditor(((editor) => {
      const editorName = editor.option("name");
      if (editorsData && editorName in editorsData) {
        editor.reset(editorsData[editorName]);
        this._updateIsDirty(editorName);
      } else {
        editor.reset();
      }
    }));
    this._renderValidationSummary();
  }
  updateData(data17, value2) {
    this._updateData(data17, value2);
  }
  getEditor(dataField) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField);
  }
  getButton(name2) {
    return this._itemsRunTimeInfo.findWidgetInstanceByName(name2);
  }
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollable) {
      that._scrollable.update().done((() => {
        deferred.resolveWith(that);
      }));
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  }
  itemOption(id, option, value2) {
    const items = this._generateItemsFromData(this.option("items"));
    const item = this._getItemByField(id, items);
    const path = getItemPath(items, item);
    if (!item) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return item;
      case 3: {
        const itemAction = this._tryCreateItemOptionAction(option, item, value2, item[option], path);
        this._changeItemOption(item, option, value2);
        const fullName = getFullOptionName(path, option);
        if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value2)) {
          this.option("items", items);
        }
        break;
      }
      default:
        if (isObject(option)) {
          if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
            let allowUpdateItems;
            each(option, ((optionName, optionValue) => {
              const itemAction = this._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
              this._changeItemOption(item, optionName, optionValue);
              if (!allowUpdateItems && !this._tryExecuteItemOptionAction(itemAction)) {
                allowUpdateItems = true;
              }
            }));
            allowUpdateItems && this.option("items", items);
          }
        }
    }
  }
  validate() {
    return validation_engine_default.validateGroup(this._getValidationGroup());
  }
  getItemID(name2) {
    const {
      formID
    } = this.option();
    return `dx_${formID}_${name2 || new guid_default()}`;
  }
  getTargetScreenFactor() {
    return this._targetScreenFactor;
  }
};
component_registrator_default("dxForm", Form);
var m_form_default = Form;

// node_modules/devextreme/esm/ui/form/ui.form.js
var ui_form_default = m_form_default;

// node_modules/devextreme/esm/ui/form.js
var form_default = ui_form_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_form_based.js
var editingControllerExtender2 = (Base) => class extends Base {
  init() {
    this._editForm = null;
    this._updateEditFormDeferred = null;
    super.init();
  }
  isEditRow(rowIndex) {
    return !this.isPopupEditMode() && super.isEditRow(rowIndex);
  }
  isFormOrPopupEditMode() {
    return this.isPopupEditMode() || this.isFormEditMode();
  }
  isFormEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_FORM;
  }
  getFirstEditableColumnIndex() {
    const firstFormItem = this._firstFormItem;
    if (this.isFormEditMode() && firstFormItem) {
      const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
      const editRowIndex = this._dataController.getRowIndexByKey(editRowKey);
      const $editFormElements = this._rowsView.getCellElements(editRowIndex);
      return this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column);
    }
    return super.getFirstEditableColumnIndex();
  }
  getEditFormRowIndex() {
    return this.isFormOrPopupEditMode() ? this._getVisibleEditRowIndex() : super.getEditFormRowIndex();
  }
  _isEditColumnVisible() {
    const result2 = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    return this.isFormOrPopupEditMode() ? editingOptions.allowUpdating || result2 : result2;
  }
  _handleDataChanged(args) {
    if (this.isPopupEditMode()) {
      var _args$items, _args$changeTypes;
      const editRowKey = this.option("editing.editRowKey");
      const hasEditRow = null === args || void 0 === args || null === (_args$items = args.items) || void 0 === _args$items ? void 0 : _args$items.some(((item) => equalByValue(item.key, editRowKey)));
      const onlyInsertChanges = (null === (_args$changeTypes = args.changeTypes) || void 0 === _args$changeTypes ? void 0 : _args$changeTypes.length) && args.changeTypes.every(((item) => "insert" === item));
      if (("refresh" === args.changeType || hasEditRow && args.isOptionChanged) && !onlyInsertChanges) {
        this._repaintEditPopup();
      }
    }
    super._handleDataChanged(args);
  }
  getPopupContent() {
    var _this$_editPopup;
    const popupVisible = null === (_this$_editPopup = this._editPopup) || void 0 === _this$_editPopup ? void 0 : _this$_editPopup.option("visible");
    if (this.isPopupEditMode() && popupVisible) {
      return this._$popupContent;
    }
  }
  _showAddedRow(rowIndex) {
    if (this.isPopupEditMode()) {
      this._showEditPopup(rowIndex);
    } else {
      super._showAddedRow(rowIndex);
    }
  }
  _cancelEditDataCore() {
    super._cancelEditDataCore();
    if (this.isPopupEditMode()) {
      this._hideEditPopup();
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    const editForm = this._editForm;
    if (this.isPopupEditMode()) {
      if (this.option("repaintChangesOnly")) {
        var _row$update;
        null === (_row$update = row.update) || void 0 === _row$update || _row$update.call(row, row);
        this._rowsView.renderDelayedTemplates();
      } else if (editForm) {
        this._updateEditFormDeferred = new Deferred().done((() => editForm.repaint()));
        if (!this._updateLockCount) {
          this._updateEditFormDeferred.resolve();
        }
      }
    } else {
      super._updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue);
    }
  }
  _showEditPopup(rowIndex, repaintForm) {
    const isMobileDevice = "desktop" !== devices_default.current().deviceType;
    const editPopupClass = this.addWidgetPrefix(EDIT_POPUP_CLASS);
    const popupOptions = extend({
      showTitle: false,
      fullScreen: isMobileDevice,
      wrapperAttr: {
        class: editPopupClass
      },
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getSaveButtonConfig()
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getCancelButtonConfig()
      }],
      contentTemplate: this._getPopupEditFormTemplate(rowIndex)
    }, this.option(EDITING_POPUP_OPTION_NAME));
    if (!this._editPopup) {
      const $popupContainer = renderer_default("<div>").appendTo(this.component.$element()).addClass(editPopupClass);
      this._editPopup = this._createComponent($popupContainer, ui_popup_default);
      this._editPopup.on("hiding", this._getEditPopupHiddenHandler());
      this._editPopup.on("shown", ((e) => {
        m_events_engine_default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not(`.${FOCUSABLE_ELEMENT_CLASS}`).first(), "focus");
        if (repaintForm) {
          var _this$_editForm;
          null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm || _this$_editForm.repaint();
        }
      }));
    }
    this._editPopup.option(popupOptions);
    this._editPopup.show();
    super._showEditPopup(rowIndex, repaintForm);
  }
  _getPopupEditFormTemplate(rowIndex) {
    const row = this.component.getVisibleRows()[rowIndex];
    const templateOptions = {
      row,
      values: row.values,
      rowType: row.rowType,
      key: row.key,
      rowIndex
    };
    this._rowsView._addWatchMethod(templateOptions, row);
    return (container) => {
      const formTemplate = this.getEditFormTemplate();
      const scrollable = this._createComponent(renderer_default("<div>").appendTo(container), ui_scrollable_default);
      this._$popupContent = renderer_default(scrollable.content());
      formTemplate(this._$popupContent, templateOptions, {
        isPopupForm: true
      });
      this._rowsView.renderDelayedTemplates();
      renderer_default(container).parent().attr("aria-label", this.localize("dxDataGrid-ariaEditForm"));
    };
  }
  _repaintEditPopup() {
    const rowIndex = this._getVisibleEditRowIndex();
    if (rowIndex >= 0) {
      var _this$_editPopup2, _this$_editPopup3;
      const defaultAnimation = null === (_this$_editPopup2 = this._editPopup) || void 0 === _this$_editPopup2 ? void 0 : _this$_editPopup2.option("animation");
      null === (_this$_editPopup3 = this._editPopup) || void 0 === _this$_editPopup3 || _this$_editPopup3.option("animation", null);
      this._showEditPopup(rowIndex, true);
      if (void 0 !== defaultAnimation) {
        this._editPopup.option("animation", defaultAnimation);
      }
    }
  }
  _hideEditPopup() {
    var _this$_editPopup4;
    null === (_this$_editPopup4 = this._editPopup) || void 0 === _this$_editPopup4 || _this$_editPopup4.option("visible", false);
  }
  optionChanged(args) {
    if ("editing" === args.name && this.isFormOrPopupEditMode()) {
      const {
        fullName
      } = args;
      if (0 === fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
        this._handleFormOptionChange(args);
        args.handled = true;
      } else if (0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {
        this._handlePopupOptionChange(args);
        args.handled = true;
      }
    }
    super.optionChanged(args);
  }
  _handleFormOptionChange(args) {
    var _this$_editPopup5;
    if (this.isFormEditMode()) {
      const editRowIndex = this._getVisibleEditRowIndex();
      if (editRowIndex >= 0) {
        this._dataController.updateItems({
          changeType: "update",
          rowIndices: [editRowIndex]
        });
      }
    } else if (null !== (_this$_editPopup5 = this._editPopup) && void 0 !== _this$_editPopup5 && _this$_editPopup5.option("visible") && 0 === args.fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
      this._repaintEditPopup();
    }
  }
  _handlePopupOptionChange(args) {
    const editPopup = this._editPopup;
    if (editPopup) {
      const popupOptionName = args.fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);
      if (popupOptionName) {
        editPopup.option(popupOptionName, args.value);
      } else {
        editPopup.option(args.value);
      }
    }
  }
  renderFormEditorTemplate(detailCellOptions, item, formTemplateOptions, container, isReadOnly) {
    const that = this;
    const $container = renderer_default(container);
    const {
      column
    } = item;
    const editorType = getEditorType(item);
    const row = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row;
    const rowData = null === row || void 0 === row ? void 0 : row.data;
    const form = formTemplateOptions.component;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, null === row || void 0 === row ? void 0 : row.rowType);
    const {
      label,
      labelMark,
      labelMode
    } = formTemplateOptions.editorOptions || {};
    const cellOptions = extend({}, detailCellOptions, {
      data: rowData,
      cellElement: null,
      isOnForm: true,
      item,
      id: form.getItemID(item.name || item.dataField),
      column: extend({}, column, {
        editorType,
        editorOptions: extend({
          label,
          labelMark,
          labelMode
        }, column.editorOptions, item.editorOptions)
      }),
      columnIndex: column.index,
      setValue: !isReadOnly && column.allowEditing && function(value3, text) {
        that.updateFieldValue(cellOptions, value3, text);
      }
    });
    cellOptions.value = value2;
    cellOptions.displayValue = displayValue;
    cellOptions.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    const template = this._getFormEditItemTemplate.bind(this)(cellOptions, column);
    this._rowsView.renderTemplate($container, template, cellOptions, !!isElementInDom($container)).done((() => {
      this._rowsView._updateCell($container, cellOptions);
    }));
    return cellOptions;
  }
  getFormEditorTemplate(cellOptions, item) {
    const column = this.component.columnOption(item.name || item.dataField);
    return (options2, container) => {
      const $container = renderer_default(container);
      const {
        row
      } = cellOptions;
      if (null !== row && void 0 !== row && row.watch) {
        const dispose = row.watch((() => column.selector(row.data)), (() => {
          var _validator;
          let $editorElement = $container.find(".dx-widget").first();
          let validator = $editorElement.data("dxValidator");
          const validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();
          $container.contents().remove();
          cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options2, $container);
          $editorElement = $container.find(".dx-widget").first();
          validator = $editorElement.data("dxValidator");
          if (validatorOptions && !validator) {
            $editorElement.dxValidator({
              validationRules: validatorOptions.validationRules,
              validationGroup: validatorOptions.validationGroup,
              dataGetter: validatorOptions.dataGetter
            });
          }
        }));
        m_events_engine_default.on($container, removeEvent, dispose);
      }
      cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options2, $container);
    };
  }
  getEditFormOptions(detailOptions) {
    var _this$_getValidationG;
    const editFormOptions = null === (_this$_getValidationG = this._getValidationGroupsInForm) || void 0 === _this$_getValidationG ? void 0 : _this$_getValidationG.call(this, detailOptions);
    const userCustomizeItem = this.option("editing.form.customizeItem");
    const editFormItemClass = this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS);
    let items = this.option("editing.form.items");
    const isCustomEditorType = {};
    if (!items) {
      const columns7 = this._columnsController.getColumns();
      items = [];
      each(columns7, ((_, column) => {
        if (!column.isBand && !column.type) {
          items.push({
            column,
            name: column.name,
            dataField: column.dataField
          });
        }
      }));
    } else {
      forEachFormItems(items, ((item) => {
        const itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);
        if (itemId) {
          isCustomEditorType[itemId] = !!item.editorType;
        }
      }));
    }
    return extend({}, editFormOptions, {
      items,
      formID: `dx-${new guid_default()}`,
      customizeItem: (item) => {
        let column;
        const itemId = item.name || item.dataField;
        if (item.column || itemId) {
          column = item.column || this._columnsController.columnOption(item.name ? `name:${item.name}` : `dataField:${item.dataField}`);
        }
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          if ("boolean" === column.dataType && void 0 === item.label.visible) {
            const labelMode = this.option("editing.form.labelMode");
            if ("floating" === labelMode || "static" === labelMode) {
              item.label.visible = true;
            }
          }
          item.template = item.template || this.getFormEditorTemplate(detailOptions, item);
          item.column = column;
          item.isCustomEditorType = isCustomEditorType[itemId];
          if (column.formItem) {
            extend(item, column.formItem);
          }
          if (void 0 === item.isRequired && column.validationRules) {
            item.isRequired = column.validationRules.some(((rule) => "required" === rule.type));
            item.validationRules = [];
          }
          const itemVisible = isDefined(item.visible) ? item.visible : true;
          if (!this._firstFormItem && itemVisible) {
            this._firstFormItem = item;
          }
        }
        null === userCustomizeItem || void 0 === userCustomizeItem || userCustomizeItem.call(this, item);
        item.cssClass = isString(item.cssClass) ? `${item.cssClass} ${editFormItemClass}` : editFormItemClass;
      }
    });
  }
  getEditFormTemplate() {
    return ($container, detailOptions, options2) => {
      const editFormOptions = this.option(EDITING_FORM_OPTION_NAME);
      const baseEditFormOptions = this.getEditFormOptions(detailOptions);
      const $formContainer = renderer_default("<div>").appendTo($container);
      const isPopupForm = null === options2 || void 0 === options2 ? void 0 : options2.isPopupForm;
      this._firstFormItem = void 0;
      if (isPopupForm) {
        $formContainer.addClass(this.addWidgetPrefix(EDIT_POPUP_FORM_CLASS));
      }
      this._editForm = this._createComponent($formContainer, form_default, extend({}, editFormOptions, baseEditFormOptions));
      if (!isPopupForm) {
        const $buttonsContainer = renderer_default("<div>").addClass(this.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default2, this._getSaveButtonConfig());
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default2, this._getCancelButtonConfig());
      }
      this._editForm.on("contentReady", (() => {
        var _this$_editPopup6;
        this._rowsView.renderDelayedTemplates();
        null === (_this$_editPopup6 = this._editPopup) || void 0 === _this$_editPopup6 || _this$_editPopup6.repaint();
      }));
    };
  }
  getEditForm() {
    return this._editForm;
  }
  _endUpdateCore() {
    var _this$_updateEditForm;
    null === (_this$_updateEditForm = this._updateEditFormDeferred) || void 0 === _this$_updateEditForm || _this$_updateEditForm.resolve();
  }
  _beforeEndSaving(changes) {
    super._beforeEndSaving(changes);
    if (this.isPopupEditMode()) {
      var _this$_editPopup7;
      null === (_this$_editPopup7 = this._editPopup) || void 0 === _this$_editPopup7 || _this$_editPopup7.hide();
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      type: type2
    } = change;
    if (this.isPopupEditMode() && type2 === DATA_EDIT_DATA_INSERT_TYPE) {
      item.visible = false;
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex) {
    const isPopupEditMode = this.isPopupEditMode();
    super._editRowFromOptionChangedCore(rowIndices, rowIndex, isPopupEditMode);
    if (isPopupEditMode) {
      this._showEditPopup(rowIndex);
    }
  }
};
var data6 = (Base) => class extends Base {
  _updateEditItem(item) {
    if (this._editingController.isFormEditMode()) {
      item.rowType = "detail";
    }
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    if (false === isLiveUpdate && newItem.isEditing && this._editingController.isFormEditMode()) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView5 = (Base) => class extends Base {
  _renderCellContent($cell, options2) {
    if ("data" === options2.rowType && this._editingController.isPopupEditMode() && false === options2.row.visible) {
      return;
    }
    super._renderCellContent.apply(this, arguments);
  }
  getCellElements(rowIndex) {
    const $cellElements = super.getCellElements(rowIndex);
    const editingController = this._editingController;
    const editForm = editingController.getEditForm();
    const editFormRowIndex = editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && $cellElements && editForm) {
      return editForm.$element().find(`.${this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS)}, .${BUTTON_CLASS}`);
    }
    return $cellElements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    const editFormRowIndex = this._editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && isString(columnIdentifier)) {
      const column = this._columnsController.columnOption(columnIdentifier);
      return this._getEditFormEditorVisibleIndex($cells, column);
    }
    return super._getVisibleColumnIndex.apply(this, arguments);
  }
  _getEditFormEditorVisibleIndex($cells, column) {
    let visibleIndex = -1;
    each($cells, ((index, cellElement) => {
      const item = renderer_default(cellElement).find(".dx-field-item-content").data("dx-form-item");
      if (null !== item && void 0 !== item && item.column && column && item.column.index === column.index) {
        visibleIndex = index;
        return false;
      }
    }));
    return visibleIndex;
  }
  _isFormItem(parameters) {
    const isDetailRow3 = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType;
    const isPopupEditing = "data" === parameters.rowType && this._editingController.isPopupEditMode();
    return (isDetailRow3 || isPopupEditing) && parameters.item;
  }
  _updateCell($cell, parameters) {
    if (this._isFormItem(parameters)) {
      this._formItemPrepared(parameters, $cell);
    } else {
      super._updateCell($cell, parameters);
    }
  }
  _updateContent() {
    const editingController = this._editingController;
    const oldEditForm = editingController.getEditForm();
    const validationGroup = null === oldEditForm || void 0 === oldEditForm ? void 0 : oldEditForm.option("validationGroup");
    const deferred = super._updateContent.apply(this, arguments);
    return deferred.done((() => {
      const newEditForm = editingController.getEditForm();
      if (validationGroup && newEditForm && newEditForm !== oldEditForm) {
        newEditForm.option("validationGroup", validationGroup);
      }
    }));
  }
};
var editingFormBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender2,
      data: data6
    },
    views: {
      rowsView: rowsView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_form_based.js
m_core_default.registerModule("editingFormBased", editingFormBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_cell_based.js
var editingControllerExtender3 = (Base) => class extends Base {
  init() {
    const needCreateHandlers = !this._saveEditorHandler;
    super.init();
    if (needCreateHandlers) {
      let $pointerDownTarget;
      let isResizing;
      this._pointerUpEditorHandler = () => {
        var _this$_columnsResizer;
        isResizing = null === (_this$_columnsResizer = this._columnsResizerController) || void 0 === _this$_columnsResizer ? void 0 : _this$_columnsResizer.isResizing();
      };
      this._pointerDownEditorHandler = (e) => $pointerDownTarget = renderer_default(e.target);
      this._saveEditorHandler = this.createAction((function(e) {
        const {
          event
        } = e;
        const $target = renderer_default(event.target);
        const targetComponent = event[TARGET_COMPONENT_NAME];
        const {
          component
        } = this;
        if (isEditable($pointerDownTarget) && !$pointerDownTarget.is($target)) {
          return;
        }
        function checkEditorPopup($element) {
          if (!$element) {
            return false;
          }
          const $dropDownEditorOverlay = $element.closest(`.${DROPDOWN_EDITOR_OVERLAY_CLASS}`);
          const $componentElement = component.$element();
          return $dropDownEditorOverlay.length > 0 && 0 === $componentElement.closest($dropDownEditorOverlay).length;
        }
        if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {
          const isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());
          const isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== this.component;
          const isAddRowButton = !!$target.closest(`.${this.addWidgetPrefix(ADD_ROW_BUTTON_CLASS)}`).length;
          const isFocusOverlay = $target.hasClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
          const isCellEditMode = this.isCellEditMode();
          if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && this.isEditing()) && (isElementInDom($target) || isAnotherComponent)) {
            this._closeEditItem.bind(this)($target);
          }
        }
      }));
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
    }
  }
  isCellEditMode() {
    return this.option("editing.mode") === EDIT_MODE_CELL;
  }
  isBatchEditMode() {
    return this.option("editing.mode") === EDIT_MODE_BATCH;
  }
  isCellOrBatchEditMode() {
    return this.isCellEditMode() || this.isBatchEditMode();
  }
  _needToCloseEditableCell($targetElement) {
    const $element = this.component.$element();
    let result2 = this.isEditing();
    const isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;
    if (isCurrentComponentElement) {
      const isDataRow2 = $targetElement.closest(`.${DATA_ROW_CLASS}`).length;
      if (isDataRow2) {
        const $targetCell = $targetElement.closest(`.${ROW_CLASS}> td`);
        const rowIndex = this._rowsView.getRowIndex($targetCell.parent());
        const cellElements = this._rowsView.getCellElements(rowIndex);
        if (null !== cellElements && void 0 !== cellElements && cellElements.length) {
          var _visibleColumns$colum;
          const columnIndex = cellElements.index($targetCell);
          const visibleColumns = this._columnsController.getVisibleColumns();
          const allowEditing = null === (_visibleColumns$colum = visibleColumns[columnIndex]) || void 0 === _visibleColumns$colum ? void 0 : _visibleColumns$colum.allowEditing;
          const isEditingCell2 = this.isEditCell(rowIndex, columnIndex);
          result2 = result2 && !allowEditing && !isEditingCell2;
        }
      }
    }
    return result2 || super._needToCloseEditableCell($targetElement);
  }
  _closeEditItem($targetElement) {
    if (this._needToCloseEditableCell($targetElement)) {
      this.closeEditCell();
    }
  }
  _focusEditorIfNeed() {
    if (this._needFocusEditor && this.isCellOrBatchEditMode()) {
      var _this$_rowsView;
      const editColumnIndex = this._getVisibleEditColumnIndex();
      const $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
      this._refocusEditCell = false;
      clearTimeout(this._inputFocusTimeoutID);
      if ($cell && !$cell.find(":focus").length) {
        this._focusEditingCell((() => {
          this._editCellInProgress = false;
        }), $cell, true);
      } else {
        this._editCellInProgress = false;
      }
      this._needFocusEditor = false;
    } else {
      super._focusEditorIfNeed();
    }
  }
  isEditing() {
    if (this.isCellOrBatchEditMode()) {
      const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
      const isEditColumnNameDefined = isDefined(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME));
      return isEditRowKeyDefined && isEditColumnNameDefined;
    }
    return super.isEditing();
  }
  _handleEditColumnNameChange(args) {
    const oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);
    if (this.isCellOrBatchEditMode() && -1 !== oldRowIndex && isDefined(args.value) && args.value !== args.previousValue) {
      const columnIndex = this._columnsController.getVisibleColumnIndex(args.value);
      const oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);
      this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex);
    }
  }
  _addRow(parentKey) {
    if (this.isCellEditMode() && this.hasChanges()) {
      const deferred = new Deferred();
      this.saveEditData().done((() => {
        if (!this.hasChanges()) {
          this.addRow(parentKey).done(deferred.resolve).fail(deferred.reject);
        } else {
          deferred.reject("cancel");
        }
      }));
      return deferred.promise();
    }
    return super._addRow(parentKey);
  }
  editCell(rowIndex, columnIndex) {
    return this._editCell({
      rowIndex,
      columnIndex
    });
  }
  _editCell(options2) {
    const d = new Deferred();
    let coreResult;
    this.executeOperation(d, (() => {
      coreResult = this._editCellCore(options2);
      when(coreResult).done(d.resolve).fail(d.reject);
    }));
    return void 0 !== coreResult ? coreResult : d.promise();
  }
  _editCellCore(options2) {
    const editCellOptions = this._getNormalizedEditCellOptions(options2);
    const {
      columnIndex,
      rowIndex,
      column,
      item
    } = editCellOptions;
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (column && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && this.isCellOrBatchEditMode()) {
      if (this.isEditCell(rowIndex, columnIndex)) {
        return true;
      }
      return when(this._beforeEditCell(rowIndex, columnIndex, item)).done(((cancel) => {
        if (cancel) {
          return;
        }
        if (!this._prepareEditCell(editCellOptions)) {
          this._processCanceledEditingCell();
        }
      }));
    }
    return false;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    if (this.isCellEditMode() && !item.isNewRow && this.hasChanges()) {
      const isSaving = new Deferred();
      this.saveEditData().always((() => {
        isSaving.resolve(this.hasChanges());
      }));
      this.addDeferred(isSaving);
      return isSaving;
    }
    return false;
  }
  publicMethods() {
    const publicMethods = super.publicMethods();
    return publicMethods.concat(["editCell", "closeEditCell"]);
  }
  _getNormalizedEditCellOptions(_ref) {
    let {
      oldColumnIndex,
      oldRowIndex,
      columnIndex,
      rowIndex
    } = _ref;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const items = this._dataController.items();
    const item = items[rowIndex];
    let oldColumn;
    if (isDefined(oldColumnIndex)) {
      oldColumn = visibleColumns[oldColumnIndex];
    } else {
      oldColumn = this._getEditColumn();
    }
    if (!isDefined(oldRowIndex)) {
      oldRowIndex = this._getVisibleEditRowIndex();
    }
    if (isString(columnIndex)) {
      columnIndex = columnsController.columnOption(columnIndex, "index");
      columnIndex = columnsController.getVisibleIndex(columnIndex);
    }
    const column = visibleColumns[columnIndex];
    return {
      oldColumn,
      columnIndex,
      oldRowIndex,
      rowIndex,
      column,
      item
    };
  }
  _prepareEditCell(_ref2) {
    let {
      item,
      column,
      oldColumn,
      columnIndex,
      oldRowIndex
    } = _ref2;
    const editingStartParams = {
      data: null === item || void 0 === item ? void 0 : item.data,
      cancel: false,
      column,
      key: !item.isNewRow ? item.key : void 0
    };
    if (this._isEditingStart(editingStartParams)) {
      return false;
    }
    this._pageIndex = this._dataController.pageIndex();
    this._setEditRowKey(item.key, true);
    this._setEditColumnNameByIndex(columnIndex, true);
    this._repaintEditCell(column, oldColumn, oldRowIndex);
    if (!column.showEditorAlways) {
      this._addInternalData({
        key: item.key,
        oldData: item.oldData ?? item.data
      });
    }
    return true;
  }
  closeEditCell(isError, withoutSaveEditData) {
    let result2 = when();
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    if (this.isCellOrBatchEditMode()) {
      const deferred = new Deferred();
      result2 = new Deferred();
      this.executeOperation(deferred, (() => {
        this._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result2.resolve);
      }));
    }
    return result2.promise();
  }
  _closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData) {
    const dataController2 = this._dataController;
    const deferred = new Deferred();
    const promise = deferred.promise();
    if (this.isCellEditMode() && this.hasChanges()) {
      if (!withoutSaveEditData) {
        this.saveEditData().done(((error) => {
          if (!this.hasChanges()) {
            this.closeEditCell(!!error).always(deferred.resolve);
            return;
          }
          deferred.resolve();
        }));
        return promise;
      }
    } else {
      this._resetEditRowKey();
      this._resetEditColumnName();
      if (oldEditRowIndex >= 0) {
        const rowIndices = [oldEditRowIndex];
        this._beforeCloseEditCellInBatchMode(rowIndices);
        if (!isError) {
          dataController2.updateItems({
            changeType: "update",
            rowIndices
          });
        }
      }
    }
    deferred.resolve();
    return promise;
  }
  _resetModifiedClassCells(changes) {
    if (this.isBatchEditMode()) {
      const columnsCount = this._columnsController.getVisibleColumns().length;
      changes.forEach(((_ref3) => {
        let {
          key
        } = _ref3;
        const rowIndex = this._dataController.getRowIndexByKey(key);
        for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
          const cellElement = this._rowsView._getCellElement(rowIndex, columnIndex);
          null === cellElement || void 0 === cellElement || cellElement.removeClass(CELL_MODIFIED_CLASS);
        }
      }));
    }
  }
  _prepareChange(options2, value2, text) {
    const $cellElement = renderer_default(options2.cellElement);
    if (this.isBatchEditMode() && void 0 !== options2.key) {
      this._applyModified($cellElement, options2);
    }
    return super._prepareChange(options2, value2, text);
  }
  _cancelSaving(result2) {
    const dataController2 = this._dataController;
    if (this.isCellOrBatchEditMode()) {
      if (this.isBatchEditMode()) {
        this._resetEditIndices();
      }
      dataController2.updateItems();
    }
    super._cancelSaving(result2);
  }
  optionChanged(args) {
    const {
      fullName
    } = args;
    if ("editing" === args.name && fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME) {
      this._handleEditColumnNameChange(args);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex) {
    const columns7 = this._columnsController.getVisibleColumns();
    if (columnIndex > -1) {
      deferRender((() => {
        this._repaintEditCell(columns7[columnIndex], columns7[oldColumnIndex], oldRowIndex);
      }));
    }
  }
  _handleEditRowKeyChange(args) {
    if (this.isCellOrBatchEditMode()) {
      const columnIndex = this._getVisibleEditColumnIndex();
      const oldRowIndexCorrection = this._getEditRowIndexCorrection();
      const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
      if (isDefined(args.value) && args.value !== args.previousValue) {
        var _this$_editCellFromOp;
        null === (_this$_editCellFromOp = this._editCellFromOptionChanged) || void 0 === _this$_editCellFromOp || _this$_editCellFromOp.call(this, columnIndex, columnIndex, oldRowIndex);
      }
    } else {
      super._handleEditRowKeyChange(args);
    }
  }
  deleteRow(rowIndex) {
    if (this.isCellEditMode() && this.isEditing()) {
      const {
        isNewRow
      } = this._dataController.items()[rowIndex];
      const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
      this.closeEditCell(null, isNewRow).always((() => {
        rowIndex = this._dataController.getRowIndexByKey(rowKey);
        this._checkAndDeleteRow(rowIndex);
      }));
    } else {
      super.deleteRow(rowIndex);
    }
  }
  _checkAndDeleteRow(rowIndex) {
    if (this.isBatchEditMode()) {
      this._deleteRowCore(rowIndex);
    } else {
      super._checkAndDeleteRow(rowIndex);
    }
  }
  _refreshCore(params) {
    const {
      isPageChanged
    } = params ?? {};
    const needResetIndexes = this.isBatchEditMode() || isPageChanged && "virtual" !== this.option("scrolling.mode");
    if (this.isCellOrBatchEditMode()) {
      if (needResetIndexes) {
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
    } else {
      super._refreshCore(params);
    }
  }
  _allowRowAdding(params) {
    if (this.isBatchEditMode()) {
      return true;
    }
    return super._allowRowAdding(params);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    const dataController2 = this._dataController;
    if (this.isBatchEditMode()) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, rowIndex]
      });
      return new Deferred().resolve();
    }
    return super._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (this.isCellOrBatchEditMode()) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      super._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
    }
  }
  _isDefaultButtonVisible(button, options2) {
    if (this.isCellOrBatchEditMode()) {
      const isBatchMode = this.isBatchEditMode();
      switch (button.name) {
        case "save":
        case "cancel":
        case "edit":
          return false;
        case "delete":
          return super._isDefaultButtonVisible(button, options2) && (!isBatchMode || !options2.row.removed);
        case "undelete":
          return isBatchMode && this.allowDeleting(options2) && options2.row.removed;
        default:
          return super._isDefaultButtonVisible(button, options2);
      }
    }
    return super._isDefaultButtonVisible(button, options2);
  }
  _isRowDeleteAllowed() {
    const callBaseResult = super._isRowDeleteAllowed();
    return callBaseResult || this.isBatchEditMode();
  }
  _beforeEndSaving(changes) {
    if (this.isCellEditMode()) {
      var _changes$;
      if ("update" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {
        super._beforeEndSaving(changes);
      }
    } else {
      if (this.isBatchEditMode()) {
        this._resetModifiedClassCells(changes);
      }
      super._beforeEndSaving(changes);
    }
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = super.prepareEditButtons(headerPanel8);
    const needEditingButtons = editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting;
    if (needEditingButtons && this.isBatchEditMode()) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "save", "saveEditData", 21));
      buttonItems.push(this.prepareButtonItem(headerPanel8, "revert", "cancelEditData", 22));
    }
    return buttonItems;
  }
  _saveEditDataInner() {
    var _deferred;
    const editRow = this._dataController.getVisibleRows()[this.getEditRowIndex()];
    const editColumn = this._getEditColumn();
    const showEditorAlways = null === editColumn || void 0 === editColumn ? void 0 : editColumn.showEditorAlways;
    const isUpdateInCellMode = this.isCellEditMode() && !(null !== editRow && void 0 !== editRow && editRow.isNewRow);
    let deferred;
    if (isUpdateInCellMode && showEditorAlways) {
      deferred = new Deferred();
      this.addDeferred(deferred);
    }
    return super._saveEditDataInner().always(null === (_deferred = deferred) || void 0 === _deferred ? void 0 : _deferred.resolve);
  }
  _applyChange(options2, params, forceUpdateRow) {
    const isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
    const {
      showEditorAlways
    } = options2.column;
    const isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
    const focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex);
    if (focusPreviousEditingCell) {
      this._focusEditingCell();
      this._updateEditRow(options2.row, true, isCustomSetCellValue);
      return;
    }
    return super._applyChange(options2, params, forceUpdateRow);
  }
  _applyChangeCore(options2, forceUpdateRow) {
    const {
      showEditorAlways
    } = options2.column;
    const isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
    if (showEditorAlways && !forceUpdateRow) {
      if (isUpdateInCellMode) {
        this._setEditRowKey(options2.row.key, true);
        this._setEditColumnNameByIndex(options2.columnIndex, true);
        return this.saveEditData();
      }
      if (this.isBatchEditMode()) {
        forceUpdateRow = this._needUpdateRow(options2.column);
        return super._applyChangeCore(options2, forceUpdateRow);
      }
    }
    return super._applyChangeCore(options2, forceUpdateRow);
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    if (this.isBatchEditMode() && type2 === DATA_EDIT_DATA_REMOVE_TYPE) {
      item.data = createObjectWithChanges(item.data, data17);
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (this.isBatchEditMode() && !processIfBatch) {
      return;
    }
    return super._processRemoveCore(changes, editIndex, processIfBatch);
  }
  _processRemoveIfError(changes, editIndex) {
    if (this.isBatchEditMode()) {
      return;
    }
    return super._processRemoveIfError(changes, editIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
    super._beforeFocusElementInRow(rowIndex);
    const editRowIndex = rowIndex >= 0 ? rowIndex : 0;
    const columnIndex = this.getFirstEditableColumnIndex();
    columnIndex >= 0 && this.editCell(editRowIndex, columnIndex);
  }
};
var rowsView6 = (Base) => class extends Base {
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    const editingController = this._editingController;
    if (editingController.isCellOrBatchEditMode() && this.option("editing.allowUpdating")) {
      m_events_engine_default.on($table, addNamespace(m_hold_default.name, "dxDataGridRowsView"), `td:not(.${EDITOR_CELL_CLASS})`, this.createAction((() => {
        if (editingController.isEditing()) {
          editingController.closeEditCell();
        }
      })));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isRowRemoved = !!row.removed;
      if (editingController.isBatchEditMode()) {
        isRowRemoved && $row.addClass(ROW_REMOVED);
      }
    }
    return $row;
  }
};
var editingCellBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender3
    },
    views: {
      rowsView: rowsView6
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_cell_based.js
m_core_default.registerModule("editingCellBased", editingCellBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/validating/m_validating.js
var INSERT_INDEX2 = "__DX_INSERT_INDEX__";
var EDIT_MODE_ROW2 = "row";
var EDIT_MODE_BATCH2 = "batch";
var EDIT_MODE_CELL2 = "cell";
var FORM_BASED_MODES = ["popup", "form"];
var VALIDATION_STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var validationResultIsValid = function(result2) {
  return isDefined(result2) && "cancel" !== result2;
};
var cellValueShouldBeValidated = function(value2, rowOptions) {
  return void 0 !== value2 || void 0 === value2 && rowOptions && !rowOptions.isNewRow;
};
var ValidatingController = class extends m_modules_default.Controller {
  constructor() {
    super(...arguments);
    this._isValidationInProgress = false;
    this._disableApplyValidationResults = false;
  }
  init() {
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._columnsController = this.getController("columns");
    this.createAction("onRowValidating");
    if (!this._validationState) {
      this.initValidationState();
    }
  }
  initValidationState() {
    this._validationState = [];
    this._validationStateCache = {};
  }
  _rowIsValidated(change) {
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    return !!validationData && !!validationData.validated;
  }
  _getValidationData(key, create2) {
    const keyHash = getKeyHash(key);
    const isObjectKeyHash = isObject(keyHash);
    let validationData;
    if (isObjectKeyHash) {
      validationData = this._validationState.filter(((data17) => equalByValue(data17.key, key)))[0];
    } else {
      validationData = this._validationStateCache[keyHash];
    }
    if (!validationData && create2) {
      validationData = {
        key,
        isValid: true
      };
      this._validationState.push(validationData);
      if (!isObjectKeyHash) {
        this._validationStateCache[keyHash] = validationData;
      }
    }
    return validationData;
  }
  _getBrokenRules(validationData, validationResults) {
    let brokenRules;
    if (validationResults) {
      brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule];
    } else {
      brokenRules = validationData.brokenRules || [];
    }
    return brokenRules;
  }
  _rowValidating(validationData, validationResults) {
    const deferred = new Deferred();
    const change = this._editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
    const brokenRules = this._getBrokenRules(validationData, validationResults);
    const isValid = validationResults ? validationResults.isValid : validationData.isValid;
    const parameters = {
      brokenRules,
      isValid,
      key: change.key,
      newData: change.data,
      oldData: this._editingController._getOldData(change.key),
      promise: null,
      errorText: this.getHiddenValidatorsErrorText(brokenRules)
    };
    this.executeAction("onRowValidating", parameters);
    when(fromPromise(parameters.promise)).always((() => {
      validationData.isValid = parameters.isValid;
      validationData.errorText = parameters.errorText;
      deferred.resolve(parameters);
    }));
    return deferred.promise();
  }
  getHiddenValidatorsErrorText(brokenRules) {
    const brokenRulesMessages = [];
    each(brokenRules, ((_, brokenRule) => {
      const {
        column
      } = brokenRule;
      const isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;
      const isVisibleColumn2 = column && column.visible;
      if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn2 || isGroupExpandColumn)) {
        brokenRulesMessages.push(brokenRule.message);
      }
    }));
    return brokenRulesMessages.join(", ");
  }
  validate(isFull) {
    let isValid = true;
    const editingController = this._editingController;
    const deferred = new Deferred();
    const completeList = [];
    const editMode = editingController.getEditMode();
    isFull = isFull || editMode === EDIT_MODE_ROW2;
    if (this._isValidationInProgress) {
      return deferred.resolve(false).promise();
    }
    this._isValidationInProgress = true;
    if (isFull) {
      editingController.addDeferred(deferred);
      const changes = editingController.getChanges();
      each(changes, ((index, _ref) => {
        let {
          type: type2,
          key
        } = _ref;
        if ("remove" !== type2) {
          const validationData = this._getValidationData(key, true);
          const validationResult = this.validateGroup(validationData);
          completeList.push(validationResult);
          validationResult.done(((validationResult2) => {
            validationData.validated = true;
            isValid = isValid && validationResult2.isValid;
          }));
        }
      }));
    } else if (this._currentCellValidator) {
      const validationResult = this.validateGroup(this._currentCellValidator._findGroup());
      completeList.push(validationResult);
      validationResult.done(((validationResult2) => {
        isValid = validationResult2.isValid;
      }));
    }
    when(...completeList).done((() => {
      this._isValidationInProgress = false;
      deferred.resolve(isValid);
    }));
    return deferred.promise();
  }
  validateGroup(validationData) {
    var _validationResult;
    const result2 = new Deferred();
    const validateGroup = validationData && validation_engine_default.getGroupConfig(validationData);
    let validationResult;
    if (null !== validateGroup && void 0 !== validateGroup && validateGroup.validators.length) {
      this.resetRowValidationResults(validationData);
      validationResult = validation_engine_default.validateGroup(validationData);
    }
    when((null === (_validationResult = validationResult) || void 0 === _validationResult ? void 0 : _validationResult.complete) || validationResult).done(((validationResult2) => {
      when(this._rowValidating(validationData, validationResult2)).done(result2.resolve);
    }));
    return result2.promise();
  }
  isRowDataModified(change) {
    return !isEmptyObject(change.data);
  }
  updateValidationState(change) {
    const editMode = this._editingController.getEditMode();
    const {
      key
    } = change;
    const validationData = this._getValidationData(key, true);
    if (!FORM_BASED_MODES.includes(editMode)) {
      if ("insert" === change.type && !this.isRowDataModified(change)) {
        validationData.isValid = true;
        return;
      }
      this.setDisableApplyValidationResults(true);
      const groupConfig = validation_engine_default.getGroupConfig(validationData);
      if (groupConfig) {
        const validationResult = validation_engine_default.validateGroup(validationData);
        when(validationResult.complete || validationResult).done(((validationResult2) => {
          validationData.isValid = validationResult2.isValid;
          validationData.brokenRules = validationResult2.brokenRules;
        }));
      } else if (!validationData.brokenRules || !validationData.brokenRules.length) {
        validationData.isValid = true;
      }
      this.setDisableApplyValidationResults(false);
    } else {
      validationData.isValid = true;
    }
  }
  setValidator(validator) {
    this._currentCellValidator = validator;
  }
  renderCellPendingIndicator($container) {
    let $indicator = $container.find(".dx-pending-indicator");
    if (!$indicator.length) {
      const $indicatorContainer = $container;
      $indicator = renderer_default("<div>").appendTo($indicatorContainer).addClass("dx-pending-indicator");
      this._createComponent($indicator, load_indicator_default);
      $container.addClass("dx-validation-pending");
    }
  }
  disposeCellPendingIndicator($container) {
    const $indicator = $container.find(".dx-pending-indicator");
    if ($indicator.length) {
      const indicator = load_indicator_default.getInstance($indicator);
      if (indicator) {
        indicator.dispose();
        indicator.$element().remove();
      }
      $container.removeClass("dx-validation-pending");
    }
  }
  validationStatusChanged(result2) {
    const {
      validator
    } = result2;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    this.updateCellValidationResult({
      rowKey: validationGroup.key,
      columnIndex: column.index,
      validationResult: result2
    });
  }
  validatorInitialized(arg) {
    arg.component.on("validating", this.validationStatusChanged.bind(this));
    arg.component.on("validated", this.validationStatusChanged.bind(this));
  }
  validatorDisposing(arg) {
    const validator = arg.component;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    const result2 = this.getCellValidationResult({
      rowKey: null === validationGroup || void 0 === validationGroup ? void 0 : validationGroup.key,
      columnIndex: column.index
    });
    if (validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.pending) {
      this.cancelCellValidationResult({
        change: validationGroup,
        columnIndex: column.index
      });
    }
  }
  applyValidationResult($container, result2) {
    const {
      validator
    } = result2;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    result2.brokenRules && result2.brokenRules.forEach(((rule) => {
      rule.columnIndex = column.index;
      rule.column = column;
    }));
    if ($container) {
      const validationResult = this.getCellValidationResult({
        rowKey: validationGroup.key,
        columnIndex: column.index
      });
      const requestIsDisabled = validationResultIsValid(validationResult) && validationResult.disabledPendingId === result2.id;
      if (this._disableApplyValidationResults || requestIsDisabled) {
        return;
      }
      if (result2.status === VALIDATION_STATUS.invalid) {
        const $focus = $container.find(":focus");
        if (!focused($focus)) {
          m_events_engine_default.trigger($focus, "focus");
          m_events_engine_default.trigger($focus, m_pointer_default.down);
        }
      }
      const editor = !column.editCellTemplate && this._editorFactoryController.getEditorInstance($container);
      if (result2.status === VALIDATION_STATUS.pending) {
        if (editor) {
          editor.option("validationStatus", VALIDATION_STATUS.pending);
        } else {
          this.renderCellPendingIndicator($container);
        }
      } else if (editor) {
        editor.option("validationStatus", VALIDATION_STATUS.valid);
      } else {
        this.disposeCellPendingIndicator($container);
      }
      $container.toggleClass(this.addWidgetPrefix("invalid"), result2.status === VALIDATION_STATUS.invalid);
    }
  }
  _syncInternalEditingData(parameters) {
    var _parameters$row;
    const editingController = this._editingController;
    const change = editingController.getChangeByKey(parameters.key);
    const oldDataFromState = editingController._getOldData(parameters.key);
    const oldData = null === (_parameters$row = parameters.row) || void 0 === _parameters$row ? void 0 : _parameters$row.oldData;
    if (change && oldData && !oldDataFromState) {
      editingController._addInternalData({
        key: parameters.key,
        oldData
      });
    }
  }
  createValidator(parameters, $container) {
    const editingController = this._editingController;
    const {
      column
    } = parameters;
    let {
      showEditorAlways
    } = column;
    if (isDefined(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {
      return;
    }
    const editIndex = editingController.getIndexByKey(parameters.key, editingController.getChanges());
    let needCreateValidator = editIndex > -1;
    if (!needCreateValidator) {
      if (!showEditorAlways) {
        var _this$_columnsControl;
        const visibleColumns = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getVisibleColumns()) || [];
        showEditorAlways = visibleColumns.some(((column2) => column2.showEditorAlways));
      }
      const isEditRow2 = equalByValue(this.option("editing.editRowKey"), parameters.key);
      const isCellOrBatchEditingAllowed = editingController.isCellOrBatchEditMode() && editingController.allowUpdating({
        row: parameters.row
      });
      needCreateValidator = isEditRow2 || isCellOrBatchEditingAllowed && showEditorAlways;
      if (isCellOrBatchEditingAllowed && showEditorAlways) {
        var _parameters$row2;
        editingController._addInternalData({
          key: parameters.key,
          oldData: (null === (_parameters$row2 = parameters.row) || void 0 === _parameters$row2 ? void 0 : _parameters$row2.oldData) ?? parameters.data
        });
      }
    }
    if (needCreateValidator) {
      if ($container && !$container.length) {
        ui_errors_default.log("E1050");
        return;
      }
      this._syncInternalEditingData(parameters);
      const validationData = this._getValidationData(parameters.key, true);
      const getValue = () => {
        const change = editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
        const value2 = column.calculateCellValue((null === change || void 0 === change ? void 0 : change.data) || {});
        return void 0 !== value2 ? value2 : parameters.value;
      };
      const useDefaultValidator = $container && $container.hasClass("dx-widget");
      $container && $container.addClass(this.addWidgetPrefix("validator"));
      const validator = new validator_default($container || renderer_default("<div>"), {
        name: column.caption,
        validationRules: extend(true, [], column.validationRules),
        validationGroup: validationData,
        adapter: useDefaultValidator ? null : {
          getValue,
          applyValidationResults: (result2) => {
            this.applyValidationResult($container, result2);
          }
        },
        dataGetter() {
          const key = null === validationData || void 0 === validationData ? void 0 : validationData.key;
          const change = editingController.getChangeByKey(key);
          const oldData = editingController._getOldData(key);
          return {
            data: createObjectWithChanges(oldData, null === change || void 0 === change ? void 0 : change.data),
            column
          };
        },
        onInitialized: this.validatorInitialized.bind(this),
        onDisposing: this.validatorDisposing.bind(this)
      });
      if (useDefaultValidator) {
        const adapter = validator.option("adapter");
        if (adapter) {
          const originBypass = adapter.bypass;
          const defaultAdapterBypass = () => parameters.row.isNewRow && !this._isValidationInProgress && !editingController.isCellModified(parameters);
          adapter.getValue = getValue;
          adapter.validationRequestsCallbacks = [];
          adapter.bypass = () => originBypass.call(adapter) || defaultAdapterBypass();
        }
      }
      return validator;
    }
    return;
  }
  setDisableApplyValidationResults(flag) {
    this._disableApplyValidationResults = flag;
  }
  getDisableApplyValidationResults() {
    return this._disableApplyValidationResults;
  }
  isCurrentValidatorProcessing(_ref2) {
    let {
      rowKey,
      columnIndex
    } = _ref2;
    return this._currentCellValidator && equalByValue(this._currentCellValidator.option("validationGroup").key, rowKey) && this._currentCellValidator.option("dataGetter")().column.index === columnIndex;
  }
  validateCell(validator) {
    const cellParams = {
      rowKey: validator.option("validationGroup").key,
      columnIndex: validator.option("dataGetter")().column.index,
      validationResult: null
    };
    let validationResult = this.getCellValidationResult(cellParams);
    const stateRestored = validationResultIsValid(validationResult);
    const adapter = validator.option("adapter");
    if (!stateRestored) {
      validationResult = validator.validate();
    } else {
      const currentCellValue = adapter.getValue();
      if (!equalByValue(currentCellValue, validationResult.value)) {
        validationResult = validator.validate();
      }
    }
    const deferred = new Deferred();
    if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {
      this.updateCellValidationResult(cellParams);
      adapter.applyValidationResults(validationResult);
    }
    when(validationResult.complete || validationResult).done(((validationResult2) => {
      stateRestored && adapter.applyValidationResults(validationResult2);
      deferred.resolve(validationResult2);
    }));
    return deferred.promise();
  }
  updateCellValidationResult(_ref3) {
    let {
      rowKey,
      columnIndex,
      validationResult
    } = _ref3;
    const validationData = this._getValidationData(rowKey);
    if (!validationData) {
      return;
    }
    if (!validationData.validationResults) {
      validationData.validationResults = {};
    }
    let result2;
    if (validationResult) {
      result2 = extend({}, validationResult);
      validationData.validationResults[columnIndex] = result2;
      if (validationResult.status === VALIDATION_STATUS.pending) {
        if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
          result2.deferred = new Deferred();
          result2.complete.always((() => {
            result2.deferred.resolve();
          }));
          this._editingController.addDeferred(result2.deferred);
        }
        if (this._disableApplyValidationResults) {
          result2.disabledPendingId = validationResult.id;
          return;
        }
      }
    } else {
      result2 = validationData.validationResults[columnIndex];
    }
    if (result2 && result2.disabledPendingId) {
      delete result2.disabledPendingId;
    }
  }
  getCellValidationResult(_ref4) {
    var _validationData$valid;
    let {
      rowKey,
      columnIndex
    } = _ref4;
    const validationData = this._getValidationData(rowKey, true);
    return null === validationData || void 0 === validationData || null === (_validationData$valid = validationData.validationResults) || void 0 === _validationData$valid ? void 0 : _validationData$valid[columnIndex];
  }
  removeCellValidationResult(_ref5) {
    let {
      change,
      columnIndex
    } = _ref5;
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    if (validationData && validationData.validationResults) {
      this.cancelCellValidationResult({
        change,
        columnIndex
      });
      delete validationData.validationResults[columnIndex];
    }
  }
  cancelCellValidationResult(_ref6) {
    let {
      change,
      columnIndex
    } = _ref6;
    const validationData = this._getValidationData(change.key);
    if (change && validationData.validationResults) {
      const result2 = validationData.validationResults[columnIndex];
      if (result2) {
        result2.deferred && result2.deferred.reject("cancel");
        validationData.validationResults[columnIndex] = "cancel";
      }
    }
  }
  resetRowValidationResults(validationData) {
    if (validationData) {
      validationData.validationResults && delete validationData.validationResults;
      delete validationData.validated;
    }
  }
  isInvalidCell(_ref7) {
    let {
      rowKey,
      columnIndex
    } = _ref7;
    const result2 = this.getCellValidationResult({
      rowKey,
      columnIndex
    });
    return validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.invalid;
  }
  getCellValidator(_ref8) {
    let {
      rowKey,
      columnIndex
    } = _ref8;
    const validationData = this._getValidationData(rowKey);
    const groupConfig = validationData && validation_engine_default.getGroupConfig(validationData);
    const validators = groupConfig && groupConfig.validators;
    return validators && validators.filter(((v) => {
      const {
        column
      } = v.option("dataGetter")();
      return column ? column.index === columnIndex : false;
    }))[0];
  }
  setCellValidationStatus(cellOptions) {
    const validationResult = this.getCellValidationResult({
      rowKey: cellOptions.key,
      columnIndex: cellOptions.column.index
    });
    if (isDefined(validationResult)) {
      cellOptions.validationStatus = "cancel" !== validationResult ? validationResult.status : "cancel";
    } else {
      delete cellOptions.validationStatus;
    }
  }
};
var validatingEditingExtender = (Base) => class extends Base {
  processDataItemTreeListHack(item) {
    super.processDataItem.apply(this, arguments);
  }
  processItemsTreeListHack(items, e) {
    return super.processItems.apply(this, arguments);
  }
  _addChange(changeParams) {
    const change = super._addChange.apply(this, arguments);
    if (change && "remove" !== changeParams.type) {
      this._validatingController.updateValidationState(change);
    }
    return change;
  }
  _handleChangesChange(args) {
    super._handleChangesChange.apply(this, arguments);
    args.value.forEach(((change) => {
      if (void 0 === this._validatingController._getValidationData(change.key)) {
        this._validatingController.updateValidationState(change);
      }
    }));
  }
  _updateRowAndPageIndices() {
    const that = this;
    const startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex();
    let rowIndex = startInsertIndex;
    each(that.getChanges(), ((_, _ref9) => {
      let {
        key,
        type: type2
      } = _ref9;
      const validationData = this._validatingController._getValidationData(key);
      if (validationData && !validationData.isValid && validationData.pageIndex !== that._pageIndex) {
        validationData.pageIndex = that._pageIndex;
        if ("insert" === type2) {
          validationData.rowIndex = startInsertIndex;
        } else {
          validationData.rowIndex = rowIndex;
        }
        rowIndex++;
      }
    }));
  }
  _getValidationGroupsInForm(detailOptions) {
    const validationData = this._validatingController._getValidationData(detailOptions.key, true);
    return {
      validationGroup: validationData
    };
  }
  _validateEditFormAfterUpdate(row, isCustomSetCellValue) {
    if (isCustomSetCellValue && this._editForm) {
      this._editForm.validate();
    }
    super._validateEditFormAfterUpdate.apply(this, arguments);
  }
  _prepareEditCell(parameters) {
    const {
      column,
      item
    } = parameters;
    const isNotCanceled = super._prepareEditCell(parameters);
    const key = !item.isNewRow ? item.key : void 0;
    if (isNotCanceled && column.showEditorAlways) {
      this._validatingController.updateValidationState({
        key
      });
    }
    return isNotCanceled;
  }
  processItems(items, changeType) {
    const changes = this.getChanges();
    const getIndexByChange = (change, items2) => {
      let index = -1;
      const isInsert = "insert" === change.type;
      const {
        key
      } = change;
      each(items2, ((i, item) => {
        if (equalByValue(key, isInsert ? item.key : this._dataController.keyOf(item))) {
          index = i;
          return false;
        }
        return;
      }));
      return index;
    };
    items = super.processItems(items, changeType);
    const itemsCount = items.length;
    if (this.getEditMode() === EDIT_MODE_BATCH2 && "prepend" !== changeType && "append" !== changeType) {
      changes.forEach(((change) => {
        const {
          key
        } = change;
        const validationData = this._validatingController._getValidationData(key);
        if (validationData && change.type && validationData.pageIndex === this._pageIndex && (null === change || void 0 === change ? void 0 : change.pageIndex) !== this._pageIndex) {
          !(function(change2, validationData2) {
            const data17 = {
              key: change2.key
            };
            const index = getIndexByChange(change2, items);
            if (index >= 0) {
              return;
            }
            validationData2.rowIndex = validationData2.rowIndex > itemsCount ? validationData2.rowIndex % itemsCount : validationData2.rowIndex;
            const {
              rowIndex
            } = validationData2;
            data17[INSERT_INDEX2] = 1;
            items.splice(rowIndex, 0, data17);
          })(change, validationData);
        }
      }));
    }
    return items;
  }
  processDataItem(item) {
    const isInserted = item.data[INSERT_INDEX2];
    const key = isInserted ? item.data.key : item.key;
    const editMode = this.getEditMode();
    if (editMode === EDIT_MODE_BATCH2 && isInserted && key) {
      const changes = this.getChanges();
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const change = changes[editIndex];
        if ("insert" !== change.type) {
          const oldData = this._getOldData(change.key);
          item.data = extend(true, {}, oldData, change.data);
          item.key = key;
        }
      }
    }
    super.processDataItem.apply(this, arguments);
  }
  _createInvisibleColumnValidators(changes) {
    const that = this;
    const columns7 = this._columnsController.getColumns();
    const invisibleColumns = this._columnsController.getInvisibleColumns().filter(((column) => !column.isBand));
    const groupColumns = this._columnsController.getGroupColumns().filter(((column) => !column.showWhenGrouped && -1 === invisibleColumns.indexOf(column)));
    const invisibleColumnValidators = [];
    const isCellVisible = (column, rowKey) => this._dataController.getRowIndexByKey(rowKey) >= 0 && invisibleColumns.indexOf(column) < 0;
    invisibleColumns.push(...groupColumns);
    if (!FORM_BASED_MODES.includes(this.getEditMode())) {
      each(columns7, ((_, column) => {
        changes.forEach(((change) => {
          let data17;
          if (isCellVisible(column, change.key)) {
            return;
          }
          if ("insert" === change.type) {
            data17 = change.data;
          } else if ("update" === change.type) {
            const oldData = that._getOldData(change.key);
            if (!isDefined(oldData)) {
              return;
            }
            data17 = createObjectWithChanges(oldData, change.data);
          }
          if (data17) {
            const validator = this._validatingController.createValidator({
              column,
              key: change.key,
              value: column.calculateCellValue(data17)
            });
            if (validator) {
              invisibleColumnValidators.push(validator);
            }
          }
        }));
      }));
    }
    return function() {
      invisibleColumnValidators.forEach(((validator) => {
        validator.dispose();
      }));
    };
  }
  _beforeSaveEditData(change, editIndex) {
    let result2 = super._beforeSaveEditData.apply(this, arguments);
    const validationData = this._validatingController._getValidationData(null === change || void 0 === change ? void 0 : change.key, true);
    if (change) {
      const isValid = "remove" === change.type || validationData.isValid;
      result2 = result2 || !isValid;
    } else {
      const disposeValidators = this._createInvisibleColumnValidators(this.getChanges());
      result2 = new Deferred();
      this.executeOperation(result2, (() => {
        this._validatingController.validate(true).done(((isFullValid) => {
          disposeValidators();
          this._updateRowAndPageIndices();
          switch (this.getEditMode()) {
            case EDIT_MODE_CELL2:
              if (!isFullValid) {
                this._focusEditingCell();
              }
              break;
            case EDIT_MODE_BATCH2:
              if (!isFullValid) {
                this._resetEditRowKey();
                this._resetEditColumnName();
                this._dataController.updateItems();
              }
          }
          result2.resolve(!isFullValid);
        }));
      }));
    }
    return result2.promise ? result2.promise() : result2;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    const result2 = super._beforeEditCell(rowIndex, columnIndex, item);
    if (this.getEditMode() === EDIT_MODE_CELL2) {
      const $cell = this._rowsView._getCellElement(rowIndex, columnIndex);
      const validator = $cell && $cell.data("dxValidator");
      const rowOptions = $cell && $cell.closest(".dx-row").data("options");
      const value2 = validator && validator.option("adapter").getValue();
      if (validator && cellValueShouldBeValidated(value2, rowOptions)) {
        const deferred = new Deferred();
        when(this._validatingController.validateCell(validator), result2).done(((validationResult, result3) => {
          deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result3);
        }));
        return deferred.promise();
      }
      if (!validator) {
        return result2;
      }
    }
    return false;
  }
  _afterSaveEditData(cancel) {
    let $firstErrorRow;
    const isCellEditMode = this.getEditMode() === EDIT_MODE_CELL2;
    each(this.getChanges(), ((_, change) => {
      const $errorRow = this._showErrorRow(change);
      $firstErrorRow = $firstErrorRow || $errorRow;
    }));
    if ($firstErrorRow) {
      const scrollable = this._rowsView.getScrollable();
      if (scrollable) {
        scrollable.update();
        scrollable.scrollToElement($firstErrorRow);
      }
    }
    if (cancel && isCellEditMode && this._needUpdateRow()) {
      const editRowIndex = this.getEditRowIndex();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [editRowIndex]
      });
      this._focusEditingCell();
    } else if (!cancel) {
      let shouldResetValidationState = true;
      if (isCellEditMode) {
        const columns7 = this._columnsController.getColumns();
        const columnsWithValidatingEditors = columns7.filter(((col) => {
          var _col$validationRules;
          return col.showEditorAlways && (null === (_col$validationRules = col.validationRules) || void 0 === _col$validationRules ? void 0 : _col$validationRules.length) > 0;
        })).length > 0;
        shouldResetValidationState = !columnsWithValidatingEditors;
      }
      if (shouldResetValidationState) {
        this._validatingController.initValidationState();
      }
    }
  }
  _handleDataChanged(args) {
    const validationState = this._validatingController._validationState;
    if ("standard" === this.option("scrolling.mode")) {
      this.resetRowAndPageIndices();
    }
    if ("prepend" === args.changeType) {
      each(validationState, ((_, validationData) => {
        validationData.rowIndex += args.items.length;
      }));
    }
    super._handleDataChanged(args);
  }
  resetRowAndPageIndices() {
    const validationState = this._validatingController._validationState;
    each(validationState, ((_, validationData) => {
      if (validationData.pageIndex !== this._pageIndex) {
        delete validationData.pageIndex;
        delete validationData.rowIndex;
      }
    }));
  }
  _beforeCancelEditData() {
    this._validatingController.initValidationState();
    super._beforeCancelEditData();
  }
  _showErrorRow(change) {
    let $popupContent;
    const items = this._dataController.items();
    const rowIndex = this.getIndexByKey(change.key, items);
    const validationData = this._validatingController._getValidationData(change.key);
    if (!(null !== validationData && void 0 !== validationData && validationData.isValid) && null !== validationData && void 0 !== validationData && validationData.errorText && rowIndex >= 0) {
      $popupContent = this.getPopupContent();
      return this._errorHandlingController && this._errorHandlingController.renderErrorRow(null === validationData || void 0 === validationData ? void 0 : validationData.errorText, rowIndex, $popupContent);
    }
  }
  updateFieldValue(e) {
    const deferred = new Deferred();
    this._validatingController.removeCellValidationResult({
      change: this.getChangeByKey(e.key),
      columnIndex: e.column.index
    });
    super.updateFieldValue.apply(this, arguments).done((() => {
      const currentValidator = this._validatingController.getCellValidator({
        rowKey: e.key,
        columnIndex: e.column.index
      });
      when(currentValidator && this._validatingController.validateCell(currentValidator)).done(((validationResult) => {
        this._editorFactoryController.refocus();
        deferred.resolve(validationResult);
      }));
    }));
    return deferred.promise();
  }
  highlightDataCell($cell, parameters) {
    super.highlightDataCell.apply(this, arguments);
    this._validatingController.setCellValidationStatus(parameters);
    const isEditableCell = !!parameters.setValue;
    const cellModified = this.isCellModified(parameters);
    const isValidated = isDefined(parameters.validationStatus);
    const needValidation = cellModified && parameters.column.setCellValue || isEditableCell && !cellModified && !(parameters.row.isNewRow || !isValidated);
    if (needValidation) {
      const validator = $cell.data("dxValidator");
      if (validator) {
        when(this._validatingController.validateCell(validator)).done((() => {
          this._validatingController.setCellValidationStatus(parameters);
        }));
      }
    }
  }
  getChangeByKey(key) {
    const changes = this.getChanges();
    return changes[m_utils_default.getIndexByKey(key, changes)];
  }
  isCellModified(parameters) {
    const cellModified = super.isCellModified(parameters);
    const change = this.getChangeByKey(parameters.key);
    const isCellInvalid = !!parameters.row && this._validatingController.isInvalidCell({
      rowKey: parameters.key,
      columnIndex: parameters.column.index
    });
    return cellModified || this._validatingController._rowIsValidated(change) && isCellInvalid;
  }
};
var getWidthOfVisibleCells = function(that, element) {
  const rowIndex = renderer_default(element).closest("tr").index();
  const $cellElements = renderer_default(that._rowsView.getRowElement(rowIndex)).first().children().filter(":not(.dx-hidden-cell)");
  return that._rowsView._getWidths($cellElements).reduce(((w1, w2) => w1 + w2), 0);
};
var getBoundaryNonFixedColumnsInfo = function(fixedColumns) {
  let firstNonFixedColumnIndex;
  let lastNonFixedColumnIndex;
  fixedColumns.some(((column, index) => {
    if ("transparent" === column.command) {
      firstNonFixedColumnIndex = 0 === index ? -1 : index;
      lastNonFixedColumnIndex = index === fixedColumns.length - 1 ? -1 : index + column.colspan - 1;
      return true;
    }
    return;
  }));
  return {
    startColumnIndex: firstNonFixedColumnIndex,
    endColumnIndex: lastNonFixedColumnIndex
  };
};
var validatingEditorFactoryExtender = (Base) => class extends Base {
  _showRevertButton($container) {
    var _this$_revertTooltip, _$tooltipElement2;
    let $tooltipElement = null === (_this$_revertTooltip = this._revertTooltip) || void 0 === _this$_revertTooltip ? void 0 : _this$_revertTooltip.$element();
    if (!$container || !$container.length) {
      var _$tooltipElement;
      null === (_$tooltipElement = $tooltipElement) || void 0 === _$tooltipElement || _$tooltipElement.remove();
      this._revertTooltip = void 0;
      return;
    }
    if ($container.find($tooltipElement).length) {
      var _this$_revertTooltip2;
      null === (_this$_revertTooltip2 = this._revertTooltip) || void 0 === _this$_revertTooltip2 || _this$_revertTooltip2.repaint();
      return;
    }
    const $overlayContainer = this.getRevertButtonContainer($container);
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    null === (_$tooltipElement2 = $tooltipElement) || void 0 === _$tooltipElement2 || _$tooltipElement2.remove();
    $tooltipElement = renderer_default("<div>").addClass(revertTooltipClass).appendTo($container);
    const tooltipOptions = {
      animation: null,
      visible: true,
      width: "auto",
      height: "auto",
      shading: false,
      container: $overlayContainer,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        class: revertTooltipClass
      },
      contentTemplate: () => {
        const $buttonElement = renderer_default("<div>").addClass("dx-revert-button");
        const buttonOptions = {
          icon: "revert",
          hint: this.option("editing.texts.validationCancelChanges"),
          elementAttr: {
            id: "dxRevertButton",
            "aria-label": message_default.format("dxDataGrid-ariaRevertButton")
          },
          onClick: () => {
            this._editingController.cancelEditData();
          }
        };
        return new button_default2($buttonElement, buttonOptions).$element();
      },
      position: {
        my: "left top",
        at: "right top",
        offset: "1 0",
        collision: "flip",
        boundaryOffset: "0 0",
        boundary: this._rowsView.element(),
        of: $container
      },
      onPositioned: this.overlayPositionedHandler.bind(this)
    };
    this._revertTooltip = new ui_overlay_default($tooltipElement, tooltipOptions);
  }
  _hideFixedGroupCell($cell, overlayOptions) {
    var _this$_rowsView, _this$_rowsView$isFix;
    let $nextFixedRowElement;
    let $groupCellElement;
    const isFixedColumns = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || null === (_this$_rowsView$isFix = _this$_rowsView.isFixedColumns) || void 0 === _this$_rowsView$isFix ? void 0 : _this$_rowsView$isFix.call(_this$_rowsView);
    const isFormOrPopupEditMode = this._editingController.isFormOrPopupEditMode();
    if (isFixedColumns && !isFormOrPopupEditMode) {
      const nextRowOptions = $cell.closest(".dx-row").next().data("options");
      if (nextRowOptions && "group" === nextRowOptions.rowType) {
        $nextFixedRowElement = renderer_default(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();
        $groupCellElement = $nextFixedRowElement.find(".dx-group-cell");
        if ($groupCellElement.length && "hidden" !== $groupCellElement.get(0).style.visibility) {
          $groupCellElement.css("visibility", "hidden");
          overlayOptions.onDisposing = function() {
            $groupCellElement.css("visibility", "");
          };
        }
      }
    }
  }
  _showValidationMessage($cell, messages, alignment) {
    const editorPopup = $cell.find(".dx-dropdowneditor-overlay").data("dxPopup");
    const isOverlayVisible = editorPopup && editorPopup.option("visible");
    const myPosition = isOverlayVisible ? "top right" : `top ${alignment}`;
    const atPosition = isOverlayVisible ? "top left" : `bottom ${alignment}`;
    const $overlayContainer = this.getValidationMessageContainer($cell);
    let errorMessageText = "";
    messages && messages.forEach(((message) => {
      errorMessageText += (errorMessageText.length ? "<br/>" : "") + encodeHtml(message);
    }));
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    this._rowsView.element().find(`.${invalidMessageClass}`).remove();
    const $overlayElement = renderer_default("<div>").addClass("dx-invalid-message").addClass("dx-invalid-message-always").addClass(invalidMessageClass).html(errorMessageText).appendTo($cell);
    const overlayOptions = {
      container: $overlayContainer,
      shading: false,
      width: "auto",
      height: "auto",
      visible: true,
      animation: false,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        id: "dxInvalidMessage",
        class: `dx-invalid-message dx-invalid-message-always ${invalidMessageClass}`
      },
      position: {
        collision: "flip",
        boundary: this._rowsView.element(),
        boundaryOffset: "0 0",
        offset: {
          x: 0,
          y: !isOverlayVisible && browser_default.mozilla ? -1 : 0
        },
        my: myPosition,
        at: atPosition,
        of: $cell
      },
      onPositioned: (e) => {
        this.overlayPositionedHandler(e, isOverlayVisible);
        this._shiftValidationMessageIfNeed(e.component.$content(), $cell);
      }
    };
    this._hideFixedGroupCell($cell, overlayOptions);
    new ui_overlay_default($overlayElement, overlayOptions);
  }
  getValidationMessages() {
    var _this$_rowsView$eleme;
    return null === (_this$_rowsView$eleme = this._rowsView.element()) || void 0 === _this$_rowsView$eleme ? void 0 : _this$_rowsView$eleme.find(this._getValidationMessagesSelector());
  }
  getRevertButton() {
    var _this$_revertTooltip3;
    return renderer_default(null === (_this$_revertTooltip3 = this._revertTooltip) || void 0 === _this$_revertTooltip3 ? void 0 : _this$_revertTooltip3.element());
  }
  _hideValidationMessage() {
    var _this$_rowsView$eleme2;
    const validationMessages = null === (_this$_rowsView$eleme2 = this._rowsView.element()) || void 0 === _this$_rowsView$eleme2 ? void 0 : _this$_rowsView$eleme2.find(this._getValidationMessagesSelector());
    null === validationMessages || void 0 === validationMessages || validationMessages.remove();
  }
  _normalizeValidationMessagePositionAndMaxWidth(options2, isRevertButton, isOverlayVisible) {
    const fixedColumns = this._columnsController.getFixedColumns();
    if (!fixedColumns || !fixedColumns.length) {
      return;
    }
    let position2;
    const visibleTableWidth = !isRevertButton && getWidthOfVisibleCells(this, options2.element);
    const $overlayContentElement = options2.component.$content();
    const validationMessageWidth = getOuterWidth($overlayContentElement, true);
    const needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;
    const columnIndex = this._rowsView.getCellIndex(renderer_default(options2.element).closest("td"));
    const boundaryNonFixedColumnsInfo = getBoundaryNonFixedColumnsInfo(fixedColumns);
    if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {
      position2 = {
        collision: "none flip",
        my: "top left",
        at: isOverlayVisible ? "top right" : "bottom left"
      };
    } else if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {
      position2 = {
        collision: "none flip",
        my: "top right",
        at: isRevertButton || isOverlayVisible ? "top left" : "bottom right"
      };
      if (isRevertButton) {
        position2.offset = "-1 0";
      }
    }
    return position2 && {
      position: position2,
      maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0
    };
  }
  _shiftValidationMessageIfNeed($content, $cell) {
    const $revertContent = this._revertTooltip && this._revertTooltip.$content();
    if (!$revertContent) {
      return;
    }
    const contentOffset = $content.offset();
    const revertContentOffset = $revertContent.offset();
    if (contentOffset.top === revertContentOffset.top && contentOffset.left + getWidth($content) > revertContentOffset.left) {
      const left = getWidth($revertContent) + 2;
      $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left);
    }
  }
  getOverlayBaseZIndex() {
    return ui_overlay_default.baseZIndex();
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    if (!e.component.__skipPositionProcessing) {
      const isRevertButton = renderer_default(e.element).hasClass(this.addWidgetPrefix("revert-tooltip"));
      const needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();
      const normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);
      e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);
      if (normalizedPosition) {
        e.component.option(normalizedPosition);
      } else if (needRepaint) {
        e.component.repaint();
      }
    }
  }
  _getRevertTooltipsSelector() {
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    return `.dx-editor-cell .${revertTooltipClass}`;
  }
  _getValidationMessagesSelector() {
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    return `.dx-editor-cell .${invalidMessageClass}, .dx-cell-modified .${invalidMessageClass}`;
  }
  loseFocus(skipValidator) {
    if (!skipValidator) {
      this._validatingController.setValidator(null);
    }
    super.loseFocus();
  }
  updateCellState($element, validationResult, isHideBorder) {
    var _change$data;
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const $cell = null !== $focus && void 0 !== $focus && $focus.is("td") ? $focus : null;
    const rowOptions = null === $focus || void 0 === $focus ? void 0 : $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    const column = $cell && this._columnsController.getVisibleColumns()[$cell.index()];
    const isCellModified = void 0 !== (null === change || void 0 === change || null === (_change$data = change.data) || void 0 === _change$data ? void 0 : _change$data[null === column || void 0 === column ? void 0 : column.name]) && !this._editingController.isSaving();
    const validationDescriptionValues = [];
    if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
      if ((null === validationResult || void 0 === validationResult ? void 0 : validationResult.status) === VALIDATION_STATUS.invalid || isCellModified) {
        this._showRevertButton($focus);
        validationDescriptionValues.push("dxRevertButton");
      } else {
        this._revertTooltip && this._revertTooltip.$element().remove();
      }
    }
    const showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;
    if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {
      const errorMessages = [];
      validationResult.brokenRules.forEach(((rule) => {
        if (rule.message) {
          errorMessages.push(rule.message);
        }
      }));
      if (errorMessages.length) {
        this._showValidationMessage($focus, errorMessages, column.alignment || "left");
        validationDescriptionValues.push("dxInvalidMessage");
      }
    }
    this._updateAriaValidationAttributes($focus, validationDescriptionValues);
    !isHideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();
  }
  _updateAriaValidationAttributes($focus, inputDescriptionValues) {
    if (0 === inputDescriptionValues.length) {
      return;
    }
    const editMode = this._editingController.getEditMode();
    const shouldSetValidationAriaAttributes = [EDIT_MODE_CELL2, EDIT_MODE_BATCH2, EDIT_MODE_ROW2].includes(editMode);
    if (shouldSetValidationAriaAttributes) {
      const $focusElement = this._getCurrentFocusElement($focus);
      $focusElement.attr("aria-labelledby", inputDescriptionValues.join(" "));
      $focusElement.attr("aria-invalid", true);
    }
  }
  _getCurrentFocusElement($focus) {
    if (this._editingController.isEditing()) {
      return $focus.find(EDITORS_INPUT_SELECTOR).first();
    }
    return $focus;
  }
  focus($element, isHideBorder) {
    if (!arguments.length) {
      return super.focus();
    }
    this._hideValidationMessage();
    if (null !== $element && void 0 !== $element && $element.hasClass("dx-row") || null !== $element && void 0 !== $element && $element.hasClass("dx-master-detail-cell")) {
      return super.focus($element, isHideBorder);
    }
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const validator = $focus && ($focus.data("dxValidator") || $element.find(`.${this.addWidgetPrefix("validator")}`).eq(0).data("dxValidator"));
    const rowOptions = $focus && $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    let validationResult;
    if (validator) {
      this._validatingController.setValidator(validator);
      const value2 = validator.option("adapter").getValue();
      if (cellValueShouldBeValidated(value2, rowOptions) || this._validatingController._rowIsValidated(change)) {
        this._editingController.waitForDeferredOperations().done((() => {
          const isDetached = !this._rowsView.isElementInside($element);
          if (isDetached) {
            return;
          }
          when(this._validatingController.validateCell(validator)).done(((result2) => {
            validationResult = result2;
            const {
              column
            } = validationResult.validator.option("dataGetter")();
            if (change && column && !this._validatingController.isCurrentValidatorProcessing({
              rowKey: change.key,
              columnIndex: column.index
            })) {
              return;
            }
            if (!isFluent(current()) && validationResult.status === VALIDATION_STATUS.invalid) {
              isHideBorder = true;
            }
            this.updateCellState($element, validationResult, isHideBorder);
            super.focus.call(this, $element, isHideBorder);
          }));
        }));
        return super.focus($element, isHideBorder);
      }
    }
    this.updateCellState($element, validationResult, isHideBorder);
    return super.focus($element, isHideBorder);
  }
  getEditorInstance($container) {
    const $editor = $container.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
  getValidationMessageContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getRevertButtonContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`).parent();
  }
  hasOverlayElements() {
    const $validationMessageElements = this.getValidationMessages();
    const $revertButtonElement = this.getRevertButton();
    return super.hasOverlayElements() || !!(null !== $validationMessageElements && void 0 !== $validationMessageElements && $validationMessageElements.length) || !!(null !== $revertButtonElement && void 0 !== $revertButtonElement && $revertButtonElement.length);
  }
};
var validatingDataControllerExtender = (Base) => class extends Base {
  _getValidationStatus(validationResult) {
    const validationStatus = validationResultIsValid(validationResult) ? validationResult.status : validationResult;
    return validationStatus || VALIDATION_STATUS.valid;
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    var _oldRow$cells, _cell$column$validati;
    const cell = null === (_oldRow$cells = oldRow.cells) || void 0 === _oldRow$cells ? void 0 : _oldRow$cells[columnIndex];
    const oldValidationStatus = this._getValidationStatus({
      status: null === cell || void 0 === cell ? void 0 : cell.validationStatus
    });
    const validationResult = this._validatingController.getCellValidationResult({
      rowKey: oldRow.key,
      columnIndex
    });
    const validationData = this._validatingController._getValidationData(oldRow.key);
    const newValidationStatus = this._getValidationStatus(validationResult);
    const rowIsModified = JSON.stringify(newRow.modifiedValues) !== JSON.stringify(oldRow.modifiedValues);
    const validationStatusChanged = oldValidationStatus !== newValidationStatus && rowIsModified;
    const cellIsMarkedAsInvalid = renderer_default(null === cell || void 0 === cell ? void 0 : cell.cellElement).hasClass(this.addWidgetPrefix("invalid"));
    const hasValidationRules = null === cell || void 0 === cell || null === (_cell$column$validati = cell.column.validationRules) || void 0 === _cell$column$validati ? void 0 : _cell$column$validati.length;
    const rowEditStateChanged = oldRow.isEditing !== newRow.isEditing && hasValidationRules;
    const cellValidationStateChanged = validationStatusChanged || validationData.isValid && cellIsMarkedAsInvalid;
    if (rowEditStateChanged || cellValidationStateChanged) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
};
var validatingRowsViewExtender = (Base) => class extends Base {
  updateFreeSpaceRowHeight($table) {
    const that = this;
    let $rowElements;
    let $freeSpaceRowElement;
    let $freeSpaceRowElements;
    const $element = that.element();
    const $tooltipContent = $element && $element.find(`.${that.addWidgetPrefix("invalid-message")} .dx-overlay-content`);
    super.updateFreeSpaceRowHeight($table);
    if ($tooltipContent && $tooltipContent.length) {
      $rowElements = that._getRowElements().filter(":visible");
      $freeSpaceRowElements = that._getFreeSpaceRowElements($table);
      $freeSpaceRowElement = $freeSpaceRowElements.first();
      const rowElementsHasFocusInside = $rowElements.find(":focus").length > 0;
      if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || getOuterHeight($tooltipContent) > getOuterHeight($freeSpaceRowElement)) && rowElementsHasFocusInside) {
        $freeSpaceRowElements.show();
        setHeight($freeSpaceRowElements, getOuterHeight($tooltipContent));
        return true;
      }
    }
    return;
  }
  _formItemPrepared(cellOptions, $container) {
    super._formItemPrepared.apply(this, arguments);
    deferUpdate((() => {
      const $editor = $container.find(".dx-widget").first();
      const isEditorDisposed = $editor.length && !$editor.children().length;
      if (!isEditorDisposed) {
        this._validatingController.createValidator(cellOptions, $editor);
      }
    }));
  }
  _cellPrepared($cell, parameters) {
    if (!this._editingController.isFormOrPopupEditMode()) {
      this._validatingController.createValidator(parameters, $cell);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _restoreErrorRow(contentTable) {
    this._editingController && this._editingController.hasChanges() && this._getRowElements(contentTable).each(((_, item) => {
      const rowOptions = renderer_default(item).data("options");
      if (rowOptions) {
        const change = this._editingController.getChangeByKey(rowOptions.key);
        change && this._editingController._showErrorRow(change);
      }
    }));
  }
};
var validatingModule = {
  defaultOptions: () => ({
    editing: {
      texts: {
        validationCancelChanges: message_default.format("dxDataGrid-validationCancelChanges")
      }
    }
  }),
  controllers: {
    validating: ValidatingController
  },
  extenders: {
    controllers: {
      editing: validatingEditingExtender,
      editorFactory: validatingEditorFactoryExtender,
      data: validatingDataControllerExtender
    },
    views: {
      rowsView: validatingRowsViewExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/validating.js
m_core_default.registerModule("validating", validatingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_data_loader/m_virtual_data_loader.js
var LEGACY_SCROLLING_MODE = "scrolling.legacyMode";
var needTwoPagesLoading = (that) => that.option("scrolling.loadTwoPagesOnStart") || that._controller.isVirtual() || that._controller.getViewportItemIndex() > 0;
var getBeginPageIndex = (that) => that._cache.length ? that._cache[0].pageIndex : -1;
var getEndPageIndex = (that) => that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1;
var fireChanged = (that, changed, args) => {
  that._isChangedFiring = true;
  changed(args);
  that._isChangedFiring = false;
};
var processDelayChanged = (that, changed, args) => {
  if (that._isDelayChanged) {
    that._isDelayChanged = false;
    fireChanged(that, changed, args);
    return true;
  }
};
var getViewportPageCount = (that) => {
  const pageSize = that._dataOptions.pageSize();
  const preventPreload = that.option("scrolling.preventPreload");
  if (preventPreload) {
    return 0;
  }
  let realViewportSize = that._controller.viewportSize();
  if (that._controller.isVirtualMode() && that.option("scrolling.removeInvisiblePages")) {
    realViewportSize = 0;
    const viewportSize = that._controller.viewportSize() * that._controller.viewportItemSize();
    let offset = that._controller.getContentOffset();
    const position2 = that._controller.getViewportPosition();
    const virtualItemsCount = that._controller.virtualItemsCount();
    const totalItemsCount = that._dataOptions.totalItemsCount();
    for (let itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
      if (offset >= position2 + viewportSize) {
        break;
      }
      const itemSize = that._controller.getItemSizes()[itemIndex] || that._controller.viewportItemSize();
      offset += itemSize;
      if (offset >= position2) {
        realViewportSize++;
      }
    }
  }
  return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1;
};
var getPreloadPageCount = (that, previous) => {
  const preloadEnabled = that.option("scrolling.preloadEnabled");
  let pageCount = getViewportPageCount(that);
  const isAppendMode3 = that._controller.isAppendMode();
  if (pageCount) {
    if (previous) {
      pageCount = preloadEnabled ? 1 : 0;
    } else {
      if (preloadEnabled) {
        pageCount++;
      }
      if (isAppendMode3 || !needTwoPagesLoading(that)) {
        pageCount--;
      }
    }
  }
  return pageCount;
};
var getPageIndexForLoad = (that) => {
  let result2 = -1;
  const beginPageIndex = getBeginPageIndex(that);
  const dataOptions = that._dataOptions;
  if (beginPageIndex < 0) {
    result2 = that._pageIndex;
  } else if (!that._cache[that._pageIndex - beginPageIndex]) {
    result2 = that._pageIndex;
  } else if (beginPageIndex >= 0 && that._controller.viewportSize() >= 0) {
    if (beginPageIndex > 0) {
      const needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataOptions.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
      const needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
      if (needToLoadPrevPage) {
        result2 = beginPageIndex - 1;
      }
    }
    if (result2 < 0) {
      const needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
      if (needToLoadNextPage) {
        result2 = beginPageIndex + that._cache.length;
      }
    }
  }
  if (that._loadingPageIndexes[result2]) {
    result2 = -1;
  }
  return result2;
};
var loadCore = (that, pageIndex) => {
  const dataOptions = that._dataOptions;
  if (pageIndex === that.pageIndex() || !dataOptions.isLoading() && pageIndex < dataOptions.pageCount() || !dataOptions.hasKnownLastPage() && pageIndex === dataOptions.pageCount()) {
    dataOptions.pageIndex(pageIndex);
    that._loadingPageIndexes[pageIndex] = true;
    return when(dataOptions.load()).always((() => {
      that._loadingPageIndexes[pageIndex] = false;
    }));
  }
};
var processChanged = (that, changed, changeType, isDelayChanged, removeCacheItem) => {
  const dataOptions = that._dataOptions;
  const items = dataOptions.items().slice();
  let change = isObject(changeType) ? changeType : void 0;
  const isPrepend = "prepend" === changeType;
  const viewportItems = dataOptions.viewportItems();
  if (changeType && isString(changeType) && !that._isDelayChanged) {
    change = {
      changeType,
      items
    };
    if (removeCacheItem) {
      change.removeCount = removeCacheItem.itemsCount;
      if (change.removeCount && dataOptions.correctCount) {
        change.removeCount = dataOptions.correctCount(viewportItems, change.removeCount, isPrepend);
      }
    }
  }
  let removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
  if (removeItemCount && dataOptions.correctCount) {
    removeItemCount = dataOptions.correctCount(viewportItems, removeItemCount, isPrepend);
  }
  if ("append" === changeType) {
    viewportItems.push.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(0, removeItemCount);
    }
  } else if (isPrepend) {
    viewportItems.unshift.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(-removeItemCount);
    }
  } else {
    that._dataOptions.viewportItems(items);
  }
  dataOptions.updateLoading();
  that._lastPageIndex = that.pageIndex();
  that._isDelayChanged = isDelayChanged;
  if (!isDelayChanged) {
    fireChanged(that, changed, change);
  }
};
var VirtualDataLoader = class {
  constructor(controller, dataOptions) {
    this._dataOptions = dataOptions;
    this._controller = controller;
    this._pageIndex = this._lastPageIndex = dataOptions.pageIndex();
    this._cache = [];
    this._loadingPageIndexes = {};
  }
  option() {
    return this._controller.option.apply(this._controller, arguments);
  }
  viewportItemIndexChanged(itemIndex) {
    const pageSize = this._dataOptions.pageSize();
    const pageCount = this._dataOptions.pageCount();
    const virtualMode = this._controller.isVirtualMode();
    const appendMode = this._controller.isAppendMode();
    const totalItemsCount = this._dataOptions.totalItemsCount();
    let newPageIndex;
    if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
      const viewportSize = this._controller.viewportSize();
      if (viewportSize && itemIndex + viewportSize >= totalItemsCount && !this._controller.isVirtual()) {
        if (this._dataOptions.hasKnownLastPage()) {
          newPageIndex = pageCount - 1;
          const lastPageSize = totalItemsCount % pageSize;
          if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < viewportSize) {
            newPageIndex--;
          }
        } else {
          newPageIndex = pageCount;
        }
      } else {
        newPageIndex = Math.floor(itemIndex / pageSize);
        const maxPageIndex = pageCount - 1;
        newPageIndex = Math.max(newPageIndex, 0);
        newPageIndex = Math.min(newPageIndex, maxPageIndex);
      }
      this.pageIndex(newPageIndex);
      return this.load();
    }
  }
  pageIndex(pageIndex) {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE) && (isVirtualMode3 || isAppendMode3)) {
      if (void 0 !== pageIndex) {
        this._pageIndex = pageIndex;
      }
      return this._pageIndex;
    }
    return this._dataOptions.pageIndex(pageIndex);
  }
  beginPageIndex(defaultPageIndex) {
    let index = getBeginPageIndex(this);
    if (index < 0) {
      index = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex();
    }
    return index;
  }
  endPageIndex() {
    const endPageIndex = getEndPageIndex(this);
    return endPageIndex > 0 ? endPageIndex : this._lastPageIndex;
  }
  pageSize() {
    return this._dataOptions.pageSize();
  }
  load() {
    const dataOptions = this._dataOptions;
    let result2;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE) && (isVirtualMode3 || isAppendMode3)) {
      const pageIndexForLoad = getPageIndexForLoad(this);
      if (pageIndexForLoad >= 0) {
        const loadResult = loadCore(this, pageIndexForLoad);
        if (loadResult) {
          result2 = new Deferred();
          loadResult.done((() => {
            const delayDeferred = this._delayDeferred;
            if (delayDeferred) {
              delayDeferred.done(result2.resolve).fail(result2.reject);
            } else {
              result2.resolve();
            }
          })).fail(result2.reject);
          dataOptions.updateLoading();
        }
      }
    } else {
      result2 = dataOptions.load();
    }
    if (!result2 && this._lastPageIndex !== this.pageIndex()) {
      this._dataOptions.onChanged({
        changeType: "pageIndex"
      });
    }
    return result2 || new Deferred().resolve();
  }
  loadIfNeed() {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if ((isVirtualMode3 || isAppendMode3) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
      const position2 = this._controller.getViewportPosition();
      if (position2 > 0) {
        this._controller._setViewportPositionCore(position2);
      } else {
        this.load();
      }
    }
  }
  handleDataChanged(callBase, e) {
    const dataOptions = this._dataOptions;
    let lastCacheLength = this._cache.length;
    let changeType;
    let removeInvisiblePages;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (e && e.changes) {
      fireChanged(this, callBase, e);
    } else if (false !== this.option(LEGACY_SCROLLING_MODE) && (isVirtualMode3 || isAppendMode3)) {
      const beginPageIndex = getBeginPageIndex(this);
      if (beginPageIndex >= 0) {
        if (isVirtualMode3 && beginPageIndex + this._cache.length !== dataOptions.pageIndex() && beginPageIndex - 1 !== dataOptions.pageIndex()) {
          lastCacheLength = 0;
          this._cache = [];
        }
        if (isAppendMode3) {
          if (0 === dataOptions.pageIndex()) {
            this._cache = [];
          } else if (dataOptions.pageIndex() < getEndPageIndex(this)) {
            fireChanged(this, callBase, {
              changeType: "append",
              items: []
            });
            return;
          }
        }
      }
      const cacheItem = {
        pageIndex: dataOptions.pageIndex(),
        itemsLength: dataOptions.items(true).length,
        itemsCount: this.itemsCount(true)
      };
      if (this.option("scrolling.removeInvisiblePages") && isVirtualMode3) {
        removeInvisiblePages = this._cache.length > Math.max(getPreloadPageCount(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2);
      } else {
        processDelayChanged(this, callBase, {
          isDelayed: true
        });
      }
      let removeCacheItem;
      if (beginPageIndex === dataOptions.pageIndex() + 1) {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.pop();
        }
        changeType = "prepend";
        this._cache.unshift(cacheItem);
      } else {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.shift();
        }
        changeType = "append";
        this._cache.push(cacheItem);
      }
      const isDelayChanged = isVirtualMode3 && 0 === lastCacheLength && needTwoPagesLoading(this);
      processChanged(this, callBase, this._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
      this._delayDeferred = this.load().done((() => {
        if (processDelayChanged(this, callBase)) {
          this.load();
        }
      }));
    } else {
      processChanged(this, callBase, e);
    }
  }
  getDelayDeferred() {
    return this._delayDeferred;
  }
  itemsCount(isBase) {
    let count = 0;
    const isVirtualMode3 = this._controller.isVirtualMode();
    if (!isBase && isVirtualMode3) {
      this._cache.forEach(((cacheItem) => {
        count += cacheItem.itemsCount;
      }));
    } else {
      count = this._dataOptions.itemsCount();
    }
    return count;
  }
  virtualItemsCount() {
    let pageIndex = getBeginPageIndex(this);
    if (pageIndex < 0) {
      pageIndex = this._dataOptions.pageIndex();
    }
    const beginItemsCount = pageIndex * this._dataOptions.pageSize();
    const itemsCount = this._cache.length * this._dataOptions.pageSize();
    const endItemsCount = Math.max(0, this._dataOptions.totalItemsCount() - itemsCount - beginItemsCount);
    return {
      begin: beginItemsCount,
      end: endItemsCount
    };
  }
  reset() {
    this._loadingPageIndexes = {};
    this._cache = [];
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js
var LEGACY_SCROLLING_MODE2 = "scrolling.legacyMode";
var isVirtualMode = (that) => "virtual" === that.option("scrolling.mode") || that._isVirtual;
var isAppendMode = (that) => "infinite" === that.option("scrolling.mode") && !that._isVirtual;
function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
  let $scrollElement;
  const scrollableArray = [];
  const scrollToArray = [];
  const disposeArray = [];
  $targetElement = $targetElement || $element;
  function getElementOffset(scrollable) {
    const $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
    const scrollableOffset = position_default.offset($scrollableElement);
    if (!scrollableOffset) {
      return $element.offset().top;
    }
    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);
  }
  const widgetScrollStrategy = {
    on(scrollable, eventName, handler) {
      scrollable.on("scroll", handler);
    },
    off(scrollable, eventName, handler) {
      scrollable.off("scroll", handler);
    }
  };
  function subscribeToScrollEvents($scrollElement2) {
    const isDocument = "#document" === $scrollElement2.get(0).nodeName;
    const isElement = $scrollElement2.get(0).nodeType === getWindow().Node.ELEMENT_NODE;
    let scrollable = $scrollElement2.data("dxScrollable");
    let eventsStrategy = widgetScrollStrategy;
    if (!scrollable) {
      scrollable = isDocument && renderer_default(getWindow()) || isElement && "auto" === $scrollElement2.css("overflowY") && $scrollElement2;
      eventsStrategy = m_events_engine_default;
      if (!scrollable) {
        return;
      }
    }
    const handler = /* @__PURE__ */ (function(scrollable2) {
      return function() {
        let scrollTop = scrollable2.scrollTop() - getElementOffset(scrollable2);
        scrollTop = scrollTop > 0 ? scrollTop : 0;
        scrollChangedHandler(scrollTop);
      };
    })(scrollable);
    eventsStrategy.on(scrollable, "scroll", handler);
    scrollToArray.push(((pos) => {
      const topOffset = getElementOffset(scrollable);
      const scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
      if (pos - topOffset >= 0) {
        scrollable[scrollMethod](pos + topOffset);
      }
    }));
    scrollableArray.push(scrollable);
    disposeArray.push((() => {
      eventsStrategy.off(scrollable, "scroll", handler);
    }));
  }
  const getScrollElementParent = ($element2) => renderer_default($element2.get(0).parentNode ?? $element2.get(0).host);
  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = getScrollElementParent($scrollElement)) {
    subscribeToScrollEvents($scrollElement);
  }
  return {
    scrollTo(pos) {
      each(scrollToArray, ((_, scrollTo) => {
        scrollTo(pos);
      }));
    },
    dispose() {
      each(disposeArray, ((_, dispose) => {
        dispose();
      }));
    }
  };
}
var VirtualScrollController = class {
  constructor(component, dataOptions, isVirtual) {
    this._dataOptions = dataOptions;
    this.component = component;
    this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE2) ? 15 : 0;
    this._viewportItemSize = 20;
    this._viewportItemIndex = 0;
    this._position = 0;
    this._isScrollingBack = false;
    this._contentSize = 0;
    this._itemSizes = {};
    this._sizeRatio = 1;
    this._isVirtual = isVirtual;
    this.positionChanged = callbacks_default();
    this._dataLoader = new VirtualDataLoader(this, this._dataOptions);
  }
  getItemSizes() {
    return this._itemSizes;
  }
  option(name2, value2) {
    return this.component.option.apply(this.component, arguments);
  }
  isVirtual() {
    return this._isVirtual;
  }
  virtualItemsCount() {
    if (isVirtualMode(this)) {
      const dataOptions = this._dataOptions;
      const totalItemsCount = dataOptions.totalItemsCount();
      if (false === this.option(LEGACY_SCROLLING_MODE2) && -1 !== totalItemsCount) {
        const viewportParams = this.getViewportParams();
        const loadedOffset = dataOptions.loadedOffset();
        const loadedItemCount = dataOptions.loadedItemCount();
        const skip = Math.max(viewportParams.skip, loadedOffset);
        const take = Math.min(viewportParams.take, loadedItemCount);
        const endItemsCount = Math.max(totalItemsCount - (skip + take), 0);
        return {
          begin: skip,
          end: endItemsCount
        };
      }
      return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
    }
    return;
  }
  getScrollingTimeout() {
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync)) {
      scrollingTimeout = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration());
      if (scrollingTimeout < this.option("scrolling.renderingThreshold")) {
        scrollingTimeout = this.option("scrolling.minTimeout") || 0;
      }
    } else if (renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout") ?? 0;
    }
    return scrollingTimeout;
  }
  setViewportPosition(position2) {
    const result2 = new Deferred();
    const scrollingTimeout = this.getScrollingTimeout();
    clearTimeout(this._scrollTimeoutID);
    if (scrollingTimeout > 0) {
      this._scrollTimeoutID = setTimeout((() => {
        this._setViewportPositionCore(position2);
        result2.resolve();
      }), scrollingTimeout);
    } else {
      this._setViewportPositionCore(position2);
      result2.resolve();
    }
    return result2.promise();
  }
  getViewportPosition() {
    return this._position;
  }
  getItemIndexByPosition(position2, viewportItemIndex, height) {
    position2 = position2 ?? this._position;
    const defaultItemSize = this.getItemSize();
    let offset = 0;
    let itemOffset = 0;
    const itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);
    for (let i = 0; i < itemOffsetsWithSize.length && offset < position2; i++) {
      const itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
      let itemOffsetDiff = (position2 - offset) / defaultItemSize;
      if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
        itemOffset += itemOffsetDiff;
        if (this._sizeRatio < 1 && isDefined(viewportItemIndex)) {
          itemOffset = viewportItemIndex + height / this._viewportItemSize;
        }
        break;
      } else {
        itemOffsetDiff = itemOffsetWithSize - itemOffset;
        offset += itemOffsetDiff * defaultItemSize;
        itemOffset += itemOffsetDiff;
      }
      const itemSize = this._itemSizes[itemOffsetWithSize];
      offset += itemSize;
      itemOffset += offset < position2 ? 1 : (position2 - offset + itemSize) / itemSize;
    }
    return Math.round(50 * itemOffset) / 50;
  }
  isScrollingBack() {
    return this._isScrollingBack;
  }
  _setViewportPositionCore(position2) {
    const prevPosition = this._position || 0;
    this._position = position2;
    if (prevPosition !== this._position) {
      this._isScrollingBack = this._position < prevPosition;
    }
    const itemIndex = this.getItemIndexByPosition();
    const result2 = this.setViewportItemIndex(itemIndex);
    this.positionChanged.fire();
    return result2;
  }
  setContentItemSizes(sizes) {
    const virtualItemsCount = this.virtualItemsCount();
    this._contentSize = sizes.reduce(((a, b) => a + b), 0);
    if (virtualItemsCount) {
      sizes.forEach(((size, index) => {
        this._itemSizes[virtualItemsCount.begin + index] = size;
      }));
      const virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;
      const contentHeightLimit = m_utils_default.getContentHeightLimit(browser_default);
      if (virtualContentSize > contentHeightLimit) {
        this._sizeRatio = contentHeightLimit / virtualContentSize;
      } else {
        this._sizeRatio = 1;
      }
    }
  }
  getItemSize() {
    return this._viewportItemSize * this._sizeRatio;
  }
  getItemOffset(itemIndex, isEnd) {
    const virtualItemsCount = this.virtualItemsCount();
    let itemCount = itemIndex;
    if (!virtualItemsCount) {
      return 0;
    }
    let offset = 0;
    const totalItemsCount = this._dataOptions.totalItemsCount();
    Object.keys(this._itemSizes).forEach(((currentItemIndex) => {
      if (!itemCount) {
        return;
      }
      if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
        offset += this._itemSizes[currentItemIndex];
        itemCount--;
      }
    }));
    return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio);
  }
  getContentOffset(type2) {
    const isEnd = "end" === type2;
    const virtualItemsCount = this.virtualItemsCount();
    if (!virtualItemsCount) {
      return 0;
    }
    return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);
  }
  getVirtualContentSize() {
    const virtualItemsCount = this.virtualItemsCount();
    return virtualItemsCount ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
  }
  getViewportItemIndex() {
    return this._viewportItemIndex;
  }
  setViewportItemIndex(itemIndex) {
    this._viewportItemIndex = itemIndex;
    if (false === this.option(LEGACY_SCROLLING_MODE2)) {
      return;
    }
    return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
  }
  viewportItemSize(size) {
    if (void 0 !== size) {
      this._viewportItemSize = size;
    }
    return this._viewportItemSize;
  }
  viewportSize(size) {
    if (void 0 !== size) {
      this._viewportSize = size;
    }
    return this._viewportSize;
  }
  viewportHeight(height, scrollTop) {
    const position2 = scrollTop ?? this._position;
    const begin = this.getItemIndexByPosition(position2);
    const end = this.getItemIndexByPosition(position2 + height, begin, height);
    this.viewportSize(Math.ceil(end - begin));
    if (!isDefined(scrollTop) && this._viewportItemIndex !== begin) {
      this._setViewportPositionCore(position2);
    }
  }
  reset(isRefresh) {
    this._dataLoader.reset();
    if (!isRefresh) {
      this._itemSizes = {};
    }
  }
  subscribeToWindowScrollEvents($element) {
    this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, ((scrollTop) => {
      if (this.viewportItemSize()) {
        this.setViewportPosition(scrollTop);
      }
    }));
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    this._windowScroll && this._windowScroll.dispose();
    this._windowScroll = null;
  }
  scrollTo(pos) {
    this._windowScroll && this._windowScroll.scrollTo(pos);
  }
  isVirtualMode() {
    return isVirtualMode(this);
  }
  isAppendMode() {
    return isAppendMode(this);
  }
  getViewportParams() {
    const virtualMode = "virtual" === this.option("scrolling.mode");
    const totalItemsCount = this._dataOptions.totalItemsCount();
    const hasKnownLastPage = this._dataOptions.hasKnownLastPage();
    const topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;
    const bottomIndex = this._viewportSize + topIndex;
    const maxGap = this.option("scrolling.prerenderedRowChunkSize") || 1;
    const isScrollingBack = this.isScrollingBack();
    const minGap = this.option("scrolling.prerenderedRowCount") ?? 1;
    const topMinGap = isScrollingBack ? minGap : 0;
    const bottomMinGap = isScrollingBack ? 0 : minGap;
    const skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;
    let take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;
    if (virtualMode) {
      const remainedItems = Math.max(0, totalItemsCount - skip);
      take = Math.min(take, remainedItems);
    }
    return {
      skip,
      take
    };
  }
  itemsCount() {
    let result2 = 0;
    if (this.option(LEGACY_SCROLLING_MODE2)) {
      result2 = this._dataLoader.itemsCount.apply(this._dataLoader, arguments);
    } else {
      result2 = this._dataOptions.itemsCount();
    }
    return result2;
  }
  pageIndex() {
    return this._dataLoader.pageIndex(...arguments);
  }
  beginPageIndex() {
    return this._dataLoader.beginPageIndex(...arguments);
  }
  endPageIndex() {
    return this._dataLoader.endPageIndex(...arguments);
  }
  pageSize() {
    return this._dataLoader.pageSize(...arguments);
  }
  load() {
    return this._dataLoader.load(...arguments);
  }
  loadIfNeed() {
    return this._dataLoader.loadIfNeed(...arguments);
  }
  handleDataChanged() {
    return this._dataLoader.handleDataChanged(...arguments);
  }
  getDelayDeferred() {
    return this._dataLoader.getDelayDeferred();
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling.js
var FREESPACE_CLASS = "dx-freespace-row";
var ROW_INSERTED2 = "dx-row-inserted";
var LEGACY_SCROLLING_MODE3 = "scrolling.legacyMode";
var PAGING_METHOD_NAMES = ["beginPageIndex", "endPageIndex", "pageIndex"];
var isVirtualMode2 = function(that) {
  return "virtual" === that.option("scrolling.mode");
};
var isAppendMode2 = function(that) {
  return "infinite" === that.option("scrolling.mode");
};
var isVirtualPaging = function(that) {
  return isVirtualMode2(that) || isAppendMode2(that);
};
var correctCount = function(items, count, fromEnd, isItemCountableFunc) {
  for (let i = 0; i < count + 1; i++) {
    const item = items[fromEnd ? items.length - 1 - i : i];
    if (item && !isItemCountableFunc(item, i === count, fromEnd)) {
      count++;
    }
  }
  return count;
};
var isItemCountableByDataSource = function(item, dataSource) {
  return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && dataSource.isGroupItemCountable(item.data);
};
var updateItemIndices = function(items) {
  items.forEach(((item, index) => {
    item.rowIndex = index;
  }));
  return items;
};
var updateLoading = function(that) {
  const beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
  if (isVirtualMode2(that)) {
    if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
      if (!that._isLoading) {
        that._isLoading = true;
        that.loadingChanged.fire(true);
      }
    } else if (that._isLoading) {
      that._isLoading = false;
      that.loadingChanged.fire(false);
    }
  }
};
var proxyDataSourceAdapterMethod = function(that, methodName, args) {
  if (false === that.option(LEGACY_SCROLLING_MODE3) && PAGING_METHOD_NAMES.includes(methodName)) {
    const dataSource = that._dataSource;
    return dataSource.pageIndex.apply(dataSource, args);
  }
  const virtualScrollController = that._virtualScrollController;
  return virtualScrollController[methodName].apply(virtualScrollController, args);
};
var removeEmptyRows = function($emptyRows, className) {
  const tBodies = $emptyRows.toArray().map(((row) => renderer_default(row).parent(`.${className}`).get(0))).filter(((row) => row));
  if (tBodies.length) {
    $emptyRows = renderer_default(tBodies);
  }
  const rowCount = className === FREESPACE_CLASS ? $emptyRows.length - 1 : $emptyRows.length;
  for (let i = 0; i < rowCount; i++) {
    $emptyRows.eq(i).remove();
  }
};
var dataSourceAdapterExtender2 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._items = [];
    this._totalCount = -1;
    this._isLoaded = true;
    this._loadPageCount = 1;
    this._virtualScrollController = new VirtualScrollController(this.component, this._getVirtualScrollDataOptions());
  }
  dispose() {
    this._virtualScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _getVirtualScrollDataOptions() {
    const that = this;
    return {
      pageSize: () => that.pageSize(),
      totalItemsCount: () => that.totalItemsCount(),
      hasKnownLastPage: () => that.hasKnownLastPage(),
      pageIndex: (index) => that._dataSource.pageIndex(index),
      isLoading: () => that._dataSource.isLoading() && !that.isCustomLoading(),
      pageCount: () => that.pageCount(),
      load: () => that._dataSource.load(),
      updateLoading() {
        updateLoading(that);
      },
      itemsCount: () => that.itemsCount(true),
      items: () => that._dataSource.items(),
      viewportItems(items) {
        if (items) {
          that._items = items;
        }
        return that._items;
      },
      onChanged(e) {
        that.changed.fire(e);
      },
      changingDuration() {
        if (that.isLoading()) {
          return 300;
        }
        return that._renderTime || 0;
      }
    };
  }
  _handleLoadingChanged(isLoading) {
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      super._handleLoadingChanged.apply(this, arguments);
      return;
    }
    if (!isVirtualMode2(this) || this._isLoadingAll) {
      this._isLoading = isLoading;
      super._handleLoadingChanged.apply(this, arguments);
    }
    if (isLoading) {
      this._startLoadTime = /* @__PURE__ */ new Date();
    } else {
      this._startLoadTime = void 0;
    }
  }
  _handleLoadError() {
    if (false !== this.option(LEGACY_SCROLLING_MODE3)) {
      this._isLoading = false;
      this.loadingChanged.fire(false);
    }
    super._handleLoadError.apply(this, arguments);
  }
  _handleDataChanged(e) {
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      this._items = this._dataSource.items().slice();
      this._totalCount = this._dataSourceTotalCount(true);
      super._handleDataChanged.apply(this, arguments);
      return;
    }
    const callBase = super._handleDataChanged.bind(this);
    this._virtualScrollController.handleDataChanged(callBase, e);
  }
  _customizeRemoteOperations(options2, operationTypes) {
    const newMode = false === this.option(LEGACY_SCROLLING_MODE3);
    let renderAsync = this.option("scrolling.renderAsync");
    if (!isDefined(renderAsync)) {
      renderAsync = this._renderTime >= this.option("scrolling.renderingThreshold");
    }
    if ((isVirtualMode2(this) || isAppendMode2(this) && newMode) && !operationTypes.reload && (operationTypes.skip || newMode) && !renderAsync) {
      options2.delay = void 0;
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  items() {
    return this._items;
  }
  _dataSourceTotalCount(isBase) {
    return false === this.option(LEGACY_SCROLLING_MODE3) && isVirtualMode2(this) && !isBase ? this._totalCount : super._dataSourceTotalCount();
  }
  itemsCount(isBase) {
    if (isBase || false === this.option(LEGACY_SCROLLING_MODE3)) {
      return super.itemsCount();
    }
    return this._virtualScrollController.itemsCount();
  }
  load(loadOptions) {
    if (false === this.option(LEGACY_SCROLLING_MODE3) || loadOptions) {
      return super.load(loadOptions);
    }
    return this._virtualScrollController.load();
  }
  isLoading() {
    return false === this.option(LEGACY_SCROLLING_MODE3) ? this._dataSource.isLoading() : this._isLoading;
  }
  isLoaded() {
    return this._dataSource.isLoaded() && this._isLoaded;
  }
  resetPagesCache(isLiveUpdate) {
    if (!isLiveUpdate) {
      this._virtualScrollController.reset(true);
    }
    super.resetPagesCache.apply(this, arguments);
  }
  _changeRowExpandCore() {
    const result2 = super._changeRowExpandCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return result2;
    }
    this.resetPagesCache();
    updateLoading(this);
    return result2;
  }
  reload() {
    this._dataSource.pageIndex(this.pageIndex());
    const virtualScrollController = this._virtualScrollController;
    if (false !== this.option(LEGACY_SCROLLING_MODE3) && virtualScrollController) {
      const d = new Deferred();
      super.reload.apply(this, arguments).done(((r) => {
        const delayDeferred = virtualScrollController.getDelayDeferred();
        if (delayDeferred) {
          delayDeferred.done(d.resolve).fail(d.reject);
        } else {
          d.resolve(r);
        }
      })).fail(d.reject);
      return d;
    }
    return super.reload.apply(this, arguments);
  }
  refresh(options2, operationTypes) {
    if (false !== this.option(LEGACY_SCROLLING_MODE3)) {
      const {
        storeLoadOptions
      } = options2;
      const dataSource = this._dataSource;
      if (operationTypes.reload) {
        this._virtualScrollController.reset();
        dataSource.items().length = 0;
        this._isLoaded = false;
        updateLoading(this);
        this._isLoaded = true;
        if (isAppendMode2(this)) {
          this.pageIndex(0);
          dataSource.pageIndex(0);
          storeLoadOptions.pageIndex = 0;
          options2.pageIndex = 0;
          storeLoadOptions.skip = 0;
        } else {
          dataSource.pageIndex(this.pageIndex());
          if (dataSource.paginate()) {
            options2.pageIndex = this.pageIndex();
            storeLoadOptions.skip = this.pageIndex() * this.pageSize();
          }
        }
      } else if (isAppendMode2(this) && storeLoadOptions.skip && this._totalCountCorrection < 0) {
        storeLoadOptions.skip += this._totalCountCorrection;
      }
    }
    return super.refresh.apply(this, arguments);
  }
  loadPageCount(count) {
    if (!isDefined(count)) {
      return this._loadPageCount;
    }
    this._loadPageCount = count;
  }
  _handleDataLoading(options2) {
    const loadPageCount = this.loadPageCount();
    const pageSize = this.pageSize();
    const newMode = false === this.option(LEGACY_SCROLLING_MODE3);
    const {
      storeLoadOptions
    } = options2;
    const takeIsDefined = isDefined(storeLoadOptions.take);
    options2.loadPageCount = loadPageCount;
    if (!options2.isCustomLoading && newMode && takeIsDefined && loadPageCount > 1 && pageSize > 0) {
      storeLoadOptions.take = loadPageCount * pageSize;
    }
    super._handleDataLoading.apply(this, arguments);
  }
  _loadPageSize() {
    return super._loadPageSize.apply(this, arguments) * this.loadPageCount();
  }
  beginPageIndex() {
    return proxyDataSourceAdapterMethod(this, "beginPageIndex", [...arguments]);
  }
  endPageIndex() {
    return proxyDataSourceAdapterMethod(this, "endPageIndex", [...arguments]);
  }
  pageIndex(pageIndex) {
    return proxyDataSourceAdapterMethod(this, "pageIndex", [...arguments]);
  }
  virtualItemsCount() {
    return proxyDataSourceAdapterMethod(this, "virtualItemsCount", [...arguments]);
  }
  getContentOffset() {
    return proxyDataSourceAdapterMethod(this, "getContentOffset", [...arguments]);
  }
  getVirtualContentSize() {
    return proxyDataSourceAdapterMethod(this, "getVirtualContentSize", [...arguments]);
  }
  setContentItemSizes() {
    return proxyDataSourceAdapterMethod(this, "setContentItemSizes", [...arguments]);
  }
  setViewportPosition() {
    return proxyDataSourceAdapterMethod(this, "setViewportPosition", [...arguments]);
  }
  getViewportItemIndex() {
    return proxyDataSourceAdapterMethod(this, "getViewportItemIndex", [...arguments]);
  }
  setViewportItemIndex(viewportItemIndex) {
    return proxyDataSourceAdapterMethod(this, "setViewportItemIndex", [...arguments]);
  }
  getItemIndexByPosition() {
    return proxyDataSourceAdapterMethod(this, "getItemIndexByPosition", [...arguments]);
  }
  viewportSize() {
    return proxyDataSourceAdapterMethod(this, "viewportSize", [...arguments]);
  }
  viewportItemSize() {
    return proxyDataSourceAdapterMethod(this, "viewportItemSize", [...arguments]);
  }
  getItemSize() {
    return proxyDataSourceAdapterMethod(this, "getItemSize", [...arguments]);
  }
  getItemSizes() {
    return proxyDataSourceAdapterMethod(this, "getItemSizes", [...arguments]);
  }
  loadIfNeed() {
    return proxyDataSourceAdapterMethod(this, "loadIfNeed", [...arguments]);
  }
};
var data7 = (Base) => class extends Base {
  dispose() {
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _refreshDataSource() {
    const baseResult = super._refreshDataSource.apply(this, arguments) || new Deferred().resolve().promise();
    baseResult.done(this.initVirtualRows.bind(this));
    return baseResult;
  }
  _loadDataSource() {
    if (this._rowsScrollController && isVirtualPaging(this)) {
      var _this$_dataSource;
      const {
        loadPageCount
      } = isDefined(this._loadViewportParams) ? this.getLoadPageParams() : {
        loadPageCount: 0
      };
      loadPageCount >= 1 && (null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.loadPageCount(loadPageCount));
    }
    return super._loadDataSource.apply(this, arguments);
  }
  getRowPageSize() {
    const rowPageSize = this.option("scrolling.rowPageSize");
    const pageSize = this.pageSize();
    return pageSize && pageSize < rowPageSize ? pageSize : rowPageSize;
  }
  reload() {
    const rowsScrollController = this._rowsScrollController || this._dataSource;
    const itemIndex = rowsScrollController && rowsScrollController.getItemIndexByPosition();
    const result2 = super.reload.apply(this, arguments);
    return result2 && result2.done((() => {
      if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
        const rowIndexOffset = this.getRowIndexOffset();
        const rowIndex = Math.floor(itemIndex) - rowIndexOffset;
        const {
          component
        } = this;
        const scrollable = component.getScrollable && component.getScrollable();
        const isSortingOperation = this.dataSource().operationTypes().sorting;
        if (scrollable && !isSortingOperation && rowIndex >= 0) {
          var _$rowElement$position;
          const rowElement = component.getRowElement(rowIndex);
          const $rowElement = rowElement && rowElement[0] && renderer_default(rowElement[0]);
          let top = $rowElement && (null === (_$rowElement$position = $rowElement.position()) || void 0 === _$rowElement$position ? void 0 : _$rowElement$position.top);
          const isChromeLatest = browser_default.chrome && Number(browser_default.version ?? 0) >= 91;
          const allowedTopOffset = browser_default.mozilla || isChromeLatest ? 1 : 0;
          if (top && top > allowedTopOffset) {
            top = Math.round(top + getOuterHeight($rowElement) * (itemIndex % 1));
            scrollable.scrollTo({
              y: top
            });
          }
        }
      }
    }));
  }
  initVirtualRows() {
    const virtualRowsRendering = m_utils_default.isVirtualRowRendering(this);
    this._allItems = null;
    this._loadViewportParams = null;
    if ("virtual" !== this.option("scrolling.mode") && !virtualRowsRendering || !virtualRowsRendering || false !== this.option(LEGACY_SCROLLING_MODE3) && !this.option("scrolling.rowPageSize")) {
      this._visibleItems = null;
      this._rowsScrollController = null;
      return;
    }
    const pageIndex = !isVirtualMode2(this) && this.pageIndex() >= this.pageCount() ? this.pageCount() - 1 : this.pageIndex();
    this._rowPageIndex = Math.ceil(pageIndex * this.pageSize() / this.getRowPageSize());
    this._visibleItems = false === this.option(LEGACY_SCROLLING_MODE3) ? null : [];
    this._viewportChanging = false;
    this._needUpdateViewportAfterLoading = false;
    if (!this._rowsScrollController) {
      this._rowsScrollController = new VirtualScrollController(this.component, this._getRowsScrollDataOptions(), true);
      this._rowsScrollController.positionChanged.add((() => {
        var _this$_dataSource2;
        if (false === this.option(LEGACY_SCROLLING_MODE3)) {
          this._viewportChanging = true;
          this.loadViewport();
          this._viewportChanging = false;
          return;
        }
        null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 || _this$_dataSource2.setViewportItemIndex(this._rowsScrollController.getViewportItemIndex());
      }));
    }
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      this._updateLoadViewportParams();
    }
    if (this.isLoaded() && false !== this.option(LEGACY_SCROLLING_MODE3)) {
      this._rowsScrollController.load();
    }
  }
  isViewportChanging() {
    return this._viewportChanging;
  }
  _getRowsScrollDataOptions() {
    const that = this;
    const isItemCountable = function(item) {
      return isItemCountableByDataSource(item, that._dataSource);
    };
    return {
      pageSize: () => that.getRowPageSize(),
      loadedOffset() {
        var _that$_dataSource;
        return isVirtualMode2(that) && (null === (_that$_dataSource = that._dataSource) || void 0 === _that$_dataSource ? void 0 : _that$_dataSource.lastLoadOptions().skip) || 0;
      },
      loadedItemCount: () => that._itemCount,
      totalItemsCount() {
        if (isVirtualPaging(that)) {
          return that.totalItemsCount();
        }
        return false === that.option(LEGACY_SCROLLING_MODE3) ? that._itemCount : that._items.filter(isItemCountable).length;
      },
      hasKnownLastPage: () => false === that.option(LEGACY_SCROLLING_MODE3) ? that.hasKnownLastPage() : true,
      pageIndex(index) {
        if (void 0 !== index) {
          that._rowPageIndex = index;
        }
        return that._rowPageIndex;
      },
      isLoading: () => that.isLoading(),
      pageCount() {
        const pageCount = Math.ceil(this.totalItemsCount() / this.pageSize());
        return pageCount || 1;
      },
      load() {
        if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
          that._rowPageIndex = this.pageCount() - 1;
          that._rowsScrollController.pageIndex(that._rowPageIndex);
        }
        if (!this.items().length && this.totalItemsCount()) {
          return;
        }
        that._rowsScrollController.handleDataChanged(((change) => {
          change = change || {};
          change.changeType = change.changeType || "refresh";
          change.items = change.items || that._visibleItems;
          that._visibleItems.forEach(((item, index) => {
            item.rowIndex = index;
          }));
          that._fireChanged(change);
        }));
      },
      updateLoading() {
      },
      itemsCount() {
        return this.items(true).length;
      },
      correctCount: (items, count, fromEnd) => correctCount(items, count, fromEnd, ((item, isNextAfterLast, fromEnd2) => {
        if (item.isNewRow) {
          return isNextAfterLast && !fromEnd2;
        }
        if (isNextAfterLast && fromEnd2) {
          return !item.isNewRow;
        }
        return isItemCountable(item);
      })),
      items(countableOnly) {
        let result2 = that._items;
        if (that.option(LEGACY_SCROLLING_MODE3)) {
          const dataSource = that.dataSource();
          const virtualItemsCount = null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount();
          const begin = virtualItemsCount ? virtualItemsCount.begin : 0;
          const rowPageSize = that.getRowPageSize();
          let skip = that._rowPageIndex * rowPageSize - begin;
          let take = rowPageSize;
          if (skip < 0) {
            return [];
          }
          if (skip) {
            skip = this.correctCount(result2, skip);
            result2 = result2.slice(skip);
          }
          if (take) {
            take = this.correctCount(result2, take);
            result2 = result2.slice(0, take);
          }
        }
        return countableOnly ? result2.filter(isItemCountable) : result2;
      },
      viewportItems(items) {
        if (items && false !== that.option(LEGACY_SCROLLING_MODE3)) {
          that._visibleItems = items;
        }
        return that._visibleItems;
      },
      onChanged() {
      },
      changingDuration() {
        const dataSource = that.dataSource();
        if (null !== dataSource && void 0 !== dataSource && dataSource.isLoading() && false !== that.option(LEGACY_SCROLLING_MODE3)) {
          return 300;
        }
        return (null === dataSource || void 0 === dataSource ? void 0 : dataSource._renderTime) || 0;
      }
    };
  }
  _updateItemsCore(change) {
    const delta = this.getRowIndexDelta();
    super._updateItemsCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3) && m_utils_default.isVirtualRowRendering(this)) {
      if ("update" === change.changeType && 0 === change.rowIndices.length && change.cancelEmptyChanges) {
        change.cancel = true;
      }
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      const visibleItems = this._visibleItems;
      const isRefresh = "refresh" === change.changeType || change.isLiveUpdate;
      if ("append" === change.changeType && change.items && !change.items.length) {
        return;
      }
      if (isRefresh || "append" === change.changeType || "prepend" === change.changeType) {
        change.cancel = true;
        isRefresh && rowsScrollController.reset(true);
        rowsScrollController.load();
      } else {
        if ("update" === change.changeType) {
          change.rowIndices.forEach(((rowIndex, index) => {
            const changeType = change.changeTypes[index];
            const newItem = change.items[index];
            if ("update" === changeType) {
              visibleItems[rowIndex] = newItem;
            } else if ("insert" === changeType) {
              visibleItems.splice(rowIndex, 0, newItem);
            } else if ("remove" === changeType) {
              visibleItems.splice(rowIndex, 1);
            }
          }));
        } else {
          visibleItems.forEach(((item, index) => {
            visibleItems[index] = this._items[index + delta] || visibleItems[index];
          }));
          change.items = visibleItems;
        }
        updateItemIndices(visibleItems);
      }
    }
  }
  _updateLoadViewportParams() {
    const viewportParams = this._rowsScrollController.getViewportParams();
    const pageSize = this.pageSize();
    if (viewportParams && !isVirtualPaging(this) && pageSize > 0) {
      const pageOffset = this.pageIndex() * pageSize;
      viewportParams.skip += pageOffset;
    }
    this._loadViewportParams = viewportParams;
  }
  _processItems() {
    const resultItems = super._processItems.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      const dataSource = this._dataSource;
      let currentIndex = (null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().skip) ?? 0;
      let prevCountable;
      let prevRowType;
      let isPrevRowNew;
      let wasCountableItem = false;
      let newRows = [];
      resultItems.forEach(((item) => {
        const {
          rowType
        } = item;
        const itemCountable = isItemCountableByDataSource(item, dataSource);
        const isNextGroupItem = "group" === rowType && (prevCountable || itemCountable || "group" !== prevRowType && currentIndex > 0);
        const isNextDataItem = "data" === rowType && itemCountable && (prevCountable || "group" !== prevRowType);
        if (!item.isNewRow && isDefined(prevCountable)) {
          const isPrevNewRowFirst = isPrevRowNew && !wasCountableItem;
          if ((isNextGroupItem || isNextDataItem) && !isPrevNewRowFirst) {
            currentIndex++;
          }
        }
        if (isNextGroupItem || isNextDataItem) {
          wasCountableItem = true;
        }
        if (item.isNewRow) {
          newRows.push(item);
        } else {
          newRows.forEach(((it) => {
            it.loadIndex = currentIndex;
          }));
          newRows = [];
        }
        item.loadIndex = currentIndex;
        prevCountable = itemCountable;
        prevRowType = rowType;
        isPrevRowNew = item.isNewRow;
      }));
      newRows.forEach(((it) => {
        it.loadIndex = currentIndex;
      }));
    }
    return resultItems;
  }
  _afterProcessItems(items) {
    this._itemCount = items.filter(((item) => isItemCountableByDataSource(item, this._dataSource))).length;
    if (isDefined(this._loadViewportParams)) {
      this._updateLoadViewportParams();
      let result2 = items;
      this._allItems = items;
      if (items.length) {
        const {
          skipForCurrentPage
        } = this.getLoadPageParams(true);
        const skip = items[0].loadIndex + skipForCurrentPage;
        const {
          take
        } = this._loadViewportParams;
        result2 = items.filter(((it) => {
          const isNewRowInEmptyData = it.isNewRow && it.loadIndex === skip && 0 === take;
          const isLoadIndexGreaterStart = it.loadIndex >= skip;
          const isLoadIndexLessEnd = it.loadIndex < skip + take || isNewRowInEmptyData;
          return isLoadIndexGreaterStart && isLoadIndexLessEnd;
        }));
      }
      return result2;
    }
    return super._afterProcessItems.apply(this, arguments);
  }
  _applyChange(change) {
    const that = this;
    const {
      items
    } = change;
    const {
      changeType
    } = change;
    let {
      removeCount
    } = change;
    if (removeCount) {
      const fromEnd = "prepend" === changeType;
      removeCount = correctCount(that._items, removeCount, fromEnd, ((item, isNextAfterLast) => "data" === item.rowType && !item.isNewRow || "group" === item.rowType && (that._dataSource.isGroupItemCountable(item.data) || isNextAfterLast)));
      change.removeCount = removeCount;
    }
    switch (changeType) {
      case "prepend":
        that._items.unshift.apply(that._items, items);
        if (removeCount) {
          that._items.splice(-removeCount);
        }
        break;
      case "append":
        that._items.push.apply(that._items, items);
        if (removeCount) {
          that._items.splice(0, removeCount);
        }
        break;
      default:
        super._applyChange(change);
    }
  }
  items(allItems) {
    return allItems ? this._allItems || this._items : this._visibleItems || this._items;
  }
  getRowIndexDelta() {
    let delta = 0;
    if (this.option(LEGACY_SCROLLING_MODE3)) {
      const visibleItems = this._visibleItems;
      if (visibleItems && visibleItems[0]) {
        delta = this._items.indexOf(visibleItems[0]);
      }
    }
    return delta < 0 ? 0 : delta;
  }
  getRowIndexOffset(byLoadedRows, needGroupOffset) {
    let offset = 0;
    const dataSource = this.dataSource();
    const rowsScrollController = this._rowsScrollController;
    const newMode = false === this.option(LEGACY_SCROLLING_MODE3);
    const virtualPaging = isVirtualPaging(this);
    if (rowsScrollController && !byLoadedRows) {
      if (newMode && isDefined(this._loadViewportParams)) {
        const {
          skipForCurrentPage,
          pageIndex
        } = this.getLoadPageParams(true);
        const items = this.items(true);
        offset = virtualPaging ? pageIndex * this.pageSize() : 0;
        if (items.length) {
          const firstLoadIndex = items[0].loadIndex;
          offset += items.filter(((item) => item.loadIndex < firstLoadIndex + skipForCurrentPage)).length;
        }
      } else {
        offset = rowsScrollController.beginPageIndex() * rowsScrollController.pageSize();
      }
    } else if (virtualPaging && newMode && dataSource) {
      var _lastLoadOptions$skip;
      const lastLoadOptions = dataSource.lastLoadOptions();
      if (needGroupOffset && null !== (_lastLoadOptions$skip = lastLoadOptions.skips) && void 0 !== _lastLoadOptions$skip && _lastLoadOptions$skip.length) {
        offset = lastLoadOptions.skips.reduce(((res, skip) => res + skip), 0);
      } else {
        offset = lastLoadOptions.skip ?? 0;
      }
    } else if (isVirtualMode2(this) && dataSource) {
      offset = dataSource.beginPageIndex() * dataSource.pageSize();
    }
    return offset;
  }
  getDataIndex() {
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return this.getRowIndexOffset(true, true);
    }
    return super.getDataIndex.apply(this, arguments);
  }
  viewportSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportSize.apply(dataSource, arguments);
  }
  viewportHeight(height, scrollTop) {
    var _this$_rowsScrollCont;
    null === (_this$_rowsScrollCont = this._rowsScrollController) || void 0 === _this$_rowsScrollCont || _this$_rowsScrollCont.viewportHeight(height, scrollTop);
  }
  viewportItemSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportItemSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportItemSize.apply(dataSource, arguments);
  }
  setViewportPosition() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    this._isPaging = false;
    if (rowsScrollController) {
      rowsScrollController.setViewportPosition.apply(rowsScrollController, arguments);
    } else {
      null === dataSource || void 0 === dataSource || dataSource.setViewportPosition.apply(dataSource, arguments);
    }
  }
  setContentItemSizes(sizes) {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.setContentItemSizes(sizes);
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.setContentItemSizes(sizes);
  }
  getPreloadedRowCount() {
    const preloadCount = this.option("scrolling.preloadedRowCount");
    const preloadEnabled = this.option("scrolling.preloadEnabled");
    if (isDefined(preloadCount)) {
      return preloadCount;
    }
    const viewportSize = this.viewportSize();
    return preloadEnabled ? 2 * viewportSize : viewportSize;
  }
  getLoadPageParams(byLoadedPage) {
    var _this$_dataSource3, _this$_dataSource4;
    const pageSize = this.pageSize();
    const viewportParams = this._loadViewportParams;
    const lastLoadOptions = null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.lastLoadOptions();
    const loadedPageIndex = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.pageIndex) || 0;
    const loadedTake = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.take) || 0;
    const isScrollingBack = this._rowsScrollController.isScrollingBack();
    const topPreloadCount = isScrollingBack ? this.getPreloadedRowCount() : 0;
    const bottomPreloadCount = isScrollingBack ? 0 : this.getPreloadedRowCount();
    const totalCountCorrection = (null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.totalCountCorrection()) || 0;
    const skipWithPreload = Math.max(0, viewportParams.skip - topPreloadCount);
    const pageIndex = byLoadedPage ? loadedPageIndex : Math.floor(pageSize ? skipWithPreload / pageSize : 0);
    const pageOffset = pageIndex * pageSize;
    const skipForCurrentPage = viewportParams.skip - pageOffset;
    const loadingTake = viewportParams.take + skipForCurrentPage + bottomPreloadCount - totalCountCorrection;
    const take = byLoadedPage ? loadedTake : loadingTake;
    const loadPageCount = Math.ceil(pageSize ? take / pageSize : 0);
    return {
      pageIndex,
      loadPageCount: Math.max(1, loadPageCount),
      skipForCurrentPage: Math.max(0, skipForCurrentPage)
    };
  }
  _updateVisiblePageIndex(currentPageIndex) {
    if (!this._rowsScrollController) {
      return;
    }
    if (isDefined(currentPageIndex)) {
      this._silentOption("paging.pageIndex", currentPageIndex);
      this.pageChanged.fire();
      return;
    }
    const viewPortItemIndex = this._rowsScrollController.getViewportItemIndex();
    const newPageIndex = Math.floor(viewPortItemIndex / this.pageSize());
    if (this.pageIndex() !== newPageIndex) {
      this._silentOption("paging.pageIndex", newPageIndex);
      this.updateItems({
        changeType: "pageIndex"
      });
    }
  }
  _getChangedLoadParams() {
    const loadedPageParams = this.getLoadPageParams(true);
    const {
      pageIndex,
      loadPageCount
    } = this.getLoadPageParams();
    const pageIndexIsValid = this._pageIndexIsValid(pageIndex);
    let result2 = null;
    if (!this._isLoading && pageIndexIsValid && (pageIndex !== loadedPageParams.pageIndex || loadPageCount !== loadedPageParams.loadPageCount)) {
      result2 = {
        pageIndex,
        loadPageCount
      };
    }
    return result2;
  }
  _pageIndexIsValid(pageIndex) {
    let result2 = true;
    if (isAppendMode2(this) && this.hasKnownLastPage() || isVirtualMode2(this)) {
      result2 = pageIndex * this.pageSize() < this.totalItemsCount();
    }
    return result2;
  }
  _loadItems(checkLoading, viewportIsFilled) {
    const virtualPaging = isVirtualPaging(this);
    const dataSourceAdapter = this._dataSource;
    const changedParams = this._getChangedLoadParams();
    const currentLoadPageCount = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.loadPageCount()) ?? 0;
    const lastRequiredItemCount = this.pageSize() * currentLoadPageCount;
    const currentPageIndex = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.pageIndex()) ?? 0;
    const pageIndexNotChanged = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) === currentPageIndex;
    const allLoadedInAppendMode = isAppendMode2(this) && this.totalItemsCount() < lastRequiredItemCount;
    const isRepaintMode = "repaint" === this.option("editing.refreshMode");
    const pageIndexIncreased = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) > currentPageIndex;
    let result2 = false;
    if (!dataSourceAdapter || virtualPaging && checkLoading && (isRepaintMode && viewportIsFilled || pageIndexIncreased || pageIndexNotChanged && allLoadedInAppendMode)) {
      return result2;
    }
    if (virtualPaging && this._isLoading) {
      this._needUpdateViewportAfterLoading = true;
    }
    if (virtualPaging && changedParams) {
      result2 = true;
      dataSourceAdapter.pageIndex(changedParams.pageIndex);
      dataSourceAdapter.loadPageCount(changedParams.loadPageCount);
      this._repaintChangesOnly = true;
      this._needUpdateDimensions = true;
      const viewportChanging = this._viewportChanging;
      this.load().always((() => {
        this._repaintChangesOnly = void 0;
        this._needUpdateDimensions = void 0;
      })).done((() => {
        const isLastPage = this.pageCount() > 0 && this.pageIndex() === this.pageCount() - 1;
        (viewportChanging || isLastPage) && this._updateVisiblePageIndex();
        if (this._needUpdateViewportAfterLoading) {
          this._needUpdateViewportAfterLoading = false;
          this.loadViewport({
            checkLoadedParamsOnly: true
          });
        }
      }));
    }
    return result2;
  }
  loadViewport(params) {
    const {
      checkLoadedParamsOnly,
      checkLoading,
      viewportIsNotFilled
    } = params ?? {};
    const virtualPaging = isVirtualPaging(this);
    if (virtualPaging || m_utils_default.isVirtualRowRendering(this)) {
      var _this$_dataSource5;
      this._updateLoadViewportParams();
      const loadingItemsStarted = this._loadItems(checkLoading, !viewportIsNotFilled);
      const isCustomLoading = null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.isCustomLoading();
      const isLoading = checkLoading && !isCustomLoading && this._isLoading;
      const needToUpdateItems = !(loadingItemsStarted || isLoading || checkLoadedParamsOnly);
      if (needToUpdateItems) {
        var _this$_editingControl;
        const noPendingChangesInEditing = !(null !== (_this$_editingControl = this._editingController) && void 0 !== _this$_editingControl && null !== (_this$_editingControl = _this$_editingControl.getChanges()) && void 0 !== _this$_editingControl && _this$_editingControl.length);
        this.updateItems({
          repaintChangesOnly: true,
          needUpdateDimensions: true,
          useProcessedItemsCache: noPendingChangesInEditing,
          cancelEmptyChanges: true
        });
      }
    }
  }
  updateViewport() {
    var _this$_loadViewportPa;
    const viewportSize = this.viewportSize();
    const itemCount = this.items().length;
    const viewportIsNotFilled = viewportSize > itemCount;
    const currentTake = (null === (_this$_loadViewportPa = this._loadViewportParams) || void 0 === _this$_loadViewportPa ? void 0 : _this$_loadViewportPa.take) ?? 0;
    const rowsScrollController = this._rowsScrollController;
    const newTake = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.getViewportParams().take;
    (viewportIsNotFilled || currentTake < newTake) && !this._isPaging && itemCount && this.loadViewport({
      checkLoading: true,
      viewportIsNotFilled
    });
  }
  loadIfNeed() {
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.loadIfNeed();
    const dataSource = this._dataSource;
    return dataSource && dataSource.loadIfNeed();
  }
  getItemSize() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSize.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return dataSource && dataSource.getItemSize.apply(dataSource, arguments);
  }
  getItemSizes() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSizes.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return dataSource && dataSource.getItemSizes.apply(dataSource, arguments);
  }
  getContentOffset() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getContentOffset.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return dataSource && dataSource.getContentOffset.apply(dataSource, arguments);
  }
  refresh(options2) {
    const dataSource = this._dataSource;
    if (dataSource && options2 && options2.load && isAppendMode2(this)) {
      dataSource.resetCurrentTotalCount();
    }
    return super.refresh.apply(this, arguments);
  }
  topItemIndex() {
    var _this$_loadViewportPa2;
    return null === (_this$_loadViewportPa2 = this._loadViewportParams) || void 0 === _this$_loadViewportPa2 ? void 0 : _this$_loadViewportPa2.skip;
  }
  bottomItemIndex() {
    const viewportParams = this._loadViewportParams;
    return viewportParams && viewportParams.skip + viewportParams.take;
  }
  virtualItemsCount() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.virtualItemsCount.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount.apply(dataSource, arguments);
  }
  pageIndex(pageIndex) {
    const virtualPaging = isVirtualPaging(this);
    const rowsScrollController = this._rowsScrollController;
    if (false === this.option(LEGACY_SCROLLING_MODE3) && virtualPaging && rowsScrollController) {
      if (void 0 === pageIndex) {
        return this.option("paging.pageIndex") ?? 0;
      }
    }
    return super.pageIndex.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged.apply(this, arguments);
    const {
      operationTypes
    } = e;
    if (false === this.option(LEGACY_SCROLLING_MODE3) && isVirtualPaging(this) && operationTypes) {
      const {
        fullReload,
        pageIndex
      } = operationTypes;
      if (e.isDataChanged && !fullReload && pageIndex) {
        this._updateVisiblePageIndex(this._dataSource.pageIndex());
      }
    }
  }
  _getPagingOptionValue(optionName) {
    let result2 = super._getPagingOptionValue.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE3) && isVirtualPaging(this)) {
      result2 = this[optionName]();
    }
    return result2;
  }
  isEmpty() {
    return false === this.option(LEGACY_SCROLLING_MODE3) ? !this.items(true).length : super.isEmpty.apply(this, arguments);
  }
  isLastPageLoaded() {
    let result2 = false;
    if (false === this.option(LEGACY_SCROLLING_MODE3) && isVirtualPaging(this)) {
      const {
        pageIndex,
        loadPageCount
      } = this.getLoadPageParams(true);
      const pageCount = this.pageCount();
      result2 = pageIndex + loadPageCount >= pageCount;
    } else {
      result2 = super.isLastPageLoaded.apply(this, arguments);
    }
    return result2;
  }
  reset() {
    this._itemCount = 0;
    this._allItems = null;
    super.reset.apply(this, arguments);
  }
  _applyFilter() {
    var _this$_dataSource6;
    null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 || _this$_dataSource6.loadPageCount(1);
    return super._applyFilter.apply(this, arguments);
  }
  getVirtualContentSize() {
    var _this$_dataSource7;
    return null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.getVirtualContentSize.apply(this._dataSource, arguments);
  }
  setViewportItemIndex() {
    var _this$_dataSource8;
    return null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.setViewportItemIndex.apply(this._dataSource, arguments);
  }
};
var resizing3 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._resizeTimeout);
  }
  _updateMasterDataGridCore(masterDataGrid) {
    return when(super._updateMasterDataGridCore.apply(this, arguments)).done(((masterDataGridUpdated) => {
      const isNewVirtualMode = isVirtualMode2(masterDataGrid) && false === masterDataGrid.option(LEGACY_SCROLLING_MODE3);
      if (!masterDataGridUpdated && isNewVirtualMode) {
        const scrollable = masterDataGrid.getScrollable();
        if (scrollable) {
          masterDataGrid.updateDimensions();
        }
      }
    }));
  }
  hasResizeTimeout() {
    return isDefined(this._resizeTimeout);
  }
  resize() {
    let result2;
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      clearTimeout(this._resizeTimeout);
      this._resizeTimeout = null;
      const diff = /* @__PURE__ */ new Date() - this._lastTime;
      const updateTimeout = this.option("scrolling.updateTimeout");
      if (this._lastTime && diff < updateTimeout) {
        result2 = new Deferred();
        this._resizeTimeout = setTimeout((() => {
          this._resizeTimeout = null;
          super.resize.apply(this).done(result2.resolve).fail(result2.reject);
          this._lastTime = /* @__PURE__ */ new Date();
        }), updateTimeout);
        this._lastTime = /* @__PURE__ */ new Date();
      } else {
        result2 = super.resize.apply(this);
        if (this._dataController.isLoaded()) {
          this._lastTime = /* @__PURE__ */ new Date();
        }
      }
    } else {
      result2 = super.resize.apply(this);
    }
    return result2;
  }
};
var rowsView7 = (Base) => class extends Base {
  init() {
    var _this$_dataController;
    super.init();
    this._dataController.pageChanged.add(((pageIndex) => {
      const scrollTop = this._scrollTop;
      this.scrollToPage(pageIndex ?? this._dataController.pageIndex());
      if (false === this.option(LEGACY_SCROLLING_MODE3) && this._scrollTop === scrollTop) {
        this._dataController.updateViewport();
      }
    }));
    this._dataController.dataSourceChanged.add((() => {
      !this._scrollTop && this._scrollToCurrentPageOnResize();
    }));
    null === (_this$_dataController = this._dataController.stateLoaded) || void 0 === _this$_dataController || _this$_dataController.add((() => {
      this._scrollToCurrentPageOnResize();
    }));
    this._scrollToCurrentPageOnResize();
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    super.dispose();
  }
  _scrollToCurrentPageOnResize() {
    if (this._dataController.pageIndex() > 0) {
      const resizeHandler = () => {
        this.resizeCompleted.remove(resizeHandler);
        this.scrollToPage(this._dataController.pageIndex());
      };
      this.resizeCompleted.add(resizeHandler);
    }
  }
  scrollToPage(pageIndex) {
    const pageSize = this._dataController ? this._dataController.pageSize() : 0;
    let scrollPosition;
    if (isVirtualMode2(this) || isAppendMode2(this)) {
      const itemSize = this._dataController.getItemSize();
      const itemSizes = this._dataController.getItemSizes();
      const itemIndex = pageIndex * pageSize;
      scrollPosition = itemIndex * itemSize;
      for (const index in itemSizes) {
        if (parseInt(index) < itemIndex) {
          scrollPosition += itemSizes[index] - itemSize;
        }
      }
    } else {
      scrollPosition = 0;
    }
    this.scrollTo({
      y: scrollPosition,
      x: this._scrollLeft
    });
  }
  renderDelayedTemplates() {
    this.waitAsyncTemplates().done((() => {
      this._updateContentPosition(true);
    }));
    super.renderDelayedTemplates.apply(this, arguments);
  }
  _renderCore(e) {
    const startRenderTime = /* @__PURE__ */ new Date();
    const deferred = super._renderCore.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    if (dataSource && e) {
      const itemCount = e.items ? e.items.length : 20;
      const viewportSize = this._dataController.viewportSize() || 20;
      if (m_utils_default.isVirtualRowRendering(this) && itemCount > 0 && false !== this.option(LEGACY_SCROLLING_MODE3)) {
        dataSource._renderTime = (/* @__PURE__ */ new Date() - startRenderTime) * viewportSize / itemCount;
      } else {
        dataSource._renderTime = /* @__PURE__ */ new Date() - startRenderTime;
      }
    }
    return deferred;
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return $rows && $rows.not(".dx-virtual-row");
  }
  _removeRowsElements(contentTable, removeCount, changeType) {
    let rowElements = this._getRowElements(contentTable).toArray();
    if ("append" === changeType) {
      rowElements = rowElements.slice(0, removeCount);
    } else {
      rowElements = rowElements.slice(-removeCount);
    }
    rowElements.map(((rowElement) => {
      const $rowElement = renderer_default(rowElement);
      this._errorHandlingController && this._errorHandlingController.removeErrorRow($rowElement.next());
      $rowElement.remove();
    }));
  }
  _updateContent(tableElement, change) {
    let $freeSpaceRowElements;
    const contentElement = this._findContentElement();
    const changeType = change && change.changeType;
    const d = Deferred();
    const contentTable = contentElement.children().first();
    if ("append" === changeType || "prepend" === changeType) {
      this.waitAsyncTemplates().done((() => {
        const $tBodies = this._getBodies(tableElement);
        if (1 === $tBodies.length) {
          this._getBodies(contentTable)["append" === changeType ? "append" : "prepend"]($tBodies.children());
        } else {
          $tBodies["append" === changeType ? "appendTo" : "prependTo"](contentTable);
        }
        tableElement.remove();
        $freeSpaceRowElements = this._getFreeSpaceRowElements(contentTable);
        removeEmptyRows($freeSpaceRowElements, FREESPACE_CLASS);
        if (change.removeCount) {
          this._removeRowsElements(contentTable, change.removeCount, changeType);
        }
        this._restoreErrorRow(contentTable);
        d.resolve();
      })).fail(d.reject);
    } else {
      super._updateContent.apply(this, arguments).done((() => {
        if ("update" === changeType) {
          this._restoreErrorRow(contentTable);
        }
        d.resolve();
      })).fail(d.reject);
    }
    return d.promise().done((() => {
      this._updateBottomLoading();
    }));
  }
  _addVirtualRow($table, isFixed, location, position2) {
    if (!position2) {
      return;
    }
    let $virtualRow = this._createEmptyRow("dx-virtual-row", isFixed, position2);
    $virtualRow = this._wrapRowIfNeed($table, $virtualRow);
    this._appendEmptyRow($table, $virtualRow, location);
  }
  _updateContentItemSizes() {
    const rowHeights = this._getRowHeights();
    const correctedRowHeights = this._correctRowHeights(rowHeights);
    this._dataController.setContentItemSizes(correctedRowHeights);
  }
  _updateViewportSize(viewportHeight, scrollTop) {
    if (!isDefined(viewportHeight)) {
      viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
    }
    this._dataController.viewportHeight(viewportHeight, scrollTop);
  }
  _getRowHeights() {
    var _this$_editingControl2, _this$_editingControl3;
    const isPopupEditMode = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isPopupEditMode) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2);
    let rowElements = this._getRowElements(this._tableElement).toArray();
    if (isPopupEditMode) {
      rowElements = rowElements.filter(((row) => !renderer_default(row).hasClass(ROW_INSERTED2)));
    }
    return rowElements.map(((row) => getBoundingRect(row).height));
  }
  _correctRowHeights(rowHeights) {
    const dataController2 = this._dataController;
    const dataSource = dataController2._dataSource;
    const correctedRowHeights = [];
    const visibleRows = dataController2.getVisibleRows();
    let itemSize = 0;
    let firstCountableItem = true;
    let lastLoadIndex = -1;
    for (let i = 0; i < rowHeights.length; i++) {
      const currentItem = visibleRows[i];
      if (!isDefined(currentItem)) {
        continue;
      }
      if (false === this.option(LEGACY_SCROLLING_MODE3)) {
        if (lastLoadIndex >= 0 && lastLoadIndex !== currentItem.loadIndex) {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
        lastLoadIndex = currentItem.loadIndex;
      } else if (isItemCountableByDataSource(currentItem, dataSource)) {
        if (firstCountableItem) {
          firstCountableItem = false;
        } else {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
      }
      itemSize += rowHeights[i];
    }
    itemSize > 0 && correctedRowHeights.push(itemSize);
    return correctedRowHeights;
  }
  _updateContentPosition(isRender) {
    const rowHeight = this._rowHeight || 20;
    this._dataController.viewportItemSize(rowHeight);
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      const isEmptyRows = this._dataController.isEmpty();
      if (isEmptyRows) {
        return;
      }
      if (!isRender) {
        this._updateContentItemSizes();
      }
      const top = this._dataController.getContentOffset("begin");
      const bottom = this._dataController.getContentOffset("end");
      const $tables = this.getTableElements();
      const $virtualRows = $tables.children("tbody").children(".dx-virtual-row");
      removeEmptyRows($virtualRows, "dx-virtual-row");
      $tables.each(((index, element) => {
        const isFixed = index > 0;
        const prevFixed = this._isFixedTableRendering;
        this._isFixedTableRendering = isFixed;
        this._addVirtualRow(renderer_default(element), isFixed, "top", top);
        this._addVirtualRow(renderer_default(element), isFixed, "bottom", bottom);
        this._isFixedTableRendering = prevFixed;
      }));
    }
  }
  _isTableLinesDisplaysCorrect(table) {
    const hasColumnLines = table.find(".dx-column-lines").length > 0;
    return hasColumnLines === this.option("showColumnLines");
  }
  _isColumnElementsEqual($columns, $virtualColumns) {
    let result2 = $columns.length === $virtualColumns.length;
    if (result2) {
      each($columns, ((index, element) => {
        if (element.style.width !== $virtualColumns[index].style.width) {
          result2 = false;
          return result2;
        }
        return;
      }));
    }
    return result2;
  }
  _getCellClasses(column) {
    const classes = [];
    const {
      cssClass
    } = column;
    const isExpandColumn = "expand" === column.command;
    cssClass && classes.push(cssClass);
    isExpandColumn && classes.push(this.addWidgetPrefix("group-space"));
    return classes;
  }
  _findBottomLoadPanel($contentElement) {
    const $element = $contentElement || this.element();
    const $bottomLoadPanel = $element && $element.find(`.${this.addWidgetPrefix("bottom-load-panel")}`);
    if ($bottomLoadPanel && $bottomLoadPanel.length) {
      return $bottomLoadPanel;
    }
  }
  _updateBottomLoading() {
    const that = this;
    const virtualMode = isVirtualMode2(this);
    const appendMode = isAppendMode2(this);
    const showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode);
    const $contentElement = that._findContentElement();
    const bottomLoadPanelElement = that._findBottomLoadPanel($contentElement);
    if (showBottomLoading) {
      if (!bottomLoadPanelElement) {
        renderer_default("<div>").addClass(that.addWidgetPrefix("bottom-load-panel")).append(that._createComponent(renderer_default("<div>"), load_indicator_default, {
          elementAttr: {
            role: null,
            "aria-label": null
          }
        }).$element()).appendTo($contentElement);
      }
    } else if (bottomLoadPanelElement) {
      bottomLoadPanelElement.remove();
    }
  }
  _handleScroll(e) {
    const legacyScrollingMode = true === this.option(LEGACY_SCROLLING_MODE3);
    const zeroTopPosition = 0 === e.scrollOffset.top;
    const isScrollTopChanged = this._scrollTop !== e.scrollOffset.top;
    const hasScrolled = isScrollTopChanged || e.forceUpdateScrollPosition;
    const isValidScrollTarget = this._hasHeight || !legacyScrollingMode && zeroTopPosition;
    if (hasScrolled && isValidScrollTarget && this._rowHeight) {
      this._scrollTop = e.scrollOffset.top;
      const isVirtualRowRendering = isVirtualMode2(this) || "standard" !== this.option("scrolling.rowRenderingMode");
      if (isVirtualRowRendering && false === this.option(LEGACY_SCROLLING_MODE3)) {
        this._updateContentItemSizes();
        this._updateViewportSize(null, this._scrollTop);
      }
      this._dataController.setViewportPosition(e.scrollOffset.top);
    }
    super._handleScroll.apply(this, arguments);
  }
  _needUpdateRowHeight(itemsCount) {
    return super._needUpdateRowHeight.apply(this, arguments) || itemsCount > 0 && isAppendMode2(this) && !m_utils_default.isVirtualRowRendering(this);
  }
  _updateRowHeight() {
    super._updateRowHeight.apply(this, arguments);
    if (this._rowHeight) {
      this._updateContentPosition();
      const viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
      if (false === this.option(LEGACY_SCROLLING_MODE3)) {
        this._updateViewportSize(viewportHeight);
        this._dataController.updateViewport();
      } else {
        this._dataController.viewportSize(Math.ceil(viewportHeight / this._rowHeight));
      }
    }
  }
  updateFreeSpaceRowHeight() {
    const result2 = super.updateFreeSpaceRowHeight.apply(this, arguments);
    if (result2) {
      this._updateContentPosition();
    }
    return result2;
  }
  setLoading(isLoading, messageText) {
    const dataController2 = this._dataController;
    const hasBottomLoadPanel = dataController2.pageIndex() > 0 && dataController2.isLoaded() && !!this._findBottomLoadPanel();
    if (false === this.option(LEGACY_SCROLLING_MODE3) && isLoading && dataController2.isViewportChanging()) {
      return;
    }
    if (hasBottomLoadPanel) {
      isLoading = false;
    }
    super.setLoading.call(this, isLoading, messageText);
  }
  isGridDragging() {
    return this.component.option("isDragging");
  }
  throwHeightWarningIfNeed() {
    const isGridDragging = this.isGridDragging();
    if (void 0 === this._hasHeight || isGridDragging) {
      return;
    }
    const needToThrow = !this._hasHeight && isVirtualPaging(this);
    if (needToThrow && !this._heightWarningIsThrown) {
      this._heightWarningIsThrown = true;
      ui_errors_default.log("W1025");
    }
  }
  _resizeCore() {
    const that = this;
    const $element = that.element();
    super._resizeCore();
    this.throwHeightWarningIfNeed();
    if (that.component.$element() && !that._windowScroll && isElementInDom($element)) {
      that._windowScroll = subscribeToExternalScrollers($element, ((scrollPos) => {
        if (!that._hasHeight && that._rowHeight) {
          that._dataController.setViewportPosition(scrollPos);
        }
      }), that.component.$element());
      that.on("disposing", (() => {
        that._windowScroll.dispose();
      }));
    }
    if (false !== this.option(LEGACY_SCROLLING_MODE3)) {
      that.loadIfNeed();
    }
  }
  loadIfNeed() {
    var _this$_dataController2, _this$_dataController3;
    null === (_this$_dataController2 = this._dataController) || void 0 === _this$_dataController2 || null === (_this$_dataController3 = _this$_dataController2.loadIfNeed) || void 0 === _this$_dataController3 || _this$_dataController3.call(_this$_dataController2);
  }
  _restoreErrorRow(contentTable) {
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      var _this$_errorHandlingC;
      null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || _this$_errorHandlingC.removeErrorRow();
    }
    super._restoreErrorRow.apply(this, arguments);
  }
};
var virtualScrollingModule = {
  defaultOptions: () => ({
    scrolling: {
      timeout: 300,
      updateTimeout: 300,
      minTimeout: 0,
      renderingThreshold: 100,
      removeInvisiblePages: true,
      rowPageSize: 5,
      prerenderedRowChunkSize: 1,
      mode: "standard",
      preloadEnabled: false,
      rowRenderingMode: "standard",
      loadTwoPagesOnStart: false,
      legacyMode: false,
      prerenderedRowCount: 1
    }
  }),
  extenders: {
    controllers: {
      data: data7,
      resizing: resizing3
    },
    views: {
      rowsView: rowsView7
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_scrolling.js
m_core_default.registerModule("virtualScrolling", virtualScrollingModule);
m_data_source_adapter_default.extend(dataSourceAdapterExtender2);

// node_modules/devextreme/esm/__internal/ui/overlay/m_utils.js
var getElementMaxHeightByWindow = ($element, startLocation) => {
  const $window = renderer_default(m_window_default.getWindow());
  const {
    top: elementOffset
  } = $element.offset();
  let actualOffset;
  if (isNumeric(startLocation)) {
    if (startLocation < elementOffset) {
      return elementOffset - startLocation;
    }
    actualOffset = getInnerHeight($window) - startLocation + $window.scrollTop();
  } else {
    const offsetTop = elementOffset - $window.scrollTop();
    const offsetBottom = getInnerHeight($window) - offsetTop - getOuterHeight($element);
    actualOffset = Math.max(offsetTop, offsetBottom);
  }
  return 0.9 * actualOffset;
};

// node_modules/devextreme/esm/__internal/ui/menu/m_submenu.js
var Submenu = class extends m_context_menu_default {
  _getMaxUsableSpace(offsetTop, windowHeight, anchorHeight) {
    return Math.max(offsetTop, windowHeight - offsetTop - anchorHeight);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      orientation: "horizontal",
      tabIndex: null,
      onHoverStart: noop
    });
  }
  _initDataAdapter() {
    this._dataAdapter = this.option("_dataAdapter");
    if (!this._dataAdapter) {
      super._initDataAdapter();
    }
  }
  _renderContentImpl() {
    this._renderContextMenuOverlay();
    super._renderContentImpl();
    const node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
    node && this._renderItems(this._getChildNodes(node));
    this._renderDelimiter();
  }
  _renderDelimiter() {
    this.$contentDelimiter = renderer_default("<div>").appendTo(this._itemContainer()).addClass("dx-context-menu-content-delimiter");
  }
  _getOverlayOptions() {
    return extend(true, super._getOverlayOptions(), {
      onPositioned: this._overlayPositionedActionHandler.bind(this),
      position: {
        precise: true
      }
    });
  }
  _overlayPositionedActionHandler(arg) {
    this._showDelimiter(arg);
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    this._toggleFocusClass(false, e.currentTarget);
  }
  _isMenuHorizontal() {
    return "horizontal" === this.option("orientation");
  }
  _hoverStartHandler(e) {
    const hoverStartAction = this.option("onHoverStart");
    hoverStartAction(e);
    super._hoverStartHandler(e);
    this._toggleFocusClass(true, e.currentTarget);
  }
  _drawSubmenu($rootItem) {
    this._actions.onShowing({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._drawSubmenu($rootItem);
    this._actions.onShown({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _hideSubmenu($rootItem) {
    this._actions.onHiding({
      cancel: true,
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._hideSubmenu($rootItem);
    this._actions.onHidden({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _showDelimiter(arg) {
    if (!this.$contentDelimiter) {
      return;
    }
    const $submenu = this._itemContainer().children(".dx-submenu").eq(0);
    const $rootItem = this.option("position").of.find(".dx-context-menu-container-border");
    const position2 = {
      of: $submenu,
      precise: true
    };
    const containerOffset = arg.position;
    const vLocation = containerOffset.v.location;
    const hLocation = containerOffset.h.location;
    const rootOffset = $rootItem.offset();
    const offsetLeft = Math.round(rootOffset.left);
    const offsetTop = Math.round(rootOffset.top);
    const rootWidth = getWidth($rootItem);
    const rootHeight = getHeight($rootItem);
    const submenuWidth = getWidth($submenu);
    const submenuHeight = getHeight($submenu);
    this.$contentDelimiter.css("display", "block");
    setWidth(this.$contentDelimiter, this._isMenuHorizontal() ? rootWidth < submenuWidth ? rootWidth : submenuWidth : 3);
    setHeight(this.$contentDelimiter, this._isMenuHorizontal() ? 3 : rootHeight < submenuHeight ? rootHeight : submenuHeight);
    if (this._isMenuHorizontal()) {
      if (vLocation > offsetTop) {
        if (Math.round(hLocation) === offsetLeft) {
          position2.offset = "0 -2.5";
          position2.at = position2.my = "left top";
        } else {
          position2.offset = "0 -2.5";
          position2.at = position2.my = "right top";
        }
      } else {
        setHeight(this.$contentDelimiter, 5);
        if (Math.round(hLocation) === offsetLeft) {
          position2.offset = "0 5";
          position2.at = position2.my = "left bottom";
        } else {
          position2.offset = "0 5";
          position2.at = position2.my = "right bottom";
        }
      }
    } else if (hLocation > offsetLeft) {
      if (Math.round(vLocation) === offsetTop) {
        position2.offset = "-2.5 0";
        position2.at = position2.my = "left top";
      } else {
        position2.offset = "-2.5 0";
        position2.at = position2.my = "left bottom";
      }
    } else if (Math.round(vLocation) === offsetTop) {
      position2.offset = "2.5 0";
      position2.at = position2.my = "right top";
    } else {
      position2.offset = "2.5 0";
      position2.at = position2.my = "right bottom";
    }
    position_default.setup(this.$contentDelimiter, position2);
  }
  _getContextMenuPosition() {
    return this.option("position");
  }
  isOverlayVisible() {
    return this._overlay.option("visible");
  }
  getOverlayContent() {
    return this._overlay.$content();
  }
};
var m_submenu_default = Submenu;

// node_modules/devextreme/esm/__internal/ui/menu/m_menu.js
var DX_ADAPTIVE_MODE_CLASS = "dx-menu-adaptive-mode";
var DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = `${DX_ADAPTIVE_MODE_CLASS}-overlay-wrapper`;
var DEFAULT_DELAY2 = {
  show: 50,
  hide: 300
};
var ACTIONS2 = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
var Menu = class extends m_menu_base_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      orientation: "horizontal",
      submenuDirection: "auto",
      showFirstSubmenuMode: {
        name: "onClick",
        delay: {
          show: 50,
          hide: 300
        }
      },
      hideSubmenuOnMouseLeave: false,
      onSubmenuShowing: null,
      onSubmenuShown: null,
      onSubmenuHiding: null,
      onSubmenuHidden: null,
      adaptivityEnabled: false
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _itemElements() {
    const rootMenuElements = super._itemElements();
    const submenuElements = this._submenuItemElements();
    return rootMenuElements.add(submenuElements);
  }
  _submenuItemElements() {
    let elements = [];
    const currentSubmenu = this._submenus.length && this._submenus[0];
    if (currentSubmenu && currentSubmenu.itemsContainer()) {
      elements = currentSubmenu.itemsContainer().find(".dx-menu-item");
    }
    return elements;
  }
  _focusTarget() {
    return this.$element();
  }
  _isMenuHorizontal() {
    return "horizontal" === this.option("orientation");
  }
  _moveFocus(location) {
    const $items = this._getAvailableItems();
    const isMenuHorizontal = this._isMenuHorizontal();
    const $activeItem = this._getActiveItem(true);
    let argument;
    let operation;
    let navigationAction;
    let $newTarget;
    switch (location) {
      case "up":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("prevItem");
        argument = isMenuHorizontal ? $activeItem : $items;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "down":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("nextItem");
        argument = isMenuHorizontal ? $activeItem : $items;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "right":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("nextItem") : "showSubmenu";
        argument = isMenuHorizontal ? $items : $activeItem;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "left":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("prevItem") : "showSubmenu";
        argument = isMenuHorizontal ? $items : $activeItem;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      default:
        return super._moveFocus(location);
    }
    if ($newTarget && 0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getItemsNavigationOperation(operation) {
    let navOperation = operation;
    if (this.option("rtlEnabled")) {
      navOperation = "prevItem" === operation ? "nextItem" : "prevItem";
    }
    return navOperation;
  }
  _getKeyboardNavigationAction(operation, argument) {
    let action = noop;
    switch (operation) {
      case "showSubmenu":
        if (!argument.hasClass("dx-state-disabled")) {
          action = this._showSubmenu.bind(this, argument);
        }
        break;
      case "nextItem":
        action = this._nextItem.bind(this, argument);
        break;
      case "prevItem":
        action = this._prevItem.bind(this, argument);
    }
    return action;
  }
  _clean() {
    super._clean();
    this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer);
  }
  _visibilityChanged(visible) {
    if (visible) {
      if (!this._menuItemsWidth) {
        this._updateItemsWidthCache();
      }
      this._dimensionChanged();
    }
  }
  _isAdaptivityEnabled() {
    return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation");
  }
  _updateItemsWidthCache() {
    const $menuItems = this.$element().find("ul").first().children("li").children(".dx-menu-item");
    this._menuItemsWidth = this._getSummaryItemsSize("width", $menuItems, true);
  }
  _dimensionChanged() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    const containerWidth = getOuterWidth(this.$element());
    this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth);
  }
  _init() {
    super._init();
    this._submenus = [];
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS2, ((index, action) => {
      this._actions[action] = this._createActionByOption(action);
    }));
  }
  _initMarkup() {
    this._visibleSubmenu = null;
    this.$element().addClass("dx-menu");
    super._initMarkup();
    this._addCustomCssClass(this.$element());
    this.setAria("role", "menubar");
  }
  _setAriaRole(state) {
    const role = this._isAdaptivityEnabled() && state ? void 0 : "menubar";
    this.setAria({
      role
    });
  }
  _render() {
    super._render();
    this._initAdaptivity();
  }
  _isTargetOutOfComponent(relatedTarget) {
    const isInsideRootMenu = 0 !== renderer_default(relatedTarget).closest(".dx-menu").length;
    const isInsideContextMenu = 0 !== renderer_default(relatedTarget).closest(".dx-context-menu").length;
    const isTargetOutOfComponent = !(isInsideRootMenu || isInsideContextMenu);
    return isTargetOutOfComponent;
  }
  _focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    if (relatedTarget) {
      const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
      if (isTargetOutside) {
        this._hideVisibleSubmenu();
      }
    }
    super._focusOutHandler(e);
  }
  _renderHamburgerButton() {
    this._hamburger = new button_default2(renderer_default("<div>").addClass("dx-menu-hamburger-button"), {
      icon: "menu",
      activeStateEnabled: false,
      onClick: this._toggleTreeView.bind(this)
    });
    return this._hamburger.$element();
  }
  _toggleTreeView(state) {
    if (isPlainObject(state)) {
      state = !this._overlay.option("visible");
    }
    this._overlay.option("visible", state);
    if (state) {
      this._treeView.focus();
    }
    this._toggleHamburgerActiveState(state);
  }
  _toggleHamburgerActiveState(state) {
    this._hamburger && this._hamburger.$element().toggleClass("dx-state-active", state);
  }
  _toggleAdaptiveMode(state) {
    const $menuItemsContainer = this.$element().find(".dx-menu-horizontal");
    const $adaptiveElements = this.$element().find(`.${DX_ADAPTIVE_MODE_CLASS}`);
    if (state) {
      this._hideVisibleSubmenu();
    } else {
      this._treeView && this._treeView.collapseAll();
      this._overlay && this._toggleTreeView(state);
    }
    this._setAriaRole(state);
    $menuItemsContainer.toggle(!state);
    $adaptiveElements.toggle(state);
  }
  _removeAdaptivity() {
    if (!this._$adaptiveContainer) {
      return;
    }
    this._toggleAdaptiveMode(false);
    this._$adaptiveContainer.remove();
    this._$adaptiveContainer = null;
    this._treeView = null;
    this._hamburger = null;
    this._overlay = null;
  }
  _treeviewItemClickHandler(e) {
    this._actions.onItemClick(e);
    if (!e.node.children.length) {
      this._toggleTreeView(false);
    }
  }
  _getAdaptiveOverlayOptions() {
    const rtl = this.option("rtlEnabled");
    const position2 = rtl ? "right" : "left";
    return {
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(this.$element()),
      deferRendering: false,
      shading: false,
      animation: false,
      hideOnParentScroll: true,
      onHidden: () => {
        this._toggleHamburgerActiveState(false);
      },
      height: "auto",
      hideOnOutsideClick: (e) => !renderer_default(e.target).closest(".dx-menu-hamburger-button").length,
      position: {
        collision: "flipfit",
        at: `bottom ${position2}`,
        my: `top ${position2}`,
        of: this._hamburger.$element()
      }
    };
  }
  _getTreeViewOptions() {
    const menuOptions = {};
    each(["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"], ((_, option) => {
      menuOptions[option] = this.option(option);
    }));
    each(["onItemContextMenu", "onSelectionChanged", "onItemRendered"], ((_, actionName) => {
      menuOptions[actionName] = (e) => {
        this._actions[actionName](e);
      };
    }));
    return extend(menuOptions, {
      dataSource: this.getDataSource(),
      animationEnabled: !!this.option("animation"),
      onItemClick: this._treeviewItemClickHandler.bind(this),
      onItemExpanded: (e) => {
        this._overlay.repaint();
        this._actions.onSubmenuShown(e);
      },
      onItemCollapsed: (e) => {
        this._overlay.repaint();
        this._actions.onSubmenuHidden(e);
      },
      selectNodesRecursive: false,
      selectByClick: this.option("selectByClick"),
      expandEvent: "click",
      _supportItemUrl: true
    });
  }
  _initAdaptivity() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    this._$adaptiveContainer = renderer_default("<div>").addClass(DX_ADAPTIVE_MODE_CLASS);
    const $hamburger = this._renderHamburgerButton();
    this._treeView = this._createComponent(renderer_default("<div>"), tree_view_default, this._getTreeViewOptions());
    this._overlay = this._createComponent(renderer_default("<div>"), ui_overlay_default, this._getAdaptiveOverlayOptions());
    this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
    this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);
    this._$adaptiveContainer.append($hamburger);
    this._$adaptiveContainer.append(this._overlay.$element());
    this.$element().append(this._$adaptiveContainer);
    this._updateItemsWidthCache();
    this._dimensionChanged();
  }
  _getDelay(delayType) {
    const {
      delay
    } = this.option("showFirstSubmenuMode");
    if (!isDefined(delay)) {
      return DEFAULT_DELAY2[delayType];
    }
    return isObject(delay) ? delay[delayType] : delay;
  }
  _keyboardHandler(e) {
    return super._keyboardHandler(e, !!this._visibleSubmenu);
  }
  _renderContainer() {
    const $wrapper = renderer_default("<div>");
    $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? "dx-menu-horizontal" : "dx-menu-vertical");
    return super._renderContainer($wrapper);
  }
  _renderSubmenuItems(node, $itemFrame) {
    const submenu = this._createSubmenu(node, $itemFrame);
    this._submenus.push(submenu);
    this._renderBorderElement($itemFrame);
    return submenu;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat(this._visibleSubmenu);
  }
  _createSubmenu(node, $rootItem) {
    const $submenuContainer = renderer_default("<div>").addClass("dx-context-menu").appendTo($rootItem);
    const items = this._getChildNodes(node);
    const subMenu = this._createComponent($submenuContainer, m_submenu_default, extend(this._getSubmenuOptions(), {
      _dataAdapter: this._dataAdapter,
      _parentKey: node.internalFields.key,
      items,
      onHoverStart: this._clearTimeouts.bind(this),
      position: this.getSubmenuPosition($rootItem)
    }));
    this._attachSubmenuHandlers($rootItem, subMenu);
    return subMenu;
  }
  _getSubmenuOptions() {
    const $submenuTarget = renderer_default("<div>");
    const isMenuHorizontal = this._isMenuHorizontal();
    return {
      itemTemplate: this.option("itemTemplate"),
      target: $submenuTarget,
      orientation: this.option("orientation"),
      selectionMode: this.option("selectionMode"),
      cssClass: this.option("cssClass"),
      selectByClick: this.option("selectByClick"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      showSubmenuMode: this.option("showSubmenuMode"),
      displayExpr: this.option("displayExpr"),
      disabledExpr: this.option("disabledExpr"),
      selectedExpr: this.option("selectedExpr"),
      itemsExpr: this.option("itemsExpr"),
      onFocusedItemChanged: (e) => {
        if (!e.component.option("visible")) {
          return;
        }
        this.option("focusedElement", e.component.option("focusedElement"));
      },
      onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
      onItemClick: this._nestedItemOnItemClickHandler.bind(this),
      onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
      onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "prevItem"),
      onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "nextItem"),
      onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? "prevItem" : null),
      onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, "nextItem") : null
    };
  }
  _getShowFirstSubmenuMode() {
    if (!this._isDesktopDevice()) {
      return "onClick";
    }
    const optionValue = this.option("showFirstSubmenuMode");
    return isObject(optionValue) ? optionValue.name : optionValue;
  }
  _moveMainMenuFocus(direction) {
    const $items = this._getAvailableItems();
    const itemCount = $items.length;
    const $currentItem = $items.filter(".dx-menu-item-expanded").eq(0);
    let itemIndex = $items.index($currentItem);
    this._hideSubmenu(this._visibleSubmenu);
    itemIndex += "prevItem" === direction ? -1 : 1;
    if (itemIndex >= itemCount) {
      itemIndex = 0;
    } else if (itemIndex < 0) {
      itemIndex = itemCount - 1;
    }
    const $newItem = $items.eq(itemIndex);
    this.option("focusedElement", getPublicElement($newItem));
  }
  _nestedItemOnSelectionChangedHandler(args) {
    const selectedItem = args.addedItems.length && args.addedItems[0];
    const submenu = m_submenu_default.getInstance(args.element);
    const {
      onSelectionChanged
    } = this._actions;
    onSelectionChanged(args);
    selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
    this._clearRootSelection();
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
  }
  _clearSelectionInSubmenus(item, targetSubmenu) {
    const cleanAllSubmenus = !arguments.length;
    each(this._submenus, ((index, submenu) => {
      const $submenu = submenu._itemContainer();
      const isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer());
      const $selectedItem = $submenu.find(`.${this._selectedItemClass()}`);
      if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
        $selectedItem.removeClass(this._selectedItemClass());
        const selectedItemData = this._getItemData($selectedItem);
        if (selectedItemData) {
          selectedItemData.selected = false;
        }
        submenu._clearSelectedItems();
      }
    }));
  }
  _clearRootSelection() {
    const $prevSelectedItem = this.$element().find(".dx-menu-items-container").first().children().children().filter(`.${this._selectedItemClass()}`);
    if ($prevSelectedItem.length) {
      const prevSelectedItemData = this._getItemData($prevSelectedItem);
      prevSelectedItemData.selected = false;
      $prevSelectedItem.removeClass(this._selectedItemClass());
    }
  }
  _nestedItemOnItemClickHandler(e) {
    this._actions.onItemClick(e);
  }
  _nestedItemOnItemRenderedHandler(e) {
    this._actions.onItemRendered(e);
  }
  _attachSubmenuHandlers($menuAnchorItem, submenu) {
    const $submenuOverlayContent = submenu.getOverlayContent();
    const submenus = $submenuOverlayContent.find(".dx-submenu");
    const submenuMouseLeaveName = addNamespace(HOVEREND, `${this.NAME}_submenu`);
    submenu.option({
      onShowing: this._submenuOnShowingHandler.bind(this, $menuAnchorItem, submenu),
      onShown: this._submenuOnShownHandler.bind(this, $menuAnchorItem, submenu),
      onHiding: this._submenuOnHidingHandler.bind(this, $menuAnchorItem, submenu),
      onHidden: this._submenuOnHiddenHandler.bind(this, $menuAnchorItem, submenu)
    });
    each(submenus, ((index, submenu2) => {
      m_events_engine_default.off(submenu2, submenuMouseLeaveName);
      m_events_engine_default.on(submenu2, submenuMouseLeaveName, null, this._submenuMouseLeaveHandler.bind(this, $menuAnchorItem));
    }));
  }
  _submenuOnShowingHandler($menuAnchorItem, submenu, _ref) {
    let {
      rootItem
    } = _ref;
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    this._actions.onSubmenuShowing(params);
    $border.show();
    $menuAnchorItem.addClass("dx-menu-item-expanded");
  }
  _submenuOnShownHandler($menuAnchorItem, submenu, _ref2) {
    let {
      rootItem
    } = _ref2;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    this._actions.onSubmenuShown(params);
  }
  _submenuOnHidingHandler($menuAnchorItem, submenu, eventArgs) {
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(eventArgs.rootItem, submenu, $menuAnchorItem, true);
    eventArgs.itemData = params.itemData;
    eventArgs.rootItem = params.rootItem;
    eventArgs.submenuContainer = params.submenuContainer;
    eventArgs.submenu = params.submenu;
    this._actions.onSubmenuHiding(eventArgs);
    const {
      focusedElement
    } = this.option();
    const {
      focusedElement: submenuFocusedElement
    } = submenu.option();
    const isVisibleSubmenuHiding = this._visibleSubmenu === submenu;
    const isFocusedElementHiding = focusedElement === submenuFocusedElement;
    if (isVisibleSubmenuHiding && isFocusedElementHiding) {
      this.option("focusedElement", $menuAnchorItem);
    }
    if (!eventArgs.cancel) {
      if (isVisibleSubmenuHiding) {
        this._visibleSubmenu = null;
      }
      $border.hide();
      $menuAnchorItem.removeClass("dx-menu-item-expanded");
    }
  }
  _submenuOnHiddenHandler($menuAnchorItem, submenu, _ref3) {
    let {
      rootItem
    } = _ref3;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem, true);
    this._actions.onSubmenuHidden(params);
  }
  _getVisibilityChangeEventParams(submenuItem, submenu, $menuAnchorItem, isHide) {
    let itemData;
    let $submenuContainer;
    if (submenuItem) {
      const anchor = isHide ? renderer_default(submenuItem).closest(".dx-menu-item")[0] : submenuItem;
      itemData = this._getItemData(anchor);
      $submenuContainer = renderer_default(anchor).find(".dx-submenu").first();
    } else {
      const $overlayContent = renderer_default(submenu._overlay.content());
      itemData = this._getItemData($menuAnchorItem);
      $submenuContainer = $overlayContent.find(".dx-submenu").first();
    }
    return {
      itemData,
      rootItem: getPublicElement($menuAnchorItem),
      submenuContainer: getPublicElement($submenuContainer),
      submenu
    };
  }
  _submenuMouseLeaveHandler($rootItem, eventArgs) {
    const target = renderer_default(eventArgs.relatedTarget).parents(".dx-context-menu")[0];
    const contextMenu2 = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
    if (this.option("hideSubmenuOnMouseLeave") && target !== contextMenu2) {
      this._clearTimeouts();
      setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
    }
  }
  _hideSubmenuAfterTimeout() {
    if (!this._visibleSubmenu) {
      return;
    }
    const isRootItemHovered = renderer_default(this._visibleSubmenu.$element().context).hasClass("dx-state-hover");
    const isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find(".dx-state-hover").length;
    const hoveredElementFromSubMenu = this._visibleSubmenu.getOverlayContent().get(0).querySelector(":hover");
    if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {
      this._visibleSubmenu.hide();
    }
  }
  _getSubmenuByRootElement($rootItem) {
    if (!$rootItem) {
      return false;
    }
    const $submenu = $rootItem.children(".dx-context-menu");
    return $submenu.length && m_submenu_default.getInstance($submenu);
  }
  getSubmenuPosition($rootItem) {
    const isHorizontalMenu = this._isMenuHorizontal();
    const submenuDirection = this.option("submenuDirection").toLowerCase();
    const rtlEnabled = this.option("rtlEnabled");
    const submenuPosition = {
      collision: "flip",
      of: $rootItem,
      precise: true
    };
    switch (submenuDirection) {
      case "leftortop":
        submenuPosition.at = "left top";
        submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
        break;
      case "rightorbottom":
        submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
        submenuPosition.my = "left top";
        break;
      default:
        if (isHorizontalMenu) {
          submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        } else {
          submenuPosition.at = rtlEnabled ? "left top" : "right top";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        }
    }
    return submenuPosition;
  }
  _renderBorderElement($item) {
    renderer_default("<div>").appendTo($item).addClass("dx-context-menu-container-border").hide();
  }
  _itemPointerHandler(e) {
    const $target = renderer_default(e.target);
    const $closestItem = $target.closest(this._itemElements());
    if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
      this.option("focusedElement", null);
      return;
    }
    super._itemPointerHandler(e);
  }
  _hoverStartHandler(e) {
    const mouseMoveEventName = addNamespace(m_pointer_default.move, this.NAME);
    const $item = this._getItemElementByEventArgs(e);
    const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    const isSelectionActive = isDefined(e.buttons) && 1 === e.buttons || !isDefined(e.buttons) && 1 === e.which;
    if (this._isItemDisabled($item)) {
      return;
    }
    m_events_engine_default.off($item, mouseMoveEventName);
    if (!this._hasChildren(node)) {
      this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
      return;
    }
    if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
      const submenu = this._getSubmenuByElement($item);
      this._clearTimeouts();
      if (!submenu.isOverlayVisible()) {
        m_events_engine_default.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
        this._showSubmenuTimer = this._getDelay("hide");
      }
    }
  }
  _hoverEndHandler(eventArg) {
    const $item = this._getItemElementByEventArgs(eventArg);
    const relatedTarget = renderer_default(eventArg.relatedTarget);
    super._hoverEndHandler(eventArg);
    this._clearTimeouts();
    if (this._isItemDisabled($item)) {
      return;
    }
    if (relatedTarget.hasClass("dx-context-menu-content-delimiter")) {
      return;
    }
    if (this.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass("dx-menu-items-container")) {
      this._hideSubmenuTimer = setTimeout((() => {
        this._hideSubmenuAfterTimeout();
      }), this._getDelay("hide"));
    }
  }
  _hideVisibleSubmenu() {
    if (!this._visibleSubmenu) {
      return false;
    }
    this._hideSubmenu(this._visibleSubmenu);
    return true;
  }
  _showSubmenu($itemElement) {
    const submenu = this._getSubmenuByElement($itemElement);
    if (this._visibleSubmenu !== submenu) {
      this._hideVisibleSubmenu();
    }
    if (submenu) {
      this._clearTimeouts();
      this.focus();
      submenu.show();
      this.option("focusedElement", submenu.option("focusedElement"));
    }
    this._visibleSubmenu = submenu;
    this._hoveredRootItem = $itemElement;
  }
  _hideSubmenu(submenu) {
    if (submenu) {
      submenu.hide();
    }
    if (this._visibleSubmenu === submenu) {
      this._visibleSubmenu = null;
    }
    this._hoveredRootItem = null;
  }
  _itemMouseMoveHandler(e) {
    if (e.pointers && e.pointers.length) {
      return;
    }
    const $item = renderer_default(e.currentTarget);
    if (!isDefined(this._showSubmenuTimer)) {
      return;
    }
    this._clearTimeouts();
    this._showSubmenuTimer = setTimeout((() => {
      const submenu = this._getSubmenuByElement($item);
      if (submenu && !submenu.isOverlayVisible()) {
        this._showSubmenu($item);
      }
    }), this._getDelay("show"));
  }
  _clearTimeouts() {
    clearTimeout(this._hideSubmenuTimer);
    clearTimeout(this._showSubmenuTimer);
  }
  _getSubmenuByElement($itemElement, itemData) {
    const submenu = this._getSubmenuByRootElement($itemElement);
    if (submenu) {
      return submenu;
    }
    itemData = itemData ?? this._getItemData($itemElement);
    const node = this._dataAdapter.getNodeByItem(itemData);
    return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement);
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    const args = actionArgs.args.length && actionArgs.args[0];
    if (!args || this._disabledGetter(args.itemData)) {
      return;
    }
    const $itemElement = renderer_default(args.itemElement);
    const currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);
    this._updateSelectedItemOnClick(actionArgs);
    if (this._visibleSubmenu) {
      if (this._visibleSubmenu === currentSubmenu) {
        if ("onClick" === this.option("showFirstSubmenuMode")) {
          this._hideSubmenu(this._visibleSubmenu);
        }
        return;
      }
      this._hideSubmenu(this._visibleSubmenu);
    }
    if (!currentSubmenu) {
      return;
    }
    if (!currentSubmenu.isOverlayVisible()) {
      this._showSubmenu($itemElement);
    }
  }
  _optionChanged(args) {
    if (ACTIONS2.includes(args.name)) {
      this._initActions();
      return;
    }
    switch (args.name) {
      case "orientation":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showFirstSubmenuMode":
      case "hideSubmenuOnMouseLeave":
        break;
      case "showSubmenuMode":
        this._changeSubmenusOption(args.name, args.value);
        break;
      case "adaptivityEnabled":
        args.value ? this._initAdaptivity() : this._removeAdaptivity();
        break;
      case "width":
        if (this._isAdaptivityEnabled()) {
          this._treeView.option(args.name, args.value);
          this._overlay.option(args.name, args.value);
        }
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "animation":
        if (this._isAdaptivityEnabled()) {
          this._treeView.option("animationEnabled", !!args.value);
        }
        super._optionChanged(args);
        break;
      default:
        if (this._isAdaptivityEnabled() && (args.name === args.fullName || "items" === args.name)) {
          this._treeView.option(args.fullName, args.value);
        }
        super._optionChanged(args);
    }
  }
  _changeSubmenusOption(name2, value2) {
    each(this._submenus, ((index, submenu) => {
      submenu.option(name2, value2);
    }));
  }
  selectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.selectItem(itemElement);
  }
  unselectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.unselectItem(itemElement);
  }
};
component_registrator_default("dxMenu", Menu);
var m_menu_default = Menu;

// node_modules/devextreme/esm/ui/menu.js
var menu_default = m_menu_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_row.js
var OPERATION_ICONS = {
  "=": "filter-operation-equals",
  "<>": "filter-operation-not-equals",
  "<": "filter-operation-less",
  "<=": "filter-operation-less-equal",
  ">": "filter-operation-greater",
  ">=": "filter-operation-greater-equal",
  default: "filter-operation-default",
  notcontains: "filter-operation-not-contains",
  contains: "filter-operation-contains",
  startswith: "filter-operation-starts-with",
  endswith: "filter-operation-ends-with",
  between: "filter-operation-between"
};
var OPERATION_DESCRIPTORS = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  between: "between"
};
var FILTER_MENU = "dx-filter-menu";
var EDITORS_INPUT_SELECTOR2 = "input:not([type='hidden'])";
var BETWEEN_OPERATION_DATA_TYPES = ["date", "datetime", "number"];
function isOnClickApplyFilterMode(that) {
  return "onClick" === that.option("filterRow.applyFilter");
}
var getEditorInstance = function($editorContainer) {
  const $editor = $editorContainer && $editorContainer.children();
  const componentNames = $editor && $editor.data("dxComponents");
  const editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
  if (editor instanceof editor_default2) {
    return editor;
  }
  return null;
};
var getRangeTextByFilterValue = function(that, column) {
  let result2 = "";
  let rangeEnd = "";
  const filterValue = getColumnFilterValue(that, column);
  const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "filterRow");
  if (Array.isArray(filterValue)) {
    result2 = m_utils_default.formatValue(filterValue[0], formatOptions);
    rangeEnd = m_utils_default.formatValue(filterValue[1], formatOptions);
    if ("" !== rangeEnd) {
      result2 += ` - ${rangeEnd}`;
    }
  } else if (isDefined(filterValue)) {
    result2 = m_utils_default.formatValue(filterValue, formatOptions);
  }
  return result2;
};
function getColumnFilterValue(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue;
  }
}
var getColumnSelectedFilterOperation = function(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation;
  }
};
var isValidFilterValue = function(filterValue, column) {
  if (column && BETWEEN_OPERATION_DATA_TYPES.includes(column.dataType) && Array.isArray(filterValue)) {
    return false;
  }
  return void 0 !== filterValue;
};
var getFilterValue2 = function(that, columnIndex, $editorContainer) {
  const column = that._columnsController.columnOption(columnIndex);
  const filterValue = getColumnFilterValue(that, column);
  const isFilterRange = $editorContainer.closest(`.${that.addWidgetPrefix("filter-range-overlay")}`).length;
  const isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"));
  if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
    if (isRangeStart) {
      return filterValue[0];
    }
    return filterValue[1];
  }
  return !isFilterRange && isValidFilterValue(filterValue, column) ? filterValue : null;
};
var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
  if ("between" === getColumnSelectedFilterOperation(that, column)) {
    const columnFilterValue = getColumnFilterValue(that, column);
    if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
      return [filterValue, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0];
    }
    return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue];
  }
  return filterValue;
};
var updateFilterValue = function(that, options2) {
  const value2 = "" === options2.value ? null : options2.value;
  const $editorContainer = options2.container;
  const column = that._columnsController.columnOption(options2.column.index);
  const filterValue = getFilterValue2(that, column.index, $editorContainer);
  if (!isDefined(filterValue) && !isDefined(value2)) {
    return;
  }
  that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value2);
  const columnOptionName = isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue";
  const normalizedValue = normalizeFilterValue(that, value2, column, $editorContainer);
  const isBetween = "between" === getColumnSelectedFilterOperation(that, column);
  const notFireEvent = options2.notFireEvent || isBetween && Array.isArray(normalizedValue) && normalizedValue.includes(void 0);
  that._columnsController.columnOption(column.index, columnOptionName, normalizedValue, notFireEvent);
};
var columnHeadersView3 = (Base) => class extends Base {
  init() {
    super.init();
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterRow":
      case "showColumnLines":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "syncLookupFilterValues":
        if (args.value) {
          this.updateLookupDataSource();
        } else {
          this.render();
        }
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _updateEditorValue(column, $editorContainer) {
    const editor = getEditorInstance($editorContainer);
    editor && editor.option("value", getFilterValue2(this, column.index, $editorContainer));
  }
  _columnOptionChanged(e) {
    const that = this;
    const {
      optionNames
    } = e;
    let $cell;
    let $editorContainer;
    let $editorRangeElements;
    let $menu;
    if (m_utils_default.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "filterValues", "filterType"]) && void 0 !== e.columnIndex) {
      const visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
      const column = that._columnsController.columnOption(e.columnIndex);
      $cell = that._getCellElement(that.element().find(`.${that.addWidgetPrefix("filter-row")}`).index(), visibleIndex) ?? renderer_default();
      $editorContainer = $cell.find(".dx-editor-container").first();
      if (optionNames.filterValue || optionNames.bufferedFilterValue) {
        that._updateEditorValue(column, $editorContainer);
        const overlayInstance = $cell.find(`.${that.addWidgetPrefix("filter-range-overlay")}`).data("dxOverlay");
        if (overlayInstance) {
          $editorRangeElements = overlayInstance.$content().find(".dx-editor-container");
          that._updateEditorValue(column, $editorRangeElements.first());
          that._updateEditorValue(column, $editorRangeElements.last());
        }
        if (!overlayInstance || !overlayInstance.option("visible")) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
        }
      }
      if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
        if (visibleIndex >= 0 && column) {
          $menu = $cell.find(".dx-menu");
          if ($menu.length) {
            that._updateFilterOperationChooser($menu, column, $editorContainer);
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
              that._renderFilterRangeContent($cell, column);
            } else if ($editorContainer.find(".dx-filter-range-content").length) {
              that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
              that._hideFilterRange();
            }
          }
        }
      }
      return;
    }
    super._columnOptionChanged(e);
  }
  _renderCore() {
    this._filterRangeOverlayInstance = null;
    return super._renderCore.apply(this, arguments);
  }
  _resizeCore() {
    var _this$_filterRangeOve;
    super._resizeCore.apply(this, arguments);
    null === (_this$_filterRangeOve = this._filterRangeOverlayInstance) || void 0 === _this$_filterRangeOve || _this$_filterRangeOve.repaint();
  }
  isFilterRowVisible() {
    return this._isElementVisible(this.option("filterRow"));
  }
  isVisible() {
    return super.isVisible() || this.isFilterRowVisible();
  }
  _initFilterRangeOverlay($cell, column) {
    const that = this;
    const sharedData = {};
    const $editorContainer = $cell.find(".dx-editor-container");
    const filterRangeOverlayClass = that.addWidgetPrefix("filter-range-overlay");
    const $overlay = renderer_default("<div>").addClass(filterRangeOverlayClass).appendTo($cell);
    return that._createComponent($overlay, ui_overlay_default, {
      height: "auto",
      shading: false,
      showTitle: false,
      focusStateEnabled: false,
      hideOnOutsideClick: true,
      hideOnParentScroll: true,
      _hideOnParentScrollTarget: $overlay,
      wrapperAttr: {
        class: filterRangeOverlayClass
      },
      animation: false,
      position: {
        my: "top",
        at: "top",
        of: $editorContainer.length && $editorContainer || $cell,
        offset: "0 -1"
      },
      contentTemplate(contentElement) {
        let editorOptions;
        let $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-start")}`).appendTo(contentElement);
        column = that._columnsController.columnOption(column.index);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", ((e) => {
          let $prevElement = $cell.find("[tabindex]").not(e.target).first();
          if ("tab" === normalizeKeyName(e) && e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            if (!$prevElement.length) {
              $prevElement = $cell.prev().find("[tabindex]").last();
            }
            m_events_engine_default.trigger($prevElement, "focus");
          }
        }));
        $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-end")}`).appendTo(contentElement);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", ((e) => {
          if ("tab" === normalizeKeyName(e) && !e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            m_events_engine_default.trigger($cell.next().find("[tabindex]").first(), "focus");
          }
        }));
        return renderer_default(contentElement).addClass(that.getWidgetContainerClass());
      },
      onShown(e) {
        const $editor = e.component.$content().find(".dx-editor-container").first();
        m_events_engine_default.trigger($editor.find(EDITORS_INPUT_SELECTOR2), "focus");
      },
      onHidden() {
        column = that._columnsController.columnOption(column.index);
        $cell.find(".dx-menu").parent().addClass("dx-editor-with-menu");
        if ("between" === getColumnSelectedFilterOperation(that, column)) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
          that.component.updateDimensions();
        }
      }
    });
  }
  _updateFilterRangeOverlay(options2) {
    const overlayInstance = this._filterRangeOverlayInstance;
    overlayInstance && overlayInstance.option(options2);
  }
  _showFilterRange($cell, column) {
    const that = this;
    const $overlay = $cell.children(`.${that.addWidgetPrefix("filter-range-overlay")}`);
    let overlayInstance = $overlay.length && $overlay.data("dxOverlay");
    if (!overlayInstance && column) {
      overlayInstance = that._initFilterRangeOverlay($cell, column);
    }
    if (!overlayInstance.option("visible")) {
      that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.hide();
      that._filterRangeOverlayInstance = overlayInstance;
      that._updateFilterRangeOverlay({
        width: getOuterWidth($cell, true) + 1
      });
      that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.show();
    }
  }
  _hideFilterRange() {
    const overlayInstance = this._filterRangeOverlayInstance;
    overlayInstance && overlayInstance.hide();
  }
  getFilterRangeOverlayInstance() {
    return this._filterRangeOverlayInstance;
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("filter" === row.rowType) {
      $row.addClass(this.addWidgetPrefix("filter-row"));
      if (!this.option("useLegacyKeyboardNavigation")) {
        m_events_engine_default.on($row, "keydown", ((event) => selectView("filterRow", this, event)));
      }
    }
    return $row;
  }
  _getRows() {
    const result2 = super._getRows();
    if (this.isFilterRowVisible()) {
      result2.push({
        rowType: "filter"
      });
    }
    return result2;
  }
  _renderFilterCell(cell, options2) {
    const that = this;
    const {
      column
    } = options2;
    const $cell = renderer_default(cell);
    if (that.component.option("showColumnHeaders")) {
      that.setAria("describedby", column.headerId, $cell);
    }
    that.setAria("label", message_default.format("dxDataGrid-ariaFilterCell"), $cell);
    $cell.addClass("dx-editor-cell");
    const $container = renderer_default("<div>").appendTo($cell);
    const $editorContainer = renderer_default("<div>").addClass("dx-editor-container").appendTo($container);
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      that._renderFilterRangeContent($cell, column);
    } else {
      const editorOptions = that._getEditorOptions($editorContainer, column);
      that._renderEditor($editorContainer, editorOptions);
    }
    const {
      alignment
    } = column;
    if (alignment && "center" !== alignment) {
      $cell.find(EDITORS_INPUT_SELECTOR2).first().css("textAlign", column.alignment);
    }
    if (column.filterOperations && column.filterOperations.length) {
      that._renderFilterOperationChooser($container, column, $editorContainer);
    }
  }
  _renderCellContent($cell, options2) {
    const that = this;
    const {
      column
    } = options2;
    if ("filter" === options2.rowType) {
      if (column.command) {
        $cell.html("&nbsp;");
      } else if (column.allowFiltering) {
        that.renderTemplate($cell, that._renderFilterCell.bind(that), options2).done((() => {
          that._updateCell($cell, options2);
        }));
        return;
      }
    }
    super._renderCellContent.apply(this, arguments);
  }
  _getEditorOptions($editorContainer, column) {
    const that = this;
    const accessibilityOptions = {
      editorOptions: {
        inputAttr: that._getFilterInputAccessibilityAttributes(column)
      }
    };
    const result2 = extend(accessibilityOptions, column, {
      value: getFilterValue2(that, column.index, $editorContainer),
      parentType: "filterRow",
      showAllText: that.option("filterRow.showAllText"),
      updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : 700,
      width: null,
      setValue(value2, notFireEvent) {
        updateFilterValue(that, {
          column,
          value: value2,
          container: $editorContainer,
          notFireEvent
        });
      }
    });
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
        result2.placeholder = that.option("filterRow.betweenStartText");
      } else {
        result2.placeholder = that.option("filterRow.betweenEndText");
      }
    }
    return result2;
  }
  _getFilterInputAccessibilityAttributes(column) {
    const columnAriaLabel = message_default.format("dxDataGrid-ariaFilterCell");
    if (this.component.option("showColumnHeaders")) {
      return {
        "aria-label": columnAriaLabel,
        "aria-describedby": column.headerId
      };
    }
    return {
      "aria-label": columnAriaLabel
    };
  }
  _renderEditor($editorContainer, options2) {
    $editorContainer.empty();
    const $element = renderer_default("<div>").appendTo($editorContainer);
    const dataSource = this._dataController.dataSource();
    if (options2.lookup && this.option("syncLookupFilterValues")) {
      this._applyFilterViewController.setCurrentColumnForFiltering(options2);
      const filter = this._dataController.getCombinedFilter();
      this._applyFilterViewController.setCurrentColumnForFiltering(null);
      const lookupDataSource = m_utils_default.getWrappedLookupDataSource(options2, dataSource, filter);
      const lookupOptions = _extends({}, options2, {
        lookup: _extends({}, options2.lookup, {
          dataSource: lookupDataSource
        })
      });
      return this._editorFactoryController.createEditor($element, lookupOptions);
    }
    return this._editorFactoryController.createEditor($element, options2);
  }
  _renderFilterRangeContent($cell, column) {
    const that = this;
    const $editorContainer = $cell.find(".dx-editor-container").first();
    $editorContainer.empty();
    const $filterRangeContent = renderer_default("<div>").addClass("dx-filter-range-content").attr("tabindex", this.option("tabIndex"));
    m_events_engine_default.on($filterRangeContent, "focusin", (() => {
      that._showFilterRange($cell, column);
    }));
    $filterRangeContent.appendTo($editorContainer);
    that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
  }
  _updateFilterRangeContent($cell, value2) {
    const $filterRangeContent = $cell.find(".dx-filter-range-content");
    if ($filterRangeContent.length) {
      if ("" === value2) {
        $filterRangeContent.html("&nbsp;");
      } else {
        $filterRangeContent.text(value2);
      }
    }
  }
  _updateFilterOperationChooser($menu, column, $editorContainer) {
    var _column$filterOperati;
    const that = this;
    let isCellWasFocused;
    const restoreFocus3 = function() {
      const menu = menu_default.getInstance($menu);
      menu && menu.option("focusedElement", null);
      isCellWasFocused && that._focusEditor($editorContainer);
    };
    const editorFactoryController = this._editorFactoryController;
    const ariaSearchBox = message_default.format("dxDataGrid-ariaSearchBox");
    that._createComponent($menu, menu_default, {
      integrationOptions: {},
      activeStateEnabled: false,
      selectionMode: "single",
      cssClass: `${that.getWidgetContainerClass()} dx-cell-focus-disabled ${FILTER_MENU}`,
      showFirstSubmenuMode: "onHover",
      hideSubmenuOnMouseLeave: true,
      items: [{
        name: getColumnSelectedFilterOperation(that, column) || ariaSearchBox,
        disabled: !(null !== (_column$filterOperati = column.filterOperations) && void 0 !== _column$filterOperati && _column$filterOperati.length),
        icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
        selectable: false,
        items: that._getFilterOperationMenuItems(column)
      }],
      onItemRendered: (_ref) => {
        let {
          itemElement,
          itemData
        } = _ref;
        if (null !== itemData && void 0 !== itemData && itemData.items && null !== itemData && void 0 !== itemData && itemData.name) {
          const labelText = that._getOperationDescriptionFromDescriptor(itemData.name) || ariaSearchBox;
          this.setAria("label", labelText, renderer_default(itemElement));
        }
      },
      onItemClick(properties) {
        var _properties$itemData;
        const selectedFilterOperation = properties.itemData.name;
        const columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column);
        let notFocusEditor = false;
        const isOnClickMode = isOnClickApplyFilterMode(that);
        const options2 = {};
        if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
          return;
        }
        if (selectedFilterOperation) {
          options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
          if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
            notFocusEditor = "between" === selectedFilterOperation;
            options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          }
        } else {
          options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
        }
        const isResetFilterOperation = !(null !== (_properties$itemData = properties.itemData) && void 0 !== _properties$itemData && _properties$itemData.name);
        const isNotFireEvent = isResetFilterOperation ? false : void 0;
        that._columnsController.columnOption(column.index, options2, void 0, isNotFireEvent);
        that._applyFilterViewController.setHighLight($editorContainer, true);
        if (!selectedFilterOperation) {
          const editor = getEditorInstance($editorContainer);
          if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
            editor.clear();
            editor.option("isValid", true);
          }
        }
        if (!notFocusEditor) {
          that._focusEditor($editorContainer);
        } else {
          that._showFilterRange($editorContainer.closest(".dx-editor-cell"), column);
        }
      },
      onSubmenuShowing() {
        isCellWasFocused = that._isEditorFocused($editorContainer);
        editorFactoryController.loseFocus();
      },
      onSubmenuHiding() {
        m_events_engine_default.trigger($menu, "blur");
        restoreFocus3();
      },
      onContentReady(e) {
        m_events_engine_default.on($menu, "blur", (() => {
          const menu = e.component;
          menu._hideSubmenuAfterTimeout();
          restoreFocus3();
        }));
      },
      rtlEnabled: that.option("rtlEnabled")
    });
  }
  _isEditorFocused($container) {
    return $container.hasClass("dx-focused") || $container.parents(".dx-focused").length;
  }
  _focusEditor($container) {
    this._editorFactoryController.focus($container);
    m_events_engine_default.trigger($container.find(EDITORS_INPUT_SELECTOR2), "focus");
  }
  _renderFilterOperationChooser($container, column, $editorContainer) {
    const that = this;
    let $menu;
    if (that.option("filterRow.showOperationChooser")) {
      $container.addClass("dx-editor-with-menu");
      $menu = renderer_default("<div>").prependTo($container);
      that._updateFilterOperationChooser($menu, column, $editorContainer);
    }
  }
  _getFilterOperationMenuItems(column) {
    const that = this;
    let result2 = [{}];
    const filterRowOptions = that.option("filterRow");
    if (column.filterOperations && column.filterOperations.length) {
      const availableFilterOperations = column.filterOperations.filter(((value2) => isDefined(OPERATION_DESCRIPTORS[value2])));
      result2 = map(availableFilterOperations, ((value2) => ({
        name: value2,
        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value2,
        text: that._getOperationDescriptionFromDescriptor(value2),
        icon: OPERATION_ICONS[value2]
      })));
      result2.push({
        name: null,
        text: filterRowOptions && filterRowOptions.resetOperationText,
        icon: OPERATION_ICONS.default
      });
    }
    return result2;
  }
  _getOperationDescriptionFromDescriptor(value2) {
    const filterRowOptions = this.option("filterRow");
    const operationDescriptions = (null === filterRowOptions || void 0 === filterRowOptions ? void 0 : filterRowOptions.operationDescriptions) || {};
    const descriptionName = OPERATION_DESCRIPTORS[value2];
    return operationDescriptions[descriptionName];
  }
  _handleDataChanged(e) {
    var _this$_dataController, _this$_dataController2, _dataSource$lastLoadO, _e$operationTypes, _e$operationTypes2;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.dataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const lastLoadOptions = null === dataSource || void 0 === dataSource || null === (_dataSource$lastLoadO = dataSource.lastLoadOptions) || void 0 === _dataSource$lastLoadO ? void 0 : _dataSource$lastLoadO.call(dataSource);
    super._handleDataChanged.apply(this, arguments);
    if (null !== (_e$operationTypes = e.operationTypes) && void 0 !== _e$operationTypes && _e$operationTypes.filtering || null !== (_e$operationTypes2 = e.operationTypes) && void 0 !== _e$operationTypes2 && _e$operationTypes2.fullReload) {
      var _e$operationTypes3;
      this.updateLookupDataSource((null === (_e$operationTypes3 = e.operationTypes) || void 0 === _e$operationTypes3 ? void 0 : _e$operationTypes3.filtering) || (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.filter));
    }
  }
  updateLookupDataSource(filterChanged) {
    if (!this.option("syncLookupFilterValues")) {
      return;
    }
    if (!this.element()) {
      return;
    }
    const columns7 = this._columnsController.getVisibleColumns();
    const dataSource = this._dataController.dataSource();
    const applyFilterViewController = this._applyFilterViewController;
    const rowIndex = this.element().find(`.${this.addWidgetPrefix("filter-row")}`).index();
    if (-1 === rowIndex) {
      return;
    }
    columns7.forEach(((column, index) => {
      if (!column.lookup || column.calculateCellValue !== column.defaultCalculateCellValue) {
        return;
      }
      const $cell = this._getCellElement(rowIndex, index);
      const editor = getEditorInstance(null === $cell || void 0 === $cell ? void 0 : $cell.find(".dx-editor-container"));
      if (editor) {
        applyFilterViewController.setCurrentColumnForFiltering(column);
        const filter = this._dataController.getCombinedFilter() || null;
        applyFilterViewController.setCurrentColumnForFiltering(null);
        const editorDataSource = editor.option("dataSource");
        const shouldUpdateFilter = !filterChanged || !equalByValue(editorDataSource.__dataGridSourceFilter || null, filter);
        if (shouldUpdateFilter) {
          const lookupDataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
          editor.option("dataSource", lookupDataSource);
        }
      }
    }));
  }
  getColumnElements(index, bandColumnIndex) {
    var _rows$index;
    const rows = this._getRows();
    if ("filter" === (null === rows || void 0 === rows || null === (_rows$index = rows[index]) || void 0 === _rows$index ? void 0 : _rows$index.rowType) && arguments.length < 2) {
      return this.getCellElements(index);
    }
    return super.getColumnElements(index, bandColumnIndex);
  }
  isFilterRowCell($cell) {
    return !!$cell.closest(`.${this.addWidgetPrefix("filter-row")}`).length;
  }
};
var data8 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const applyFilterController = this._applyFilterController;
    each(columns7, (function() {
      var _applyFilterControlle;
      const shouldSkip = (null === (_applyFilterControlle = applyFilterController.getCurrentColumnForFiltering()) || void 0 === _applyFilterControlle ? void 0 : _applyFilterControlle.index) === this.index;
      if (this.allowFiltering && this.calculateFilterExpression && isDefined(this.filterValue) && !shouldSkip) {
        const filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
        filters.push(filter);
      }
    }));
    return m_utils_default.combineFilters(filters);
  }
};
var ApplyFilterViewController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
  }
  _getHeaderPanel() {
    if (!this._headerPanel) {
      this._headerPanel = this.getView("headerPanel");
    }
    return this._headerPanel;
  }
  setHighLight($element, value2) {
    if (isOnClickApplyFilterMode(this)) {
      $element && $element.toggleClass("dx-highlight-outline", value2) && $element.closest(".dx-editor-cell").toggleClass("dx-filter-modified", value2);
      this._getHeaderPanel().enableApplyButton(value2);
    }
  }
  applyFilter() {
    const columns7 = this._columnsController.getColumns();
    this._columnsController.beginUpdate();
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      if (void 0 !== column.bufferedFilterValue) {
        this._columnsController.columnOption(i, "filterValue", column.bufferedFilterValue);
        column.bufferedFilterValue = void 0;
      }
      if (void 0 !== column.bufferedSelectedFilterOperation) {
        this._columnsController.columnOption(i, "selectedFilterOperation", column.bufferedSelectedFilterOperation);
        column.bufferedSelectedFilterOperation = void 0;
      }
    }
    this._columnsController.endUpdate();
    this.removeHighLights();
  }
  removeHighLights() {
    if (isOnClickApplyFilterMode(this)) {
      const columnHeadersViewElement = this.getView("columnHeadersView").element();
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-highlight-outline`).removeClass("dx-highlight-outline");
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-filter-modified`).removeClass("dx-filter-modified");
      this._getHeaderPanel().enableApplyButton(false);
    }
  }
  setCurrentColumnForFiltering(column) {
    this._currentColumn = column;
  }
  getCurrentColumnForFiltering() {
    return this._currentColumn;
  }
};
var columnsResizer = (Base) => class extends Base {
  _startResizing() {
    const that = this;
    super._startResizing.apply(that, arguments);
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        const cellIndex = overlayInstance.$element().closest("td").index();
        if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
          overlayInstance.$content().hide();
        }
      }
    }
  }
  _endResizing() {
    const that = this;
    let $cell;
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        $cell = overlayInstance.$element().closest("td");
        that._columnHeadersView._updateFilterRangeOverlay({
          width: getOuterWidth($cell, true) + 1
        });
        overlayInstance.$content().show();
      }
    }
    super._endResizing.apply(that, arguments);
  }
};
var editing = (Base) => class extends Base {
  updateFieldValue(options2) {
    if (options2.column.lookup) {
      this._needUpdateLookupDataSource = true;
    }
    return super.updateFieldValue.apply(this, arguments);
  }
  _afterSaveEditData(cancel) {
    if (this._needUpdateLookupDataSource && !cancel) {
      var _this$getView;
      null === (_this$getView = this.getView("columnHeadersView")) || void 0 === _this$getView || _this$getView.updateLookupDataSource();
    }
    this._needUpdateLookupDataSource = false;
    return super._afterSaveEditData.apply(this, arguments);
  }
  _afterCancelEditData() {
    this._needUpdateLookupDataSource = false;
    return super._afterCancelEditData.apply(this, arguments);
  }
};
var headerPanel4 = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController = this.getController("data");
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    if ("filterRow" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const filterItem = this._prepareFilterItem();
    return filterItem.concat(items);
  }
  _prepareFilterItem() {
    const that = this;
    const filterItem = [];
    if (that._isShowApplyFilterButton()) {
      const hintText = that.option("filterRow.applyFilterText");
      const columns7 = that._columnsController.getColumns();
      const disabled = !columns7.filter(((column) => void 0 !== column.bufferedFilterValue)).length;
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass("dx-apply-button"));
      };
      const onClickHandler = function() {
        that._applyFilterViewController.applyFilter();
      };
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "apply-filter",
          disabled,
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized
        },
        showText: "inMenu",
        name: "applyFilterButton",
        location: "after",
        locateInMenu: "auto",
        sortIndex: 10
      };
      filterItem.push(toolbarItem);
    }
    return filterItem;
  }
  _isShowApplyFilterButton() {
    const filterRowOptions = this.option("filterRow");
    return !!(null !== filterRowOptions && void 0 !== filterRowOptions && filterRowOptions.visible) && "onClick" === filterRowOptions.applyFilter;
  }
  enableApplyButton(value2) {
    this.setToolbarItemDisabled("applyFilterButton", !value2);
  }
};
var filterRowModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    filterRow: {
      visible: false,
      showOperationChooser: true,
      showAllText: message_default.format("dxDataGrid-filterRowShowAllText"),
      resetOperationText: message_default.format("dxDataGrid-filterRowResetOperationText"),
      applyFilter: "auto",
      applyFilterText: message_default.format("dxDataGrid-applyFilterText"),
      operationDescriptions: {
        equal: message_default.format("dxDataGrid-filterRowOperationEquals"),
        notEqual: message_default.format("dxDataGrid-filterRowOperationNotEquals"),
        lessThan: message_default.format("dxDataGrid-filterRowOperationLess"),
        lessThanOrEqual: message_default.format("dxDataGrid-filterRowOperationLessOrEquals"),
        greaterThan: message_default.format("dxDataGrid-filterRowOperationGreater"),
        greaterThanOrEqual: message_default.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
        startsWith: message_default.format("dxDataGrid-filterRowOperationStartsWith"),
        contains: message_default.format("dxDataGrid-filterRowOperationContains"),
        notContains: message_default.format("dxDataGrid-filterRowOperationNotContains"),
        endsWith: message_default.format("dxDataGrid-filterRowOperationEndsWith"),
        between: message_default.format("dxDataGrid-filterRowOperationBetween"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      },
      betweenStartText: message_default.format("dxDataGrid-filterRowOperationBetweenStartText"),
      betweenEndText: message_default.format("dxDataGrid-filterRowOperationBetweenEndText")
    }
  }),
  controllers: {
    applyFilter: ApplyFilterViewController
  },
  extenders: {
    controllers: {
      data: data8,
      columnsResizer,
      editing
    },
    views: {
      columnHeadersView: columnHeadersView3,
      headerPanel: headerPanel4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_row.js
m_core_default.registerModule("filterRow", filterRowModule);

// node_modules/devextreme/esm/__internal/ui/list/modules/m_search.js
ui_search_box_mixin_default.setEditorClass(text_box_default2);

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter_core.js
var HANDLER_DECORATED_KEY = Symbol("HANDLER_DECORATED_KEY");
function resetChildrenItemSelection(items) {
  items = items || [];
  for (let i = 0; i < items.length; i++) {
    items[i].selected = false;
    resetChildrenItemSelection(items[i].items);
  }
}
function getSelectAllCheckBox(listComponent) {
  const selector = "dxTreeView" === listComponent.NAME ? ".dx-treeview-select-all-item" : ".dx-list-select-all-checkbox";
  return listComponent.$element().find(selector).dxCheckBox("instance");
}
function getListSelectAllValueChangedHandler(selectAllCheckBox, listComponent) {
  const originalHandler = selectAllCheckBox.option("onValueChanged");
  if (null !== originalHandler && void 0 !== originalHandler && originalHandler[HANDLER_DECORATED_KEY]) {
    return originalHandler;
  }
  const handler = (originalEvent) => {
    const {
      event,
      value: value2
    } = originalEvent;
    const isEventFromUI = !!event;
    null === event || void 0 === event || event.stopPropagation();
    switch (true) {
      case (isEventFromUI && true === value2):
        listComponent.selectAll();
        return;
      case (isEventFromUI && false === value2):
        listComponent.unselectAll();
        return;
      default:
        null === originalHandler || void 0 === originalHandler || originalHandler(originalEvent);
    }
  };
  handler[HANDLER_DECORATED_KEY] = true;
  return handler;
}
function decorateListSelectAllValueChanged(listComponent) {
  const selectAllCheckBox = getSelectAllCheckBox(listComponent);
  if (!selectAllCheckBox) {
    return;
  }
  const handler = getListSelectAllValueChangedHandler(selectAllCheckBox, listComponent);
  selectAllCheckBox.option("onValueChanged", handler);
}
function updateListSelectAllState(listComponent, filterValues) {
  if (listComponent.option("searchValue")) {
    return;
  }
  const selectAllCheckBox = getSelectAllCheckBox(listComponent);
  if (selectAllCheckBox && null !== filterValues && void 0 !== filterValues && filterValues.length) {
    selectAllCheckBox.option("value", void 0);
  }
}
function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
  if (filterValuesMatch ^ isExcludeFilter) {
    item.selected = true;
    if (isExcludeFilter && item.items) {
      for (let j = 0; j < item.items.length; j++) {
        if (!item.items[j].selected) {
          item.selected = void 0;
          break;
        }
      }
    }
  } else if (isExcludeFilter || item.selected) {
    item.selected = false;
    resetChildrenItemSelection(item.items);
  }
}
var HeaderFilterView = class extends m_modules_default.View {
  getPopupContainer() {
    return this._popupContainer;
  }
  getListComponent() {
    return this._listComponent;
  }
  applyHeaderFilter(options2) {
    const list = this.getListComponent();
    const searchValue = list.option("searchValue");
    const selectAllCheckBox = getSelectAllCheckBox(list);
    const isAllSelected = !searchValue && !options2.isFilterBuilder && (null === selectAllCheckBox || void 0 === selectAllCheckBox ? void 0 : selectAllCheckBox.option("value"));
    const filterValues = [];
    const fillSelectedItemKeys = function(filterValues2, items, isExclude) {
      each(items, ((_, item) => {
        if (void 0 !== item.selected && !!item.selected ^ isExclude) {
          const node = list._getNode(item);
          const hasChildren2 = list._hasChildren(node);
          const hasChildrenWithSelection = hasChildren2 && item.items && item.items.some(((item2) => item2.selected));
          if (!searchValue || !hasChildrenWithSelection) {
            filterValues2.push(item.value);
            return;
          }
        }
        if (item.items && item.items.length) {
          fillSelectedItemKeys(filterValues2, item.items, isExclude);
        }
      }));
    };
    if (!isAllSelected) {
      if ("tree" === options2.type) {
        if (options2.filterType) {
          options2.filterType = "include";
        }
        fillSelectedItemKeys(filterValues, list.option("items"), false);
        options2.filterValues = filterValues;
      }
    } else {
      if ("tree" === options2.type) {
        options2.filterType = "exclude";
      }
      if (Array.isArray(options2.filterValues)) {
        options2.filterValues = [];
      }
    }
    if (options2.filterValues && !options2.filterValues.length) {
      options2.filterValues = null;
    }
    options2.apply();
    this.hideHeaderFilterMenu();
  }
  showHeaderFilterMenu($columnElement, options2) {
    const that = this;
    if (options2) {
      that._initializePopupContainer(options2);
      const popupContainer = that.getPopupContainer();
      that.hideHeaderFilterMenu();
      that.updatePopup($columnElement, options2);
      popupContainer.show();
    }
  }
  hideHeaderFilterMenu() {
    const headerFilterMenu = this.getPopupContainer();
    headerFilterMenu && headerFilterMenu.hide();
  }
  updatePopup($element, options2) {
    const that = this;
    const showColumnLines = this.option("showColumnLines");
    const alignment = "right" === options2.alignment ^ !showColumnLines ? "left" : "right";
    that._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-headerFilterLabel")
    });
    if (that._popupContainer) {
      that._cleanPopupContent();
      that._popupContainer.option("position", {
        my: `${alignment} top`,
        at: `${alignment} bottom`,
        of: $element,
        collision: "fit fit"
      });
    }
  }
  _getSearchExpr(options2, headerFilterOptions) {
    const {
      lookup
    } = options2;
    const {
      useDefaultSearchExpr
    } = options2;
    const headerFilterDataSource = headerFilterOptions.dataSource;
    const filterSearchExpr = headerFilterOptions.search.searchExpr;
    if (filterSearchExpr) {
      return filterSearchExpr;
    }
    if (useDefaultSearchExpr || isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      return "text";
    }
    if (lookup) {
      return lookup.displayExpr || "this";
    }
    if (options2.dataSource) {
      const {
        group
      } = options2.dataSource;
      if (Array.isArray(group) && group.length > 0) {
        return group[0].selector;
      }
      if (isFunction(group) && !options2.remoteFiltering) {
        return group;
      }
    }
    return options2.dataField || options2.selector;
  }
  _cleanPopupContent() {
    this._popupContainer && this._popupContainer.$content().empty();
  }
  _initializePopupContainer(options2) {
    const that = this;
    const $element = that.element();
    const headerFilterOptions = this._normalizeHeaderFilterOptions(options2);
    const {
      height,
      width
    } = headerFilterOptions;
    const dxPopupOptions = {
      width,
      height,
      visible: false,
      shading: false,
      showTitle: false,
      showCloseButton: false,
      hideOnParentScroll: false,
      dragEnabled: false,
      hideOnOutsideClick: true,
      wrapperAttr: {
        class: "dx-header-filter-menu"
      },
      focusStateEnabled: false,
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.ok,
          onClick() {
            that.applyHeaderFilter(options2);
          }
        }
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.cancel,
          onClick() {
            that.hideHeaderFilterMenu();
          }
        }
      }],
      resizeEnabled: true,
      onShowing(e) {
        e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
        that._initializeListContainer(options2, headerFilterOptions);
        options2.onShowing && options2.onShowing(e);
      },
      onShown() {
        that.getListComponent().focus();
      },
      onHidden: options2.onHidden,
      onInitialized(e) {
        const {
          component
        } = e;
        component.option("animation", component._getDefaultOptions().animation);
      },
      _loopFocus: true
    };
    if (!isDefined(that._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
    } else {
      that._popupContainer.option(dxPopupOptions);
    }
  }
  _initializeListContainer(options2, headerFilterOptions) {
    const that = this;
    const $content = that._popupContainer.$content();
    const needShowSelectAllCheckbox = !options2.isFilterBuilder && headerFilterOptions.allowSelectAll;
    const widgetOptions = {
      searchEnabled: headerFilterOptions.search.enabled,
      searchTimeout: headerFilterOptions.search.timeout,
      searchEditorOptions: headerFilterOptions.search.editorOptions,
      searchMode: headerFilterOptions.search.mode || "",
      dataSource: options2.dataSource,
      onContentReady() {
        that.renderCompleted.fire();
      },
      itemTemplate(data17, _, element) {
        const $element = renderer_default(element);
        if (options2.encodeHtml) {
          return $element.text(data17.text);
        }
        return $element.html(data17.text);
      }
    };
    const shouldChangeSelectAllCheckBoxVisibility = () => needShowSelectAllCheckbox && false !== that.option("headerFilter.hideSelectAllOnSearch");
    const onTreeViewOptionChanged = (event) => {
      switch (true) {
        case ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()):
          event.component.option("showCheckBoxesMode", event.value ? "normal" : "selectAll");
          break;
        case "showCheckBoxesMode" === event.fullName:
          Promise.resolve().then((() => {
            event.component._searchEditor.focus();
          })).catch((() => {
          }));
      }
    };
    const onListOptionChanged = (event) => {
      if ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()) {
        event.component.option("selectionMode", event.value ? "multiple" : "all");
      }
    };
    if ("tree" === options2.type) {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), tree_view_default, extend(widgetOptions, {
        showCheckBoxesMode: needShowSelectAllCheckbox ? "selectAll" : "normal",
        onOptionChanged: onTreeViewOptionChanged,
        keyExpr: "id"
      }));
    } else {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), list_light_default, extend(widgetOptions, {
        searchExpr: that._getSearchExpr(options2, headerFilterOptions),
        pageLoadMode: "scrollBottom",
        showSelectionControls: true,
        selectionMode: needShowSelectAllCheckbox ? "all" : "multiple",
        onOptionChanged: onListOptionChanged,
        onSelectionChanged(event) {
          const {
            component: listComponent
          } = event;
          const items = listComponent.option("items");
          const selectedItems = listComponent.option("selectedItems");
          if (!listComponent._selectedItemsUpdating && !listComponent.option("searchValue") && !options2.isFilterBuilder) {
            const filterValues = options2.filterValues || [];
            const isExclude = "exclude" === options2.filterType;
            if (0 === selectedItems.length && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
              options2.filterType = "include";
              options2.filterValues = [];
            } else if (selectedItems.length === items.length) {
              options2.filterType = "exclude";
              options2.filterValues = [];
            }
          }
          each(items, ((index, item) => {
            const selected = m_utils_default.getIndexByKey(item, selectedItems, null) >= 0;
            const oldSelected = !!item.selected;
            if (oldSelected !== selected) {
              item.selected = selected;
              options2.filterValues = options2.filterValues || [];
              const filterValueIndex = m_utils_default.getIndexByKey(item.value, options2.filterValues, null);
              if (filterValueIndex >= 0) {
                options2.filterValues.splice(filterValueIndex, 1);
              }
              const isExcludeFilterType = "exclude" === options2.filterType;
              if (selected ^ isExcludeFilterType) {
                options2.filterValues.push(item.value);
              }
            }
          }));
          updateListSelectAllState(listComponent, options2.filterValues);
        },
        onContentReady(e) {
          const {
            component: listComponent
          } = e;
          const items = listComponent.option("items");
          const selectedItems = [];
          each(items, (function() {
            if (this.selected) {
              selectedItems.push(this);
            }
          }));
          listComponent._selectedItemsUpdating = true;
          listComponent.option("selectedItems", selectedItems);
          listComponent._selectedItemsUpdating = false;
          decorateListSelectAllValueChanged(listComponent);
          updateListSelectAllState(listComponent, options2.filterValues);
        }
      }));
    }
  }
  _normalizeHeaderFilterOptions(options2) {
    const generalHeaderFilter = this.option("headerFilter") || {};
    const specificHeaderFilter = options2.headerFilter || {};
    const generalDeprecated = {
      search: {
        enabled: generalHeaderFilter.allowSearch,
        timeout: generalHeaderFilter.searchTimeout
      }
    };
    const specificDeprecated = {
      search: {
        enabled: specificHeaderFilter.allowSearch,
        mode: specificHeaderFilter.searchMode,
        timeout: specificHeaderFilter.searchTimeout
      }
    };
    return extend(true, {}, generalHeaderFilter, generalDeprecated, specificHeaderFilter, specificDeprecated);
  }
  _renderCore() {
    this.element().addClass("dx-header-filter-menu");
  }
};
var allowHeaderFiltering = function(column) {
  return isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering;
};
var headerFilterMixin = (Base) => class extends Base {
  optionChanged(args) {
    if ("headerFilter" === args.name) {
      const requireReady = "columnHeadersView" === this.name;
      this._invalidate(requireReady, requireReady);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _applyColumnState(options2) {
    let $headerFilterIndicator;
    const {
      rootElement
    } = options2;
    const {
      column
    } = options2;
    if ("headerFilter" === options2.name) {
      rootElement.find(".dx-header-filter").remove();
      if (allowHeaderFiltering(column)) {
        $headerFilterIndicator = super._applyColumnState(options2).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
        if (!this.option("useLegacyKeyboardNavigation")) {
          $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0);
        }
        const indicatorLabel = message_default.format("dxDataGrid-headerFilterIndicatorLabel", column.caption);
        $headerFilterIndicator.attr("aria-label", indicatorLabel);
        $headerFilterIndicator.attr("aria-haspopup", "dialog");
        $headerFilterIndicator.attr("role", "button");
      }
      return $headerFilterIndicator;
    }
    return super._applyColumnState(options2);
  }
  _isHeaderFilterEmpty(column) {
    return !column.filterValues || !column.filterValues.length;
  }
  _getIndicatorClassName(name2) {
    if ("headerFilter" === name2) {
      return "dx-header-filter";
    }
    return super._getIndicatorClassName(name2);
  }
  _renderIndicator(options2) {
    const $container = options2.container;
    const $indicator = options2.indicator;
    if ("headerFilter" === options2.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if ($container.children().length && (!rtlEnabled && "right" === options2.columnAlignment || rtlEnabled && "left" === options2.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options2);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter.js
var DATE_INTERVAL_FORMATS = {
  month: (value2) => date_default.getMonthNames()[value2 - 1],
  quarter: (value2) => date_default.format(new Date(2e3, 3 * value2 - 1), "quarter")
};
function ungroupUTCDates(items, dateParts, dates) {
  dateParts = dateParts || [];
  dates = dates || [];
  items.forEach(((item) => {
    if (isDefined(item.key)) {
      const isMonthPart = 1 === dateParts.length;
      dateParts.push(isMonthPart ? item.key - 1 : item.key);
      if (item.items) {
        ungroupUTCDates(item.items, dateParts, dates);
      } else {
        const date = new Date(Date.UTC.apply(Date, dateParts));
        dates.push(date);
      }
      dateParts.pop();
    } else {
      dates.push(null);
    }
  }));
  return dates;
}
function convertDataFromUTCToLocal(data17, column) {
  const dates = ungroupUTCDates(data17);
  const query = m_query_default(dates);
  const group = m_utils_default.getHeaderFilterGroupParameters(_extends({}, column, {
    calculateCellValue: (date) => date
  }));
  return m_store_helper_default.queryByOptions(query, {
    group
  }).toArray();
}
function isUTCFormat(format2) {
  return "Z" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-1)) || "'Z'" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-3));
}
var getFormatOptions = function(value2, column, currentLevel) {
  const groupInterval = filtering_default.getGroupInterval(column);
  const result2 = m_utils_default.getFormatOptionsByColumn(column, "headerFilter");
  if (groupInterval) {
    result2.groupInterval = groupInterval[currentLevel];
    if (m_utils_default.isDateType(column.dataType)) {
      result2.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]];
    } else if ("number" === column.dataType) {
      result2.getDisplayFormat = function() {
        const formatOptions = {
          format: column.format,
          target: "headerFilter"
        };
        const firstValueText = m_utils_default.formatValue(value2, formatOptions);
        const secondValue = value2 + groupInterval[currentLevel];
        const secondValueText = m_utils_default.formatValue(secondValue, formatOptions);
        return firstValueText && secondValueText ? `${firstValueText} - ${secondValueText}` : "";
      };
    }
  }
  return result2;
};
var HeaderFilterController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._headerFilterView = this.getView("headerFilterView");
  }
  _updateSelectedState(items, column) {
    let i = items.length;
    const isExclude = "exclude" === column.filterType;
    while (i--) {
      const item = items[i];
      if ("items" in items[i]) {
        this._updateSelectedState(items[i].items, column);
      }
      updateHeaderFilterItemSelectionState(item, m_utils_default.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude);
    }
  }
  _normalizeGroupItem(item, currentLevel, options2) {
    let value2;
    let displayValue;
    const {
      path
    } = options2;
    const {
      valueSelector
    } = options2;
    const {
      displaySelector
    } = options2;
    const {
      column
    } = options2;
    if (valueSelector && displaySelector) {
      value2 = valueSelector(item);
      displayValue = displaySelector(item);
    } else {
      value2 = item.key;
      displayValue = value2;
    }
    if (!isObject(item)) {
      item = {};
    } else {
      item = extend({}, item);
    }
    path.push(value2);
    if (1 === path.length) {
      item.value = path[0];
    } else {
      item.value = path.join("/");
    }
    item.text = this.getHeaderItemText(displayValue, column, currentLevel, options2.headerFilterOptions);
    return item;
  }
  getHeaderItemText(displayValue, column, currentLevel, headerFilterOptions) {
    let text = m_utils_default.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
    if (!text) {
      text = headerFilterOptions.texts.emptyValue;
    }
    return text;
  }
  _processGroupItems(groupItems, currentLevel, path, options2) {
    const that = this;
    let displaySelector;
    let valueSelector;
    const {
      column
    } = options2;
    const {
      lookup
    } = column;
    const {
      level
    } = options2;
    path = path || [];
    currentLevel = currentLevel || 0;
    if (lookup) {
      displaySelector = compileGetter(lookup.displayExpr);
      valueSelector = compileGetter(lookup.valueExpr);
    }
    for (let i = 0; i < groupItems.length; i++) {
      groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
        column: options2.column,
        headerFilterOptions: options2.headerFilterOptions,
        displaySelector,
        valueSelector,
        path
      });
      if ("items" in groupItems[i]) {
        if (currentLevel === level || !isDefined(groupItems[i].value)) {
          delete groupItems[i].items;
        } else {
          that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options2);
        }
      }
      path.pop();
    }
  }
  getDataSource(column) {
    var _column$headerFilter;
    const dataSource = this._dataController.dataSource();
    const remoteGrouping = null === dataSource || void 0 === dataSource ? void 0 : dataSource.remoteOperations().grouping;
    const group = m_utils_default.getHeaderFilterGroupParameters(column, remoteGrouping);
    const headerFilterDataSource = null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.dataSource;
    const headerFilterOptions = this.option("headerFilter");
    let isLookup = false;
    const options2 = {
      component: this.component
    };
    if (!dataSource) {
      return;
    }
    if (isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      options2.dataSource = normalizeDataSourceOptions(headerFilterDataSource);
    } else if (column.lookup) {
      isLookup = true;
      if (this.option("syncLookupFilterValues")) {
        this._currentColumn = column;
        const filter = this._dataController.getCombinedFilter();
        this._currentColumn = null;
        options2.dataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
      } else {
        options2.dataSource = m_utils_default.normalizeLookupDataSource(column.lookup);
      }
    } else {
      const cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
      this._currentColumn = column;
      const filter = this._dataController.getCombinedFilter();
      this._currentColumn = null;
      options2.dataSource = {
        filter,
        group,
        useDefaultSearch: true,
        load: (options3) => {
          const d = new Deferred();
          options3.dataField = column.dataField || column.name;
          dataSource.load(options3).done(((data17) => {
            const convertUTCDates = remoteGrouping && isUTCFormat(column.serializationFormat) && cutoffLevel > 3;
            if (convertUTCDates) {
              data17 = convertDataFromUTCToLocal(data17, column);
            }
            that._processGroupItems(data17, null, null, {
              level: cutoffLevel,
              column,
              headerFilterOptions
            });
            d.resolve(data17);
          })).fail(d.reject);
          return d;
        }
      };
    }
    if (isFunction(headerFilterDataSource)) {
      headerFilterDataSource.call(column, options2);
    }
    const origPostProcess = options2.dataSource.postProcess;
    const that = this;
    options2.dataSource.postProcess = function(data17) {
      let items = data17;
      if (isLookup) {
        items = items.filter(((item) => null !== item[column.lookup.valueExpr]));
        if (0 === this.pageIndex() && !this.searchValue()) {
          items = items.slice(0);
          items.unshift(null);
        }
        that._processGroupItems(items, null, null, {
          level: 0,
          column,
          headerFilterOptions
        });
      }
      items = origPostProcess && origPostProcess.call(this, items) || items;
      that._updateSelectedState(items, column);
      return items;
    };
    return options2.dataSource;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  showHeaderFilterMenu(columnIndex, isGroupPanel) {
    const columnsController = this._columnsController;
    const column = extend(true, {}, this._columnsController.getColumns()[columnIndex]);
    if (column) {
      const visibleIndex = columnsController.getVisibleIndex(columnIndex);
      const view = isGroupPanel ? this.getView("headerPanel") : this.getView("columnHeadersView");
      const $columnElement = view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex);
      this.showHeaderFilterMenuBase({
        columnElement: $columnElement,
        column,
        applyFilter: true,
        apply() {
          columnsController.columnOption(columnIndex, {
            filterValues: this.filterValues,
            filterType: this.filterType
          });
        }
      });
    }
  }
  showHeaderFilterMenuBase(options2) {
    const that = this;
    const {
      column
    } = options2;
    if (column) {
      const groupInterval = filtering_default.getGroupInterval(column);
      const dataSource = that._dataController.dataSource();
      const remoteFiltering = dataSource && dataSource.remoteOperations().filtering;
      const previousOnHidden = options2.onHidden;
      extend(options2, column, {
        type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
        remoteFiltering,
        onShowing: (e) => {
          const dxResizableInstance = e.component.$overlayContent().dxResizable("instance");
          dxResizableInstance && dxResizableInstance.option("onResizeEnd", ((e2) => {
            let headerFilterByColumn = this._columnsController.columnOption(options2.dataField, "headerFilter");
            headerFilterByColumn = headerFilterByColumn || {};
            headerFilterByColumn.width = e2.width;
            headerFilterByColumn.height = e2.height;
            this._columnsController.columnOption(options2.dataField, "headerFilter", headerFilterByColumn, true);
          }));
        },
        onHidden: () => {
          null === previousOnHidden || void 0 === previousOnHidden || previousOnHidden();
          restoreFocus(this);
        }
      });
      options2.dataSource = that.getDataSource(options2);
      if (options2.isFilterBuilder) {
        options2.dataSource.filter = null;
        options2.alignment = "right";
      }
      that._headerFilterView.showHeaderFilterMenu(options2.columnElement, options2);
    }
  }
  hideHeaderFilterMenu() {
    this._headerFilterView.hideHeaderFilterMenu();
  }
};
var columnHeadersView4 = (Base) => class extends headerFilterMixin(Base) {
  _renderCellContent($cell, options2) {
    const that = this;
    let $headerFilterIndicator;
    const {
      column
    } = options2;
    if (!column.command && allowHeaderFiltering(column) && that.option("headerFilter.visible") && "header" === options2.rowType) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
      $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter");
    }
    super._renderCellContent.apply(this, arguments);
  }
  _subscribeToIndicatorEvent($indicator, column, indicatorName) {
    if ("headerFilter" === indicatorName) {
      m_events_engine_default.on($indicator, CLICK_EVENT_NAME, this.createAction(((e) => {
        e.event.stopPropagation();
        saveFocusedElementInfo($indicator, this);
        this._headerFilterController.showHeaderFilterMenu(column.index, false);
      })));
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicator = super._updateIndicator($cell, column, indicatorName);
    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName);
  }
  _updateHeaderFilterIndicators() {
    if (this.option("headerFilter.visible")) {
      this._updateIndicators("headerFilter");
    }
  }
  _needUpdateFilterIndicators() {
    return true;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    const isFilterRowAndHeaderFilterValuesChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterValue"]);
    const isHeaderFilterValuesAndTypeChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterType"]);
    const shouldUpdateFilterIndicators = (isFilterRowAndHeaderFilterValuesChanged || isHeaderFilterValuesAndTypeChanged) && this._needUpdateFilterIndicators();
    if (shouldUpdateFilterIndicators) {
      this._updateHeaderFilterIndicators();
    }
    if (!isHeaderFilterValuesAndTypeChanged) {
      super._columnOptionChanged(e);
    }
  }
};
var headerPanel5 = (Base) => class extends headerFilterMixin(Base) {
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem.apply(that, arguments);
    let $headerFilterIndicator;
    if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $item,
        column: {
          alignment: getDefaultAlignment(that.option("rtlEnabled")),
          filterValues: groupColumn.filterValues,
          allowHeaderFiltering: true,
          caption: groupColumn.caption
        },
        showColumnLines: true
      });
      $headerFilterIndicator && m_events_engine_default.on($headerFilterIndicator, CLICK_EVENT_NAME, that.createAction(((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        this._headerFilterController.showHeaderFilterMenu(groupColumn.index, true);
      })));
    }
    return $item;
  }
};
var data9 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const headerFilterController = this._headerFilterController;
    const currentColumn = headerFilterController.getCurrentColumn();
    each(columns7, ((_, column) => {
      let filter;
      if (currentColumn && currentColumn.index === column.index) {
        return;
      }
      if (allowHeaderFiltering(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
        let filterValues = [];
        each(column.filterValues, ((_2, filterValue) => {
          if (Array.isArray(filterValue)) {
            filter = filterValue;
          } else {
            if (column.deserializeValue && !m_utils_default.isDateType(column.dataType) && "number" !== column.dataType) {
              filterValue = column.deserializeValue(filterValue);
            }
            filter = column.createFilterExpression(filterValue, "=", "headerFilter");
          }
          if (filter) {
            filter.columnIndex = column.index;
          }
          filterValues.push(filter);
        }));
        filterValues = m_utils_default.combineFilters(filterValues, "or");
        filters.push("exclude" === column.filterType ? ["!", filterValues] : filterValues);
      }
    }));
    return m_utils_default.combineFilters(filters);
  }
};
var headerFilterModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    headerFilter: {
      visible: false,
      width: 252,
      height: 325,
      allowSelectAll: true,
      search: {
        enabled: false,
        timeout: 500,
        mode: "contains",
        editorOptions: {}
      },
      texts: {
        emptyValue: message_default.format("dxDataGrid-headerFilterEmptyValue"),
        ok: message_default.format("dxDataGrid-headerFilterOK"),
        cancel: message_default.format("dxDataGrid-headerFilterCancel")
      }
    }
  }),
  controllers: {
    headerFilter: HeaderFilterController
  },
  views: {
    headerFilterView: HeaderFilterView
  },
  extenders: {
    controllers: {
      data: data9
    },
    views: {
      columnHeadersView: columnHeadersView4,
      headerPanel: headerPanel5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_filter.js
m_core_default.registerModule("headerFilter", headerFilterModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_between.js
function editorTemplate(conditionInfo, container) {
  const $editorStart = renderer_default("<div>").addClass("dx-filterbuilder-range-start");
  const $editorEnd = renderer_default("<div>").addClass("dx-filterbuilder-range-end");
  let values = conditionInfo.value || [];
  const getStartValue = function(values2) {
    return values2 && values2.length > 0 ? values2[0] : null;
  };
  const getEndValue = function(values2) {
    return values2 && 2 === values2.length ? values2[1] : null;
  };
  container.append($editorStart);
  container.append(renderer_default("<span>").addClass("dx-filterbuilder-range-separator").text(""));
  container.append($editorEnd);
  container.addClass("dx-filterbuilder-range");
  this._editorFactory.createEditor.call(this, $editorStart, extend({}, conditionInfo.field, conditionInfo, {
    value: getStartValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [value2, getEndValue(values)];
      conditionInfo.setValue(values);
    }
  }));
  this._editorFactory.createEditor.call(this, $editorEnd, extend({}, conditionInfo.field, conditionInfo, {
    value: getEndValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [getStartValue(values), value2];
      conditionInfo.setValue(values);
    }
  }));
}
function getConfig2(caption, context) {
  return {
    name: "between",
    caption,
    icon: "range",
    valueSeparator: "",
    dataTypes: ["number", "date", "datetime"],
    editorTemplate: editorTemplate.bind(context),
    notForLookup: true
  };
}

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_operations_dictionary.js
var OPERATION_ICONS2 = {
  "=": "equal",
  "<>": "notequal",
  "<": "less",
  "<=": "lessorequal",
  ">": "greater",
  ">=": "greaterorequal",
  notcontains: "doesnotcontain",
  contains: "contains",
  startswith: "startswith",
  endswith: "endswith",
  isblank: "isblank",
  isnotblank: "isnotblank"
};
var OPERATION_NAME = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  isblank: "isBlank",
  isnotblank: "isNotBlank",
  between: "between"
};
var m_filter_operations_dictionary_default = {
  getIconByFilterOperation: (filterOperation) => OPERATION_ICONS2[filterOperation],
  getNameByFilterOperation: (filterOperation) => OPERATION_NAME[filterOperation]
};

// node_modules/devextreme/esm/__internal/filter_builder/m_utils.js
var DATATYPE_OPERATIONS2 = {
  number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
  date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  boolean: ["=", "<>", "isblank", "isnotblank"],
  object: ["isblank", "isnotblank"]
};
var DEFAULT_FORMAT = {
  date: "shortDate",
  datetime: "shortDateShortTime"
};
var LOOKUP_OPERATIONS = ["=", "<>", "isblank", "isnotblank"];
var AVAILABLE_FIELD_PROPERTIES = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
function getFormattedValueText(field, value2) {
  const fieldFormat = field.format || DEFAULT_FORMAT[field.dataType];
  if (isBoolean(value2)) {
    const trueText = field.trueText || message_default.format("dxDataGrid-trueText");
    const falseText = field.falseText || message_default.format("dxDataGrid-falseText");
    return value2 ? trueText : falseText;
  }
  if ("date" === field.dataType || "datetime" === field.dataType) {
    return format_helper_default.format(new Date(value2), fieldFormat);
  }
  return format_helper_default.format(value2, fieldFormat);
}
function isNegationGroup(group) {
  return group && group.length > 1 && "!" === group[0] && !isCondition(group);
}
function getGroupCriteria(group) {
  return isNegationGroup(group) ? group[1] : group;
}
function setGroupCriteria(group, criteria) {
  if (isNegationGroup(group)) {
    group[1] = criteria;
  } else {
    group = criteria;
  }
  return group;
}
function convertGroupToNewStructure(group, value2) {
  if ((function(value3) {
    return -1 !== value3.indexOf("!");
  })(value2)) {
    if (!isNegationGroup(group)) {
      !(function(group2) {
        const criteria = group2.slice(0);
        group2.length = 0;
        group2.push("!", criteria);
      })(group);
    }
  } else if (isNegationGroup(group)) {
    !(function(group2) {
      const criteria = getGroupCriteria(group2);
      group2.length = 0;
      [].push.apply(group2, criteria);
    })(group);
  }
}
function setGroupValue(group, value2) {
  convertGroupToNewStructure(group, value2);
  const criteria = getGroupCriteria(group);
  let i;
  value2 = (function(value3) {
    return -1 === value3.indexOf("!") ? value3 : value3.substring(1);
  })(value2);
  !(function(criteria2, value3) {
    for (i = 0; i < criteria2.length; i++) {
      if (!Array.isArray(criteria2[i])) {
        criteria2[i] = value3;
      }
    }
  })(criteria, value2);
  return group;
}
function getGroupMenuItem(group, availableGroups) {
  const groupValue = getGroupValue(group);
  return availableGroups.filter(((item) => item.value === groupValue))[0];
}
function getCriteriaOperation(criteria) {
  if (isCondition(criteria)) {
    return "and";
  }
  let value2 = "";
  for (let i = 0; i < criteria.length; i++) {
    const item = criteria[i];
    if (!Array.isArray(item)) {
      if (value2 && value2 !== item) {
        throw errors.Error("E4019");
      }
      if ("!" !== item) {
        value2 = item;
      }
    }
  }
  return value2;
}
function getGroupValue(group) {
  const criteria = getGroupCriteria(group);
  let value2 = getCriteriaOperation(criteria);
  if (!value2) {
    value2 = "and";
  }
  if (criteria !== group) {
    value2 = `!${value2}`;
  }
  return value2;
}
function getDefaultFilterOperations(field) {
  return field.lookup && LOOKUP_OPERATIONS || DATATYPE_OPERATIONS2[field.dataType || "string"];
}
function containItems(entity) {
  return Array.isArray(entity) && entity.length;
}
function getFilterOperations(field) {
  const result2 = containItems(field.filterOperations) ? field.filterOperations : getDefaultFilterOperations(field);
  return extend([], result2);
}
function getCaptionByOperation(operation, filterOperationDescriptions) {
  const operationName = m_filter_operations_dictionary_default.getNameByFilterOperation(operation);
  return filterOperationDescriptions && filterOperationDescriptions[operationName] ? filterOperationDescriptions[operationName] : operationName;
}
function getOperationFromAvailable(operation, availableOperations) {
  for (let i = 0; i < availableOperations.length; i++) {
    if (availableOperations[i].value === operation) {
      return availableOperations[i];
    }
  }
  throw new ui_errors_default.Error("E1048", operation);
}
function getCustomOperation(customOperations, name2) {
  const filteredOperations = customOperations.filter(((item) => item.name === name2));
  return filteredOperations.length ? filteredOperations[0] : null;
}
function getAvailableOperations(field, filterOperationDescriptions, customOperations) {
  const filterOperations = getFilterOperations(field);
  const isLookupField = !!field.lookup;
  customOperations.forEach(((customOperation) => {
    if (!field.filterOperations && -1 === filterOperations.indexOf(customOperation.name)) {
      const dataTypes = customOperation && customOperation.dataTypes;
      const isOperationForbidden = isLookupField ? !!customOperation.notForLookup : false;
      if (!isOperationForbidden && dataTypes && dataTypes.indexOf(field.dataType || "string") >= 0) {
        filterOperations.push(customOperation.name);
      }
    }
  }));
  return filterOperations.map(((operation) => {
    const customOperation = getCustomOperation(customOperations, operation);
    if (customOperation) {
      return {
        icon: customOperation.icon || "icon-none",
        text: customOperation.caption || captionize(customOperation.name),
        value: customOperation.name,
        isCustom: true
      };
    }
    return {
      icon: m_filter_operations_dictionary_default.getIconByFilterOperation(operation) || "icon-none",
      text: getCaptionByOperation(operation, filterOperationDescriptions),
      value: operation
    };
  }));
}
function getDefaultOperation(field) {
  return field.defaultFilterOperation || getFilterOperations(field)[0];
}
function createCondition(field, customOperations) {
  const condition = [field.dataField, "", ""];
  const filterOperation = getDefaultOperation(field);
  updateConditionByOperation(condition, filterOperation, customOperations);
  return condition;
}
function removeItem(group, item) {
  const criteria = getGroupCriteria(group);
  const index = criteria.indexOf(item);
  criteria.splice(index, 1);
  if (1 !== criteria.length) {
    criteria.splice(index, 1);
  }
  return group;
}
function createEmptyGroup(value2) {
  const isNegation = isNegationGroupOperation(value2);
  const groupOperation = isNegation ? getGroupOperationFromNegationOperation(value2) : value2;
  return isNegation ? ["!", [groupOperation]] : [groupOperation];
}
function addItem(item, group) {
  const criteria = getGroupCriteria(group);
  const groupValue = getGroupValue(criteria);
  1 === criteria.length ? criteria.unshift(item) : criteria.push(item, groupValue);
  return group;
}
function getField(dataField, fields) {
  for (let i = 0; i < fields.length; i++) {
    if (fields[i].name === dataField) {
      return fields[i];
    }
    if (fields[i].dataField.toLowerCase() === dataField.toLowerCase()) {
      return fields[i];
    }
  }
  const extendedFields = getItems(fields, true).filter(((item) => item.dataField.toLowerCase() === dataField.toLowerCase()));
  if (extendedFields.length > 0) {
    return extendedFields[0];
  }
  throw new ui_errors_default.Error("E1047", dataField);
}
function isGroup(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length < 2 || Array.isArray(criteria[0]) || Array.isArray(criteria[1]);
}
function isCondition(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length > 1 && !Array.isArray(criteria[0]) && !Array.isArray(criteria[1]);
}
function convertToInnerGroup(group, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  const groupOperation = getCriteriaOperation(group).toLowerCase() || defaultGroupOperation;
  let innerGroup = [];
  for (let i = 0; i < group.length; i++) {
    if (isGroup(group[i])) {
      innerGroup.push(convertToInnerStructure(group[i], customOperations, defaultGroupOperation));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    } else if (isCondition(group[i])) {
      innerGroup.push(convertToInnerCondition(group[i], customOperations));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    }
  }
  if (0 === innerGroup.length) {
    innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
  }
  return innerGroup;
}
function conditionHasCustomOperation(condition, customOperations) {
  const customOperation = getCustomOperation(customOperations, condition[1]);
  return customOperation && customOperation.name === condition[1];
}
function convertToInnerCondition(condition, customOperations) {
  if (conditionHasCustomOperation(condition, customOperations)) {
    return condition;
  }
  if (condition.length < 3) {
    condition[2] = condition[1];
    condition[1] = "=";
  }
  return condition;
}
function isNegationGroupOperation(operation) {
  return -1 !== operation.indexOf("not");
}
function getGroupOperationFromNegationOperation(operation) {
  return operation.substring(3).toLowerCase();
}
function appendGroupOperationToCriteria(criteria, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  return isNegation ? ["!", criteria, groupOperation] : [criteria, groupOperation];
}
function appendGroupOperationToGroup(group, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  group.push(groupOperation);
  let result2 = group;
  if (isNegation) {
    result2 = ["!", result2];
  }
  return result2;
}
function convertToInnerStructure(value2, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  if (!value2) {
    return createEmptyGroup(defaultGroupOperation);
  }
  value2 = extend(true, [], value2);
  if (isCondition(value2)) {
    return appendGroupOperationToCriteria(convertToInnerCondition(value2, customOperations), defaultGroupOperation);
  }
  if (isNegationGroup(value2)) {
    return ["!", isCondition(value2[1]) ? appendGroupOperationToCriteria(convertToInnerCondition(value2[1], customOperations), defaultGroupOperation) : isNegationGroup(value2[1]) ? appendGroupOperationToCriteria(convertToInnerStructure(value2[1], customOperations), defaultGroupOperation) : convertToInnerGroup(value2[1], customOperations, defaultGroupOperation)];
  }
  return convertToInnerGroup(value2, customOperations, defaultGroupOperation);
}
function getNormalizedFields(fields) {
  return fields.reduce(((result2, field) => {
    if (isDefined(field.dataField)) {
      const normalizedField = {};
      for (const key in field) {
        if (field[key] && AVAILABLE_FIELD_PROPERTIES.includes(key)) {
          normalizedField[key] = field[key];
        }
      }
      normalizedField.defaultCalculateFilterExpression = filtering_default.defaultCalculateFilterExpression;
      if (!isDefined(normalizedField.dataType)) {
        normalizedField.dataType = "string";
      }
      if (!isDefined(normalizedField.trueText)) {
        normalizedField.trueText = message_default.format("dxDataGrid-trueText");
      }
      if (!isDefined(normalizedField.falseText)) {
        normalizedField.falseText = message_default.format("dxDataGrid-falseText");
      }
      result2.push(normalizedField);
    }
    return result2;
  }), []);
}
function getConditionFilterExpression(condition, fields, customOperations, target) {
  const field = getField(condition[0], fields);
  const filterExpression = convertToInnerCondition(condition, customOperations);
  const customOperation = customOperations.length && getCustomOperation(customOperations, filterExpression[1]);
  if (customOperation && customOperation.calculateFilterExpression) {
    return customOperation.calculateFilterExpression.apply(customOperation, [filterExpression[2], field, fields]);
  }
  if (field.createFilterExpression) {
    return field.createFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  if (field.calculateFilterExpression) {
    return field.calculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  return field.defaultCalculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
}
function getFilterExpression(value2, fields, customOperations, target) {
  if (!isDefined(value2)) {
    return null;
  }
  if (isNegationGroup(value2)) {
    const filterExpression2 = getFilterExpression(value2[1], fields, customOperations, target);
    return ["!", filterExpression2];
  }
  const criteria = getGroupCriteria(value2);
  if (isCondition(criteria)) {
    return getConditionFilterExpression(criteria, fields, customOperations, target) || null;
  }
  let result2 = [];
  let filterExpression;
  const groupValue = getGroupValue(criteria);
  for (let i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      filterExpression = getFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        i && result2.push(groupValue);
        result2.push(filterExpression);
      }
    } else if (isCondition(criteria[i])) {
      filterExpression = getConditionFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        result2.length && result2.push(groupValue);
        result2.push(filterExpression);
      }
    }
  }
  if (1 === result2.length) {
    result2 = result2[0];
  }
  return result2.length ? result2 : null;
}
function getNormalizedFilter(group) {
  const criteria = getGroupCriteria(group);
  let i;
  if (0 === criteria.length) {
    return null;
  }
  const itemsForRemove = [];
  for (i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      const normalizedGroupValue = getNormalizedFilter(criteria[i]);
      if (normalizedGroupValue) {
        criteria[i] = normalizedGroupValue;
      } else {
        itemsForRemove.push(criteria[i]);
      }
    } else if (isCondition(criteria[i])) {
      if (!isValidCondition(criteria[i])) {
        itemsForRemove.push(criteria[i]);
      }
    }
  }
  for (i = 0; i < itemsForRemove.length; i++) {
    removeItem(criteria, itemsForRemove[i]);
  }
  if (1 === criteria.length) {
    return null;
  }
  criteria.splice(criteria.length - 1, 1);
  if (1 === criteria.length) {
    group = setGroupCriteria(group, criteria[0]);
  }
  if (0 === group.length) {
    return null;
  }
  return group;
}
function getCurrentLookupValueText(field, value2, handler) {
  if ("" === value2) {
    handler("");
    return;
  }
  const {
    lookup
  } = field;
  if (lookup.items) {
    handler(lookup.calculateCellValue(value2) || "");
  } else {
    const lookupDataSource = isFunction(lookup.dataSource) ? lookup.dataSource({}) : lookup.dataSource;
    const dataSource = new DataSource(lookupDataSource);
    dataSource.loadSingle(lookup.valueExpr, value2).done(((result2) => {
      let valueText = "";
      if (result2) {
        valueText = lookup.displayExpr ? compileGetter(lookup.displayExpr)(result2) : result2;
      }
      if (field.customizeText) {
        valueText = field.customizeText({
          value: value2,
          valueText
        });
      }
      handler(valueText);
    })).fail((() => {
      handler("");
    }));
  }
}
function getPrimitiveValueText(field, value2, customOperation, target, options2) {
  let valueText = getFormattedValueText(field, value2);
  if (field.customizeText) {
    valueText = field.customizeText.call(field, {
      value: value2,
      valueText,
      target
    });
  }
  if (customOperation && customOperation.customizeText) {
    valueText = customOperation.customizeText.call(customOperation, {
      value: value2,
      valueText,
      field,
      target
    }, options2);
  }
  return valueText;
}
function getArrayValueText(field, value2, customOperation, target) {
  const options2 = {
    values: value2
  };
  return value2.map(((v) => getPrimitiveValueText(field, v, customOperation, target, options2)));
}
function checkDefaultValue(value2) {
  return "" === value2 || null === value2;
}
function getCurrentValueText(field, value2, customOperation) {
  let target = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "filterBuilder";
  if (checkDefaultValue(value2)) {
    return "";
  }
  if (Array.isArray(value2)) {
    const result2 = new Deferred();
    when.apply(this, getArrayValueText(field, value2, customOperation, target)).done((function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const text = args.some(((item) => !checkDefaultValue(item))) ? args.map(((item) => !checkDefaultValue(item) ? item : "?")) : "";
      result2.resolve(text);
    }));
    return result2;
  }
  return getPrimitiveValueText(field, value2, customOperation, target);
}
function itemExists(plainItems, parentId) {
  return plainItems.some(((item) => item.dataField === parentId));
}
function pushItemAndCheckParent(originalItems, plainItems, item) {
  const {
    dataField
  } = item;
  if (hasParent(dataField)) {
    item.parentId = getParentIdFromItemDataField(dataField);
    if (!itemExists(plainItems, item.parentId) && !itemExists(originalItems, item.parentId)) {
      pushItemAndCheckParent(originalItems, plainItems, {
        id: item.parentId,
        dataType: "object",
        dataField: item.parentId,
        caption: generateCaptionByDataField(item.parentId, true),
        filterOperations: ["isblank", "isnotblank"],
        defaultCalculateFilterExpression: filtering_default.defaultCalculateFilterExpression
      });
    }
  }
  plainItems.push(item);
}
function generateCaptionByDataField(dataField, allowHierarchicalFields) {
  let caption = "";
  if (allowHierarchicalFields) {
    dataField = dataField.substring(dataField.lastIndexOf(".") + 1);
  } else if (hasParent(dataField)) {
    dataField.split(".").forEach(((field, index, arr) => {
      caption += captionize(field);
      if (index !== arr.length - 1) {
        caption += ".";
      }
    }));
    return caption;
  }
  return captionize(dataField);
}
function getItems(fields, allowHierarchicalFields) {
  const items = [];
  for (let i = 0; i < fields.length; i++) {
    const item = extend(true, {
      caption: generateCaptionByDataField(fields[i].dataField, allowHierarchicalFields)
    }, fields[i]);
    item.id = item.name || item.dataField;
    if (allowHierarchicalFields) {
      pushItemAndCheckParent(fields, items, item);
    } else {
      items.push(item);
    }
  }
  return items;
}
function hasParent(dataField) {
  return -1 !== dataField.lastIndexOf(".");
}
function getParentIdFromItemDataField(dataField) {
  return dataField.substring(0, dataField.lastIndexOf("."));
}
function getCaptionWithParents(item, plainItems) {
  if (hasParent(item.dataField)) {
    const parentId = getParentIdFromItemDataField(item.dataField);
    for (let i = 0; i < plainItems.length; i++) {
      if (plainItems[i].dataField === parentId) {
        return `${getCaptionWithParents(plainItems[i], plainItems)}.${item.caption}`;
      }
    }
  }
  return item.caption;
}
function updateConditionByOperation(condition, operation, customOperations) {
  let customOperation = getCustomOperation(customOperations, operation);
  if (customOperation) {
    if (false === customOperation.hasValue) {
      condition[1] = operation;
      condition.length = 2;
    } else {
      condition[1] = operation;
      condition[2] = "";
    }
    return condition;
  }
  if ("isblank" === operation) {
    condition[1] = "=";
    condition[2] = null;
  } else if ("isnotblank" === operation) {
    condition[1] = "<>";
    condition[2] = null;
  } else {
    customOperation = getCustomOperation(customOperations, condition[1]);
    if (customOperation || 2 === condition.length || null === condition[2]) {
      condition[2] = "";
    }
    condition[1] = operation;
  }
  return condition;
}
function getOperationValue(condition) {
  let caption;
  if (null === condition[2]) {
    if ("=" === condition[1]) {
      caption = "isblank";
    } else {
      caption = "isnotblank";
    }
  } else {
    caption = condition[1];
  }
  return caption;
}
function isValidCondition(condition) {
  return "" !== condition[2];
}
function getMergedOperations(customOperations, betweenCaption, context) {
  const result2 = extend(true, [], customOperations);
  let betweenIndex = -1;
  result2.some(((customOperation, index) => {
    if ("between" === customOperation.name) {
      betweenIndex = index;
      return true;
    }
    return;
  }));
  if (-1 !== betweenIndex) {
    result2[betweenIndex] = extend(getConfig2(betweenCaption, context), result2[betweenIndex]);
  } else {
    result2.unshift(getConfig2(betweenCaption, context));
  }
  return result2;
}
function isMatchedCondition(filter, addedFilterDataField) {
  return filter[0] === addedFilterDataField;
}
function removeFieldConditionsFromFilter(filter, dataField) {
  if (!filter || 0 === filter.length) {
    return null;
  }
  if (isCondition(filter)) {
    const hasMatchedCondition = isMatchedCondition(filter, dataField);
    return !hasMatchedCondition ? filter : null;
  }
  return syncConditionIntoGroup(filter, [dataField], false);
}
function syncConditionIntoGroup(filter, addedFilter, canPush) {
  const result2 = [];
  const isNegation = isNegationGroup(filter);
  filter.forEach(((item) => {
    if (isCondition(item)) {
      if (isMatchedCondition(item, addedFilter[0])) {
        if (canPush) {
          result2.push(addedFilter);
          canPush = false;
        } else {
          result2.splice(result2.length - 1, 1);
        }
      } else {
        result2.push(item);
      }
    } else {
      (result2.length || isGroup(item)) && result2.push(item);
    }
  }));
  if (0 === result2.length) {
    return null;
  }
  if (canPush) {
    result2.push("and");
    result2.push(addedFilter);
  }
  if (isNegation) {
    return ["!", 1 === result2.length ? result2[0] : result2];
  }
  return 1 === result2.length ? result2[0] : result2;
}
function syncFilters(filter, addedFilter) {
  if (null === filter || 0 === filter.length) {
    return addedFilter;
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, addedFilter[0])) {
      return addedFilter;
    }
    return [filter, "and", addedFilter];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [addedFilter, "and", filter];
  }
  return syncConditionIntoGroup(filter, addedFilter, true);
}
function getMatchedConditions(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return [];
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, dataField)) {
      return [filter];
    }
    return [];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [];
  }
  const result2 = filter.filter(((item) => isCondition(item) && isMatchedCondition(item, dataField)));
  return result2;
}
function filterHasField(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return false;
  }
  if (isCondition(filter)) {
    return filter[0] === dataField;
  }
  return filter.some(((item) => (isCondition(item) || isGroup(item)) && filterHasField(item, dataField)));
}
var renderValueText = function($container, value2, customOperation) {
  if (Array.isArray(value2)) {
    const lastItemIndex = value2.length - 1;
    $container.empty();
    value2.forEach(((t, i) => {
      renderer_default("<span>").addClass("dx-filterbuilder-text-part").text(t).appendTo($container);
      if (i !== lastItemIndex) {
        renderer_default("<span>").addClass("dx-filterbuilder-text-separator").text(customOperation && customOperation.valueSeparator ? customOperation.valueSeparator : "|").addClass("dx-filterbuilder-text-separator-empty").appendTo($container);
      }
    }));
  } else if (value2) {
    $container.text(value2);
  } else {
    $container.text(message_default.format("dxFilterBuilder-enterValueText"));
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_custom_operations.js
function baseOperation(grid) {
  const getFullText = function(itemText, parentText) {
    return parentText ? `${parentText}/${itemText}` : itemText;
  };
  const getSelectedItemsTexts = function(items, parentText) {
    let result2 = [];
    items.forEach(((item) => {
      if (item.items) {
        const selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
        result2 = result2.concat(selectedItemsTexts);
      }
      item.selected && result2.push(getFullText(item.text, parentText));
    }));
    return result2;
  };
  const headerFilterController = grid && grid.getController("headerFilter");
  return {
    dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
    calculateFilterExpression: function(filterValue, field, fields) {
      const result2 = [];
      const lastIndex = filterValue.length - 1;
      filterValue && filterValue.forEach(((value2, index) => {
        if (isCondition(value2) || isGroup(value2)) {
          const filterExpression = getFilterExpression(value2, fields, [], "headerFilter");
          result2.push(filterExpression);
        } else {
          const filterExpression = getFilterExpression([field.dataField, "=", value2], fields, [], "headerFilter");
          result2.push(filterExpression);
        }
        index !== lastIndex && result2.push("or");
      }));
      if (1 === result2.length) {
        return result2[0];
      }
      return result2;
    },
    editorTemplate(conditionInfo, container) {
      const div = renderer_default("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
      const column = extend(true, {}, grid.columnOption(conditionInfo.field.dataField));
      renderValueText(div, conditionInfo.text && conditionInfo.text.split("|"));
      column.filterType = "include";
      column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
      headerFilterController.showHeaderFilterMenuBase({
        columnElement: div,
        column,
        apply() {
          value2 = this.filterValues, void conditionInfo.setValue(value2);
          var value2;
          headerFilterController.hideHeaderFilterMenu();
          conditionInfo.closeEditor();
        },
        onHidden() {
          conditionInfo.closeEditor();
        },
        isFilterBuilder: true
      });
      return container;
    },
    customizeText: function(fieldInfo, options2) {
      options2 = options2 || {};
      const {
        value: value2
      } = fieldInfo;
      let column = grid.columnOption(fieldInfo.field.dataField);
      const headerFilter = column && column.headerFilter;
      const lookup = column && column.lookup;
      const values = options2.values || [value2];
      if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
        const result2 = new Deferred();
        const itemsDeferred = options2.items || new Deferred();
        if (!options2.items) {
          column = extend({}, column, {
            filterType: "include",
            filterValues: values
          });
          const dataSourceOptions = headerFilterController.getDataSource(column);
          dataSourceOptions.paginate = false;
          const dataSource = new DataSource(dataSourceOptions);
          const key = dataSource.store().key();
          if (key) {
            const {
              values: values2
            } = options2;
            if (values2 && values2.length > 1) {
              const filter = values2.reduce(((result3, value3) => {
                if (result3.length) {
                  result3.push("or");
                }
                result3.push([key, "=", value3]);
                return result3;
              }), []);
              dataSource.filter(filter);
            } else {
              dataSource.filter([key, "=", fieldInfo.value]);
            }
          } else if (fieldInfo.field.calculateDisplayValue) {
            ui_errors_default.log("W1017");
          }
          options2.items = itemsDeferred;
          dataSource.load().done(itemsDeferred.resolve);
        }
        itemsDeferred.done(((items) => {
          const index = values.indexOf(fieldInfo.value);
          result2.resolve(getSelectedItemsTexts(items, null)[index]);
        }));
        return result2;
      }
      const text = headerFilterController.getHeaderItemText(value2, column, 0, grid.option("headerFilter"));
      return text;
    }
  };
}
function anyOf(grid) {
  return extend(baseOperation(grid), {
    name: "anyof",
    icon: "selectall",
    caption: message_default.format("dxFilterBuilder-filterOperationAnyOf")
  });
}
function noneOf(grid) {
  const baseOp = baseOperation(grid);
  return extend({}, baseOp, {
    calculateFilterExpression(filterValue, field, fields) {
      const baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
      if (!baseFilter || 0 === baseFilter.length) {
        return null;
      }
      return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter];
    },
    name: "noneof",
    icon: "unselectall",
    caption: message_default.format("dxFilterBuilder-filterOperationNoneOf")
  });
}

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_sync.js
var FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
function getColumnIdentifier(column) {
  return column.name || column.dataField;
}
function checkForErrors(columns7) {
  columns7.forEach(((column) => {
    const identifier = getColumnIdentifier(column);
    if (!isDefined(identifier) && column.allowFiltering) {
      throw new ui_errors_default.Error("E1049", column.caption);
    }
  }));
}
var getEmptyFilterValues = function() {
  return {
    filterType: "include",
    filterValues: void 0
  };
};
var canSyncHeaderFilterWithFilterRow = function(column) {
  const filterValues = column.filterValues || [];
  return !filtering_default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource) || 1 === filterValues.length && null === filterValues[0];
};
var getHeaderFilterFromCondition = function(headerFilterCondition, column) {
  if (!headerFilterCondition) {
    return getEmptyFilterValues();
  }
  let filterType;
  const selectedFilterOperation = headerFilterCondition[1];
  const value2 = headerFilterCondition[2];
  const hasArrayValue = Array.isArray(value2);
  if (!hasArrayValue) {
    if (!canSyncHeaderFilterWithFilterRow(column)) {
      return getEmptyFilterValues();
    }
  }
  switch (selectedFilterOperation) {
    case "anyof":
    case "=":
      filterType = "include";
      break;
    case "noneof":
    case "<>":
      filterType = "exclude";
      break;
    default:
      return getEmptyFilterValues();
  }
  return {
    filterType,
    filterValues: hasArrayValue ? value2 : [value2]
  };
};
var getConditionFromFilterRow = function(column) {
  const value2 = column.filterValue;
  if (isDefined(value2)) {
    const operation = column.selectedFilterOperation || column.defaultFilterOperation || getDefaultOperation(column);
    const filter = [getColumnIdentifier(column), operation, column.filterValue];
    return filter;
  }
  return null;
};
var getConditionFromHeaderFilter = function(column) {
  let selectedOperation;
  let value2;
  const {
    filterValues
  } = column;
  if (!filterValues) {
    return null;
  }
  if (1 === filterValues.length && canSyncHeaderFilterWithFilterRow(column) && !Array.isArray(filterValues[0])) {
    "exclude" === column.filterType ? selectedOperation = "<>" : selectedOperation = "=";
    value2 = filterValues[0];
  } else {
    "exclude" === column.filterType ? selectedOperation = "noneof" : selectedOperation = "anyof";
    value2 = filterValues;
  }
  return [getColumnIdentifier(column), selectedOperation, value2];
};
var updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
  const headerFilter = getHeaderFilterFromCondition(headerFilterCondition, column);
  columnsController.columnOption(getColumnIdentifier(column), headerFilter);
};
var updateFilterRowCondition = function(columnsController, column, condition) {
  let filterRowOptions;
  let selectedFilterOperation = null === condition || void 0 === condition ? void 0 : condition[1];
  const filterValue = null === condition || void 0 === condition ? void 0 : condition[2];
  const filterOperations = column.filterOperations || column.defaultFilterOperations;
  const selectedOperationExists = !filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0;
  const defaultOperationSelected = selectedFilterOperation === column.defaultFilterOperation;
  const builtInOperationSelected = FILTER_ROW_OPERATIONS.includes(selectedFilterOperation);
  const filterValueNotNullOrEmpty = null !== filterValue && "" !== filterValue;
  if ((selectedOperationExists || defaultOperationSelected) && builtInOperationSelected && filterValueNotNullOrEmpty) {
    if (defaultOperationSelected && !isDefined(column.selectedFilterOperation)) {
      selectedFilterOperation = column.selectedFilterOperation;
    }
    filterRowOptions = {
      filterValue,
      selectedFilterOperation
    };
  } else {
    filterRowOptions = {
      filterValue: void 0,
      selectedFilterOperation: void 0
    };
  }
  columnsController.columnOption(getColumnIdentifier(column), filterRowOptions);
};
var FilterSyncController = class extends m_modules_default.Controller {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    if (this._dataController.isFilterSyncActive()) {
      if (this._columnsController.isAllDataTypesDefined()) {
        this._initSync();
      } else {
        this._dataController.dataSourceChanged.add((() => this._initSync()));
      }
    }
  }
  publicMethods() {
    return ["getCustomFilterOperations"];
  }
  syncFilterValue() {
    const that = this;
    const columns7 = this._columnsController.getFilteringColumns();
    this._skipSyncColumnOptions = true;
    columns7.forEach(((column) => {
      const filterConditions = getMatchedConditions(that.option("filterValue"), getColumnIdentifier(column));
      if (1 === filterConditions.length) {
        const filterCondition = filterConditions[0];
        updateHeaderFilterCondition(this._columnsController, column, filterCondition);
        updateFilterRowCondition(this._columnsController, column, filterCondition);
      } else {
        isDefined(column.filterValues) && updateHeaderFilterCondition(this._columnsController, column, null);
        isDefined(column.filterValue) && updateFilterRowCondition(this._columnsController, column, null);
      }
    }));
    this._skipSyncColumnOptions = false;
  }
  _initSync() {
    const columns7 = this._columnsController.getColumns();
    const pageIndex = this._dataController.pageIndex();
    checkForErrors(columns7);
    if (!this.option("filterValue")) {
      const filteringColumns = this._columnsController.getFilteringColumns();
      const filterValue = this.getFilterValueFromColumns(filteringColumns);
      this._silentOption("filterValue", filterValue);
    }
    this.syncFilterValue();
    this._dataController.pageIndex(pageIndex);
  }
  _getSyncFilterRow(filterValue, column) {
    const filter = getConditionFromFilterRow(column);
    if (isDefined(filter)) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  _getSyncHeaderFilter(filterValue, column) {
    const filter = getConditionFromHeaderFilter(column);
    if (filter) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  getFilterValueFromColumns(columns7) {
    if (!this._dataController.isFilterSyncActive()) {
      return null;
    }
    const filterValue = ["and"];
    columns7 && columns7.forEach(((column) => {
      const headerFilter = getConditionFromHeaderFilter(column);
      const filterRow = getConditionFromFilterRow(column);
      headerFilter && addItem(headerFilter, filterValue);
      filterRow && addItem(filterRow, filterValue);
    }));
    return getNormalizedFilter(filterValue);
  }
  syncFilterRow(column, filterValue) {
    this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column));
  }
  syncHeaderFilter(column) {
    this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column));
  }
  getCustomFilterOperations() {
    const filterBuilderCustomOperations = this.option("filterBuilder.customOperations") ?? [];
    return [anyOf(this.component), noneOf(this.component)].concat(filterBuilderCustomOperations);
  }
};
var data10 = (Base) => class extends Base {
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._applyFilter();
        this.isFilterSyncActive() && this._filterSyncController.syncFilterValue();
        args.handled = true;
        break;
      case "filterSyncEnabled":
        args.handled = true;
        break;
      case "columns":
        if (this.isFilterSyncActive()) {
          const column = this._columnsController.getColumnByPath(args.fullName);
          if (column && !this._filterSyncController._skipSyncColumnOptions) {
            const propertyName = this._parseColumnPropertyName(args.fullName);
            this._filterSyncController._skipSyncColumnOptions = true;
            if ("filterType" === propertyName) {
              if ("exclude" === args.value || "exclude" === args.previousValue) {
                this._filterSyncController.syncHeaderFilter(column);
              }
            } else if ("filterValues" === propertyName) {
              this._filterSyncController.syncHeaderFilter(column);
            } else if (["filterValue", "selectedFilterOperation"].includes(propertyName)) {
              this._filterSyncController.syncFilterRow(column, column.filterValue);
            }
            this._filterSyncController._skipSyncColumnOptions = false;
          }
        }
        super.optionChanged(args);
        break;
      default:
        super.optionChanged(args);
    }
  }
  isFilterSyncActive() {
    const filterSyncEnabledValue = this.option("filterSyncEnabled");
    return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue;
  }
  skipCalculateColumnFilters() {
    return (isDefined(this.option("filterValue")) || this._filterSyncController._skipSyncColumnOptions) && this.isFilterSyncActive();
  }
  _calculateAdditionalFilter() {
    if (false === this.option("filterPanel.filterEnabled")) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getFilteringColumns();
    let filterValue = this.option("filterValue");
    if (this.isFilterSyncActive()) {
      const currentColumnForHeaderFilter = this._headerFilterController.getCurrentColumn();
      const currentColumnForFilterRow = this._applyFilterController.getCurrentColumnForFiltering();
      const currentColumn = currentColumnForHeaderFilter || currentColumnForFilterRow;
      const needRemoveCurrentColumnFilter = currentColumnForHeaderFilter || isDefined(null === currentColumnForFilterRow || void 0 === currentColumnForFilterRow ? void 0 : currentColumnForFilterRow.filterValue);
      if (needRemoveCurrentColumnFilter && filterValue) {
        filterValue = removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(currentColumn));
      }
    }
    const customOperations = this._filterSyncController.getCustomFilterOperations();
    const calculatedFilterValue = getFilterExpression(filterValue, columns7, customOperations, "filterBuilder");
    if (calculatedFilterValue) {
      filters.push(calculatedFilterValue);
    }
    return m_utils_default.combineFilters(filters);
  }
  _parseColumnPropertyName(fullName) {
    const matched = fullName.match(/.*\.(.*)/);
    if (matched) {
      return matched[1];
    }
    return null;
  }
  clearFilter(filterName) {
    this.component.beginUpdate();
    if (arguments.length > 0) {
      if ("filterValue" === filterName) {
        this.option("filterValue", null);
      }
      super.clearFilter(filterName);
    } else {
      this.option("filterValue", null);
      super.clearFilter();
    }
    this.component.endUpdate();
  }
  _applyFilter() {
    if (this._filterSyncController._skipSyncColumnOptions) {
      return new Deferred().resolve();
    }
    return super._applyFilter.apply(this, arguments);
  }
};
var columnHeadersView5 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterValue" === args.name) {
      this._updateHeaderFilterIndicators();
    } else {
      super.optionChanged(args);
    }
  }
  _isHeaderFilterEmpty(column) {
    if (this._dataController.isFilterSyncActive()) {
      return !filterHasField(this.option("filterValue"), getColumnIdentifier(column));
    }
    return super._isHeaderFilterEmpty(column);
  }
  _needUpdateFilterIndicators() {
    return !this._dataController.isFilterSyncActive();
  }
};
var filterSyncModule = {
  defaultOptions: () => ({
    filterValue: null,
    filterSyncEnabled: "auto"
  }),
  controllers: {
    filterSync: FilterSyncController
  },
  extenders: {
    controllers: {
      data: data10
    },
    views: {
      columnHeadersView: columnHeadersView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_sync.js
m_core_default.registerModule("filterSync", filterSyncModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_builder.js
var FILTER_BUILDER_IMAGE_CLASS = "dx-filterbuilder-action-icon";
var ACTIVE_CLASS = "dx-state-active";
var SOURCE = "filterBuilder";
var TREEVIEW_NODE_CONTAINER = "dx-treeview-node-container";
var ACTIONS3 = [{
  name: "onEditorPreparing",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onEditorPrepared",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onValueChanged",
  config: {
    excludeValidators: ["disabled", "readOnly"]
  }
}];
var OPERATORS = {
  and: "and",
  or: "or",
  notAnd: "!and",
  notOr: "!or"
};
var EditorFactory2 = ui_editor_factory_mixin_default(class {
});
var FilterBuilder = class extends ui_widget_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      onEditorPreparing: null,
      onEditorPrepared: null,
      onValueChanged: null,
      fields: [],
      groupOperations: ["and", "or", "notAnd", "notOr"],
      maxGroupLevel: void 0,
      value: null,
      allowHierarchicalFields: false,
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      customOperations: [],
      closePopupOnTargetScroll: true,
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "closePopupOnTargetScroll":
        break;
      case "onEditorPreparing":
      case "onEditorPrepared":
      case "onValueChanged":
        this._initActions();
        break;
      case "customOperations":
        this._initCustomOperations();
        this._invalidate();
        break;
      case "fields":
      case "maxGroupLevel":
      case "groupOperations":
      case "allowHierarchicalFields":
      case "groupOperationDescriptions":
      case "filterOperationDescriptions":
        this._invalidate();
        break;
      case "value":
        if (args.value !== args.previousValue) {
          const disableInvalidateForValue = this._disableInvalidateForValue;
          if (!disableInvalidateForValue) {
            this._initModel();
            this._invalidate();
          }
          this._disableInvalidateForValue = false;
          this.executeAction("onValueChanged", {
            value: args.value,
            previousValue: args.previousValue
          });
          this._disableInvalidateForValue = disableInvalidateForValue;
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  getFilterExpression() {
    const fields = this._getNormalizedFields();
    const value2 = extend(true, [], this._model);
    return getFilterExpression(getNormalizedFilter(value2), fields, this._customOperations, SOURCE);
  }
  _getNormalizedFields() {
    return getNormalizedFields(this.option("fields"));
  }
  _updateFilter() {
    this._disableInvalidateForValue = true;
    const value2 = extend(true, [], this._model);
    const normalizedValue = getNormalizedFilter(value2);
    const oldValue = getNormalizedFilter(this._getModel(this.option("value")));
    if (JSON.stringify(oldValue) !== JSON.stringify(normalizedValue)) {
      this.option("value", normalizedValue);
    }
    this._disableInvalidateForValue = false;
    this._fireContentReadyAction();
  }
  _init() {
    this._initCustomOperations();
    this._initModel();
    this._initEditorFactory();
    this._initActions();
    super._init();
  }
  _initEditorFactory() {
    this._editorFactory = new EditorFactory2();
  }
  _initCustomOperations() {
    this._customOperations = getMergedOperations(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this);
  }
  _getDefaultGroupOperation() {
    var _this$option;
    return (null === (_this$option = this.option("groupOperations")) || void 0 === _this$option ? void 0 : _this$option[0]) ?? OPERATORS.and;
  }
  _getModel(value2) {
    return convertToInnerStructure(value2, this._customOperations, this._getDefaultGroupOperation());
  }
  _initModel() {
    this._model = this._getModel(this.option("value"));
  }
  _initActions() {
    const that = this;
    that._actions = {};
    ACTIONS3.forEach(((action) => {
      const actionConfig = extend({}, action.config);
      that._actions[action.name] = that._createActionByOption(action.name, actionConfig);
    }));
  }
  executeAction(actionName, options2) {
    const action = this._actions[actionName];
    return action && action(options2);
  }
  _initMarkup() {
    this.$element().addClass("dx-filterbuilder");
    super._initMarkup();
    this._addAriaAttributes(this.$element(), message_default.format("dxFilterBuilder-filterAriaRootElement"), "group");
    this._createGroupElementByCriteria(this._model).appendTo(this.$element());
  }
  _addAriaAttributes($element, ariaLabel, role, hasPopup, hasExpanded, ariaLevel) {
    if (!$element || !$element.length) {
      return;
    }
    const attributes = {
      role
    };
    if (ariaLabel) {
      if ($element.text().length > 0) {
        attributes.title = ariaLabel;
      } else {
        attributes["aria-label"] = ariaLabel;
      }
    }
    if (isDefined(hasPopup)) {
      attributes["aria-haspopup"] = `${hasPopup}`;
    }
    if (isDefined(hasExpanded)) {
      attributes["aria-expanded"] = `${hasExpanded}`;
    }
    if (isDefined(ariaLevel)) {
      attributes["aria-level"] = `${ariaLevel}`;
    }
    $element.attr(attributes);
  }
  _createConditionElement(condition, parent, groupLevel) {
    return renderer_default("<div>").addClass("dx-filterbuilder-group").append(this._createConditionItem(condition, parent, groupLevel)).attr("role", "group");
  }
  _createGroupElementByCriteria(criteria, parent) {
    let groupLevel = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const $group = this._createGroupElement(criteria, parent, groupLevel);
    const $groupContent = $group.find(".dx-filterbuilder-group-content");
    const groupCriteria = getGroupCriteria(criteria);
    for (let i = 0; i < groupCriteria.length; i++) {
      const innerCriteria = groupCriteria[i];
      if (isGroup(innerCriteria)) {
        this._createGroupElementByCriteria(innerCriteria, criteria, groupLevel + 1).appendTo($groupContent);
      } else if (isCondition(innerCriteria)) {
        this._createConditionElement(innerCriteria, criteria, `${groupLevel + 1}`).appendTo($groupContent);
      }
    }
    return $group;
  }
  _createGroupElement(criteria, parent, groupLevel) {
    const $guid = new guid_default();
    const $groupItem = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const $groupContent = renderer_default("<div>").addClass("dx-filterbuilder-group-content").attr("id", `${$guid}`);
    const $group = renderer_default("<div>").addClass("dx-filterbuilder-group").append($groupItem).append($groupContent);
    if (null != parent) {
      this._createRemoveButton((() => {
        removeItem(parent, criteria);
        $group.remove();
        this._updateFilter();
      }), "group").appendTo($groupItem);
    }
    let groupItemLevel = groupLevel;
    if (0 === groupLevel) {
      this._addAriaAttributes($group, "", "tree");
      groupItemLevel += 1;
    }
    this._addAriaAttributes($groupItem, message_default.format("dxFilterBuilder-filterAriaGroupItem"), "treeitem", null, null, groupItemLevel);
    $groupItem.attr("aria-owns", `${$guid}`);
    this._createGroupOperationButton(criteria).appendTo($groupItem);
    this._createAddButton((() => {
      const newGroup = createEmptyGroup(this._getDefaultGroupOperation());
      addItem(newGroup, criteria);
      this._createGroupElement(newGroup, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }), (() => {
      const field = this.option("fields")[0];
      const newCondition = createCondition(field, this._customOperations);
      addItem(newCondition, criteria);
      this._createConditionElement(newCondition, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }), groupLevel).appendTo($groupItem);
    return $group;
  }
  _createButton(caption) {
    return renderer_default("<div>").text(caption);
  }
  _createGroupOperationButton(criteria) {
    const groupOperations = this._getGroupOperations(criteria);
    let groupMenuItem = getGroupMenuItem(criteria, groupOperations);
    const caption = groupMenuItem.text;
    const $operationButton = groupOperations && groupOperations.length < 2 ? this._createButton(caption).addClass("dx-state-disabled") : this._createButtonWithMenu({
      caption,
      menu: {
        items: groupOperations,
        displayExpr: "text",
        keyExpr: "value",
        onItemClick: (e) => {
          if (groupMenuItem !== e.itemData) {
            setGroupValue(criteria, e.itemData.value);
            $operationButton.text(e.itemData.text);
            groupMenuItem = e.itemData;
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(groupMenuItem);
        },
        cssClass: "dx-filterbuilder-group-operations"
      }
    });
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaOperationButton"), "combobox", true, false);
    return $operationButton.addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-group-operation").attr("tabindex", 0);
  }
  _createButtonWithMenu(options2) {
    const that = this;
    const removeMenu = function() {
      that.$element().find(`.${ACTIVE_CLASS}`).removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      that.$element().find(".dx-overlay .dx-treeview").remove();
      that.$element().find(".dx-overlay").remove();
    };
    const rtlEnabled = this.option("rtlEnabled");
    const position2 = rtlEnabled ? "right" : "left";
    const $button = this._createButton(options2.caption);
    const $guid = new guid_default();
    $button.attr("aria-controls", `${$guid}`);
    extend(options2.menu, {
      id: $guid,
      focusStateEnabled: true,
      selectionMode: "single",
      onItemClick: (handler = options2.menu.onItemClick, function(e) {
        handler(e);
        if ("dxclick" === e.event.type) {
          removeMenu();
        }
      }),
      onHiding() {
        $button.removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      },
      position: {
        my: `${position2} top`,
        at: `${position2} bottom`,
        offset: "0 1",
        of: $button,
        collision: "flip"
      },
      animation: null,
      onHidden() {
        removeMenu();
      },
      cssClass: `dx-filterbuilder-overlay ${options2.menu.cssClass}`,
      rtlEnabled
    });
    var handler;
    options2.popup = {
      onShown(info) {
        const treeViewContentElement = renderer_default(info.component.content());
        const treeViewElement = treeViewContentElement.find(".dx-treeview");
        if (treeViewElement.length) {
          that._applyAccessibilityAttributes(treeViewElement);
        }
        m_events_engine_default.on(treeViewElement, "keyup keydown", ((e) => {
          const keyName = normalizeKeyName(e);
          if ("keydown" === e.type && "tab" === keyName || "keyup" === e.type && ("escape" === keyName || "enter" === keyName)) {
            info.component.hide();
            m_events_engine_default.trigger(options2.menu.position.of, "focus");
          }
        }));
        const treeView = treeViewElement.dxTreeView("instance");
        treeView.focus();
        treeView.option("focusedElement", null);
      }
    };
    this._subscribeOnClickAndEnterKey($button, (() => {
      removeMenu();
      that._createPopupWithTreeView(options2, that.$element());
      $button.addClass(ACTIVE_CLASS).attr("aria-expanded", "true");
    }));
    return $button;
  }
  _hasValueButton(condition) {
    const customOperation = getCustomOperation(this._customOperations, condition[1]);
    return customOperation ? false !== customOperation.hasValue : null !== condition[2];
  }
  _createOperationButtonWithMenu(condition, field) {
    const that = this;
    const availableOperations = getAvailableOperations(field, this.option("filterOperationDescriptions"), this._customOperations);
    let currentOperation = getOperationFromAvailable(getOperationValue(condition), availableOperations);
    const $operationButton = this._createButtonWithMenu({
      caption: currentOperation.text,
      menu: {
        items: availableOperations,
        displayExpr: "text",
        onItemRendered(e) {
          e.itemData.isCustom && renderer_default(e.itemElement).addClass("dx-filterbuilder-menu-custom-operation");
        },
        onContentReady(e) {
          e.component.selectItem(currentOperation);
        },
        onItemClick: (e) => {
          if (currentOperation !== e.itemData) {
            currentOperation = e.itemData;
            updateConditionByOperation(condition, currentOperation.value, that._customOperations);
            const $valueButton = $operationButton.siblings().filter(".dx-filterbuilder-item-value");
            if (that._hasValueButton(condition)) {
              if (0 !== $valueButton.length) {
                $valueButton.remove();
              }
              that._createValueButton(condition, field).appendTo($operationButton.parent());
            } else {
              $valueButton.remove();
            }
            $operationButton.text(currentOperation.text);
            this._updateFilter();
          }
        },
        cssClass: "dx-filterbuilder-operations"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-operation").attr("tabindex", 0);
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaItemOperation"), "combobox", true, false);
    return $operationButton;
  }
  _createOperationAndValueButtons(condition, field, $item) {
    this._createOperationButtonWithMenu(condition, field).appendTo($item);
    if (this._hasValueButton(condition)) {
      this._createValueButton(condition, field).appendTo($item);
    }
  }
  _createFieldButtonWithMenu(fields, condition, field) {
    const that = this;
    const allowHierarchicalFields = this.option("allowHierarchicalFields");
    const items = getItems(fields, allowHierarchicalFields);
    let item = getField(field.name || field.dataField, items);
    const getFullCaption = function(item2, items2) {
      return allowHierarchicalFields ? getCaptionWithParents(item2, items2) : item2.caption;
    };
    condition[0] = item.name || item.dataField;
    const $fieldButton = this._createButtonWithMenu({
      caption: getFullCaption(item, items),
      menu: {
        items,
        dataStructure: "plain",
        keyExpr: "id",
        parentId: "parentId",
        displayExpr: "caption",
        onItemClick: (e) => {
          if (item !== e.itemData) {
            item = e.itemData;
            condition[0] = item.name || item.dataField;
            condition[2] = "object" === item.dataType ? null : "";
            updateConditionByOperation(condition, getDefaultOperation(item), that._customOperations);
            $fieldButton.siblings().filter(".dx-filterbuilder-text").remove();
            that._createOperationAndValueButtons(condition, item, $fieldButton.parent());
            const caption = getFullCaption(item, e.component.option("items"));
            $fieldButton.text(caption);
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(item);
        },
        cssClass: "dx-filterbuilder-fields"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-field").attr("tabindex", 0);
    this._addAriaAttributes($fieldButton, message_default.format("dxFilterBuilder-filterAriaItemField"), "combobox", true, false);
    return $fieldButton;
  }
  _createConditionItem(condition, parent, groupLevel) {
    const $item = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const fields = this._getNormalizedFields();
    const field = getField(condition[0], fields);
    this._addAriaAttributes($item, "", "treeitem", null, null, groupLevel);
    this._createRemoveButton((() => {
      removeItem(parent, condition);
      const isSingleChild = 1 === $item.parent().children().length;
      if (isSingleChild) {
        $item.parent().remove();
      } else {
        $item.remove();
      }
      this._updateFilter();
    }), "condition").appendTo($item);
    this._createFieldButtonWithMenu(fields, condition, field).appendTo($item);
    this._createOperationAndValueButtons(condition, field, $item);
    return $item;
  }
  _getGroupOperations(criteria) {
    let groupOperations = this.option("groupOperations");
    const groupOperationDescriptions = this.option("groupOperationDescriptions");
    if (!groupOperations || !groupOperations.length) {
      groupOperations = [getGroupValue(criteria).replace("!", "not")];
    }
    return groupOperations.map(((operation) => ({
      text: groupOperationDescriptions[operation],
      value: OPERATORS[operation]
    })));
  }
  _createRemoveButton(handler, type2) {
    const $removeButton = renderer_default("<div>").addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-remove").addClass("dx-filterbuilder-action").attr("tabindex", 0);
    if (type2) {
      const removeMessage = message_default.format("dxFilterBuilder-filterAriaRemoveButton", type2);
      this._addAriaAttributes($removeButton, removeMessage, "button");
    }
    this._subscribeOnClickAndEnterKey($removeButton, handler);
    return $removeButton;
  }
  _createAddButton(addGroupHandler, addConditionHandler, groupLevel) {
    let $button;
    const maxGroupLevel = this.option("maxGroupLevel");
    if (isDefined(maxGroupLevel) && groupLevel >= maxGroupLevel) {
      $button = this._createButton();
      this._subscribeOnClickAndEnterKey($button, addConditionHandler);
    } else {
      $button = this._createButtonWithMenu({
        menu: {
          items: [{
            caption: message_default.format("dxFilterBuilder-addCondition"),
            click: addConditionHandler
          }, {
            caption: message_default.format("dxFilterBuilder-addGroup"),
            click: addGroupHandler
          }],
          displayExpr: "caption",
          onItemClick(e) {
            e.itemData.click();
          },
          cssClass: "dx-filterbuilder-add-condition"
        }
      });
    }
    this._addAriaAttributes($button, message_default.format("dxFilterBuilder-filterAriaAddButton"), "combobox", true, false);
    return $button.addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-plus").addClass("dx-filterbuilder-action").attr("tabindex", 0);
  }
  _createValueText(item, field, $container) {
    const that = this;
    const $text = renderer_default("<div>").html("&nbsp;").addClass("dx-filterbuilder-item-value-text").attr("tabindex", 0).appendTo($container);
    this._addAriaAttributes($text, message_default.format("dxFilterBuilder-filterAriaItemValue"), "button", true);
    const value2 = item[2];
    const customOperation = getCustomOperation(that._customOperations, item[1]);
    if (!customOperation && field.lookup) {
      getCurrentLookupValueText(field, value2, ((result2) => {
        renderValueText($text, result2);
      }));
    } else {
      when(getCurrentValueText(field, value2, customOperation)).done(((result2) => {
        renderValueText($text, result2, customOperation);
      }));
    }
    that._subscribeOnClickAndEnterKey($text, ((e) => {
      if ("keyup" === e.type) {
        e.stopPropagation();
      }
      that._createValueEditorWithEvents(item, field, $container);
    }));
    return $text;
  }
  _updateConditionValue(item, value2, callback) {
    const areValuesDifferent = item[2] !== value2;
    if (areValuesDifferent) {
      item[2] = value2;
    }
    callback();
    this._updateFilter();
  }
  _addDocumentKeyUp($editor, handler) {
    let isComposing = false;
    let hasCompositionJustEnded = false;
    const document2 = dom_adapter_default.getDocument();
    const documentKeyUpHandler = (e) => {
      if (isComposing || hasCompositionJustEnded) {
        hasCompositionJustEnded = false;
        return;
      }
      handler(e);
    };
    m_events_engine_default.on(document2, "keyup", documentKeyUpHandler);
    const input = $editor.find("input");
    m_events_engine_default.on(input, "compositionstart", (() => {
      isComposing = true;
    }));
    m_events_engine_default.on(input, "compositionend", (() => {
      isComposing = false;
      hasCompositionJustEnded = true;
    }));
    m_events_engine_default.on(input, "keydown", ((event) => {
      if (229 !== event.which) {
        hasCompositionJustEnded = false;
      }
    }));
    this._documentKeyUpHandler = documentKeyUpHandler;
  }
  _addDocumentClick($editor, closeEditorFunc) {
    const document2 = dom_adapter_default.getDocument();
    const documentClickHandler = (e) => {
      if (!this._isFocusOnEditorParts($editor, e.target)) {
        m_events_engine_default.trigger($editor.find("input"), "change");
        closeEditorFunc();
      }
    };
    m_events_engine_default.on(document2, "dxpointerdown", documentClickHandler);
    this._documentClickHandler = documentClickHandler;
  }
  _isFocusOnEditorParts($editor, target) {
    const activeElement = target || dom_adapter_default.getActiveElement();
    return renderer_default(activeElement).closest($editor.children()).length || renderer_default(activeElement).closest(".dx-dropdowneditor-overlay").length;
  }
  _removeEvents() {
    const document2 = dom_adapter_default.getDocument();
    isDefined(this._documentKeyUpHandler) && m_events_engine_default.off(document2, "keyup", this._documentKeyUpHandler);
    isDefined(this._documentClickHandler) && m_events_engine_default.off(document2, "dxpointerdown", this._documentClickHandler);
  }
  _dispose() {
    this._removeEvents();
    super._dispose();
  }
  _createValueEditorWithEvents(item, field, $container) {
    let value2 = item[2];
    const createValueText = () => {
      $container.empty();
      this._removeEvents();
      return this._createValueText(item, field, $container);
    };
    const closeEditor = () => {
      this._updateConditionValue(item, value2, (() => {
        createValueText();
      }));
    };
    const options2 = {
      value: "" === value2 ? null : value2,
      filterOperation: getOperationValue(item),
      setValue(data17) {
        value2 = null === data17 ? "" : data17;
      },
      closeEditor,
      text: $container.text()
    };
    $container.empty();
    const $editor = this._createValueEditor($container, field, options2);
    m_events_engine_default.trigger($editor.find("input").not(":hidden").eq(0), "focus");
    this._removeEvents();
    this._addDocumentClick($editor, closeEditor);
    this._addDocumentKeyUp($editor, ((e) => {
      const keyName = normalizeKeyName(e);
      if ("tab" === keyName) {
        if (this._isFocusOnEditorParts($editor)) {
          return;
        }
        this._updateConditionValue(item, value2, (() => {
          createValueText();
          if (e.shiftKey) {
            m_events_engine_default.trigger($container.prev(), "focus");
          }
        }));
      }
      if ("escape" === keyName) {
        m_events_engine_default.trigger(createValueText(), "focus");
      }
      if ("enter" === keyName) {
        this._updateConditionValue(item, value2, (() => {
          m_events_engine_default.trigger(createValueText(), "focus");
        }));
      }
    }));
    this._fireContentReadyAction();
  }
  _createValueButton(item, field) {
    const $valueButton = renderer_default("<div>").addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-value");
    this._createValueText(item, field, $valueButton);
    return $valueButton;
  }
  _createValueEditor($container, field, options2) {
    const $editor = renderer_default("<div>").attr("tabindex", 0).appendTo($container);
    const customOperation = getCustomOperation(this._customOperations, options2.filterOperation);
    const editorTemplate2 = customOperation && customOperation.editorTemplate ? customOperation.editorTemplate : field.editorTemplate;
    if (editorTemplate2) {
      const template = this._getTemplate(editorTemplate2);
      template.render({
        model: extend({
          field
        }, options2),
        container: $editor
      });
    } else {
      this._editorFactory.createEditor.call(this, $editor, extend({}, field, options2, {
        parentType: SOURCE
      }));
    }
    return $editor;
  }
  _createPopupWithTreeView(options2, $container) {
    const that = this;
    const $popup = renderer_default("<div>").addClass(options2.menu.cssClass).appendTo($container);
    this._createComponent($popup, ui_popup_default, {
      onHiding: options2.menu.onHiding,
      onHidden: options2.menu.onHidden,
      rtlEnabled: options2.menu.rtlEnabled,
      position: options2.menu.position,
      animation: options2.menu.animation,
      contentTemplate(contentElement) {
        const $menuContainer = renderer_default("<div>").appendTo(contentElement);
        that._createComponent($menuContainer, tree_view_default, options2.menu);
        $menuContainer.attr("id", `${options2.menu.id}`);
        this.repaint();
      },
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(options2.menu.position.of),
      visible: true,
      focusStateEnabled: false,
      preventScrollEvents: false,
      container: $popup,
      hideOnOutsideClick: true,
      onShown: options2.popup.onShown,
      shading: false,
      width: "auto",
      height: "auto",
      showTitle: false,
      _wrapperClassExternal: options2.menu.cssClass,
      _ignorePreventScrollEventsDeprecation: true
    });
  }
  _subscribeOnClickAndEnterKey($button, handler) {
    m_events_engine_default.on($button, "dxclick", handler);
    m_events_engine_default.on($button, "keyup", ((e) => {
      if ("enter" === normalizeKeyName(e)) {
        handler(e);
      }
    }));
  }
  _applyAccessibilityAttributes($element) {
    var _treeViewPopup$find;
    const treeViewPopup = $element.closest(".dx-overlay-content");
    null === treeViewPopup || void 0 === treeViewPopup || treeViewPopup.removeAttr("role");
    const treeViewNode = null === treeViewPopup || void 0 === treeViewPopup || null === (_treeViewPopup$find = treeViewPopup.find) || void 0 === _treeViewPopup$find ? void 0 : _treeViewPopup$find.call(treeViewPopup, `.${TREEVIEW_NODE_CONTAINER}`);
    null === treeViewNode || void 0 === treeViewNode || treeViewNode.attr("role", "presentation");
  }
};
component_registrator_default("dxFilterBuilder", FilterBuilder);
var m_filter_builder_default = FilterBuilder;

// node_modules/devextreme/esm/ui/filter_builder.js
var filter_builder_default = m_filter_builder_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_builder.js
var FilterBuilderView = class extends m_modules_default.View {
  init() {
    super.init();
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterBuilder":
      case "filterBuilderPopup":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _renderCore() {
    this._updatePopupOptions();
  }
  _updatePopupOptions() {
    if (this.option("filterBuilderPopup.visible")) {
      this._initPopup();
    } else if (this._filterBuilderPopup) {
      this._filterBuilderPopup.hide();
    }
  }
  _disposePopup() {
    if (this._filterBuilderPopup) {
      this._filterBuilderPopup.dispose();
      this._filterBuilderPopup = void 0;
    }
    if (this._filterBuilder) {
      this._filterBuilder.dispose();
      this._filterBuilder = void 0;
    }
  }
  _initPopup() {
    const that = this;
    that._disposePopup();
    that._filterBuilderPopup = that._createComponent(that.element(), ui_popup_default, extend({
      title: message_default.format("dxDataGrid-filterBuilderPopupTitle"),
      contentTemplate: ($contentElement) => that._getPopupContentTemplate($contentElement),
      onOptionChanged(args) {
        if ("visible" === args.name) {
          that.option("filterBuilderPopup.visible", args.value);
        }
      },
      toolbarItems: that._getPopupToolbarItems()
    }, that.option("filterBuilderPopup"), {
      onHidden() {
        restoreFocus(that);
        that._disposePopup();
      }
    }));
  }
  _getPopupContentTemplate(contentElement) {
    const $contentElement = renderer_default(contentElement);
    const $filterBuilderContainer = renderer_default("<div>").appendTo(renderer_default(contentElement));
    this._filterBuilder = this._createComponent($filterBuilderContainer, filter_builder_default, extend({
      value: this.option("filterValue"),
      fields: this._columnsController.getFilteringColumns()
    }, this.option("filterBuilder"), {
      customOperations: this._filterSyncController.getCustomFilterOperations()
    }));
    this._createComponent($contentElement, scroll_view_default, {
      direction: "both"
    });
  }
  _getPopupToolbarItems() {
    const that = this;
    return [{
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("OK"),
        onClick() {
          const filter = that._filterBuilder.option("value");
          that.option("filterValue", filter);
          that._filterBuilderPopup.hide();
        }
      }
    }, {
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("Cancel"),
        onClick() {
          that._filterBuilderPopup.hide();
        }
      }
    }];
  }
};
var filterBuilderModule = {
  defaultOptions: () => ({
    filterBuilder: {
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    },
    filterBuilderPopup: {}
  }),
  views: {
    filterBuilderView: FilterBuilderView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_builder.js
m_core_default.registerModule("filterBuilder", filterBuilderModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_panel.js
var FilterPanelView = class extends m_modules_default.View {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
    this._dataController.dataSourceChanged.add((() => this.render()));
  }
  isVisible() {
    return this.option("filterPanel.visible") && this._dataController.dataSource();
  }
  _renderCore() {
    const $element = this.element();
    $element.empty();
    const isColumnsDefined = !!this._columnsController.getColumns().length;
    if (!isColumnsDefined) {
      return;
    }
    $element.addClass(this.addWidgetPrefix("filter-panel"));
    const $leftContainer = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-left")).appendTo($element);
    this._renderFilterBuilderText($element, $leftContainer);
  }
  _renderFilterBuilderText($element, $leftContainer) {
    const $filterElement = this._getFilterElement();
    const $textElement = this._getTextElement();
    if (this.option("filterValue") || this._filterValueBuffer) {
      const $checkElement = this._getCheckElement();
      const $removeButtonElement = this._getRemoveButtonElement();
      $leftContainer.append($checkElement).append($filterElement).append($textElement);
      $element.append($removeButtonElement);
      return;
    }
    $leftContainer.append($filterElement).append($textElement);
  }
  _getCheckElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-checkbox"));
    that._createComponent($element, check_box_default2, {
      value: that.option("filterPanel.filterEnabled"),
      onValueChanged(e) {
        that.option("filterPanel.filterEnabled", e.value);
      }
    });
    $element.attr("title", this.option("filterPanel.texts.filterEnabledHint"));
    return $element;
  }
  _getFilterElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass("dx-icon-filter");
    m_events_engine_default.on($element, "click", (() => that._showFilterBuilder()));
    registerKeyboardAction2("filterPanel", that, $element, void 0, (() => that._showFilterBuilder()));
    that._addTabIndexToElement($element);
    return $element;
  }
  _getTextElement() {
    const that = this;
    const $textElement = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-text"));
    let filterText;
    const filterValue = that.option("filterValue");
    if (filterValue) {
      when(that.getFilterText(filterValue, this._filterSyncController.getCustomFilterOperations())).done(((filterText2) => {
        const customizeText = that.option("filterPanel.customizeText");
        if (customizeText) {
          const customText = customizeText({
            component: that.component,
            filterValue,
            text: filterText2
          });
          if ("string" === typeof customText) {
            filterText2 = customText;
          }
        }
        $textElement.text(filterText2);
      }));
    } else {
      filterText = that.option("filterPanel.texts.createFilter");
      $textElement.text(filterText);
    }
    m_events_engine_default.on($textElement, "click", (() => that._showFilterBuilder()));
    registerKeyboardAction2("filterPanel", that, $textElement, void 0, (() => that._showFilterBuilder()));
    that._addTabIndexToElement($textElement);
    return $textElement;
  }
  _showFilterBuilder() {
    this.option("filterBuilderPopup.visible", true);
  }
  _getRemoveButtonElement() {
    const that = this;
    const clearFilterValue = () => that.option("filterValue", null);
    const $element = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-clear-filter")).text(that.option("filterPanel.texts.clearFilter"));
    m_events_engine_default.on($element, "click", clearFilterValue);
    registerKeyboardAction2("filterPanel", this, $element, void 0, clearFilterValue);
    that._addTabIndexToElement($element);
    return $element;
  }
  _addTabIndexToElement($element) {
    if (!this.option("useLegacyKeyboardNavigation")) {
      const tabindex = this.option("tabindex") || 0;
      $element.attr("tabindex", tabindex);
    }
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._invalidate();
        this.option("filterPanel.filterEnabled", true);
        args.handled = true;
        break;
      case "filterPanel":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getConditionText(fieldText, operationText, valueText) {
    let result2 = `[${fieldText}] ${operationText}`;
    if (isDefined(valueText)) {
      result2 += valueText;
    }
    return result2;
  }
  _getValueMaskedText(value2) {
    return Array.isArray(value2) ? `('${value2.join("', '")}')` : ` '${value2}'`;
  }
  _getValueText(field, customOperation, value2) {
    const deferred = new Deferred();
    const hasCustomOperation = customOperation && customOperation.customizeText;
    if (isDefined(value2) || hasCustomOperation) {
      if (!hasCustomOperation && field.lookup) {
        getCurrentLookupValueText(field, value2, ((data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        }));
      } else {
        const displayValue = Array.isArray(value2) ? value2 : m_utils_default.getDisplayValue(field, value2, null);
        when(getCurrentValueText(field, displayValue, customOperation, "filterPanel")).done(((data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        }));
      }
    } else {
      deferred.resolve("");
    }
    return deferred.promise();
  }
  getConditionText(filterValue, options2) {
    const that = this;
    const operation = filterValue[1];
    const deferred = new Deferred();
    const customOperation = getCustomOperation(options2.customOperations, operation);
    let operationText;
    const field = getField(filterValue[0], options2.columns);
    const fieldText = field.caption || "";
    const value2 = filterValue[2];
    if (customOperation) {
      operationText = customOperation.caption || m_inflector_default.captionize(customOperation.name);
    } else if (null === value2) {
      operationText = getCaptionByOperation("=" === operation ? "isblank" : "isnotblank", options2.filterOperationDescriptions);
    } else {
      operationText = getCaptionByOperation(operation, options2.filterOperationDescriptions);
    }
    this._getValueText(field, customOperation, value2).done(((valueText) => {
      deferred.resolve(that._getConditionText(fieldText, operationText, valueText));
    }));
    return deferred;
  }
  getGroupText(filterValue, options2, isInnerGroup) {
    const that = this;
    const result2 = new Deferred();
    const textParts = [];
    const groupValue = getGroupValue(filterValue);
    filterValue.forEach(((item) => {
      if (isCondition(item)) {
        textParts.push(that.getConditionText(item, options2));
      } else if (isGroup(item)) {
        textParts.push(that.getGroupText(item, options2, true));
      }
    }));
    when.apply(this, textParts).done((function() {
      let text;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (groupValue.startsWith("!")) {
        const groupText = options2.groupOperationDescriptions[`not${groupValue.substring(1, 2).toUpperCase()}${groupValue.substring(2)}`].split(" ");
        text = `${groupText[0]} ${args[0]}`;
      } else {
        text = args.join(` ${options2.groupOperationDescriptions[groupValue]} `);
      }
      if (isInnerGroup) {
        text = `(${text})`;
      }
      result2.resolve(text);
    }));
    return result2;
  }
  getFilterText(filterValue, customOperations) {
    const options2 = {
      customOperations,
      columns: this._columnsController.getFilteringColumns(),
      filterOperationDescriptions: this.option("filterBuilder.filterOperationDescriptions"),
      groupOperationDescriptions: this.option("filterBuilder.groupOperationDescriptions")
    };
    return isCondition(filterValue) ? this.getConditionText(filterValue, options2) : this.getGroupText(filterValue, options2);
  }
};
var data11 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterPanel" === args.name) {
      this._applyFilter();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var filterPanelModule = {
  defaultOptions: () => ({
    filterPanel: {
      visible: false,
      filterEnabled: true,
      texts: {
        createFilter: message_default.format("dxDataGrid-filterPanelCreateFilter"),
        clearFilter: message_default.format("dxDataGrid-filterPanelClearFilter"),
        filterEnabledHint: message_default.format("dxDataGrid-filterPanelFilterEnabledHint")
      }
    }
  }),
  views: {
    filterPanelView: FilterPanelView
  },
  extenders: {
    controllers: {
      data: data11
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_panel.js
m_core_default.registerModule("filterPanel", filterPanelModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/search/m_search.js
function allowSearch(column) {
  return !!(column.allowSearch ?? column.allowFiltering);
}
function parseValue(column, text) {
  const {
    lookup
  } = column;
  if (!column.parseValue) {
    return text;
  }
  if (lookup) {
    return column.parseValue.call(lookup, text);
  }
  return column.parseValue(text);
}
var dataController = (base) => class extends base {
  optionChanged(args) {
    switch (args.fullName) {
      case "searchPanel.text":
      case "searchPanel":
        this._applyFilter();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return super.publicMethods().concat(["searchByText"]);
  }
  _calculateAdditionalFilter() {
    var _this$_dataController, _this$_dataController2, _dataSource$loadOptio;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.getDataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    const filter = super._calculateAdditionalFilter();
    const searchFilter = this.calculateSearchFilter(this.option("searchPanel.text"), langParams);
    return m_utils_default.combineFilters([filter, searchFilter]);
  }
  searchByText(text) {
    this.option("searchPanel.text", text);
  }
  calculateSearchFilter(text, langParams) {
    let column;
    const columns7 = this._columnsController.getColumns();
    const searchVisibleColumnsOnly = this.option("searchPanel.searchVisibleColumnsOnly");
    let lookup;
    const filters = [];
    if (!text) {
      return null;
    }
    function onQueryDone(items) {
      const valueGetter = compileGetter(lookup.valueExpr);
      for (let i = 0; i < items.length; i++) {
        const value2 = valueGetter(items[i]);
        filters.push(column.createFilterExpression(value2, null, "search"));
      }
    }
    for (let i = 0; i < columns7.length; i++) {
      column = columns7[i];
      if (searchVisibleColumnsOnly && !column.visible) {
        continue;
      }
      if (allowSearch(column) && column.calculateFilterExpression) {
        var _lookup;
        lookup = column.lookup;
        const filterValue = parseValue(column, text);
        if (null !== (_lookup = lookup) && void 0 !== _lookup && _lookup.items) {
          m_query_default(lookup.items, {
            langParams
          }).filter(column.createFilterExpression.call({
            dataField: lookup.displayExpr,
            dataType: lookup.dataType,
            calculateFilterExpression: column.calculateFilterExpression
          }, filterValue, null, "search")).enumerate().done(onQueryDone);
        } else if (void 0 !== filterValue) {
          filters.push(column.createFilterExpression(filterValue, null, "search"));
        }
      }
    }
    if (0 === filters.length) {
      return ["!"];
    }
    return m_utils_default.combineFilters(filters, "or");
  }
};
var headerPanel6 = (Base) => class extends Base {
  optionChanged(args) {
    if ("searchPanel" === args.name) {
      if ("searchPanel.text" === args.fullName) {
        const editor = this.getSearchTextEditor();
        if (editor) {
          editor.option("value", args.value);
        }
      } else {
        this._invalidate();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._prepareSearchItem(items);
  }
  _prepareSearchItem(items) {
    const that = this;
    const dataController2 = this._dataController;
    const searchPanelOptions = this.option("searchPanel");
    if (searchPanelOptions && searchPanelOptions.visible) {
      const toolbarItem = {
        template(data17, index, container) {
          const $search = renderer_default("<div>").addClass(that.addWidgetPrefix("search-panel")).appendTo(container);
          that._editorFactoryController.createEditor($search, {
            width: searchPanelOptions.width,
            placeholder: searchPanelOptions.placeholder,
            parentType: "searchPanel",
            value: that.option("searchPanel.text"),
            updateValueTimeout: 700,
            setValue(value2) {
              dataController2.searchByText(value2);
            },
            editorOptions: {
              inputAttr: {
                "aria-label": message_default.format(`${that.component.NAME}-ariaSearchInGrid`)
              }
            }
          });
          that.resize();
        },
        name: "searchPanel",
        location: "after",
        locateInMenu: "never",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  getSearchTextEditor() {
    const that = this;
    const $element = that.element();
    const $searchPanel = $element.find(`.${that.addWidgetPrefix("search-panel")}`).filter((function() {
      return renderer_default(this).closest(`.${that.addWidgetPrefix("header-panel")}`).is($element);
    }));
    if ($searchPanel.length) {
      return $searchPanel.dxTextBox("instance");
    }
    return null;
  }
};
var rowsView8 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._searchParams = [];
    this._dataController = this.getController("data");
  }
  dispose() {
    clearTimeout(this._highlightTimer);
    super.dispose();
  }
  _getFormattedSearchText(column, searchText) {
    const value2 = parseValue(column, searchText);
    const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "search");
    return m_utils_default.formatValue(value2, formatOptions);
  }
  _getStringNormalizer() {
    var _this$_dataController3, _this$_dataController4, _dataSource$loadOptio2;
    const isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
    const dataSource = null === (_this$_dataController3 = this._dataController) || void 0 === _this$_dataController3 || null === (_this$_dataController4 = _this$_dataController3.getDataSource) || void 0 === _this$_dataController4 ? void 0 : _this$_dataController4.call(_this$_dataController3);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio2 = dataSource.loadOptions) || void 0 === _dataSource$loadOptio2 || null === (_dataSource$loadOptio2 = _dataSource$loadOptio2.call(dataSource)) || void 0 === _dataSource$loadOptio2 ? void 0 : _dataSource$loadOptio2.langParams;
    return (str) => toComparable(str, isCaseSensitive, langParams);
  }
  _findHighlightingTextNodes(column, cellElement, searchText) {
    var _$items;
    const that = this;
    let $parent = cellElement.parent();
    let $items;
    const stringNormalizer = this._getStringNormalizer();
    const normalizedSearchText = stringNormalizer(searchText);
    const resultTextNodes = [];
    if (!$parent.length) {
      $parent = renderer_default("<div>").append(cellElement);
    } else if (column) {
      if (column.groupIndex >= 0 && !column.showWhenGrouped) {
        $items = cellElement;
      } else {
        const columnIndex = that._columnsController.getVisibleIndex(column.index);
        $items = $parent.children("td").eq(columnIndex).find("*");
      }
    }
    $items = null !== (_$items = $items) && void 0 !== _$items && _$items.length ? $items : $parent.find("*");
    $items.each(((_, element) => {
      const $contents = renderer_default(element).contents();
      for (let i = 0; i < $contents.length; i++) {
        const node = $contents.get(i);
        if (3 === node.nodeType) {
          const normalizedText = stringNormalizer(node.textContent ?? node.nodeValue ?? "");
          if (normalizedText.includes(normalizedSearchText)) {
            resultTextNodes.push(node);
          }
        }
      }
    }));
    return resultTextNodes;
  }
  _highlightSearchTextCore($textNode, searchText) {
    const that = this;
    const $searchTextSpan = renderer_default("<span>").addClass(that.addWidgetPrefix("search-text"));
    const text = $textNode.text();
    const firstContentElement = $textNode[0];
    const stringNormalizer = this._getStringNormalizer();
    const index = stringNormalizer(text).indexOf(stringNormalizer(searchText));
    if (index >= 0) {
      if (firstContentElement.textContent) {
        firstContentElement.textContent = text.substr(0, index);
      } else {
        firstContentElement.nodeValue = text.substr(0, index);
      }
      $textNode.after($searchTextSpan.text(text.substr(index, searchText.length)));
      $textNode = renderer_default(dom_adapter_default.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
      return that._highlightSearchTextCore($textNode, searchText);
    }
  }
  _highlightSearchText(cellElement, isEquals, column) {
    const that = this;
    const stringNormalizer = this._getStringNormalizer();
    let searchText = that.option("searchPanel.text");
    if (isEquals && column) {
      searchText = searchText && that._getFormattedSearchText(column, searchText);
    }
    if (searchText && that.option("searchPanel.highlightSearchText")) {
      const textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
      textNodes.forEach(((textNode) => {
        if (isEquals) {
          if (stringNormalizer(renderer_default(textNode).text()) === stringNormalizer(searchText ?? "")) {
            renderer_default(textNode).replaceWith(renderer_default("<span>").addClass(that.addWidgetPrefix("search-text")).text(renderer_default(textNode).text()));
          }
        } else {
          that._highlightSearchTextCore(renderer_default(textNode), searchText);
        }
      }));
    }
  }
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this.option().rowTemplate || this.option("dataRowTemplate")) {
      if (this.option("templatesRenderAsynchronously")) {
        clearTimeout(this._highlightTimer);
        this._highlightTimer = setTimeout((() => {
          this._highlightSearchText(this.getTableElement());
        }));
      } else {
        this._highlightSearchText(this.getTableElement());
      }
    }
    return deferred;
  }
  _updateCell($cell, parameters) {
    const {
      column
    } = parameters;
    const dataType = column.lookup && column.lookup.dataType || column.dataType;
    const isEquals = "string" !== dataType;
    if (allowSearch(column) && !parameters.isOnForm) {
      if (this.option("templatesRenderAsynchronously")) {
        if (!this._searchParams.length) {
          clearTimeout(this._highlightTimer);
          this._highlightTimer = setTimeout((() => {
            this._searchParams.forEach(((params) => {
              this._highlightSearchText.apply(this, params);
            }));
            this._searchParams = [];
          }));
        }
        this._searchParams.push([$cell, isEquals, column]);
      } else {
        this._highlightSearchText($cell, isEquals, column);
      }
    }
    super._updateCell($cell, parameters);
  }
};
var searchModule = {
  defaultOptions: () => ({
    searchPanel: {
      visible: false,
      width: 160,
      placeholder: message_default.format("dxDataGrid-searchPanelPlaceholder"),
      highlightSearchText: true,
      highlightCaseSensitive: false,
      text: "",
      searchVisibleColumnsOnly: false
    }
  }),
  extenders: {
    controllers: {
      data: dataController
    },
    views: {
      headerPanel: headerPanel6,
      rowsView: rowsView8
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/search.js
m_core_default.registerModule("search", searchModule);

// node_modules/devextreme/esm/__internal/pagination/common/base_pagination_props.js
var BasePaginationDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  isGridCompatibilityMode: false,
  showInfo: false,
  displayMode: "adaptive",
  maxPagesCount: 10,
  pageCount: 1,
  visible: true,
  hasKnownLastPage: true,
  pagesNavigatorVisible: "auto",
  showPageSizeSelector: "auto",
  allowedPageSizes: [5, 10],
  showNavigationButtons: false,
  itemCount: 1,
  label: message_default.format("dxPagination-ariaLabel")
});

// node_modules/devextreme/esm/__internal/pagination/common/pagination_props.js
var PaginationDefaultProps = _extends({}, BasePaginationDefaultProps, {
  pageSize: 5,
  pageIndex: 1,
  pageIndexChangedInternal: () => {
  },
  pageSizeChangedInternal: () => {
  }
});

// node_modules/devextreme/esm/__internal/pagination/common/consts.js
var PAGER_CLASS = "dx-pager";
var PAGINATION_CLASS = "dx-pagination";
var LIGHT_MODE_CLASS = "dx-light-mode";
var PAGINATION_PAGES_CLASS = "dx-pages";
var PAGINATION_PAGE_INDEXES_CLASS = "dx-page-indexes";
var PAGINATION_PAGE_CLASS = "dx-page";
var PAGINATION_SELECTION_CLASS = "dx-selection";
var PAGINATION_PAGE_SIZE_CLASS = "dx-page-size";
var PAGINATION_PAGE_SIZES_CLASS = "dx-page-sizes";
var PAGINATION_SELECTED_PAGE_SIZE_CLASS = "dx-page-size dx-selection";
var FIRST_CHILD_CLASS = "dx-first-child";

// node_modules/devextreme/esm/__internal/pagination/common/keyboard_action_context.js
var KeyboardActionContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_context.js
var PaginationConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_provider.js
var PaginationConfigProviderDefaultProps = {};
var PaginationConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
  }
  getConfig() {
    return {
      isGridCompatibilityMode: this.props.isGridCompatibilityMode
    };
  }
  getChildContext() {
    return _extends({}, this.context, {
      [PaginationConfigContext.id]: this.getConfig() || PaginationConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
PaginationConfigProvider.defaultProps = PaginationConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/compatibility_utils.js
function getPaginationConfig(context) {
  if (context[PaginationConfigContext.id]) {
    return context[PaginationConfigContext.id];
  }
  return PaginationConfigContext.defaultValue;
}
function isGridCompatibilityMode(context) {
  var _getPaginationConfig;
  return !!(null !== (_getPaginationConfig = getPaginationConfig(context)) && void 0 !== _getPaginationConfig && _getPaginationConfig.isGridCompatibilityMode);
}
function getLocalizationMessage(context, key) {
  let actualKey = key;
  if (isGridCompatibilityMode(context)) {
    actualKey = key.replace("dxPagination", "dxPager");
  }
  return message_default.getFormatter(actualKey)();
}

// node_modules/devextreme/esm/__internal/pagination/info.js
var PAGER_INFO_CLASS = "dx-info";
var InfoTextDefaultProps = {
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  itemCount: PaginationDefaultProps.itemCount
};
var InfoText = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
  }
  getInfoText() {
    return this.props.infoText ?? getLocalizationMessage(this.context, "dxPagination-infoText");
  }
  getText() {
    const {
      pageCount,
      pageIndex,
      itemCount
    } = this.props;
    return format(this.getInfoText(), (pageIndex + 1).toString(), null === pageCount || void 0 === pageCount ? void 0 : pageCount.toString(), null === itemCount || void 0 === itemCount ? void 0 : itemCount.toString());
  }
  render() {
    return createVNode(1, "div", "dx-info", this.getText(), 0, null, null, this.props.rootElementRef);
  }
};
InfoText.defaultProps = InfoTextDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/common/light_button.js
var LightButtonDefaultProps = {
  className: "",
  label: "",
  tabIndex: 0,
  selected: false
};
var LightButton = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetRef = createRef();
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.subscribeToClick = this.subscribeToClick.bind(this);
  }
  getComponentProps() {
    return this.props;
  }
  getKeyboardContext() {
    if (this.context[KeyboardActionContext.id]) {
      return this.context[KeyboardActionContext.id];
    }
    return KeyboardActionContext.defaultValue;
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.keyboardEffect, [this.getKeyboardContext(), this.props.onClick]), new InfernoEffect(this.subscribeToClick, [this.props.onClick])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.getKeyboardContext(), this.props.onClick]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props.onClick]);
  }
  keyboardEffect() {
    return this.getKeyboardContext().registerKeyboardAction(this.widgetRef.current, this.props.onClick);
  }
  subscribeToClick() {
    return subscribeToClickEvent(this.widgetRef.current, this.props.onClick);
  }
  render() {
    return createVNode(1, "div", this.props.className, this.props.children, 0, {
      tabIndex: this.props.tabIndex,
      role: "button",
      "aria-label": this.props.label,
      "aria-current": this.props.selected ? "page" : void 0
    }, null, this.widgetRef);
  }
};
LightButton.defaultProps = LightButtonDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/large.js
var PageSizeLargeDefaultProps = {
  allowedPageSizes: [],
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
};
var PageSizeLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      pageSizesText: void 0
    };
    this.state = {};
    this.onPageSizeChange = this.onPageSizeChange.bind(this);
  }
  getPageSizesText() {
    if (void 0 !== this.__getterCache.pageSizesText) {
      return this.__getterCache.pageSizesText;
    }
    const result2 = (() => {
      const {
        pageSize,
        allowedPageSizes
      } = this.props;
      return allowedPageSizes.map(((_ref3, index) => {
        const {
          text,
          value: processedPageSize
        } = _ref3;
        const selected = processedPageSize === pageSize;
        const className = combineClasses({
          [selected ? PAGINATION_SELECTED_PAGE_SIZE_CLASS : PAGINATION_PAGE_SIZE_CLASS]: true,
          [FIRST_CHILD_CLASS]: 0 === index
        });
        return {
          className,
          click: this.onPageSizeChange(processedPageSize),
          label: format(getLocalizationMessage(this.context, "dxPagination-pageSize"), processedPageSize || getLocalizationMessage(this.context, "dxPagination-pageSizesAllText")),
          text
        };
      }));
    })();
    this.__getterCache.pageSizesText = result2;
    return result2;
  }
  onPageSizeChange(processedPageSize) {
    return () => {
      this.props.pageSizeChangedInternal(processedPageSize);
      return this.props.pageSize;
    };
  }
  componentWillUpdate(nextProps) {
    const componentChanged = this.props.pageSize !== nextProps.pageSize || this.props.allowedPageSizes !== nextProps.allowedPageSizes || this.props.pageSizeChangedInternal !== nextProps.pageSizeChangedInternal;
    if (componentChanged) {
      this.__getterCache.pageSizesText = void 0;
    }
  }
  render() {
    return createFragment(this.getPageSizesText().map(((_ref) => {
      let {
        text,
        className,
        label,
        click: click2
      } = _ref;
      return createComponentVNode(2, LightButton, {
        className,
        label,
        onClick: click2,
        children: text
      }, text);
    })), 0);
  }
};
PageSizeLarge.defaultProps = PageSizeLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_label_props.js
var EditorLabelDefaultProps = {
  label: "",
  labelMode: isMaterial(current()) ? "floating" : "static"
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/base_widget_props.js
var BaseWidgetDefaultProps2 = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true,
  rtlEnabled: false
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/widget_props.js
var WidgetDefaultProps2 = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_props.js
var EditorDefaultProps = _extends({}, BaseWidgetDefaultProps2, {
  aria: WidgetDefaultProps2.aria,
  classes: WidgetDefaultProps2.classes,
  readOnly: false,
  name: "",
  value: null,
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: {}
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_state_props.js
var EditorStateDefaultProps = {
  hoverStateEnabled: true,
  activeStateEnabled: true,
  focusStateEnabled: "desktop" === devices_default.real().deviceType && !devices_default.isSimulator()
};

// node_modules/devextreme/esm/__internal/pagination/drop_down_editors/select_box.js
var NumberBoxDefaultProps = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  placeholder: "",
  hoverStateEnabled: true,
  searchEnabled: false,
  value: null,
  isReactComponentWrapper: true
});
var SelectBox2 = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: select_box_default,
      componentProps: this.componentProps,
      templateNames: ["dropDownButtonTemplate", "groupTemplate", "itemTemplate"]
    });
  }
};
SelectBox2.defaultProps = NumberBoxDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/calculate_values_fitted_width.js
function calculateValuesFittedWidth(minWidth, values) {
  return minWidth + 10 * Math.max(...values).toString().length;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/get_computed_style.js
function getElementComputedStyle(el) {
  var _window$getComputedSt;
  const window15 = getWindow();
  return el ? null === (_window$getComputedSt = window15.getComputedStyle) || void 0 === _window$getComputedSt ? void 0 : _window$getComputedSt.call(window15, el) : null;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/type_conversion.js
function toNumber3(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// node_modules/devextreme/esm/__internal/pagination/utils/get_element_width.js
function getElementStyle2(name2, element) {
  const computedStyle = getElementComputedStyle(element) ?? {};
  return toNumber3(computedStyle[name2]);
}
function getElementContentWidth(element) {
  const padding = getElementStyle2("paddingLeft", element) + getElementStyle2("paddingRight", element);
  const width = getElementStyle2("width", element);
  return width - padding;
}
function getElementWidth2(element) {
  const margin = getElementStyle2("marginLeft", element) + getElementStyle2("marginRight", element);
  const width = getElementStyle2("width", element);
  return margin + width;
}
function getElementMinWidth(element) {
  return getElementStyle2("minWidth", element);
}

// node_modules/devextreme/esm/__internal/pagination/page_size/small.js
var PaginationSmallDefaultProps = {
  allowedPageSizes: []
};
var PageSizeSmallDefaultProps = _extends({}, PaginationSmallDefaultProps, {
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
});
var PageSizeSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.updateWidth = this.updateWidth.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    return [new InfernoEffect(this.updateWidth, dependency)];
  }
  updateEffects() {
    var _this$_effects$;
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update(dependency);
  }
  updateWidth() {
    var _this$props$parentRef;
    const minWidth = getElementMinWidth(null === (_this$props$parentRef = this.props.parentRef) || void 0 === _this$props$parentRef ? void 0 : _this$props$parentRef.current);
    this.setState(((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    })));
  }
  getWidth() {
    var _this$props$allowedPa;
    return calculateValuesFittedWidth(this.state.minWidth, null === (_this$props$allowedPa = this.props.allowedPageSizes) || void 0 === _this$props$allowedPa ? void 0 : _this$props$allowedPa.map(((p2) => p2.value)));
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageSize")
    };
  }
  render() {
    const {
      allowedPageSizes,
      pageSize,
      pageSizeChangedInternal
    } = this.props;
    return createComponentVNode(2, SelectBox2, {
      displayExpr: "text",
      valueExpr: "value",
      dataSource: allowedPageSizes,
      value: pageSize,
      valueChange: pageSizeChangedInternal,
      width: this.getWidth(),
      inputAttr: this.getInputAttributes()
    });
  }
};
PageSizeSmall.defaultProps = PageSizeSmallDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/selector.js
var PageSizeSelectorDefaultProps = {
  isLargeDisplayMode: true,
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal,
  allowedPageSizes: PaginationDefaultProps.allowedPageSizes
};
var PageSizeSelector = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
    this.htmlRef = createRef();
    this.__getterCache = {
      normalizedPageSizes: void 0
    };
    this.setRootElementRef = this.setRootElementRef.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef) {
      rootElementRef.current = this.htmlRef.current;
    }
  }
  getAllText() {
    return getLocalizationMessage(this.context, "dxPagination-pageSizesAllText");
  }
  getNormalizedPageSizes() {
    if (void 0 !== this.__getterCache.normalizedPageSizes) {
      return this.__getterCache.normalizedPageSizes;
    }
    const result2 = this.props.allowedPageSizes.map(((p2) => "all" === p2 || 0 === p2 ? {
      text: this.getAllText(),
      value: 0
    } : {
      text: String(p2),
      value: p2
    }));
    this.__getterCache.normalizedPageSizes = result2;
    return result2;
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.allowedPageSizes !== nextProps.allowedPageSizes) {
      this.__getterCache.normalizedPageSizes = void 0;
    }
  }
  render() {
    const normalizedPageSizes = this.getNormalizedPageSizes();
    const {
      pageSize,
      pageSizeChangedInternal,
      isLargeDisplayMode
    } = this.props;
    return createVNode(1, "div", PAGINATION_PAGE_SIZES_CLASS, [isLargeDisplayMode && createComponentVNode(2, PageSizeLarge, {
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PageSizeSmall, {
      parentRef: this.htmlRef,
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    })], 0, null, null, this.htmlRef);
  }
};
PageSizeSelector.defaultProps = PageSizeSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/page.js
var PageDefaultProps = {
  index: 0,
  selected: false,
  className: PAGINATION_PAGE_CLASS
};
var Page = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  getLabel() {
    return format(getLocalizationMessage(this.context, "dxPagination-page"), this.getValue());
  }
  getValue() {
    return this.props.index + 1;
  }
  getClassName() {
    return combineClasses({
      [`${this.props.className}`]: !!this.props.className,
      [PAGINATION_SELECTION_CLASS]: !!this.props.selected
    });
  }
  render() {
    return createComponentVNode(2, LightButton, {
      className: this.getClassName(),
      label: this.getLabel(),
      onClick: this.props.onClick,
      selected: this.props.selected,
      children: this.getValue()
    });
  }
};
Page.defaultProps = PageDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/large.js
var PagesLargeDefaultProps = {
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
function getDelimiterType(startIndex, slidingWindowSize, pageCount) {
  switch (true) {
    case 1 === startIndex:
      return "high";
    case startIndex + slidingWindowSize === pageCount - 1:
      return "low";
    default:
      return "both";
  }
}
function createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter) {
  let pageIndexes = [];
  let indexesForReuse = [];
  switch (delimiter) {
    case "none":
      pageIndexes = [...slidingWindowIndexes];
      break;
    case "both":
      pageIndexes = [0, "low", ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1, -1);
      break;
    case "high":
      pageIndexes = [0, ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(0, -1);
      break;
    case "low":
      pageIndexes = [0, "low", ...slidingWindowIndexes, pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1);
  }
  return {
    slidingWindowIndexes,
    indexesForReuse,
    pageIndexes
  };
}
function createPageIndexes(startIndex, slidingWindowSize, pageCount, delimiter) {
  const slidingWindowIndexes = [];
  for (let i = 0; i < slidingWindowSize; i += 1) {
    slidingWindowIndexes.push(i + startIndex);
  }
  return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter);
}
var PagesLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.canReuseSlidingWindow = this.canReuseSlidingWindow.bind(this);
    this.generatePageIndexes = this.generatePageIndexes.bind(this);
    this.isSlidingWindowMode = this.isSlidingWindowMode.bind(this);
    this.onPageClick = this.onPageClick.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  getSlidingWindowState() {
    const slidingWindowState = this.slidingWindowStateHolder;
    if (!slidingWindowState) {
      return {
        indexesForReuse: [],
        slidingWindowIndexes: []
      };
    }
    return slidingWindowState;
  }
  canReuseSlidingWindow(currentPageCount, pageIndex) {
    const {
      indexesForReuse
    } = this.getSlidingWindowState();
    const lastPageIsFartherThanWindow = indexesForReuse.slice(-1)[0] < currentPageCount - 1;
    const pageIndexExistInIndexes = indexesForReuse.includes(pageIndex);
    return lastPageIsFartherThanWindow && pageIndexExistInIndexes;
  }
  generatePageIndexes() {
    const {
      pageCount,
      pageIndex
    } = this.props;
    let startIndex = 0;
    const {
      slidingWindowIndexes
    } = this.getSlidingWindowState();
    if (pageIndex === slidingWindowIndexes[0]) {
      startIndex = pageIndex - 1;
    } else if (pageIndex === slidingWindowIndexes[slidingWindowIndexes.length - 1]) {
      startIndex = pageIndex + 2 - 4;
    } else if (pageIndex < 4) {
      startIndex = 1;
    } else if (pageIndex >= pageCount - 4) {
      startIndex = pageCount - 4 - 1;
    } else {
      startIndex = pageIndex - 1;
    }
    const delimiter = getDelimiterType(startIndex, 4, pageCount);
    const indexes = createPageIndexes(startIndex, 4, pageCount, delimiter);
    const {
      pageIndexes
    } = indexes;
    this.slidingWindowStateHolder = indexes;
    return pageIndexes;
  }
  isSlidingWindowMode() {
    const {
      maxPagesCount,
      pageCount
    } = this.props;
    return pageCount <= 4 || pageCount <= maxPagesCount;
  }
  onPageClick(pageIndex) {
    this.props.pageIndexChangedInternal(pageIndex);
  }
  getPageIndexes() {
    const {
      pageCount
    } = this.props;
    if (this.isSlidingWindowMode()) {
      return createPageIndexes(0, pageCount, pageCount, "none").pageIndexes;
    }
    if (this.canReuseSlidingWindow(pageCount, this.props.pageIndex)) {
      const {
        slidingWindowIndexes
      } = this.getSlidingWindowState();
      const delimiter = getDelimiterType(slidingWindowIndexes[0], 4, pageCount);
      return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter).pageIndexes;
    }
    return this.generatePageIndexes();
  }
  getPages() {
    var _this$getConfig;
    const {
      pageIndex
    } = this.props;
    const createPage = (index) => {
      const paginationProps = "low" === index || "high" === index ? null : {
        index,
        onClick: () => this.onPageClick(index),
        selected: pageIndex === index
      };
      return {
        key: index.toString(),
        pageProps: paginationProps
      };
    };
    const indices = this.getPageIndexes();
    const rtlPageIndexes = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? [...indices].reverse() : indices;
    return rtlPageIndexes.map(((index) => createPage(index)));
  }
  render() {
    const PagesMarkup = this.getPages().map(((_ref) => {
      let {
        key,
        pageProps
      } = _ref;
      return pageProps ? createComponentVNode(2, Page, {
        index: pageProps.index,
        selected: pageProps.selected,
        onClick: pageProps.onClick
      }, key) : createVNode(1, "div", "dx-separator", ". . .", 16, null, key);
    }));
    return createFragment(PagesMarkup, 0);
  }
};
PagesLarge.defaultProps = PagesLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/number_box.js
var NumberBoxDefaultProps2 = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  value: 0,
  isReactComponentWrapper: true
});
var NumberBox = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: number_box_default,
      componentProps: this.componentProps,
      templateNames: []
    });
  }
};
NumberBox.defaultProps = NumberBoxDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/small.js
var PAGER_INFO_TEXT_CLASS = `${PAGER_INFO_CLASS}  dx-info-text`;
var PaginationSmallDefaultProps2 = {
  pageIndex: PaginationDefaultProps.pageIndex,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
var PagesSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.pageIndexRef = createRef();
    this.updateWidth = this.updateWidth.bind(this);
    this.selectLastPageIndex = this.selectLastPageIndex.bind(this);
    this.valueChange = this.valueChange.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.updateWidth, [this.state.minWidth])];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.minWidth]);
  }
  updateWidth() {
    var _this$pageIndexRef$cu;
    const el = null === (_this$pageIndexRef$cu = this.pageIndexRef.current) || void 0 === _this$pageIndexRef$cu ? void 0 : _this$pageIndexRef$cu.querySelector(".dx-page-index");
    const minWidth = el ? getElementMinWidth(el) : 0;
    this.setState(((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    })));
  }
  getValue() {
    return this.props.pageIndex + 1;
  }
  getWidth() {
    return calculateValuesFittedWidth(this.state.minWidth, [this.props.pageCount]);
  }
  getPagesCountText() {
    return (this.props.pagesCountText ?? "") || getLocalizationMessage(this.context, "dxPagination-pagesCountText");
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageNumber")
    };
  }
  selectLastPageIndex() {
    this.props.pageIndexChangedInternal(this.props.pageCount - 1);
  }
  valueChange(value2) {
    this.props.pageIndexChangedInternal(value2 - 1);
  }
  render() {
    return createVNode(1, "div", "dx-light-pages", [createComponentVNode(2, NumberBox, {
      className: "dx-page-index",
      min: 1,
      max: Math.max(this.props.pageCount, this.getValue()),
      width: this.getWidth(),
      value: this.getValue(),
      valueChange: this.valueChange,
      inputAttr: this.getInputAttributes()
    }), createVNode(1, "span", PAGER_INFO_TEXT_CLASS, this.getPagesCountText(), 0), createComponentVNode(2, Page, {
      className: "dx-pages-count",
      selected: false,
      index: this.props.pageCount - 1,
      onClick: this.selectLastPageIndex
    })], 4, null, null, this.pageIndexRef);
  }
};
PagesSmall.defaultProps = PaginationSmallDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/page_index_selector.js
var classNames = {
  nextEnabledClass: "dx-navigate-button dx-next-button",
  prevEnabledClass: "dx-navigate-button dx-prev-button",
  nextDisabledClass: "dx-button-disable dx-navigate-button dx-next-button",
  prevDisabledClass: "dx-button-disable dx-navigate-button dx-prev-button"
};
var reverseDirections = {
  next: "prev",
  prev: "next"
};
function getIncrement(direction) {
  return "next" === direction ? 1 : -1;
}
var PageIndexSelectorDefaultProps = {
  isLargeDisplayMode: true,
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal,
  showNavigationButtons: PaginationDefaultProps.showNavigationButtons,
  itemCount: PaginationDefaultProps.itemCount
};
var PageIndexSelector = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      prevButtonProps: void 0,
      nextButtonProps: void 0
    };
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.getButtonProps = this.getButtonProps.bind(this);
    this.canNavigateToPage = this.canNavigateToPage.bind(this);
    this.getNextPageIndex = this.getNextPageIndex.bind(this);
    this.canNavigateTo = this.canNavigateTo.bind(this);
    this.navigateToPage = this.navigateToPage.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  pageIndexChangedInternal(pageIndex) {
    if (this.canNavigateToPage(pageIndex)) {
      this.props.pageIndexChangedInternal(pageIndex);
    }
  }
  getButtonProps(direction) {
    var _this$getConfig;
    const rtlAwareDirection = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? reverseDirections[direction] : direction;
    const canNavigate = this.canNavigateTo(rtlAwareDirection);
    const className = classNames[`${direction}${canNavigate ? "Enabled" : "Disabled"}Class`];
    return {
      className,
      tabIndex: canNavigate ? 0 : -1,
      navigate: () => this.navigateToPage(rtlAwareDirection)
    };
  }
  canNavigateToPage(pageIndex) {
    if (!this.props.hasKnownLastPage) {
      return pageIndex >= 0;
    }
    return pageIndex >= 0 && pageIndex <= this.props.pageCount - 1;
  }
  getNextPageIndex(direction) {
    return this.props.pageIndex + getIncrement(direction);
  }
  canNavigateTo(direction) {
    return this.canNavigateToPage(this.getNextPageIndex(direction));
  }
  navigateToPage(direction) {
    this.pageIndexChangedInternal(this.getNextPageIndex(direction));
  }
  getRenderPrevButton() {
    const {
      isLargeDisplayMode,
      showNavigationButtons
    } = this.props;
    return (!isLargeDisplayMode || showNavigationButtons) ?? false;
  }
  getRenderNextButton() {
    return this.getRenderPrevButton() || !this.props.hasKnownLastPage;
  }
  getPrevButtonProps() {
    if (void 0 !== this.__getterCache.prevButtonProps) {
      return this.__getterCache.prevButtonProps;
    }
    const result2 = (() => this.getButtonProps("prev"))();
    this.__getterCache.prevButtonProps = result2;
    return result2;
  }
  getNextButtonProps() {
    if (void 0 !== this.__getterCache.nextButtonProps) {
      return this.__getterCache.nextButtonProps;
    }
    const result2 = (() => this.getButtonProps("next"))();
    this.__getterCache.nextButtonProps = result2;
    return result2;
  }
  componentWillUpdate(nextProps, nextState, context) {
    const isComponentUpdated = this.context[ConfigContext.id] !== context[ConfigContext.id] || this.props.hasKnownLastPage !== nextProps.hasKnownLastPage || this.props.pageCount !== nextProps.pageCount || this.props.pageIndex !== nextProps.pageIndex || this.props.pageIndexChangedInternal !== nextProps.pageIndexChangedInternal;
    if (isComponentUpdated) {
      this.__getterCache.prevButtonProps = void 0;
      this.__getterCache.nextButtonProps = void 0;
    }
  }
  getPrevButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-prevPage");
  }
  getNextButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-nextPage");
  }
  render() {
    const {
      className,
      tabIndex,
      navigate
    } = this.getPrevButtonProps();
    const {
      isLargeDisplayMode,
      maxPagesCount,
      pageCount,
      pageIndex,
      pagesCountText
    } = this.props;
    return createFragment([this.getRenderPrevButton() && createComponentVNode(2, LightButton, {
      label: this.getPrevButtonLabel(),
      className,
      tabIndex,
      onClick: navigate
    }), isLargeDisplayMode && createComponentVNode(2, PagesLarge, {
      maxPagesCount,
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PagesSmall, {
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal,
      pagesCountText
    }), this.getRenderNextButton() && createComponentVNode(2, LightButton, {
      label: this.getNextButtonLabel(),
      className: this.getNextButtonProps().className,
      tabIndex: this.getNextButtonProps().tabIndex,
      onClick: this.getNextButtonProps().navigate
    })], 0);
  }
};
PageIndexSelector.defaultProps = PageIndexSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/content.js
var PaginationContentDefaultProps = _extends({}, PaginationDefaultProps, {
  infoTextVisible: true,
  isLargeDisplayMode: true
});
var PaginationContent = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetElementRef = createRef();
    this.widgetRootElementRef = createRef();
    this.pagesRef = createRef();
    this.infoTextRef = createRef();
    this.__getterCache = {
      keyboardAction: void 0
    };
    this.state = {};
    this.__getterCache = {};
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.createFakeInstance = this.createFakeInstance.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  getChildContext() {
    return _extends({}, this.context, {
      [KeyboardActionContext.id]: this.getKeyboardAction() || KeyboardActionContext.defaultValue
    });
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef && this.widgetRootElementRef) {
      rootElementRef.current = this.widgetRootElementRef.current;
    }
  }
  getWidgetRootElement() {
    var _this$widgetRootEleme;
    return null === (_this$widgetRootEleme = this.widgetRootElementRef) || void 0 === _this$widgetRootEleme ? void 0 : _this$widgetRootEleme.current;
  }
  createFakeInstance() {
    return {
      option: () => false,
      element: () => this.getWidgetRootElement(),
      component: this.props._getParentComponentRootNode ? {
        element: () => {
          var _this$props$_getParen, _this$props;
          return null === (_this$props$_getParen = (_this$props = this.props)._getParentComponentRootNode) || void 0 === _this$props$_getParen ? void 0 : _this$props$_getParen.call(_this$props);
        }
      } : {
        element: () => this.getWidgetRootElement()
      },
      _createActionByOption: () => (e) => {
        var _this$props$onKeyDown, _this$props2;
        null === (_this$props$onKeyDown = (_this$props2 = this.props).onKeyDown) || void 0 === _this$props$onKeyDown || _this$props$onKeyDown.call(_this$props2, e);
      }
    };
  }
  getKeyboardAction() {
    return {
      registerKeyboardAction: (element, action) => {
        const fakePaginationInstance = this.createFakeInstance();
        return registerKeyboardAction("pager", fakePaginationInstance, element, void 0, action);
      }
    };
  }
  getInfoVisible() {
    const {
      infoTextVisible,
      showInfo
    } = this.props;
    return !!showInfo && infoTextVisible;
  }
  getPageIndexSelectorVisible() {
    return 0 !== this.props.pageSize;
  }
  getNormalizedDisplayMode() {
    const {
      displayMode,
      lightModeEnabled
    } = this.props;
    if ("adaptive" === displayMode && void 0 !== lightModeEnabled) {
      return lightModeEnabled ? "compact" : "full";
    }
    return displayMode ?? "adaptive";
  }
  getPagesContainerVisible() {
    return !!this.props.pagesNavigatorVisible && this.props.pageCount > 0;
  }
  getPagesContainerVisibility() {
    const {
      pagesNavigatorVisible,
      pageCount,
      hasKnownLastPage,
      showInfo,
      showNavigationButtons,
      showPageSizeSelector
    } = this.props;
    const shouldHideBasedOnPageCount = "auto" === pagesNavigatorVisible && 1 === pageCount && hasKnownLastPage;
    const hasExplicitVisibleComponents = Boolean(showInfo) || Boolean(showNavigationButtons) || true === showPageSizeSelector;
    const shouldHide = shouldHideBasedOnPageCount && !hasExplicitVisibleComponents;
    const result2 = shouldHide ? "hidden" : void 0;
    return result2;
  }
  getIsLargeDisplayMode() {
    const displayMode = this.getNormalizedDisplayMode();
    let result2 = false;
    if ("adaptive" === displayMode) {
      result2 = this.props.isLargeDisplayMode;
    } else {
      result2 = "full" === displayMode;
    }
    return result2;
  }
  getClasses() {
    const classesMap = {
      [`${this.props.className}`]: !!this.props.className,
      [PAGER_CLASS]: !!this.props.isGridCompatibilityMode,
      [PAGINATION_CLASS]: !this.props.isGridCompatibilityMode,
      [LIGHT_MODE_CLASS]: !this.getIsLargeDisplayMode()
    };
    return combineClasses(classesMap);
  }
  getAria() {
    return {
      role: "navigation",
      label: this.props.label ?? ""
    };
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.onKeyDown !== nextProps.onKeyDown) {
      this.__getterCache.keyboardAction = void 0;
    }
  }
  render() {
    const {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      rtlEnabled,
      visible,
      showPageSizeSelector,
      allowedPageSizesRef,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      infoTextRef,
      infoText,
      pageCount,
      pageIndex,
      itemCount,
      pagesRef,
      hasKnownLastPage,
      maxPagesCount,
      pageIndexChangedInternal,
      pagesCountText,
      showNavigationButtons,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props;
    const content = normalizeProps(createComponentVNode(2, Widget, _extends({
      rootElementRef: this.widgetRootElementRef,
      rtlEnabled,
      classes: this.getClasses(),
      visible,
      aria: this.getAria(),
      style,
      width,
      height,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    }, elementAttr, {
      children: [showPageSizeSelector && createComponentVNode(2, PageSizeSelector, {
        rootElementRef: allowedPageSizesRef,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        pageSize,
        pageSizeChangedInternal,
        allowedPageSizes
      }), this.getPagesContainerVisible() && createVNode(1, "div", PAGINATION_PAGES_CLASS, [this.getInfoVisible() && createComponentVNode(2, InfoText, {
        rootElementRef: infoTextRef,
        infoText,
        pageCount,
        pageIndex,
        itemCount
      }), this.getPageIndexSelectorVisible() && createVNode(1, "div", PAGINATION_PAGE_INDEXES_CLASS, createComponentVNode(2, PageIndexSelector, {
        hasKnownLastPage,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        maxPagesCount,
        pageCount,
        pageIndex,
        pageIndexChangedInternal,
        pagesCountText,
        showNavigationButtons,
        itemCount
      }), 2, null, null, pagesRef)], 0, {
        style: {
          visibility: this.getPagesContainerVisibility()
        }
      })]
    })));
    return createComponentVNode(2, PaginationConfigProvider, {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      children: content
    });
  }
};
PaginationContent.defaultProps = PaginationContentDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/resizable_container.js
function calculateLargeDisplayMode(_ref) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth
  } = _ref;
  return parentWidth - (pageSizesWidth + pagesWidth) > 0;
}
function calculateInfoTextVisible(_ref2) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth,
    info: infoWidth
  } = _ref2;
  const minimalWidth = pageSizesWidth + pagesWidth + infoWidth;
  return parentWidth - minimalWidth > 0;
}
function getElementsWidth(_ref3) {
  let {
    parent,
    allowedPageSizes,
    pages,
    info
  } = _ref3;
  const parentWidth = getElementContentWidth(parent);
  const pageSizesWidth = getElementWidth2(allowedPageSizes);
  const infoWidth = getElementWidth2(info);
  const pagesHtmlWidth = getElementWidth2(pages);
  return {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    info: infoWidth + getElementStyle2("marginLeft", info) + getElementStyle2("marginRight", info),
    pages: pagesHtmlWidth
  };
}
var ResizableContainerDefaultProps = {
  paginationProps: _extends({}, PaginationDefaultProps)
};
var ResizableContainer = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      infoTextVisible: true,
      isLargeDisplayMode: true
    };
    this.refs = null;
    this.parentRef = createRef();
    this.infoTextRef = createRef();
    this.pagesRef = createRef();
    this.allowedPageSizesRef = createRef();
    this.elementsWidth = {};
    this.actualIsLargeDisplayMode = true;
    this.actualInfoTextVisible = true;
    this.subscribeToResize = this.subscribeToResize.bind(this);
    this.effectUpdateChildProps = this.effectUpdateChildProps.bind(this);
    this.updateAdaptivityProps = this.updateAdaptivityProps.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context) {
    super.componentWillUpdate(nextProps, nextState, context);
  }
  createEffects() {
    return [new InfernoEffect(this.subscribeToResize, [this.state.infoTextVisible, this.state.isLargeDisplayMode]), new InfernoEffect(this.effectUpdateChildProps, [this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.infoTextVisible, this.state.isLargeDisplayMode]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate]);
  }
  subscribeToResize() {
    const callback = () => {
      if (this.getParentWidth() > 0) {
        this.updateAdaptivityProps();
      }
    };
    resize_callbacks_default.add(callback);
    return () => {
      resize_callbacks_default.remove(callback);
    };
  }
  effectUpdateChildProps() {
    if (this.getParentWidth() > 0) {
      this.updateAdaptivityProps();
    }
  }
  getContentAttributes() {
    const {
      className,
      displayMode,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      hasKnownLastPage,
      infoText,
      label,
      lightModeEnabled,
      maxPagesCount,
      onKeyDown,
      pageCount,
      pageIndex,
      pageIndexChangedInternal,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      pagesCountText,
      pagesNavigatorVisible,
      rtlEnabled,
      showInfo,
      showNavigationButtons,
      showPageSizeSelector,
      itemCount,
      visible,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props.paginationProps;
    return {
      pageSize,
      pageIndex,
      pageIndexChangedInternal,
      pageSizeChangedInternal,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      className,
      showInfo,
      infoText,
      lightModeEnabled,
      displayMode,
      maxPagesCount,
      pageCount,
      pagesCountText,
      visible,
      hasKnownLastPage,
      pagesNavigatorVisible,
      showPageSizeSelector,
      allowedPageSizes,
      rtlEnabled,
      showNavigationButtons,
      itemCount,
      onKeyDown,
      label,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    };
  }
  getParentWidth() {
    var _this$parentRef;
    return null !== (_this$parentRef = this.parentRef) && void 0 !== _this$parentRef && _this$parentRef.current ? getElementWidth2(this.parentRef.current) : 0;
  }
  updateAdaptivityProps() {
    var _this$parentRef2, _this$allowedPageSize, _this$infoTextRef, _this$pagesRef;
    const currentElementsWidth = getElementsWidth({
      parent: null === (_this$parentRef2 = this.parentRef) || void 0 === _this$parentRef2 ? void 0 : _this$parentRef2.current,
      allowedPageSizes: null === (_this$allowedPageSize = this.allowedPageSizesRef) || void 0 === _this$allowedPageSize ? void 0 : _this$allowedPageSize.current,
      info: null === (_this$infoTextRef = this.infoTextRef) || void 0 === _this$infoTextRef ? void 0 : _this$infoTextRef.current,
      pages: null === (_this$pagesRef = this.pagesRef) || void 0 === _this$pagesRef ? void 0 : _this$pagesRef.current
    });
    if (this.actualInfoTextVisible !== this.state.infoTextVisible || this.actualIsLargeDisplayMode !== this.state.isLargeDisplayMode) {
      return;
    }
    const isEmpty3 = !isDefined(this.elementsWidth);
    if (isEmpty3) {
      this.elementsWidth = {};
    }
    if (isEmpty3 || this.state.isLargeDisplayMode) {
      this.elementsWidth.allowedPageSizes = currentElementsWidth.allowedPageSizes;
      this.elementsWidth.pages = currentElementsWidth.pages;
    }
    if (isEmpty3 || this.state.infoTextVisible) {
      this.elementsWidth.info = currentElementsWidth.info;
    }
    this.actualIsLargeDisplayMode = calculateLargeDisplayMode({
      parent: currentElementsWidth.parent,
      allowedPageSizes: this.elementsWidth.allowedPageSizes,
      pages: this.elementsWidth.pages
    });
    this.actualInfoTextVisible = calculateInfoTextVisible(_extends({}, currentElementsWidth, {
      info: this.elementsWidth.info
    }));
    this.setState((() => ({
      infoTextVisible: this.actualInfoTextVisible
    })));
    this.setState((() => ({
      isLargeDisplayMode: this.actualIsLargeDisplayMode
    })));
  }
  render() {
    const {
      infoTextVisible,
      isLargeDisplayMode
    } = this.state;
    const {
      props: {
        contentTemplate: Content
      }
    } = this;
    return normalizeProps(createComponentVNode(2, Content, _extends({
      rootElementRef: this.parentRef,
      allowedPageSizesRef: this.allowedPageSizesRef,
      infoTextRef: this.infoTextRef,
      pagesRef: this.pagesRef,
      infoTextVisible,
      isLargeDisplayMode
    }, this.getContentAttributes())));
  }
};
ResizableContainer.defaultProps = ResizableContainerDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pagination.js
var Pagination = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.pageSizeChangedInternal = this.pageSizeChangedInternal.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  pageIndexChangedInternal(newPageIndex) {
    const newValue = newPageIndex + 1;
    this.setState((() => ({
      pageIndex: newValue
    })));
    this.props.pageIndexChangedInternal(newValue);
  }
  getPageIndex() {
    return this.props.pageIndex - 1;
  }
  pageSizeChangedInternal(newPageSize) {
    this.setState((() => ({
      pageSize: newPageSize
    })));
    this.props.pageSizeChangedInternal(newPageSize);
  }
  getClassName() {
    return combineClasses({
      "dx-datagrid-pager": isGridCompatibilityMode(this.context),
      [`${this.props.className}`]: !!this.props.className
    });
  }
  getPaginationProps() {
    return _extends({}, this.props, {
      className: this.getClassName(),
      pageIndex: this.getPageIndex(),
      pageIndexChangedInternal: (pageIndex) => this.pageIndexChangedInternal(pageIndex),
      pageSizeChangedInternal: (pageSize) => this.pageSizeChangedInternal(pageSize)
    });
  }
  render() {
    return createComponentVNode(2, ResizableContainer, {
      contentTemplate: PaginationContent,
      paginationProps: this.getPaginationProps()
    });
  }
};
Pagination.defaultProps = PaginationDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/validation_utils.js
function getPageSize(pageSize) {
  if (pageSize < 0) {
    return 1;
  }
  return pageSize;
}
function getItemCount(itemCount) {
  if (itemCount < 0) {
    return 0;
  }
  return itemCount;
}
function getPageCount(pageSize, itemCount) {
  if (pageSize > 0 && itemCount > 0) {
    return Math.max(1, Math.ceil(itemCount / pageSize));
  }
  return 1;
}
function getPageIndex(pageIndex, pageSize, itemCount) {
  if (pageIndex < 1) {
    return 1;
  }
  const pageCount = getPageCount(pageSize, itemCount);
  return Math.min(pageIndex, pageCount);
}
function validateOptions(oldPageSize, oldPageIndex, oldItemCount) {
  const pageSize = getPageSize(oldPageSize);
  const itemCount = getItemCount(oldItemCount);
  const pageCount = getPageCount(pageSize, oldItemCount);
  const pageIndex = getPageIndex(oldPageIndex, pageSize, itemCount);
  return {
    pageSize,
    pageIndex,
    itemCount,
    pageCount
  };
}

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination_wrapper.js
var _excluded9 = ["pageSize", "pageIndex", "itemCount"];
var PaginationWrapper = class extends ComponentWrapper {
  _optionChanged(args) {
    switch (args.name) {
      case "pageIndex": {
        const pageIndexChanged = this.option("pageIndexChanged");
        if (pageIndexChanged) {
          pageIndexChanged(args.value);
        }
        break;
      }
      case "pageSize": {
        const pageSizeChanged = this.option("pageSizeChanged");
        if (pageSizeChanged) {
          pageSizeChanged(args.value);
        }
        break;
      }
    }
    super._optionChanged(args);
  }
  getPageCount() {
    return this.option("pageCount");
  }
  _validateOptions(options2) {
    if (options2._skipValidation || this.option("_skipValidation")) {
      return options2;
    }
    const initialOptions = super._validateOptions(options2);
    let {
      pageSize,
      pageIndex,
      itemCount
    } = initialOptions, rest = _objectWithoutPropertiesLoose(initialOptions, _excluded9);
    if (void 0 === pageSize) {
      pageSize = this.option("pageSize");
    }
    if (void 0 === pageIndex) {
      pageIndex = this.option("pageIndex");
    }
    if (void 0 === itemCount) {
      itemCount = this.option("itemCount");
    }
    const validatedOptions = validateOptions(pageSize, pageIndex, itemCount);
    return _extends({}, rest, validatedOptions);
  }
};

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination.js
var Pagination2 = class extends PaginationWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["pageSize", "defaultPageSize", "pageSizeChangedInternal", "pageSizeChanged"],
        ["pageIndex", "defaultPageIndex", "pageIndexChangedInternal", "pageIndexChanged"]
      ],
      allowNull: [],
      elements: [],
      templates: [],
      props: ["defaultPageSize", "pageSizeChanged", "pageSizeChangedInternal", "defaultPageIndex", "pageIndexChanged", "pageIndexChangedInternal", "isGridCompatibilityMode", "className", "showInfo", "infoText", "lightModeEnabled", "displayMode", "maxPagesCount", "pageCount", "pagesCountText", "visible", "hasKnownLastPage", "pagesNavigatorVisible", "showPageSizeSelector", "allowedPageSizes", "rtlEnabled", "showNavigationButtons", "itemCount", "label", "onKeyDown", "pageSize", "pageIndex", "width", "height", "elementAttr", "hint", "disabled", "tabIndex", "accessKey", "activeStateEnabled", "focusStateEnabled", "hoverStateEnabled", "_skipValidation", "_getParentComponentRootNode"]
    };
  }
  get _viewComponent() {
    return Pagination;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/pager/m_pager.js
var getPageIndex2 = function(dataController2) {
  return 1 + (parseInt(dataController2.pageIndex()) || 0);
};
var PagerView = class extends m_modules_default.View {
  init() {
    const dataController2 = this.getController("data");
    dataController2.changed.add(((e) => {
      if (e && e.repaintChangesOnly) {
        const pager = this._pager;
        if (pager) {
          pager.option({
            pageIndex: getPageIndex2(dataController2),
            pageSize: dataController2.pageSize(),
            pageCount: dataController2.pageCount(),
            itemCount: dataController2.totalCount(),
            hasKnownLastPage: dataController2.hasKnownLastPage()
          });
        } else {
          this.render();
        }
      } else if (!e || "update" !== e.changeType && "updateSelection" !== e.changeType && "updateFocusedRow" !== e.changeType) {
        this._pager = null;
        this.render();
      }
    }));
  }
  dispose() {
    this._pager = null;
  }
  optionChanged(args) {
    const {
      name: name2
    } = args;
    const isPager = "pager" === name2;
    const isPaging = "paging" === name2;
    const isDataSource = "dataSource" === name2;
    const isScrolling = "scrolling" === name2;
    const dataController2 = this.getController("data");
    if (isPager || isPaging || isScrolling || isDataSource) {
      args.handled = true;
      if (dataController2.skipProcessingPagingChange(args.fullName)) {
        return;
      }
      if (isPager || isPaging) {
        this._pageSizes = null;
      }
      if (!isDataSource) {
        this._pager = null;
        this._invalidate();
        if (hasWindow() && isPager && this.component) {
          this.component.resize();
        }
      }
    }
  }
  _renderCore() {
    const that = this;
    const $element = that.element().addClass(that.addWidgetPrefix("pager"));
    const pagerOptions = that.option("pager") ?? {};
    const dataController2 = that.getController("data");
    const keyboardController = that.getController("keyboardNavigation");
    const options2 = {
      maxPagesCount: 10,
      pageIndex: getPageIndex2(dataController2),
      pageCount: dataController2.pageCount(),
      pageSize: dataController2.pageSize(),
      showPageSizeSelector: pagerOptions.showPageSizeSelector,
      showInfo: pagerOptions.showInfo,
      displayMode: pagerOptions.displayMode,
      pagesNavigatorVisible: pagerOptions.visible,
      showNavigationButtons: pagerOptions.showNavigationButtons,
      label: pagerOptions.label,
      allowedPageSizes: that.getPageSizes(),
      itemCount: dataController2.totalCount(),
      hasKnownLastPage: dataController2.hasKnownLastPage(),
      rtlEnabled: that.option("rtlEnabled"),
      isGridCompatibilityMode: true,
      _getParentComponentRootNode: () => this.component.element(),
      _skipValidation: true,
      pageIndexChanged(pageIndex) {
        if (dataController2.pageIndex() !== pageIndex - 1) {
          dataController2.pageIndex(pageIndex - 1);
        }
      },
      pageSizeChanged(pageSize) {
        dataController2.pageSize(pageSize);
      },
      onKeyDown: (e) => keyboardController && keyboardController.executeAction("onKeyDown", e)
    };
    if (isDefined(pagerOptions.infoText)) {
      options2.infoText = pagerOptions.infoText;
    }
    if (this._pager) {
      this._pager.repaint();
      return;
    }
    if (hasWindow()) {
      this._pager = that._createComponent($element, Pagination2, options2);
    } else {
      $element.addClass("dx-pager").html('<div class="dx-pages"><div class="dx-page"></div></div>');
    }
  }
  getPager() {
    return this._pager;
  }
  getPageSizes() {
    const that = this;
    const dataController2 = that.getController("data");
    const pagerOptions = that.option("pager");
    const allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes;
    const pageSize = dataController2.pageSize();
    if (!isDefined(that._pageSizes) || !that._pageSizes.includes(pageSize)) {
      that._pageSizes = [];
      if (pagerOptions) {
        if (Array.isArray(allowedPageSizes)) {
          that._pageSizes = allowedPageSizes;
        } else if (allowedPageSizes && pageSize > 1) {
          that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize];
        }
      }
    }
    return that._pageSizes;
  }
  isVisible() {
    const dataController2 = this.getController("data");
    const pagerOptions = this.option("pager");
    let pagerVisible = pagerOptions && pagerOptions.visible;
    const scrolling = this.option("scrolling");
    if ("auto" === pagerVisible) {
      if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
        pagerVisible = false;
      } else {
        pagerVisible = dataController2.pageCount() > 1 || dataController2.isLoaded() && !dataController2.hasKnownLastPage();
      }
    }
    return !!pagerVisible;
  }
  getHeight() {
    return this.getElementHeight();
  }
};
var pagerModule = {
  defaultOptions: () => ({
    pager: {
      visible: "auto",
      showPageSizeSelector: false,
      allowedPageSizes: "auto",
      label: message_default.format("dxPager-ariaLabel")
    }
  }),
  views: {
    pagerView: PagerView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/pager.js
m_core_default.registerModule("pager", pagerModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/m_columns_resizing_reordering.js
var COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent";
var MODULE_NAMESPACE2 = "dxDataGridResizingReordering";
var allowResizing = function(that) {
  return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing");
};
var allowReordering = function(that) {
  return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering");
};
var TrackerView = class extends m_modules_default.View {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._subscribeToCallback();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      this._unsubscribeFromCallback();
      if (args.value) {
        this._subscribeToCallback();
        this._invalidate();
      }
    }
    super.optionChanged(args);
  }
  _renderCore() {
    const deferred = super._renderCore();
    this.element().addClass(this.addWidgetPrefix("tracker"));
    this.hide();
    return deferred;
  }
  _unsubscribeFromCallback() {
    if (this._positionChanged) {
      this._tablePositionController.positionChanged.remove(this._positionChanged);
    }
  }
  _subscribeToCallback() {
    const that = this;
    that._positionChanged = function(position2) {
      const $element = that.element();
      if ($element && $element.hasClass(that.addWidgetPrefix("tracker"))) {
        $element.css({
          top: position2.top
        });
        setHeight($element, position2.height);
      }
    };
    this._tablePositionController.positionChanged.add(that._positionChanged);
  }
  isVisible() {
    return allowResizing(this);
  }
  show() {
    this.element().show();
  }
  hide() {
    this.element() && this.element().hide();
  }
  setHeight(value2) {
    setHeight(this.element(), value2);
  }
};
var SeparatorView = class extends m_modules_default.View {
  _renderSeparator() {
  }
  _renderCore(options2) {
    const deferred = super._renderCore(options2);
    this._isShown = true;
    this._renderSeparator();
    this.hide();
    return deferred;
  }
  show() {
    this._isShown = true;
  }
  hide() {
    this._isShown = false;
  }
  height(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setHeight($element, value2);
      } else {
        return getHeight($element);
      }
    }
  }
  width(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setWidth($element, value2);
      } else {
        return getWidth($element);
      }
    }
  }
};
var ColumnsSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._init();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._invalidate();
        this.hide(true);
      } else {
        this._unsubscribeFromCallback();
        this._isTransparent = allowResizing(this);
        this.hide(true);
      }
    }
    super.optionChanged(args);
  }
  _renderSeparator() {
    super._renderSeparator();
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("columns-separator"));
  }
  _subscribeToCallback() {
    const that = this;
    let $element;
    that._positionChanged = function(position2) {
      $element = that.element();
      if ($element) {
        $element.css({
          top: position2.top
        });
        setHeight($element, position2.height);
      }
    };
    that._tablePositionController.positionChanged.add(that._positionChanged);
  }
  _unsubscribeFromCallback() {
    this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
  }
  _init() {
    this._isTransparent = allowResizing(this);
    if (this.isVisible()) {
      this._subscribeToCallback();
    }
  }
  isVisible() {
    return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this));
  }
  show() {
    const that = this;
    const $element = this.element();
    if ($element && !that._isShown) {
      if (that._isTransparent) {
        $element.removeClass(that.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT));
      } else {
        $element.show();
      }
    }
    super.show();
  }
  hide(force) {
    const $element = this.element();
    const columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
    if ($element && (this._isShown || force)) {
      if (this._isTransparent) {
        $element.addClass(columnsSeparatorTransparent);
        $element.css("left", "");
        $element.show();
      } else {
        if ($element.hasClass(columnsSeparatorTransparent)) {
          $element.removeClass(columnsSeparatorTransparent);
        }
        $element.hide();
      }
    }
    super.hide();
  }
  moveByX(outerX) {
    const $element = this.element();
    if ($element) {
      $element.css("left", null === outerX ? 0 : outerX - this._parentElement().offset().left);
    }
  }
  changeCursor(cursorName) {
    cursorName = isDefined(cursorName) ? cursorName : "";
    const $element = this.element();
    if ($element) {
      $element.css("cursor", cursorName);
    }
  }
};
var BlockSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    dataController2.loadingChanged.add(((isLoading) => {
      if (!isLoading) {
        this.hide();
      }
    }));
  }
  _renderSeparator() {
    super._renderSeparator();
    this.element().addClass("dx-block-separator").html("&nbsp;");
  }
  hide() {
    const that = this;
    const $parent = this._parentElement();
    const $element = this.element();
    if ($element && this._isShown) {
      $element.css("display", "none");
    }
    if ($parent && !$parent.children(".dx-block-separator").length) {
      $parent.prepend(that.element());
    }
    super.hide();
  }
  isVisible() {
    const groupPanelOptions = this.option("groupPanel");
    const columnChooserOptions = this.option("columnChooser");
    return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled;
  }
  show(targetLocation) {
    const $element = this.element();
    if ($element && !this._isShown) {
      switch (targetLocation) {
        case "group":
          this.element().css("display", "block");
          break;
        case "columnChooser":
          !(function(toOptions) {
            fx_default.stop($element, true);
            fx_default.animate($element, {
              type: "slide",
              from: {
                width: 0,
                display: toOptions.display
              },
              to: toOptions,
              duration: 300,
              easing: "swing"
            });
          })({
            width: "100%",
            display: "block"
          });
          break;
        default:
          $element.css("display", "");
      }
    }
    super.show();
  }
};
var DraggingHeaderView = class extends m_modules_default.View {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    this._controller = this.getController("draggingHeader");
    this._columnsResizerViewController = this.getController("columnsResizer");
    this._columnsController = this.getController("columns");
    this._isDragging = false;
    dataController2.loadingChanged.add(((isLoading) => {
      const element = this.element();
      if (!isLoading && element) {
        element.hide();
      }
    }));
  }
  isDragging() {
    return this._isDragging;
  }
  _getDraggingPanelByPos(pos) {
    let result2;
    each(this._dragOptions.draggingPanels, ((index, draggingPanel) => {
      if (draggingPanel) {
        const boundingRect = draggingPanel.getBoundingRect();
        if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
          result2 = draggingPanel;
          return false;
        }
      }
      return;
    }));
    return result2;
  }
  _renderCore() {
    this.element().addClass(`${this.addWidgetPrefix("drag-header")} ${this.addWidgetPrefix("text-content")} dx-widget`).hide();
  }
  _resetTargetColumnOptions() {
    const params = this._dropOptions;
    params.targetColumnIndex = -1;
    delete params.targetColumnElement;
    delete params.isLast;
    delete params.posX;
    delete params.posY;
  }
  _getVisibleIndexObject(rowIndex, visibleIndex) {
    if (isDefined(rowIndex)) {
      return {
        columnIndex: visibleIndex,
        rowIndex
      };
    }
    return visibleIndex;
  }
  dispose() {
    const element = this.element();
    this._dragOptions = null;
    element && element.parent().find(`.${this.addWidgetPrefix("drag-header")}`).remove();
  }
  isVisible() {
    const commonColumnSettings = this._columnsController.getCommonSettings();
    return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding);
  }
  dragHeader(options2) {
    const {
      columnElement
    } = options2;
    const isCommandColumn = !!options2.sourceColumn.type;
    this._isDragging = true;
    this._dragOptions = options2;
    this._dropOptions = {
      sourceIndex: options2.index,
      sourceColumnIndex: this._getVisibleIndexObject(options2.rowIndex, options2.columnIndex),
      sourceColumnElement: options2.columnElement,
      sourceLocation: options2.sourceLocation
    };
    const document2 = dom_adapter_default.getDocument();
    this._onSelectStart = document2.onselectstart;
    document2.onselectstart = function() {
      return false;
    };
    this._controller.drag(this._dropOptions);
    this.element().css({
      textAlign: columnElement && columnElement.css("textAlign"),
      height: columnElement && (isCommandColumn && columnElement.get(0).clientHeight || getHeight(columnElement)),
      width: columnElement && (isCommandColumn && columnElement.get(0).clientWidth || getWidth(columnElement)),
      whiteSpace: columnElement && columnElement.css("whiteSpace")
    }).addClass(this.addWidgetPrefix("drag-action")).toggleClass("dx-drag-command-cell", isCommandColumn).text(isCommandColumn ? "" : options2.sourceColumn.caption);
    this.element().appendTo(swatch_container_default.getSwatchContainer(columnElement));
  }
  moveHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const eventData2 = eventData(e);
    const isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false;
    const dragOptions = that._dragOptions;
    if (that._isDragging && !isResizing) {
      const $element = that.element();
      const moveDeltaX = Math.abs(eventData2.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
      const moveDeltaY = Math.abs(eventData2.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
      if ($element.is(":visible") || moveDeltaX > 5 || moveDeltaY > 5) {
        $element.show();
        const newLeft = eventData2.x - dragOptions.deltaX;
        const newTop = eventData2.y - dragOptions.deltaY;
        $element.css({
          left: newLeft,
          top: newTop
        });
        that.dockHeader(eventData2);
      }
      e.preventDefault();
    }
  }
  dockHeader(eventData2) {
    const that = this;
    const targetDraggingPanel = that._getDraggingPanelByPos(eventData2);
    const controller = that._controller;
    const params = that._dropOptions;
    const dragOptions = that._dragOptions;
    if (targetDraggingPanel) {
      const rtlEnabled = that.option("rtlEnabled");
      const isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName();
      const axisName = isVerticalOrientation ? "y" : "x";
      const targetLocation = targetDraggingPanel.getName();
      const rowIndex = "headers" === targetLocation ? dragOptions.rowIndex : void 0;
      const {
        sourceColumn
      } = dragOptions;
      const columnElements = targetDraggingPanel.getColumnElements(rowIndex, null === sourceColumn || void 0 === sourceColumn ? void 0 : sourceColumn.ownerBand) || [];
      const pointsByTarget = dragOptions.pointsByTarget = dragOptions.pointsByTarget || {};
      const pointsByColumns = "columnChooser" === targetLocation ? [] : pointsByTarget[targetLocation] || controller._generatePointsByColumns(extend({}, dragOptions, {
        targetDraggingPanel,
        columns: targetDraggingPanel.getColumns(rowIndex),
        columnElements,
        isVerticalOrientation,
        startColumnIndex: "headers" === targetLocation ? renderer_default(columnElements[0]).index() : 0
      }));
      pointsByTarget[targetLocation] = pointsByColumns;
      params.targetLocation = targetLocation;
      if (pointsByColumns.length > 0) {
        for (let i = 0; i < pointsByColumns.length; i++) {
          const centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
          if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData2[axisName] > centerPosition : eventData2[axisName] < centerPosition)) {
            params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
            if (columnElements[i]) {
              params.targetColumnElement = columnElements.eq(i);
              params.isLast = false;
            } else {
              params.targetColumnElement = columnElements.last();
              params.isLast = true;
            }
            params.posX = pointsByColumns[i].x;
            params.posY = pointsByColumns[i].y;
            controller.dock(params);
            break;
          }
        }
      } else {
        that._resetTargetColumnOptions();
        controller.dock(params);
      }
    }
  }
  dropHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const controller = that._controller;
    that.element().hide();
    if (controller && that._isDragging) {
      controller.drop(that._dropOptions);
    }
    that.element().appendTo(that._parentElement());
    that._dragOptions = null;
    that._dropOptions = null;
    that._isDragging = false;
    dom_adapter_default.getDocument().onselectstart = that._onSelectStart || null;
  }
};
var isNextColumnResizingMode = function(that) {
  return "widget" !== that.option("columnResizingMode");
};
var ColumnsResizerViewController = class extends m_modules_default.ViewController {
  init() {
    this._subscribesToCallbacks = [];
    if (allowResizing(this)) {
      this._init();
    }
  }
  dispose() {
    this._unsubscribes();
    super.dispose();
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._subscribeToEvents();
      } else {
        this._unsubscribes();
      }
    }
  }
  _isHeadersRowArea(posY) {
    if (this._columnHeadersView) {
      const element = this._columnHeadersView.element();
      if (element) {
        const offsetTop = element.offset().top;
        const headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
        return posY >= offsetTop && posY <= offsetTop + headersRowHeight;
      }
    }
    return false;
  }
  _isRtlParentStyle() {
    var _this$_$parentContain;
    const rtlEnabled = this.option("rtlEnabled");
    return rtlEnabled && "rtl" === (null === (_this$_$parentContain = this._$parentContainer) || void 0 === _this$_$parentContain ? void 0 : _this$_$parentContain.parent().css("direction"));
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    point.columnIndex -= correctionValue;
  }
  _pointCreated(point, cellsLength, columns7) {
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const firstPointColumnIndex = !isNextColumnMode && rtlEnabled && !isRtlParentStyle ? 0 : 1;
    if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && (!rtlEnabled || isRtlParentStyle) ? 1 : 0)) {
      this._correctColumnIndexForPoint(point, firstPointColumnIndex, columns7);
      const currentColumn = columns7[point.columnIndex] || {};
      const nextColumn = columns7[point.columnIndex + 1] || {};
      return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing);
    }
    return true;
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    if (pointsByColumns) {
      for (let i = 0; i < pointsByColumns.length; i++) {
        if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
          continue;
        }
        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
          return pointsByColumns[i];
        }
      }
    }
    return null;
  }
  getSeparatorOffsetX($cell) {
    var _$cell$offset;
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const outerWidth = $cell[0].getBoundingClientRect().width;
    const cellOffset = (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
    return cellOffset + ((isNextColumnMode || isRtlParentStyle) && rtlEnabled ? 0 : outerWidth);
  }
  _moveSeparator(args) {
    var _that$_draggingHeader;
    const e = args.event;
    const that = e.data;
    const columnsSeparatorWidth = that._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(that);
    const deltaX = columnsSeparatorWidth / 2;
    const parentOffset = that._$parentContainer.offset();
    const parentOffsetLeft = parentOffset.left;
    const eventData2 = eventData(e);
    const isRtlParentStyle = this._isRtlParentStyle();
    const isDragging = null === (_that$_draggingHeader = that._draggingHeaderView) || void 0 === _that$_draggingHeader ? void 0 : _that$_draggingHeader.isDragging();
    if (that._isResizing && that._resizingInfo) {
      if ((parentOffsetLeft <= eventData2.x || !isNextColumnMode && isRtlParentStyle) && (!isNextColumnMode || eventData2.x <= parentOffsetLeft + getWidth(that._$parentContainer))) {
        if (that._updateColumnsWidthIfNeeded(eventData2.x)) {
          const $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
          if ($cell.length) {
            const offsetX = this.getSeparatorOffsetX($cell);
            that._columnsSeparatorView.moveByX(offsetX);
            that._tablePositionController.update(that._targetPoint.y);
            e.preventDefault();
          }
        }
      }
    } else if (!isDragging) {
      if (that._isHeadersRowArea(eventData2.y)) {
        if (that._previousParentOffset) {
          if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
            that.pointsByColumns(null);
          }
        }
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, columnsSeparatorWidth);
        that._previousParentOffset = parentOffset;
        that._isReadyResizing = false;
        if (that._targetPoint) {
          that._columnsSeparatorView.changeCursor("col-resize");
          that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
          that._tablePositionController.update(that._targetPoint.y);
          that._isReadyResizing = true;
          e.preventDefault();
        } else {
          that._columnsSeparatorView.changeCursor();
          that._columnsSeparatorView.moveByX(null);
        }
      } else {
        that.pointsByColumns(null);
        that._isReadyResizing = false;
        that._columnsSeparatorView.changeCursor();
        that._columnsSeparatorView.moveByX(null);
      }
    }
  }
  _endResizing(args) {
    const e = args.event;
    const that = e.data;
    if (that._isResizing) {
      that.pointsByColumns(null);
      that._resizingInfo = null;
      that._columnsSeparatorView.hide();
      that._columnsSeparatorView.changeCursor();
      that._trackerView.hide();
      that._isReadyResizing = false;
      that._isResizing = false;
    }
  }
  _getNextColumnIndex(currentColumnIndex) {
    return currentColumnIndex + 1;
  }
  _setupResizingInfo(posX) {
    const currentColumnIndex = this._targetPoint.columnIndex;
    const nextColumnIndex = this._getNextColumnIndex(currentColumnIndex);
    const $currentHeader = this._columnHeadersView.getHeaderElement(currentColumnIndex);
    const $nextHeader = this._columnHeadersView.getHeaderElement(nextColumnIndex);
    this._resizingInfo = {
      startPosX: posX,
      currentColumnIndex,
      currentColumnWidth: null !== $currentHeader && void 0 !== $currentHeader && $currentHeader.length ? getBoundingRect($currentHeader[0]).width : 0,
      nextColumnIndex,
      nextColumnWidth: null !== $nextHeader && void 0 !== $nextHeader && $nextHeader.length ? getBoundingRect($nextHeader[0]).width : 0,
      needToInvertResizing: this._needToInvertResizing($currentHeader)
    };
  }
  _startResizing(args) {
    const e = args.event;
    const that = e.data;
    const eventData2 = eventData(e);
    if (isTouchEvent(e)) {
      if (that._isHeadersRowArea(eventData2.y)) {
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, 10);
        if (that._targetPoint) {
          that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
          that._isReadyResizing = true;
        }
      } else {
        that._isReadyResizing = false;
      }
    }
    if (that._isReadyResizing) {
      that._setupResizingInfo(eventData2.x);
      that._isResizing = true;
      that._tablePositionController.update(that._targetPoint.y);
      that._columnsSeparatorView.show();
      that._trackerView.show();
      const scrollable = that.component.getScrollable();
      if (scrollable && that._isRtlParentStyle()) {
        that._scrollRight = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - scrollable.scrollLeft();
      }
      e.preventDefault();
      e.stopPropagation();
    }
    if (this.isResizing()) {
      this._editorFactoryController.loseFocus();
    }
  }
  _generateColumnsTopYIndex() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const rowCount = that._columnsController.getRowCount();
    const topYMap = {};
    const pointCreated = (point) => {
      const x = Math.ceil(point.x);
      if (!topYMap[x]) {
        topYMap[x] = point.y;
      }
      return true;
    };
    for (let rowIndex = 0; rowIndex < rowCount - 1; rowIndex++) {
      const cells = that._columnHeadersView.getColumnElements(rowIndex);
      if (cells && cells.length > 0) {
        m_utils_default.getPointsByColumns(cells, pointCreated, false, 0, needToCheckPrevPoint);
      }
    }
    return topYMap;
  }
  _generatePointsByColumns() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const topYMap = that._generateColumnsTopYIndex(needToCheckPrevPoint);
    const columns7 = that._columnsController ? that._columnsController.getVisibleColumns() : [];
    const cells = that._columnHeadersView.getColumnElements();
    that._pointsByColumns = [];
    if (cells && cells.length > 0) {
      that._pointsByColumns = m_utils_default.getPointsByColumns(cells, ((point) => that._pointCreated(((point2) => {
        const x = Math.ceil(point2.x);
        if (topYMap[x]) {
          point2.y = topYMap[x];
        }
        return point2;
      })(point), cells.length, columns7)), false, 0, needToCheckPrevPoint);
    }
  }
  _needToInvertResizing($cell) {
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const isNextColumnMode = isNextColumnResizingMode(this);
    return (isNextColumnMode || isRtlParentStyle) && rtlEnabled;
  }
  _unsubscribeFromEvents() {
    this._moveSeparatorHandler && m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.move, MODULE_NAMESPACE2), this._moveSeparatorHandler);
    this._startResizingHandler && m_events_engine_default.off(this._$parentContainer, addNamespace(m_pointer_default.down, MODULE_NAMESPACE2), this._startResizingHandler);
    if (this._endResizingHandler) {
      m_events_engine_default.off(this._columnsSeparatorView.element(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
      m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
    }
  }
  _subscribeToEvents() {
    this._moveSeparatorHandler = this.createAction(this._moveSeparator);
    this._startResizingHandler = this.createAction(this._startResizing);
    this._endResizingHandler = this.createAction(this._endResizing);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.move, MODULE_NAMESPACE2), this, this._moveSeparatorHandler);
    m_events_engine_default.on(this._$parentContainer, addNamespace(m_pointer_default.down, MODULE_NAMESPACE2), this, this._startResizingHandler);
    m_events_engine_default.on(this._columnsSeparatorView.element(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
  }
  _updateColumnsWidthIfNeeded(posX) {
    let deltaX;
    let needUpdate = false;
    let contentWidth = this._rowsView.contentWidth();
    const resizingInfo = this._resizingInfo;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnsSeparatorWidth = this._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(this);
    const adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");
    const isRtlParentStyle = this._isRtlParentStyle();
    const column = visibleColumns[resizingInfo.currentColumnIndex];
    const nextColumn = visibleColumns[resizingInfo.nextColumnIndex];
    const {
      needToInvertResizing
    } = resizingInfo;
    function isPercentWidth2(width) {
      return isString(width) && width.endsWith("%");
    }
    function setColumnWidth(column2, columnWidth, contentWidth2, adaptColumnWidthByRatio2) {
      if (column2) {
        const oldColumnWidth = column2.width;
        if (oldColumnWidth) {
          adaptColumnWidthByRatio2 = isPercentWidth2(oldColumnWidth);
        }
        if (adaptColumnWidthByRatio2) {
          columnsController.columnOption(column2.index, "visibleWidth", columnWidth);
          columnsController.columnOption(column2.index, "width", `${(columnWidth / contentWidth2 * 100).toFixed(3)}%`);
        } else {
          columnsController.columnOption(column2.index, "visibleWidth", null);
          columnsController.columnOption(column2.index, "width", columnWidth);
        }
      }
    }
    deltaX = posX - resizingInfo.startPosX;
    if (needToInvertResizing) {
      deltaX = -deltaX;
    }
    let {
      cellWidth,
      nextCellWidth
    } = (function(delta) {
      let nextMinWidth;
      let nextCellWidth2;
      let needCorrectionNextCellWidth;
      const cellWidth2 = resizingInfo.currentColumnWidth + delta;
      const minWidth = column && column.minWidth || columnsSeparatorWidth;
      const result2 = {};
      if (cellWidth2 >= minWidth) {
        result2.cellWidth = cellWidth2;
      } else {
        result2.cellWidth = minWidth;
        needCorrectionNextCellWidth = true;
      }
      if (isNextColumnMode) {
        nextCellWidth2 = resizingInfo.nextColumnWidth - delta;
        nextMinWidth = nextColumn && nextColumn.minWidth || columnsSeparatorWidth;
        if (nextCellWidth2 >= nextMinWidth) {
          if (needCorrectionNextCellWidth) {
            result2.nextCellWidth = resizingInfo.nextColumnWidth - (delta + minWidth - cellWidth2);
          } else {
            result2.nextCellWidth = nextCellWidth2;
          }
        } else {
          result2.nextCellWidth = nextMinWidth;
          result2.cellWidth = resizingInfo.currentColumnWidth + (delta - nextMinWidth + nextCellWidth2);
        }
      }
      return result2;
    })(deltaX);
    needUpdate = column.width !== cellWidth;
    if (needUpdate) {
      columnsController.beginUpdate();
      cellWidth = Math.floor(cellWidth);
      contentWidth = (function(contentWidth2, visibleColumns2) {
        const allColumnsHaveWidth = visibleColumns2.every(((column2) => column2.width));
        if (allColumnsHaveWidth) {
          const totalPercent = visibleColumns2.reduce(((sum, column2) => {
            if (isPercentWidth2(column2.width)) {
              sum += parseFloat(column2.width);
            }
            return sum;
          }), 0);
          if (totalPercent > 100) {
            contentWidth2 = contentWidth2 / totalPercent * 100;
          }
        }
        return contentWidth2;
      })(contentWidth, visibleColumns);
      setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
      if (isNextColumnMode) {
        nextCellWidth = Math.floor(nextCellWidth);
        setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
      } else {
        const columnWidths = this._columnHeadersView.getColumnWidths();
        columnWidths[resizingInfo.currentColumnIndex] = cellWidth;
        const hasScroll = columnWidths.reduce(((totalWidth, width) => totalWidth + width), 0) > this._rowsView.contentWidth();
        if (!hasScroll) {
          const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns);
          if (lastColumnIndex >= 0) {
            columnsController.columnOption(visibleColumns[lastColumnIndex].index, "visibleWidth", "auto");
          }
        }
        for (let i = 0; i < columnWidths.length; i++) {
          if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
            columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i]);
          }
        }
      }
      columnsController.endUpdate();
      if (!isNextColumnMode) {
        this.component.updateDimensions();
        const scrollable = this.component.getScrollable();
        if (scrollable && isRtlParentStyle) {
          const left = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - this._scrollRight;
          scrollable.scrollTo({
            left
          });
        }
      }
    }
    return needUpdate;
  }
  _subscribeToCallback(callback, handler) {
    callback.add(handler);
    this._subscribesToCallbacks.push({
      callback,
      handler
    });
  }
  _unsubscribeFromCallbacks() {
    for (let i = 0; i < this._subscribesToCallbacks.length; i++) {
      const subscribe = this._subscribesToCallbacks[i];
      subscribe.callback.remove(subscribe.handler);
    }
    this._subscribesToCallbacks = [];
  }
  _unsubscribes() {
    this._unsubscribeFromEvents();
    this._unsubscribeFromCallbacks();
  }
  _init() {
    const generatePointsByColumnsHandler = () => {
      if (!this._isResizing) {
        this.pointsByColumns(null);
      }
    };
    const generatePointsByColumnsScrollHandler = (offset) => {
      if (this._scrollLeft !== offset.left) {
        this._scrollLeft = offset.left;
        this.pointsByColumns(null);
      }
    };
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._trackerView = this.getView("trackerView");
    this._rowsView = this.getView("rowsView");
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._editorFactoryController = this.getController("editorFactory");
    this._draggingHeaderView = this.component.getView("draggingHeaderView");
    this._$parentContainer = this.component.$element();
    this._subscribeToCallback(this._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnsSeparatorView.renderCompleted, (() => {
      this._unsubscribeFromEvents();
      this._subscribeToEvents();
    }));
    this._subscribeToCallback(this._rowsView.renderCompleted, (() => {
      this._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
      this._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler);
    }));
    let previousScrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
    let previousTableHeight = 0;
    this._subscribeToCallback(this._tablePositionController.positionChanged, ((e) => {
      if (this._isResizing && !this._rowsView.isResizing) {
        const scrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
        if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
          previousScrollbarVisibility = scrollbarVisibility;
          previousTableHeight = e.height;
          this.component.updateDimensions();
        } else {
          this._rowsView.updateFreeSpaceRowHeight();
        }
      }
      previousTableHeight = e.height;
    }));
  }
  isResizing() {
    return this._isResizing;
  }
  pointsByColumns(value2) {
    if (void 0 !== value2) {
      this._pointsByColumns = value2;
    } else {
      if (!this._pointsByColumns) {
        this._generatePointsByColumns();
      }
      return this._pointsByColumns;
    }
  }
};
var TablePositionViewController = class extends m_modules_default.ViewController {
  constructor(component) {
    super(component);
    this.positionChanged = callbacks_default();
  }
  init() {
    super.init();
    this._columnsResizerController = this.getController("columnsResizer");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._pagerView = this.getView("pagerView");
    this._rowsView.resizeCompleted.add((() => {
      if (this.option("allowColumnResizing")) {
        const targetPoint = this._columnsResizerController._targetPoint;
        this.update(targetPoint ? targetPoint.y : null);
      }
    }));
  }
  update(top) {
    const params = {};
    const $element = this._columnHeadersView.element();
    const offset = $element && $element.offset();
    const offsetTop = offset && offset.top || 0;
    const diffOffsetTop = isDefined(top) ? Math.abs(top - offsetTop) : 0;
    const columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0;
    const scrollBarWidth = this._rowsView.getScrollbarWidth(true);
    const rowsHeight = this._rowsView ? this._rowsView.height() - scrollBarWidth : 0;
    const draggingHeaderView = this.component.getView("draggingHeaderView");
    params.height = columnsHeadersHeight;
    const isDraggingOrResizing = this._columnsResizerController.isResizing() || draggingHeaderView.isDragging();
    if (isDraggingOrResizing) {
      params.height += rowsHeight - diffOffsetTop;
    }
    if (null !== top && $element && $element.length) {
      params.top = $element[0].offsetTop + diffOffsetTop;
    }
    this.positionChanged.fire(params);
  }
};
var DraggingHeaderViewController = class extends m_modules_default.ViewController {
  init() {
    super.init();
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._draggingHeaderView = this.getView("draggingHeaderView");
    this._rowsView = this.getView("rowsView");
    this._blockSeparatorView = this.getView("blockSeparatorView");
    this._headerPanelView = this.getView("headerPanel");
    this._columnChooserView = this.getView("columnChooserView");
    const subscribeToEvents = () => {
      if (this._draggingHeaderView) {
        const draggingPanels = [this._columnChooserView, this._columnHeadersView, this._headerPanelView];
        this._unsubscribeFromEvents(this._draggingHeaderView, draggingPanels);
        this._subscribeToEvents(this._draggingHeaderView, draggingPanels);
      }
    };
    this._columnHeadersView.renderCompleted.add(subscribeToEvents);
    this._headerPanelView && this._headerPanelView.renderCompleted.add(subscribeToEvents);
    this._columnChooserView && this._columnChooserView.renderCompleted.add(subscribeToEvents);
  }
  dispose() {
    if (this._draggingHeaderView) {
      this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView]);
    }
  }
  _generatePointsByColumns(options2) {
    let needToCheckPrevPoint = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this.isCustomGroupColumnPosition = this.checkIsCustomGroupColumnPosition(options2);
    const points = m_utils_default.getPointsByColumns(options2.columnElements, ((point) => this._pointCreated(point, options2.columns, options2.targetDraggingPanel.getName(), options2.sourceColumn)), options2.isVerticalOrientation, options2.startColumnIndex, needToCheckPrevPoint);
    return points;
  }
  checkIsCustomGroupColumnPosition(options2) {
    let wasOnlyCommandColumns = true;
    for (let i = 0; i < options2.columns.length; i += 1) {
      const col = options2.columns[i];
      if ("expand" === col.command && !wasOnlyCommandColumns) {
        return true;
      }
      if (!col.command) {
        wasOnlyCommandColumns = false;
      }
    }
    return false;
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const targetColumn = columns7[point.columnIndex];
    const prevColumn = columns7[point.columnIndex - 1];
    const isColumnAfterExpandColumn = "expand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const isFirstExpandColumn = "expand" === (null === targetColumn || void 0 === targetColumn ? void 0 : targetColumn.command) && "expand" !== (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const sourceColumnReorderingDisabled = sourceColumn && !sourceColumn.allowReordering;
    const otherColumnsReorderingDisabled = !(null !== targetColumn && void 0 !== targetColumn && targetColumn.allowReordering) && !(null !== prevColumn && void 0 !== prevColumn && prevColumn.allowReordering);
    switch (location) {
      case "columnChooser":
        return true;
      case "headers":
        if (sourceColumnReorderingDisabled) {
          return true;
        }
        if (!isFirstExpandColumn) {
          return isColumnAfterExpandColumn || otherColumnsReorderingDisabled;
        }
        if (this.isCustomGroupColumnPosition) {
          return false;
        }
        while ("expand" === (null === (_columns$point$column = columns7[point.columnIndex]) || void 0 === _columns$point$column ? void 0 : _columns$point$column.command)) {
          var _columns$point$column;
          point.columnIndex += 1;
        }
        return false;
      default:
        return 0 === columns7.length;
    }
  }
  _subscribeToEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, ((_, draggingPanel) => {
      if (draggingPanel) {
        let columns7;
        const rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1;
        const nameDraggingPanel = draggingPanel.getName();
        const subscribeToEvents = function(index, columnElement) {
          if (!columnElement) {
            return;
          }
          const $columnElement = renderer_default(columnElement);
          const column = columns7[index];
          if (column && draggingPanel.allowDragging(column)) {
            $columnElement.addClass(that.addWidgetPrefix("drag-action"));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_START_EVENT, MODULE_NAMESPACE2), that.createAction(((args) => {
              const e = args.event;
              const eventData2 = eventData(e);
              draggingHeader4.dragHeader({
                deltaX: eventData2.x - renderer_default(e.currentTarget).offset().left,
                deltaY: eventData2.y - renderer_default(e.currentTarget).offset().top,
                sourceColumn: column,
                index: column.index,
                columnIndex: index,
                columnElement: $columnElement,
                sourceLocation: nameDraggingPanel,
                draggingPanels,
                rowIndex: that._columnsController.getRowIndex(column.index, true)
              });
            })));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.moveHeader));
            m_events_engine_default.on($columnElement, addNamespace(DRAG_END_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.dropHeader));
          }
        };
        for (let i = 0; i < rowCount; i++) {
          const columnElements = draggingPanel.getColumnElements(i) || [];
          if (columnElements.length) {
            columns7 = draggingPanel.getColumns(i) || [];
            each(columnElements, subscribeToEvents);
          }
        }
      }
    }));
  }
  _unsubscribeFromEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, ((_, draggingPanel) => {
      if (draggingPanel) {
        const columnElements = draggingPanel.getColumnElements() || [];
        each(columnElements, ((index, columnElement) => {
          const $columnElement = renderer_default(columnElement);
          m_events_engine_default.off($columnElement, addNamespace(DRAG_START_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace(DRAG_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace(DRAG_END_EVENT, MODULE_NAMESPACE2));
          $columnElement.removeClass(that.addWidgetPrefix("drag-action"));
        }));
      }
    }));
  }
  _getSeparator(targetLocation) {
    return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView;
  }
  hideSeparators(type2) {
    const blockSeparator = this._blockSeparatorView;
    const columnsSeparator = this._columnsSeparatorView;
    this._animationColumnIndex = void 0;
    blockSeparator && blockSeparator.hide();
    "block" !== type2 && columnsSeparator && columnsSeparator.hide();
  }
  allowDrop(parameters) {
    return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
  }
  drag(parameters) {
    const {
      sourceIndex
    } = parameters;
    const {
      sourceLocation
    } = parameters;
    const {
      sourceColumnElement
    } = parameters;
    const headersView = this._columnHeadersView;
    const rowsView18 = this._rowsView;
    if (sourceColumnElement) {
      sourceColumnElement.addClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      if ("headers" === sourceLocation) {
        headersView && headersView.toggleDraggableColumnClass(sourceIndex, true);
        rowsView18 && rowsView18.toggleDraggableColumnClass(sourceIndex, true);
      }
    }
  }
  dock(parameters) {
    const that = this;
    const targetColumnIndex = isObject(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex;
    const {
      sourceLocation
    } = parameters;
    const {
      targetLocation
    } = parameters;
    const separator = that._getSeparator(targetLocation);
    const hasTargetVisibleIndex = targetColumnIndex >= 0;
    that._columnHeadersView.element().find(".dx-header-row").toggleClass(that.addWidgetPrefix("drop-highlight"), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
    if (separator) {
      if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
        if ("group" === targetLocation || "columnChooser" === targetLocation) {
          !(function() {
            if (that._animationColumnIndex !== targetColumnIndex) {
              that.hideSeparators();
              separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
              that._animationColumnIndex = targetColumnIndex;
              separator.show(targetLocation);
            }
          })();
        } else {
          that.hideSeparators("block");
          that._tablePositionController.update(parameters.posY);
          separator.moveByX(parameters.posX - separator.width());
          separator.show();
        }
      } else {
        that.hideSeparators();
      }
    }
  }
  drop(parameters) {
    const {
      sourceColumnElement
    } = parameters;
    if (sourceColumnElement) {
      sourceColumnElement.removeClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      this._columnHeadersView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._rowsView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._columnHeadersView.element().find(".dx-header-row").removeClass(this.addWidgetPrefix("drop-highlight"));
    }
    if (this.allowDrop(parameters)) {
      const separator = this._getSeparator(parameters.targetLocation);
      if (separator) {
        separator.hide();
      }
      this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
    }
  }
};
var rowsView9 = (Base) => class extends Base {
  _needUpdateRowHeight(itemCount) {
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const isResizing = this._columnsResizerController.isResizing();
    return super._needUpdateRowHeight.apply(this, arguments) || itemCount > 0 && !!wordWrapEnabled && !!isResizing;
  }
};
var editorFactory = (Base) => class extends Base {
  renderFocusOverlay() {
    if (this._columnsResizerController.isResizing()) {
      return;
    }
    return super.renderFocusOverlay.apply(this, arguments);
  }
};
var columnsResizingReorderingModule = {
  views: {
    columnsSeparatorView: ColumnsSeparatorView,
    blockSeparatorView: BlockSeparatorView,
    draggingHeaderView: DraggingHeaderView,
    trackerView: TrackerView
  },
  controllers: {
    draggingHeader: DraggingHeaderViewController,
    tablePosition: TablePositionViewController,
    columnsResizer: ColumnsResizerViewController
  },
  extenders: {
    views: {
      rowsView: rowsView9
    },
    controllers: {
      editorFactory
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/columns_resizing_reordering.js
var DraggingHeaderView2 = columnsResizingReorderingModule.views.draggingHeaderView;
var DraggingHeaderViewController2 = columnsResizingReorderingModule.controllers.draggingHeader;
var ColumnsSeparatorView2 = columnsResizingReorderingModule.views.columnsSeparatorView;
var TablePositionViewController2 = columnsResizingReorderingModule.controllers.tablePosition;
var ColumnsResizerViewController2 = columnsResizingReorderingModule.controllers.columnsResizer;
var TrackerView2 = columnsResizingReorderingModule.views.trackerView;
m_core_default.registerModule("columnsResizingReordering", columnsResizingReorderingModule);

// node_modules/devextreme/esm/__internal/utils/memoize.js
var compareByReference = (args, lastArgs) => args.length === lastArgs.length && !Object.keys(args).some(((key) => args[key] !== lastArgs[key]));
var compareByValue = (args, lastArgs) => equalByValue(args, lastArgs, {
  maxDepth: 4
});
var createCacheFunc = (firstArgs, firstResult, originFunc, compareFunc) => {
  let lastArgs = firstArgs;
  let lastResult = firstResult;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const argsEquals = compareFunc(args, lastArgs);
    if (argsEquals) {
      return lastResult;
    }
    lastArgs = args;
    lastResult = originFunc(...lastArgs);
    return lastResult;
  };
};
var MEMOIZE_DEFAULT_OPTIONS = {
  compareType: "reference"
};
var memoize = function(func) {
  let {
    compareType
  } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : MEMOIZE_DEFAULT_OPTIONS;
  let cachedFunc = null;
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (!cachedFunc) {
      const firstResult = func(...args);
      cachedFunc = createCacheFunc(args, firstResult, func, "reference" === compareType ? compareByReference : compareByValue);
      return firstResult;
    }
    return cachedFunc(...args);
  };
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/const.js
var ATTRIBUTES = {
  ariaColIndex: "aria-colindex",
  dragCell: "dx-drag-cell"
};
var ROWS_VIEW_CLASS = "rowsview";
var TABLE_CLASS = "table";
var EDIT_FORM_CLASS2 = "edit-form";
var DATA_ROW_CLASS2 = "dx-data-row";
var GROUP_ROW_CLASS = "dx-group-row";
var HEADER_ROW_CLASS = "dx-header-row";
var EDIT_FORM_ITEM_CLASS2 = "edit-form-item";
var MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
var FREESPACE_ROW_CLASS = "dx-freespace-row";
var VIRTUAL_ROW_CLASS = "dx-virtual-row";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var DROPDOWN_EDITOR_OVERLAY_CLASS2 = "dx-dropdowneditor-overlay";
var COMMAND_EXPAND_CLASS2 = "dx-command-expand";
var ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive";
var ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text";
var COMMAND_SELECT_CLASS = "dx-command-select";
var COMMAND_EDIT_CLASS2 = "dx-command-edit";
var COMMAND_CELL_SELECTOR = "[class^=dx-command]";
var CELL_FOCUS_DISABLED_CLASS2 = "dx-cell-focus-disabled";
var DATEBOX_WIDGET_NAME = "dxDateBox";
var FOCUS_STATE_CLASS2 = "dx-state-focused";
var WIDGET_CLASS4 = "dx-widget";
var REVERT_BUTTON_CLASS = "dx-revert-button";
var FOCUSED_CLASS = "dx-focused";
var FAST_EDITING_DELETE_KEY = "delete";
var INTERACTIVE_ELEMENTS_SELECTOR = '\n  input:not([type="hidden"]):not([disabled]),\n  textarea:not([disabled]),\n  a:not([disabled]),\n  select:not([disabled]),\n  button:not([disabled]),\n  [tabindex]:not([disabled]),\n  .dx-checkbox:not([disabled],.dx-state-readonly)\n';
var NON_FOCUSABLE_ELEMENTS_SELECTOR = `${INTERACTIVE_ELEMENTS_SELECTOR}, .dx-dropdowneditor-icon`;
var FOCUS_TYPE_ROW = "row";
var FOCUS_TYPE_CELL = "cell";
var COLUMN_HEADERS_VIEW = "columnHeadersView";
var ROWS_VIEW = "rowsView";
var FUNCTIONAL_KEYS = ["shift", "control", "alt"];

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/dom.js
var isDragCell = ($cell) => void 0 !== $cell.attr(ATTRIBUTES.dragCell);
var getFocusableCellSelector = (columnIndex) => [`[${ATTRIBUTES.ariaColIndex}="${columnIndex + 1}"]`, `:not([${ATTRIBUTES.dragCell}])`, ":not([aria-hidden=true])"].join("");
var getCellToFocus = ($cellElements, columnIndex) => $cellElements.filter(getFocusableCellSelector(columnIndex)).first();
var GridCoreKeyboardNavigationDom = {
  isDragCell,
  getCellToFocus
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_utils.js
function isGroupRow2($row) {
  return $row && $row.hasClass(GROUP_ROW_CLASS);
}
function isGroupFooterRow($row) {
  return $row && $row.hasClass("dx-datagrid-group-footer");
}
function isDetailRow2($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS);
}
function isAdaptiveItem($element) {
  return $element && $element.hasClass(ADAPTIVE_ITEM_TEXT_CLASS);
}
function isEditRow($row) {
  return null === $row || void 0 === $row ? void 0 : $row.hasClass(EDIT_ROW);
}
function isEditForm($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS) && $row.hasClass(EDIT_FORM_CLASS2);
}
function isDataRow($row) {
  return $row && $row.hasClass(DATA_ROW_CLASS2);
}
function isNotFocusedRow($row) {
  return !$row || $row.hasClass(FREESPACE_ROW_CLASS) || $row.hasClass(VIRTUAL_ROW_CLASS);
}
function isEditorCell(that, $cell) {
  return !that._isRowEditMode() && $cell && !$cell.hasClass(COMMAND_SELECT_CLASS) && $cell.hasClass(EDITOR_CELL_CLASS);
}
function isElementDefined($element) {
  return isDefined($element) && $element.length > 0;
}
function isMobile() {
  return "desktop" !== devices_default.current().deviceType;
}
function isCellInHeaderRow($cell) {
  return !!$cell.parent(`.${HEADER_ROW_CLASS}`).length;
}
function isFixedColumnIndexOffsetRequired(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (rtlEnabled) {
    return !("right" === column.fixedPosition || isDefined(column.command) && !isDefined(column.fixedPosition));
  }
  return !(!isDefined(column.fixedPosition) || "left" === column.fixedPosition);
}
function shouldPreventScroll(that) {
  const keyboardController = that.getController("keyboardNavigation");
  return keyboardController._isVirtualScrolling() ? that.option("focusedRowIndex") === keyboardController.getRowIndex() : false;
}
function getInteractiveElements($cell) {
  return $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
}
function getInteractiveElement($cell, isLast) {
  const $focusedElement = getInteractiveElements($cell);
  return isLast ? $focusedElement.last() : $focusedElement.first();
}

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/scrollable_a11y.js
var keyboardNavigationScrollableA11yExtender = (Base) => class extends Base {
  rowsViewFocusHandler(event) {
    const $target = renderer_default(event.target);
    this.translateFocusIfNeed(event, $target);
    super.rowsViewFocusHandler(event);
  }
  rowsViewFocusOutHandler() {
    super.rowsViewFocusOutHandler();
    this.makeScrollableFocusableIfNeed();
  }
  translateFocusIfNeed(event, $target) {
    const needTranslateFocus = this.isScrollableNeedFocusable();
    const isFirstCellFixed = this._isFixedColumn(0);
    if (!needTranslateFocus || !isFirstCellFixed) {
      return;
    }
    const $firstCell = this._rowsView.getCell({
      rowIndex: 0,
      columnIndex: 0
    });
    const firstCellHasTabIndex = !!$firstCell.attr("tabindex");
    const notFixedCellIsTarget = $target.is(this._$firstNotFixedCell);
    if (firstCellHasTabIndex && notFixedCellIsTarget) {
      event.preventDefault();
      this._focus($firstCell);
    }
  }
  rowsViewRenderCompleted(e) {
    this._$firstNotFixedCell = this.getFirstNotFixedCell();
    this.makeScrollableFocusableIfNeed();
    super.rowsViewRenderCompleted(e);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    super._focus($cell, disableFocus, skipFocusEvent);
    this.makeScrollableFocusableIfNeed();
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isOriginalHandlerRequired = !isCellPositionDefined || !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isNeedFocusable = this.isScrollableNeedFocusable();
    if (isOriginalHandlerRequired && isNeedFocusable) {
      var _this$_$firstNotFixed;
      null === (_this$_$firstNotFixed = this._$firstNotFixedCell) || void 0 === _this$_$firstNotFixed || _this$_$firstNotFixed.removeAttr("tabIndex");
    }
    super._tabKeyHandler(eventArgs, isEditing);
  }
  getFirstNotFixedCell() {
    var _this$_editingControl;
    const columns7 = this._columnsController.getVisibleColumns();
    const columnIndex = columns7.findIndex(((_ref) => {
      let {
        fixed
      } = _ref;
      return !fixed;
    }));
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    return -1 === columnIndex || isEditing ? void 0 : this._rowsView._getCellElement(0, columnIndex);
  }
  isScrollableNeedFocusable() {
    var _this$_rowsView$_fixe, _this$_rowsView$getCe;
    const hasScrollable = !!this._rowsView.getScrollable();
    const hasFixedTable = !!(null !== (_this$_rowsView$_fixe = this._rowsView._fixedTableElement) && void 0 !== _this$_rowsView$_fixe && _this$_rowsView$_fixe.length);
    const isCellsRendered = !!(null !== (_this$_rowsView$getCe = this._rowsView.getCellElements(0)) && void 0 !== _this$_rowsView$getCe && _this$_rowsView$getCe.length);
    return hasScrollable && hasFixedTable && isCellsRendered;
  }
  makeScrollableFocusableIfNeed() {
    const needFocusable = this.isScrollableNeedFocusable();
    if (!needFocusable || !this._$firstNotFixedCell) {
      return;
    }
    this._applyTabIndexToElement(this._$firstNotFixedCell);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation.js
var KeyboardNavigationController = class extends m_modules_default.ViewController {
  init() {
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._editingController = this.getController("editing");
    this._headerPanel = this.getView("headerPanel");
    this._rowsView = this.getView("rowsView");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._columnsController = this.getController("columns");
    this._editorFactory = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnResizerController = this.getController("columnsResizer");
    this._memoFireFocusedCellChanged = memoize(this._memoFireFocusedCellChanged.bind(this), {
      compareType: "value"
    });
    this._memoFireFocusedRowChanged = memoize(this._memoFireFocusedRowChanged.bind(this), {
      compareType: "value"
    });
    this.focusedHandlerWithContext = this.focusedHandlerWithContext || this.focusedHandler.bind(this);
    this.columnHeadersViewRenderCompletedWithContext = this.columnHeadersViewRenderCompletedWithContext || this.columnHeadersViewRenderCompleted.bind(this);
    this.rowsViewRenderCompletedWithContext = this.rowsViewRenderCompletedWithContext || this.rowsViewRenderCompleted.bind(this);
    this.rowsViewFocusHandlerContext = this.rowsViewFocusHandlerContext || this.rowsViewFocusHandler.bind(this);
    this.rowsViewFocusOutHandlerContext = this.rowsViewFocusOutHandlerContext ?? this.rowsViewFocusOutHandler.bind(this);
    this._updateFocusTimeout = null;
    this._fastEditingStarted = false;
    this._focusedCellPosition = {};
    this._canceledCellPosition = null;
    if (this.isKeyboardEnabled()) {
      var _this$_editorFactory;
      subscribeVisibilityChange();
      null === (_this$_editorFactory = this._editorFactory) || void 0 === _this$_editorFactory || _this$_editorFactory.focused.add(this.focusedHandlerWithContext);
      this.createAction("onKeyDown");
    } else {
      var _this$_editorFactory2;
      unsubscribeVisibilityChange();
      null === (_this$_editorFactory2 = this._editorFactory) || void 0 === _this$_editorFactory2 || _this$_editorFactory2.focused.remove(this.focusedHandlerWithContext);
    }
    this.initColumnHeadersViewHandler();
    this.initRowsViewHandlers();
    this.initDocumentHandlers();
  }
  dispose() {
    super.dispose();
    this._resetFocusedView();
    keyboard.off(this._rowsViewKeyDownListener);
    keyboard.off(this._columnHeadersViewKeyDownListener);
    m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    clearTimeout(this._updateFocusTimeout);
    unsubscribeVisibilityChange();
  }
  focusedHandler($element) {
    this.setupFocusedView();
    if (this._isNeedScroll) {
      if ($element.is(":visible") && this._focusedView && this._focusedView.getScrollable()) {
        this._focusedView._scrollToElement($element);
        this._isNeedScroll = false;
      }
    }
  }
  rowsViewFocusHandler(event) {
    const $element = renderer_default(event.target);
    const isRelatedTargetInRowsView = renderer_default(event.relatedTarget).closest(this._rowsView.element()).length;
    const isLink = $element.is("a");
    if (event.relatedTarget && isLink && !isRelatedTargetInRowsView && this._isEventInCurrentGrid(event)) {
      let $focusedCell = this._getFocusedCell();
      $focusedCell = !isElementDefined($focusedCell) ? this._rowsView.getCellElements(0).filter("[tabindex]").eq(0) : $focusedCell;
      if (!$element.closest($focusedCell).length) {
        event.preventDefault();
        m_events_engine_default.trigger($focusedCell, "focus");
      }
    }
    const isCell = $element.is("td");
    const needSetFocusPosition = (this.option("focusedRowIndex") ?? -1) < 0;
    if (isCell && needSetFocusPosition) {
      this._updateFocusedCellPosition($element);
    }
  }
  rowsViewFocusOutHandler() {
    this._toggleInertAttr(false);
  }
  subscribeToRowsViewFocusEvent() {
    var _this$_rowsView;
    const $rowsView = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.element();
    m_events_engine_default.on($rowsView, "focusin", this.rowsViewFocusHandlerContext);
    m_events_engine_default.on($rowsView, "focusout", this.rowsViewFocusOutHandlerContext);
  }
  unsubscribeFromRowsViewFocusEvent() {
    var _this$_rowsView2;
    const $rowsView = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.element();
    m_events_engine_default.off($rowsView, "focusin", this.rowsViewFocusHandlerContext);
    m_events_engine_default.off($rowsView, "focusout", this.rowsViewFocusOutHandlerContext);
  }
  columnHeadersViewRenderCompleted() {
    this.initColumnHeadersViewKeyDownHandler();
  }
  rowsViewRenderCompleted(e) {
    const $rowsView = this._rowsView.element();
    const isFullUpdate = !e || "refresh" === e.changeType;
    const isFocusedViewCorrect = this._focusedView && this._focusedView.name === this._rowsView.name;
    let needUpdateFocus = false;
    const isAppend = e && ("append" === e.changeType || "prepend" === e.changeType);
    const root = renderer_default(dom_adapter_default.getRootNode($rowsView.get && $rowsView.get(0)));
    const $focusedElement = root.find(":focus");
    const isFocusedElementCorrect = this._isFocusedElementCorrect($focusedElement, $rowsView, e);
    this.unsubscribeFromRowsViewFocusEvent();
    this.subscribeToRowsViewFocusEvent();
    this.initPointerEventHandler();
    this.initRowsViewKeyDownHandler();
    this._setRowsViewAttributes();
    if (isFocusedViewCorrect && isFocusedElementCorrect) {
      needUpdateFocus = this._isNeedFocus ? !isAppend : this._isHiddenFocus && isFullUpdate && !(null !== e && void 0 !== e && e.virtualColumnsScrolling);
      if (needUpdateFocus) {
        var _e$event;
        const isScrollEvent = !!(null !== e && void 0 !== e && null !== (_e$event = e.event) && void 0 !== _e$event && _e$event.type);
        const skipFocusEvent = (null === e || void 0 === e ? void 0 : e.virtualColumnsScrolling) && isScrollEvent;
        this._updateFocus(true, skipFocusEvent);
      }
    }
  }
  _isFocusedElementCorrect($focusedElement, $rowsView, e) {
    if ($focusedElement.length && !$focusedElement.closest($rowsView).length) {
      return false;
    }
    if (!$focusedElement.length && null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_focusedCellPos;
      const focusedColumnIndex = (null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex) ?? -1;
      return this._isColumnRendered(focusedColumnIndex);
    }
    return true;
  }
  initColumnHeadersViewHandler() {
    var _this$_columnHeadersV;
    this.unsubscribeFromColumnHeadersViewKeyDownEvent();
    null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV || null === (_this$_columnHeadersV = _this$_columnHeadersV.renderCompleted) || void 0 === _this$_columnHeadersV || _this$_columnHeadersV.remove(this.columnHeadersViewRenderCompletedWithContext);
    if (this.isKeyboardEnabled()) {
      var _this$_columnHeadersV2;
      null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 || null === (_this$_columnHeadersV2 = _this$_columnHeadersV2.renderCompleted) || void 0 === _this$_columnHeadersV2 || _this$_columnHeadersV2.add(this.columnHeadersViewRenderCompletedWithContext);
    }
  }
  initRowsViewHandlers() {
    var _this$_rowsView3;
    this.unsubscribeFromRowsViewFocusEvent();
    this.unsubscribeFromPointerEvent();
    this.unsubscribeFromRowsViewKeyDownEvent();
    null === (_this$_rowsView3 = this._rowsView) || void 0 === _this$_rowsView3 || null === (_this$_rowsView3 = _this$_rowsView3.renderCompleted) || void 0 === _this$_rowsView3 || _this$_rowsView3.remove(this.rowsViewRenderCompletedWithContext);
    if (this.isKeyboardEnabled()) {
      this._rowsView.renderCompleted.add(this.rowsViewRenderCompletedWithContext);
    }
  }
  initDocumentHandlers() {
    const document2 = dom_adapter_default.getDocument();
    this._documentClickHandler = this._documentClickHandler || this.createAction(((e) => {
      var _this$_columnResizerC;
      const $target = renderer_default(e.event.target);
      const tableSelector = `.${this.addWidgetPrefix(TABLE_CLASS)}`;
      const rowsViewSelector = `.${this.addWidgetPrefix(ROWS_VIEW_CLASS)}`;
      const editorOverlaySelector = `.${DROPDOWN_EDITOR_OVERLAY_CLASS2}`;
      const needKeepFocus = !!$target.closest(tableSelector).length && !isElementInDom($target);
      if (needKeepFocus) {
        e.event.preventDefault();
        return;
      }
      const isRowsViewClick = this._isEventInCurrentGrid(e.event) && !!$target.closest(rowsViewSelector).length;
      const isEditorOverlayClick = !!$target.closest(editorOverlaySelector).length;
      const isColumnResizing = !!(null !== (_this$_columnResizerC = this._columnResizerController) && void 0 !== _this$_columnResizerC && _this$_columnResizerC.isResizing());
      if (!isRowsViewClick && !isEditorOverlayClick && !isColumnResizing) {
        const isClickOutsideFocusedView = this._focusedView ? 0 === $target.closest(this._focusedView.element()).length : true;
        if (isClickOutsideFocusedView) {
          this._resetFocusedCell(true);
        }
        this._resetFocusedView();
      }
    }));
    m_events_engine_default.off(document2, addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    if (this.isKeyboardEnabled()) {
      m_events_engine_default.on(document2, addNamespace(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    }
  }
  _setRowsViewAttributes() {
    const $rowsView = this._getRowsViewElement();
    const isGridEmpty = !this._dataController.getVisibleRows().length;
    if (isGridEmpty) {
      this._applyTabIndexToElement($rowsView);
    }
  }
  unsubscribeFromPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    this._pointerEventAction && m_events_engine_default.off($rowsView, addNamespace(pointerEventName, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
  }
  subscribeToPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    const clickSelector = `.${ROW_CLASS} > td, .${ROW_CLASS}`;
    m_events_engine_default.on($rowsView, addNamespace(pointerEventName, "dxDataGridKeyboardNavigation"), clickSelector, this._pointerEventAction);
  }
  initPointerEventHandler() {
    this._pointerEventAction = this._pointerEventAction || this.createAction(this._pointerEventHandler);
    this.unsubscribeFromPointerEvent();
    this.subscribeToPointerEvent();
  }
  unsubscribeFromColumnHeadersViewKeyDownEvent() {
    if (this._columnHeadersViewKeyDownListener) {
      keyboard.off(this._columnHeadersViewKeyDownListener);
    }
  }
  subscribeToColumnHeadersViewKeyDownEvent() {
    const $columnHeadersView = this._columnHeadersView.element();
    this._columnHeadersViewKeyDownListener = keyboard.on($columnHeadersView, null, ((e) => this._columnHeadersViewKeyDownHandler(e)));
  }
  initColumnHeadersViewKeyDownHandler() {
    this.unsubscribeFromColumnHeadersViewKeyDownEvent();
    this.subscribeToColumnHeadersViewKeyDownEvent();
  }
  unsubscribeFromRowsViewKeyDownEvent() {
    keyboard.off(this._rowsViewKeyDownListener);
  }
  subscribeToRowsViewKeyDownEvent() {
    const $rowsView = this._getRowsViewElement();
    this._rowsViewKeyDownListener = keyboard.on($rowsView, null, ((e) => this._rowsViewKeyDownHandler(e)));
  }
  initRowsViewKeyDownHandler() {
    this._rowsViewKeyDownListener && this.unsubscribeFromRowsViewKeyDownEvent();
    this.subscribeToRowsViewKeyDownEvent();
  }
  optionChanged(args) {
    switch (args.name) {
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this.init();
        }
        args.handled = true;
        break;
      case "useLegacyKeyboardNavigation":
        this.init();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  isRowFocusType() {
    return this.focusType === FOCUS_TYPE_ROW;
  }
  isCellFocusType() {
    return this.focusType === FOCUS_TYPE_CELL;
  }
  setRowFocusType() {
    if (this.option("focusedRowEnabled")) {
      this.focusType = FOCUS_TYPE_ROW;
    }
  }
  setCellFocusType() {
    this.focusType = FOCUS_TYPE_CELL;
  }
  headerTabKeyHandler(e) {
  }
  _columnHeadersViewKeyDownHandler(e) {
    if ("tab" === e.keyName) {
      this.headerTabKeyHandler(e);
    }
  }
  _rowsViewKeyDownHandler(e) {
    var _this$_editingControl;
    let needStopPropagation = true;
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    let isHandled = this._processOnKeyDown(e);
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    const {
      originalEvent
    } = e;
    if (originalEvent.isDefaultPrevented()) {
      this._isNeedFocus = false;
      this._isNeedScroll = false;
      return;
    }
    !FUNCTIONAL_KEYS.includes(e.keyName) && this._updateFocusedCellPositionByTarget(originalEvent.target);
    if (!isHandled) {
      switch (e.keyName) {
        case "leftArrow":
        case "rightArrow":
          this._leftRightKeysHandler(e, isEditing);
          isHandled = true;
          break;
        case "upArrow":
        case "downArrow":
          if (e.ctrl) {
            selectView("rowsView", this, originalEvent);
          } else {
            this._upDownKeysHandler(e, isEditing);
          }
          isHandled = true;
          break;
        case "pageUp":
        case "pageDown":
          this._pageUpDownKeyHandler(e);
          isHandled = true;
          break;
        case "space":
          isHandled = this._spaceKeyHandler(e, isEditing);
          break;
        case "A":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlAKeyHandler(e, isEditing);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "tab":
          this._tabKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "enter":
          this._enterKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "escape":
          isHandled = this._escapeKeyHandler(e, isEditing);
          break;
        case "F":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlFKeyHandler(e);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "F2":
          this._f2KeyHandler();
          isHandled = true;
          break;
        case "del":
        case "backspace":
          if (this._isFastEditingAllowed() && !this._isFastEditingStarted()) {
            isHandled = this._beginFastEditing(originalEvent, true);
          }
      }
      if (!isHandled && !this._beginFastEditing(originalEvent)) {
        this._isNeedFocus = false;
        this._isNeedScroll = false;
        needStopPropagation = false;
      }
      if (needStopPropagation) {
        originalEvent.stopPropagation();
      }
    }
  }
  _processOnKeyDown(eventArgs) {
    const {
      originalEvent
    } = eventArgs;
    const args = {
      handled: false,
      event: originalEvent
    };
    this.executeAction("onKeyDown", args);
    eventArgs.ctrl = originalEvent.ctrlKey;
    eventArgs.alt = originalEvent.altKey;
    eventArgs.shift = originalEvent.shiftKey;
    return !!args.handled;
  }
  _closeEditCell() {
    const d = Deferred();
    setTimeout((() => {
      this._editingController.closeEditCell().always(d.resolve);
    }));
    return d;
  }
  _leftRightKeysHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $event = eventArgs.originalEvent;
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    const directionCode = this._getDirectionCodeByKey(eventArgs.keyName);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const allowNavigate = (!isEditing || isEditingNavigationMode) && isDataRow($row);
    if (allowNavigate) {
      this.setCellFocusType();
      isEditingNavigationMode && this._closeEditCell();
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(directionCode);
      }
      const $cell = this._getNextCell(directionCode);
      if (isElementDefined($cell)) {
        this._arrowKeysHandlerFocusCell($event, $cell, directionCode);
      }
      $event && $event.preventDefault();
    }
  }
  isInsideMasterDetail($target) {
    const $masterDetail = $target.closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    return !!$masterDetail.get(0) && this.elementIsInsideGrid($masterDetail) && !$target.is($masterDetail);
  }
  _upDownKeysHandler(eventArgs, isEditing) {
    var _this$_editingControl2, _this$_editingControl3;
    const visibleRowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(visibleRowIndex);
    const $event = eventArgs.originalEvent;
    const isUpArrow = "upArrow" === eventArgs.keyName;
    const dataSource = this._dataController.dataSource();
    const isRowEditingInCurrentRow = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isEditRowByIndex) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2, visibleRowIndex);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const isInsideMasterDetail = this.isInsideMasterDetail(renderer_default(null === $event || void 0 === $event ? void 0 : $event.target));
    const allowNavigate = (!isRowEditingInCurrentRow || !isEditing || isEditingNavigationMode) && $row && !isEditForm($row) && !isInsideMasterDetail;
    if (allowNavigate) {
      isEditingNavigationMode && this._closeEditCell();
      if (!this._navigateNextCell($event, eventArgs.keyName)) {
        if (this._isVirtualRowRender() && isUpArrow && dataSource && !dataSource.isLoading()) {
          const rowHeight = getOuterHeight($row);
          const rowIndex = this._focusedCellPosition.rowIndex - 1;
          this._scrollBy(0, -rowHeight, rowIndex, $event);
        }
      }
      $event && $event.preventDefault();
    }
  }
  _pageUpDownKeyHandler(eventArgs) {
    const pageIndex = this._dataController.pageIndex();
    const pageCount = this._dataController.pageCount();
    const pagingEnabled = this.option("paging.enabled");
    const isPageUp = "pageUp" === eventArgs.keyName;
    const pageStep = isPageUp ? -1 : 1;
    const scrollable = this._rowsView.getScrollable();
    if (pagingEnabled && !this._isVirtualScrolling()) {
      if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
        this._dataController.pageIndex(pageIndex + pageStep);
        eventArgs.originalEvent.preventDefault();
      }
    } else if (scrollable && getHeight(scrollable.container()) < getHeight(scrollable.$content())) {
      this._scrollBy(0, getHeight(scrollable.container()) * pageStep);
      eventArgs.originalEvent.preventDefault();
    }
  }
  _spaceKeyHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $target = renderer_default(eventArgs.originalEvent && eventArgs.originalEvent.target);
    if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing) {
      const isFocusedRowElement = "row" === this._getElementType($target) && this.isRowFocusType() && isDataRow($target);
      const isFocusedSelectionCell = $target.hasClass(COMMAND_SELECT_CLASS);
      if (isFocusedSelectionCell && "onClick" === this.option("selection.showCheckBoxesMode")) {
        this._selectionController.startSelectionWithCheckboxes();
      }
      if (isFocusedRowElement || $target.parent().hasClass(DATA_ROW_CLASS2) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._selectionController.changeItemSelection(rowIndex, {
          shift: eventArgs.shift,
          control: eventArgs.ctrl
        });
        eventArgs.originalEvent.preventDefault();
        return true;
      }
      return false;
    }
    return this._beginFastEditing(eventArgs.originalEvent);
  }
  _ctrlAKeyHandler(eventArgs, isEditing) {
    if (!isEditing && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
      this._selectionController.selectAll();
      eventArgs.originalEvent.preventDefault();
    }
  }
  _toggleInertAttr(value2) {
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const editingOptions = this.option("editing");
    const direction = eventArgs.shift ? "previous" : "next";
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isFirstValidCell = eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isLastValidCell = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition);
    let isOriginalHandlerRequired = !isCellPositionDefined || isFirstValidCell || isLastValidCell;
    const eventTarget = eventArgs.originalEvent.target;
    const focusedViewElement = this._focusedView && this._focusedView.element();
    if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
      return;
    }
    renderer_default(focusedViewElement).addClass(FOCUS_STATE_CLASS2);
    if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
      if (renderer_default(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._resetFocusedCell();
      }
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(direction);
      }
      if (isEditing) {
        if (!this._editingCellTabHandler(eventArgs, direction)) {
          return;
        }
      } else if (this._targetCellTabHandler(eventArgs, direction)) {
        isOriginalHandlerRequired = true;
      }
    }
    if (isOriginalHandlerRequired) {
      const $cell = this._getFocusedCell();
      const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
      if (isLastValidCell && !isCommandCell) {
        this._toggleInertAttr(true);
      }
      this._editorFactory.loseFocus();
      if (this._editingController.isEditing() && !this._isRowEditMode()) {
        this._resetFocusedCell(true);
        this._resetFocusedView();
        this._closeEditCell();
      }
    } else {
      eventArgs.originalEvent.preventDefault();
    }
  }
  _getMaxHorizontalOffset() {
    const scrollable = this.component.getScrollable();
    return scrollable ? scrollable.scrollWidth() - getWidth(this._rowsView.element()) : 0;
  }
  _isColumnRendered(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const renderedVisibleColumns = this._columnsController.getVisibleColumns();
    const column = allVisibleColumns[columnIndex];
    let result2 = false;
    if (column) {
      result2 = renderedVisibleColumns.indexOf(column) >= 0;
    }
    return result2;
  }
  _isFixedColumn(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const column = allVisibleColumns[columnIndex];
    return !!column && !!column.fixed;
  }
  _isColumnVirtual(columnIndex) {
    const localColumnIndex = columnIndex - this._columnsController.getColumnIndexOffset();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const column = visibleColumns[localColumnIndex];
    return !!column && "virtual" === column.command;
  }
  _processVirtualHorizontalPosition(direction) {
    const scrollable = this.component.getScrollable();
    const columnIndex = this.getColumnIndex();
    let nextColumnIndex;
    let horizontalScrollPosition = 0;
    let needToScroll = false;
    switch (direction) {
      case "next":
      case "nextInRow": {
        const columnsCount = this._getVisibleColumnCount();
        nextColumnIndex = columnIndex + 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0;
        if ("next" === direction) {
          needToScroll = columnsCount === nextColumnIndex || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = columnsCount > nextColumnIndex && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
        break;
      }
      case "previous":
      case "previousInRow":
        nextColumnIndex = columnIndex - 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset();
        if ("previous" === direction) {
          const columnIndexOffset = this._columnsController.getColumnIndexOffset();
          const leftEdgePosition = nextColumnIndex < 0 && 0 === columnIndexOffset;
          needToScroll = leftEdgePosition || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = nextColumnIndex >= 0 && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
    }
    if (needToScroll) {
      scrollable.scrollTo({
        left: horizontalScrollPosition
      });
    } else if (isDefined(nextColumnIndex) && isDefined(direction) && this._isColumnVirtual(nextColumnIndex)) {
      horizontalScrollPosition = this._getHorizontalScrollPositionOffset(direction);
      0 !== horizontalScrollPosition && scrollable.scrollBy({
        left: horizontalScrollPosition,
        top: 0
      });
    }
  }
  _getHorizontalScrollPositionOffset(direction) {
    let positionOffset = 0;
    const $currentCell = this._getCell(this._focusedCellPosition);
    const currentCellWidth = $currentCell && getOuterWidth($currentCell);
    if (currentCellWidth > 0) {
      const rtlMultiplier = this.option("rtlEnabled") ? -1 : 1;
      positionOffset = "nextInRow" === direction || "next" === direction ? currentCellWidth * rtlMultiplier : currentCellWidth * rtlMultiplier * -1;
    }
    return positionOffset;
  }
  _editingCellTabHandler(eventArgs, direction) {
    const eventTarget = eventArgs.originalEvent.target;
    const $targetCell = this._getCellElementFromTarget(eventTarget);
    const isCommandCell = $targetCell.is(COMMAND_CELL_SELECTOR);
    if (this.isOriginalTabHandlerRequired($targetCell, eventArgs)) {
      return false;
    }
    if (isCommandCell) {
      return !this._targetCellTabHandler(eventArgs, direction);
    }
    this._updateFocusedCellPosition($targetCell);
    const elementType = this._getElementType(eventTarget);
    const nextCellInfo = this._getNextCellByTabKey(eventArgs.originalEvent, direction, elementType);
    const $nextCell = nextCellInfo.$cell;
    if (!$nextCell || this._handleTabKeyOnMasterDetailCell($nextCell, direction)) {
      return false;
    }
    let isEditingAllowed = false;
    const column = this._getColumnByCellElement($nextCell);
    if (null !== column && void 0 !== column && column.allowEditing) {
      const $row = $nextCell.parent();
      const rowIndex = this._getLocalRowIndex($row);
      const row = this._dataController.items()[rowIndex];
      const isDataRow2 = !row || "data" === row.rowType;
      isEditingAllowed = this._editingController.allowUpdating({
        row
      }) ? isDataRow2 : null === row || void 0 === row ? void 0 : row.isNewRow;
    }
    if (!isEditingAllowed) {
      this._closeEditCell();
    }
    const nextCellFocused = this._focusCell($nextCell, !nextCellInfo.isHighlighted);
    if (nextCellFocused) {
      const isRowMode = this._isRowEditMode();
      if (!isRowMode && isEditingAllowed) {
        this._editFocusedCell();
      } else {
        this._focusInteractiveElement($nextCell, eventArgs.shift);
      }
    }
    return true;
  }
  isOriginalTabHandlerRequired($cell, event) {
    const eventTarget = event.originalEvent.target;
    const elementType = this._getElementType(eventTarget);
    const $lastInteractiveElement = getInteractiveElement($cell, !event.shift);
    if ("cell" !== elementType || 0 === $lastInteractiveElement.length) {
      return false;
    }
    return eventTarget !== $lastInteractiveElement.get(0);
  }
  _targetCellTabHandler(eventArgs, direction) {
    const $event = eventArgs.originalEvent;
    let eventTarget = $event.target;
    let elementType = this._getElementType(eventTarget);
    let $cell = this._getCellElementFromTarget(eventTarget);
    if (!isEditorCell(this, $cell) && this.isOriginalTabHandlerRequired($cell, eventArgs)) {
      return true;
    }
    if (void 0 === this._focusedCellPosition.rowIndex && renderer_default(eventTarget).hasClass(ROW_CLASS)) {
      this._updateFocusedCellPosition($cell);
    }
    if (this.isRowFocusType()) {
      this.setCellFocusType();
      if ("row" === elementType && isDataRow(renderer_default(eventTarget))) {
        eventTarget = this.getFirstValidCellInRow(renderer_default(eventTarget));
        elementType = this._getElementType(eventTarget);
      }
    }
    const nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
    $cell = nextCellInfo.$cell;
    if (!$cell) {
      return false;
    }
    $cell = this._checkNewLineTransition($event, $cell);
    if (!$cell) {
      return false;
    }
    this._focusCell($cell, !nextCellInfo.isHighlighted);
    if (!isEditorCell(this, $cell)) {
      this._focusInteractiveElement($cell, eventArgs.shift);
    }
    return false;
  }
  _getNextCellByTabKey($event, direction, elementType) {
    let $cell = this._getNextCell(direction, elementType);
    const args = $cell && this._fireFocusedCellChanging($event, $cell, true);
    if (!args || args.cancel) {
      return {};
    }
    if (args.$newCellElement) {
      $cell = args.$newCellElement;
    }
    return {
      $cell,
      isHighlighted: args.isHighlighted
    };
  }
  _checkNewLineTransition($event, $cell) {
    const rowIndex = this.getVisibleRowIndex();
    const $row = $cell.parent();
    if (rowIndex !== this._getRowIndex($row)) {
      const cellPosition = this._getCellPosition($cell);
      const args = this._fireFocusedRowChanging($event, $row);
      if (args.cancel) {
        return;
      }
      if (args.rowIndexChanged && cellPosition) {
        this.setFocusedColumnIndex(cellPosition.columnIndex);
        $cell = this._getFocusedCell();
      }
    }
    return $cell;
  }
  _enterKeyHandler(eventArgs, isEditing) {
    var _this$_focusedView, _this$getMasterDetail;
    const rowIndex = this.getVisibleRowIndex();
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const $row = null === (_this$_focusedView = this._focusedView) || void 0 === _this$_focusedView ? void 0 : _this$_focusedView.getRow(rowIndex);
    const $cell = this._getFocusedCell();
    const needExpandGroupRow = this.option("grouping.allowCollapsing") && isGroupRow2($row);
    const needExpandMasterDetailRow = this.option("masterDetail.enabled") && (null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(COMMAND_EXPAND_CLASS2));
    const needExpandAdaptiveRow = null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(ADAPTIVE_COLUMN_NAME_CLASS);
    if (needExpandGroupRow || needExpandMasterDetailRow) {
      const item = this._dataController.items()[rowIndex];
      const isNotContinuation = (null === item || void 0 === item ? void 0 : item.data) && !item.data.isContinuation;
      if (isDefined(key) && isNotContinuation) {
        this._dataController.changeRowExpand(key);
      }
    } else if (needExpandAdaptiveRow) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key);
      this._updateFocusedCellPosition($cell);
    } else if (null !== (_this$getMasterDetail = this.getMasterDetailCell($cell)) && void 0 !== _this$getMasterDetail && _this$getMasterDetail.is($cell)) {
      if ($cell.is(":focus")) {
        this.focusFirstInteractiveElementInside($cell);
      }
    } else if (!(null !== $cell && void 0 !== $cell && $cell.hasClass(COMMAND_EDIT_CLASS2))) {
      this._processEnterKeyForDataCell(eventArgs, isEditing);
    }
  }
  focusFirstInteractiveElementInside($el) {
    $el.find(INTERACTIVE_ELEMENTS_SELECTOR).get(0).focus();
  }
  _processEnterKeyForDataCell(eventArgs, isEditing) {
    const direction = this._getEnterKeyDirection(eventArgs);
    const allowEditingOnEnterKey = this._allowEditingOnEnterKey();
    if (isEditing || !allowEditingOnEnterKey && direction) {
      this._handleEnterKeyEditingCell(eventArgs.originalEvent).done((() => {
        if ("next" === direction || "previous" === direction) {
          this._targetCellTabHandler(eventArgs, direction);
        } else if ("upArrow" === direction || "downArrow" === direction) {
          this._navigateNextCell(eventArgs.originalEvent, direction);
        }
      }));
    } else if (allowEditingOnEnterKey) {
      this._startEditing(eventArgs);
    }
  }
  _getEnterKeyDirection(eventArgs) {
    const enterKeyDirection = this.option("keyboardNavigation.enterKeyDirection");
    const isShift = eventArgs.shift;
    if ("column" === enterKeyDirection) {
      return isShift ? "upArrow" : "downArrow";
    }
    if ("row" === enterKeyDirection) {
      return isShift ? "previous" : "next";
    }
    return;
  }
  _handleEnterKeyEditingCell(event) {
    const d = Deferred();
    const {
      target
    } = event;
    const $cell = this._getCellElementFromTarget(target);
    const isRowEditMode = this._isRowEditMode();
    this._updateFocusedCellPosition($cell);
    if (isRowEditMode) {
      this._focusEditFormCell($cell);
      setTimeout(this._editingController.saveEditData.bind(this._editingController));
      d.resolve();
    } else {
      m_events_engine_default.trigger(renderer_default(target), "change");
      this._closeEditCell().always(d.resolve);
      event.preventDefault();
    }
    return d;
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    const $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
    if (isEditing) {
      this._updateFocusedCellPosition($cell);
      if (!this._isRowEditMode()) {
        if ("cell" === this._editingController.getEditMode()) {
          this._editingController.cancelEditData();
        } else {
          this._closeEditCell();
        }
      } else {
        this._focusEditFormCell($cell);
        this._editingController.cancelEditData();
        if (0 === this._dataController.items().length) {
          this._resetFocusedCell();
          this._editorFactory.loseFocus();
        }
      }
      eventArgs.originalEvent.preventDefault();
      return true;
    }
    const masterDetailCell = this.getMasterDetailCell($cell);
    if (masterDetailCell) {
      this._focusCell(masterDetailCell);
      return true;
    }
    return false;
  }
  _ctrlFKeyHandler(eventArgs) {
    if (this.option("searchPanel.visible")) {
      const searchTextEditor = this._headerPanel.getSearchTextEditor();
      if (searchTextEditor) {
        searchTextEditor.focus();
        eventArgs.originalEvent.preventDefault();
      }
    }
  }
  _f2KeyHandler() {
    const isEditing = this._editingController.isEditing();
    const rowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    if (!isEditing && isDataRow($row)) {
      this._startEditing();
    }
  }
  _navigateNextCell($event, keyCode) {
    const $cell = this._getNextCell(keyCode);
    const directionCode = this._getDirectionCodeByKey(keyCode);
    const isCellValid = $cell && this._isCellValid($cell);
    const result2 = isCellValid ? this._arrowKeysHandlerFocusCell($event, $cell, directionCode) : false;
    return result2;
  }
  _arrowKeysHandlerFocusCell($event, $nextCell, direction) {
    const isVerticalDirection = "prevRow" === direction || "nextRow" === direction;
    const args = this._fireFocusChangingEvents($event, $nextCell, isVerticalDirection, true);
    $nextCell = args.$newCellElement;
    if (!args.cancel && this._isCellValid($nextCell)) {
      this._focus($nextCell, !args.isHighlighted);
      return true;
    }
    return false;
  }
  _beginFastEditing(originalEvent, isDeleting) {
    if (!this._isFastEditingAllowed() || originalEvent.altKey || originalEvent.ctrlKey || this._editingController.isEditing()) {
      return false;
    }
    if (isDeleting) {
      this._startEditing(originalEvent, FAST_EDITING_DELETE_KEY);
    } else {
      const {
        key
      } = originalEvent;
      const keyCode = originalEvent.keyCode || originalEvent.which;
      const fastEditingKey = key || keyCode && String.fromCharCode(keyCode);
      if (fastEditingKey && (1 === fastEditingKey.length || fastEditingKey === FAST_EDITING_DELETE_KEY)) {
        this._startEditing(originalEvent, fastEditingKey);
      }
    }
    return true;
  }
  _pointerEventHandler(e) {
    var _this$_rowsView4;
    const event = e.event || e;
    let $target = renderer_default(event.currentTarget);
    const focusedViewElement = null === (_this$_rowsView4 = this._rowsView) || void 0 === _this$_rowsView4 ? void 0 : _this$_rowsView4.element();
    const $parent = $target.parent();
    const isInteractiveElement = renderer_default(event.target).is(INTERACTIVE_ELEMENTS_SELECTOR);
    const isRevertButton = !!renderer_default(event.target).closest(`.${REVERT_BUTTON_CLASS}`).length;
    const isExpandCommandCell = $target.hasClass(COMMAND_EXPAND_CLASS2);
    if (!this._isEventInCurrentGrid(event)) {
      return;
    }
    if (!isRevertButton && (this._isCellValid($target, !isInteractiveElement) || isExpandCommandCell)) {
      $target = this._isInsideEditForm($target) ? renderer_default(event.target) : $target;
      this._focusView();
      renderer_default(focusedViewElement).removeClass(FOCUS_STATE_CLASS2);
      if ($parent.hasClass(FREESPACE_ROW_CLASS)) {
        this._updateFocusedCellPosition($target);
        this._applyTabIndexToElement(this._focusedView.element());
        this._focusedView.focus(true);
      } else if (!this.getMasterDetailCell($target)) {
        this._clickTargetCellHandler(event, $target);
      } else {
        this._updateFocusedCellPosition($target);
      }
    } else if ($target.is("td")) {
      this._resetFocusedCell();
    }
  }
  _clickTargetCellHandler(event, $cell) {
    const column = this._getColumnByCellElement($cell);
    const isCellEditMode = this._isCellEditMode();
    const isEditing = this._editingController.isEditing();
    this.setCellFocusType();
    const args = this._fireFocusChangingEvents(event, $cell, true);
    $cell = args.$newCellElement;
    if (!args.cancel) {
      if (args.resetFocusedRow) {
        this._focusController._resetFocusedRow();
        return;
      }
      if (args.rowIndexChanged) {
        $cell = this._getFocusedCell();
      }
      if (!args.isHighlighted && !isCellEditMode) {
        this.setRowFocusType();
      }
      this._updateFocusedCellPosition($cell);
      if (this._allowRowUpdating() && isCellEditMode && column && column.allowEditing) {
        this._isNeedFocus = false;
        this._isHiddenFocus = false;
      } else {
        $cell = this._getFocusedCell();
        const $target = event && renderer_default(event.target).closest(`${NON_FOCUSABLE_ELEMENTS_SELECTOR}, td`);
        const skipFocusEvent = $target && $target.not($cell).is(NON_FOCUSABLE_ELEMENTS_SELECTOR);
        const isEditCell = !(null !== column && void 0 !== column && column.command) && isEditing && $cell.hasClass(EDITOR_CELL_CLASS);
        const isDisabled = !isEditCell && (!args.isHighlighted || skipFocusEvent);
        this._focus($cell, isDisabled, skipFocusEvent);
      }
    } else {
      this.setRowFocusType();
      this.setFocusedRowIndex(args.prevRowIndex);
      if (isEditing && isCellEditMode) {
        this._closeEditCell();
      }
    }
  }
  _allowRowUpdating() {
    const rowIndex = this.getVisibleRowIndex();
    const row = this._dataController.items()[rowIndex];
    return this._editingController.allowUpdating({
      row
    }, "click");
  }
  focus(element) {
    let activeElementSelector;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const isHighlighted = this._isCellElement(renderer_default(element));
    if (!element) {
      activeElementSelector = `.${this.addWidgetPrefix(ROWS_VIEW_CLASS)} .dx-row[tabindex]`;
      if (!focusedRowEnabled) {
        activeElementSelector += `, .${this.addWidgetPrefix(ROWS_VIEW_CLASS)} .dx-row > td[tabindex]`;
      }
      element = this.component.$element().find(activeElementSelector).first();
    }
    element && this._focusElement(renderer_default(element), isHighlighted);
  }
  getFocusedView() {
    return this._focusedView;
  }
  setupFocusedView() {
    if (this.isKeyboardEnabled() && !isDefined(this._focusedView)) {
      this._focusView();
    }
  }
  _focusElement($element, isHighlighted) {
    const rowsViewElement = renderer_default(this._getRowsViewElement());
    const $focusedView = $element.closest(rowsViewElement);
    const isRowFocusType = this.isRowFocusType();
    let args = {};
    if (!$focusedView.length || this._isCellElement($element) && !this._isCellValid($element)) {
      return;
    }
    this._focusView();
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    if (this._isCellElement($element) || isGroupRow2($element)) {
      this.setCellFocusType();
      args = this._fireFocusChangingEvents(null, $element, true, isHighlighted);
      $element = args.$newCellElement;
      if (isRowFocusType && !args.isHighlighted) {
        this.setRowFocusType();
      }
    }
    if (!args.cancel) {
      this._focus($element, !args.isHighlighted);
      if ("row" !== this._getElementType($element) || isEditRow($element)) {
        this._focusInteractiveElement($element);
      }
    }
  }
  _getFocusedViewByElement($element) {
    const view = this.getFocusedView();
    const $view = view && renderer_default(view.element());
    return $element && 0 !== $element.closest($view).length;
  }
  _focusView() {
    this._focusedView = this._rowsView;
  }
  _resetFocusedView() {
    this.setRowFocusType();
    this._focusedView = null;
  }
  _focusInteractiveElement($cell, isLast) {
    if (!$cell) {
      return;
    }
    const $focusedElement = getInteractiveElement($cell, isLast);
    m_utils_default.focusAndSelectElement(this, $focusedElement);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    const $row = $cell && !$cell.hasClass(ROW_CLASS) ? $cell.closest(`.${ROW_CLASS}`) : $cell;
    if ($row && isNotFocusedRow($row)) {
      return;
    }
    const focusedView = this._focusedView;
    const $focusViewElement = focusedView && focusedView.element();
    let $focusElement;
    this._isHiddenFocus = disableFocus;
    const isRowFocus = isGroupRow2($row) || isGroupFooterRow($row) || this.isRowFocusType();
    if (isRowFocus) {
      $focusElement = $row;
      if (focusedView) {
        this.setFocusedRowIndex(this._getRowIndex($row));
      }
    } else if (this._isCellElement($cell)) {
      $focusElement = $cell;
      this._updateFocusedCellPosition($cell);
    }
    if ($focusElement) {
      if ($focusViewElement) {
        $focusViewElement.find(".dx-row[tabindex], .dx-row > td[tabindex]").filter(((i, node) => m_utils_default.isElementInCurrentGrid(this, renderer_default(node)))).not($focusElement).removeClass(CELL_FOCUS_DISABLED_CLASS2).removeClass(FOCUSED_CLASS).removeAttr("tabindex");
      }
      m_events_engine_default.one($focusElement, "blur", ((e) => {
        if (e.relatedTarget) {
          $focusElement.removeClass(CELL_FOCUS_DISABLED_CLASS2).removeClass(FOCUSED_CLASS);
        }
      }));
      if (!skipFocusEvent) {
        this._applyTabIndexToElement($focusElement);
        m_events_engine_default.trigger($focusElement, "focus");
      }
      if (disableFocus) {
        $focusElement.addClass(CELL_FOCUS_DISABLED_CLASS2);
        if (isRowFocus) {
          $cell.addClass(CELL_FOCUS_DISABLED_CLASS2);
        }
      } else {
        this._editorFactory.focus($focusElement);
      }
    }
  }
  _updateFocus(isRenderView) {
    let skipFocusEvent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this._updateFocusTimeout = setTimeout((() => {
      if (this._needFocusEditingCell()) {
        this._editingController._focusEditingCell();
        return;
      }
      let $cell = this._getFocusedCell();
      const isEditing = this._editingController.isEditing();
      if (!this.getMasterDetailCell($cell) || this._isRowEditMode()) {
        if (this._hasSkipRow($cell.parent())) {
          const direction = this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
          $cell = this._getNextCell(direction);
        }
        if (isElementDefined($cell)) {
          if ($cell.is("td") || $cell.hasClass(this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2))) {
            const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
            const $focusedElementInsideCell = $cell.find(":focus");
            const isFocusedElementDefined = isElementDefined($focusedElementInsideCell);
            const column = this._getColumnByCellElement($cell);
            if ((isRenderView || !isCommandCell) && this._editorFactory.focus()) {
              if (isCommandCell && isFocusedElementDefined) {
                m_utils_default.focusAndSelectElement(this, $focusedElementInsideCell);
                return;
              }
              !isFocusedElementDefined && this._focus($cell, false, skipFocusEvent);
            } else if (!isFocusedElementDefined && (this._isNeedFocus || this._isHiddenFocus)) {
              this._focus($cell, this._isHiddenFocus, skipFocusEvent);
            }
            if (isEditing && !(null !== column && void 0 !== column && column.showEditorAlways)) {
              this._focusInteractiveElement.bind(this)($cell);
            }
          } else {
            m_events_engine_default.trigger($cell, "focus");
          }
        }
      }
    }));
  }
  _getColumnByCellElement($cell) {
    const cellIndex = this._rowsView.getCellIndex($cell);
    const columnIndex = cellIndex + this._columnsController.getColumnIndexOffset();
    return this._columnsController.getVisibleColumns(null, true)[columnIndex];
  }
  _needFocusEditingCell() {
    const isCellEditMode = this._editingController.getEditMode() === EDIT_MODE_CELL;
    const isBatchEditMode = this._editingController.getEditMode() === EDIT_MODE_BATCH;
    const cellEditModeHasChanges = isCellEditMode && this._editingController.hasChanges();
    const isNewRowBatchEditMode = isBatchEditMode && this._editingController.isNewRowInEditMode();
    const $cell = this._getFocusedCell();
    return (0 === $cell.children().length || $cell.find(FOCUSABLE_ELEMENT_SELECTOR).length > 0) && (cellEditModeHasChanges || isNewRowBatchEditMode);
  }
  _getFocusedCell() {
    return renderer_default(this._getCell(this._focusedCellPosition));
  }
  _updateFocusedCellPositionByTarget(target) {
    var _this$_focusedCellPos2;
    const elementType = this._getElementType(target);
    if ("row" === elementType && isDefined(null === (_this$_focusedCellPos2 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos2 ? void 0 : _this$_focusedCellPos2.columnIndex)) {
      const $row = renderer_default(target);
      this._focusedView && isGroupRow2($row) && this.setFocusedRowIndex(this._getRowIndex($row));
    } else {
      this._updateFocusedCellPosition(this._getCellElementFromTarget(target));
    }
  }
  _updateFocusedCellPosition($cell, direction) {
    const position2 = this._getCellPosition($cell, direction);
    if (position2) {
      if (!$cell.length || position2.rowIndex >= 0 && position2.columnIndex >= 0) {
        this.setFocusedCellPosition(position2.rowIndex, position2.columnIndex);
      }
    }
    return position2;
  }
  _getFocusedColumnIndexOffset(columnIndex) {
    let offset = 0;
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    if (column && column.fixed) {
      offset = this._getFixedColumnIndexOffset(column);
    } else if (columnIndex >= 0) {
      offset = this._columnsController.getColumnIndexOffset();
    }
    return offset;
  }
  _getFixedColumnIndexOffset(column) {
    const offset = isFixedColumnIndexOffsetRequired(this, column) ? this._getVisibleColumnCount() - this._columnsController.getVisibleColumns().length : 0;
    return offset;
  }
  _getCellPosition($cell, direction) {
    let columnIndex;
    const $row = isElementDefined($cell) && $cell.closest("tr");
    if (isElementDefined($row)) {
      const rowIndex = this._getRowIndex($row);
      columnIndex = this._rowsView.getCellIndex($cell, rowIndex);
      columnIndex += this._getFocusedColumnIndexOffset(columnIndex);
      if (direction) {
        columnIndex = "previous" === direction ? columnIndex - 1 : columnIndex + 1;
        columnIndex = this._applyColumnIndexBoundaries(columnIndex);
      }
      return {
        rowIndex,
        columnIndex
      };
    }
    return;
  }
  _focusCell($cell, isDisabled) {
    if (this._isCellValid($cell)) {
      this._focus($cell, isDisabled);
      return true;
    }
    return;
  }
  _focusEditFormCell($cell) {
    if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS)) {
      this._editorFactory.focus($cell, true);
    }
  }
  _resetFocusedCell(preventScroll) {
    var _this$_focusedView2;
    const $cell = this._getFocusedCell();
    isElementDefined($cell) && $cell.removeAttr("tabindex").removeClass(CELL_FOCUS_DISABLED_CLASS2);
    this._isNeedFocus = false;
    this._isNeedScroll = false;
    this._focusedCellPosition = {};
    clearTimeout(this._updateFocusTimeout);
    null === (_this$_focusedView2 = this._focusedView) || void 0 === _this$_focusedView2 || _this$_focusedView2.renderFocusState({
      preventScroll
    });
  }
  restoreFocusableElement(rowIndex, $event) {
    const that = this;
    let args;
    let $rowElement;
    const isUpArrow = isDefined(rowIndex);
    const $rowsViewElement = this._rowsView.element();
    const {
      columnIndex
    } = that._focusedCellPosition;
    const rowIndexOffset = that._dataController.getRowIndexOffset();
    rowIndex = isUpArrow ? rowIndex : this._rowsView.getTopVisibleItemIndex() + rowIndexOffset;
    if (!isUpArrow) {
      that._editorFactory.loseFocus();
      that._applyTabIndexToElement($rowsViewElement);
      m_events_engine_default.trigger($rowsViewElement, "focus");
    } else {
      $rowElement = this._rowsView.getRow(rowIndex - rowIndexOffset);
      args = that._fireFocusedRowChanging($event, $rowElement);
      if (!args.cancel && args.rowIndexChanged) {
        rowIndex = args.newRowIndex;
      }
    }
    if (!isUpArrow || !args.cancel) {
      that.setFocusedCellPosition(rowIndex, columnIndex);
    }
    isUpArrow && that._updateFocus();
  }
  _getNewPositionByCode(cellPosition, elementType, code) {
    let {
      columnIndex
    } = cellPosition;
    let {
      rowIndex
    } = cellPosition;
    let visibleColumnsCount;
    if (void 0 === cellPosition.rowIndex && "next" === code) {
      return {
        columnIndex: 0,
        rowIndex: 0
      };
    }
    switch (code) {
      case "nextInRow":
      case "next":
        visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < visibleColumnsCount - 1 && "row" !== elementType && this._hasValidCellAfterPosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex++;
        } else if (!this._isLastRow(rowIndex) && "next" === code) {
          columnIndex = 0;
          rowIndex++;
        }
        break;
      case "previousInRow":
      case "previous":
        if (columnIndex > 0 && "row" !== elementType && this._hasValidCellBeforePosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex--;
        } else if (rowIndex > 0 && "previous" === code) {
          rowIndex--;
          visibleColumnsCount = this._getVisibleColumnCount();
          columnIndex = visibleColumnsCount - 1;
        }
        break;
      case "upArrow":
        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
        break;
      case "downArrow":
        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
    }
    return {
      columnIndex,
      rowIndex
    };
  }
  setFocusedCellPosition(rowIndex, columnIndex) {
    this.setFocusedRowIndex(rowIndex);
    this.setFocusedColumnIndex(columnIndex);
  }
  setFocusedRowIndex(rowIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.rowIndex = rowIndex;
  }
  setFocusedColumnIndex(columnIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.columnIndex = columnIndex;
  }
  getRowIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1;
  }
  getColumnIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1;
  }
  getVisibleRowIndex() {
    var _this$_focusedCellPos3;
    const rowIndex = null === (_this$_focusedCellPos3 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos3 ? void 0 : _this$_focusedCellPos3.rowIndex;
    return !isDefined(rowIndex) || rowIndex < 0 ? -1 : rowIndex - this._dataController.getRowIndexOffset();
  }
  getVisibleColumnIndex() {
    var _this$_focusedCellPos4;
    const columnIndex = null === (_this$_focusedCellPos4 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos4 ? void 0 : _this$_focusedCellPos4.columnIndex;
    return !isDefined(columnIndex) ? -1 : columnIndex - this._columnsController.getColumnIndexOffset();
  }
  _applyColumnIndexBoundaries(columnIndex) {
    const visibleColumnsCount = this._getVisibleColumnCount();
    if (columnIndex < 0) {
      columnIndex = 0;
    } else if (columnIndex >= visibleColumnsCount) {
      columnIndex = visibleColumnsCount - 1;
    }
    return columnIndex;
  }
  _isCellByPositionValid(cellPosition) {
    const $cell = renderer_default(this._getCell(cellPosition));
    return this._isCellValid($cell);
  }
  _isLastRow(rowIndex) {
    const dataController2 = this._dataController;
    if (this._isVirtualRowRender()) {
      return rowIndex >= dataController2.getMaxRowIndex();
    }
    const lastVisibleIndex = Math.max(...dataController2.items().map(((item, index) => false !== item.visible ? index : -1)));
    return rowIndex === lastVisibleIndex;
  }
  _isFirstValidCell(cellPosition) {
    let isFirstValidCell = false;
    if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
      isFirstValidCell = isFirstValidCell || !this._hasValidCellBeforePosition(cellPosition);
    }
    return isFirstValidCell;
  }
  _hasValidCellBeforePosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    while (columnIndex > 0 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: --columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _hasValidCellAfterPosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    const visibleColumnCount = this._getVisibleColumnCount();
    while (columnIndex < visibleColumnCount - 1 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: ++columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _isLastValidCell(cellPosition) {
    const nextColumnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex + 1 : 0;
    const {
      rowIndex
    } = cellPosition;
    const checkingPosition = {
      columnIndex: nextColumnIndex,
      rowIndex
    };
    const visibleRows = this._dataController.getVisibleRows();
    const row = visibleRows && visibleRows[rowIndex];
    const isLastRow = this._isLastRow(rowIndex);
    if (!isLastRow) {
      return false;
    }
    const isFullRowFocus = "group" === (null === row || void 0 === row ? void 0 : row.rowType) || "groupFooter" === (null === row || void 0 === row ? void 0 : row.rowType);
    if (isFullRowFocus && cellPosition.columnIndex > 0) {
      return true;
    }
    if (cellPosition.columnIndex === this._getVisibleColumnCount() - 1) {
      return true;
    }
    if (this._isCellByPositionValid(checkingPosition)) {
      return false;
    }
    return this._isLastValidCell(checkingPosition);
  }
  _isCellValid($cell, isClick) {
    if (isElementDefined($cell)) {
      const $row = $cell.parent();
      const columnIndex = this._rowsView.getCellIndex($cell) + this._columnsController.getColumnIndexOffset();
      const column = this._getColumnByCellElement($cell);
      const visibleColumnCount = this._getVisibleColumnCount();
      const editingController = this._editingController;
      const isMasterDetailRow = isDetailRow2($row);
      const isShowWhenGrouped = column && column.showWhenGrouped;
      const isDataCell = column && !$cell.hasClass(COMMAND_EXPAND_CLASS2) && isDataRow($row);
      const isValidGroupSpaceColumn = function() {
        return !isMasterDetailRow && column && (!isDefined(column.groupIndex) || isShowWhenGrouped && isDataCell) || parseInt($cell.attr("colspan"), 10) > 1;
      };
      const isDragCell2 = GridCoreKeyboardNavigationDom.isDragCell($cell);
      if (isDragCell2) {
        return false;
      }
      if (this.getMasterDetailCell($cell)) {
        return true;
      }
      if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
        const rowItems = this._dataController.items();
        const visibleRowIndex = this._rowsView.getRowIndex($row);
        const row = rowItems[visibleRowIndex];
        const isCellEditing = editingController && this._isCellEditMode() && editingController.isEditing();
        const isRowEditingInCurrentRow = editingController && editingController.isEditRow(visibleRowIndex);
        const isEditing = isRowEditingInCurrentRow || isCellEditing;
        if (column.command) {
          if (this._isLegacyNavigation()) {
            return !isEditing && "expand" === column.command;
          }
          if (isCellEditing) {
            return false;
          }
          if (isRowEditingInCurrentRow) {
            return "select" !== column.command;
          }
          return !isEditing;
        }
        if (isCellEditing && row && "data" !== row.rowType) {
          return false;
        }
        return !isEditing || column.allowEditing || isClick;
      }
    }
  }
  getFirstValidCellInRow($row, columnIndex) {
    const that = this;
    const $cells = $row.find("> td");
    let $cell;
    let $result;
    columnIndex = columnIndex || 0;
    for (let i = columnIndex; i < $cells.length; ++i) {
      $cell = $cells.eq(i);
      if (that._isCellValid($cell)) {
        $result = $cell;
        break;
      }
    }
    return $result;
  }
  _getNextCell(keyCode, elementType, cellPosition) {
    const focusedCellPosition = cellPosition || this._focusedCellPosition;
    const isRowFocusType = this.isRowFocusType();
    const includeCommandCells = isRowFocusType || ["next", "previous"].includes(keyCode);
    let $cell;
    let $row;
    if (this._focusedView && focusedCellPosition) {
      const newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
      $cell = renderer_default(this._getCell(newFocusedCellPosition));
      const isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(newFocusedCellPosition) : this._isLastValidCell(newFocusedCellPosition);
      if (isElementDefined($cell) && !this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
        if (isRowFocusType) {
          $cell = this.getFirstValidCellInRow($cell.parent(), newFocusedCellPosition.columnIndex);
        } else {
          $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
        }
      }
      $row = isElementDefined($cell) && $cell.parent();
      if (this._hasSkipRow($row)) {
        const rowIndex = this._getRowIndex($row);
        if (!this._isLastRow(rowIndex)) {
          $cell = this._getNextCell(keyCode, "row", {
            columnIndex: focusedCellPosition.columnIndex,
            rowIndex
          });
        } else {
          return null;
        }
      }
      return isElementDefined($cell) ? $cell : null;
    }
    return null;
  }
  _startEditing(eventArgs, fastEditingKey) {
    const focusedCellPosition = this._focusedCellPosition;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleColumnIndex = this.getVisibleColumnIndex();
    const row = this._dataController.items()[visibleRowIndex];
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (this._isAllowEditing(row, column)) {
      if (this._isRowEditMode()) {
        this._editingController.editRow(visibleRowIndex);
      } else if (focusedCellPosition) {
        this._startEditCell(eventArgs, fastEditingKey);
      }
    }
  }
  _isAllowEditing(row, column) {
    return this._editingController.allowUpdating({
      row
    }) && column && column.allowEditing;
  }
  _editFocusedCell() {
    const rowIndex = this.getVisibleRowIndex();
    const colIndex = this.getVisibleColumnIndex();
    return this._editingController.editCell(rowIndex, colIndex);
  }
  _startEditCell(eventArgs, fastEditingKey) {
    this._fastEditingStarted = isDefined(fastEditingKey);
    const editResult = this._editFocusedCell();
    const isEditResultDeferred = isDeferred(editResult);
    const isFastEditingStarted = this._isFastEditingStarted();
    if (!isFastEditingStarted || !isEditResultDeferred && !editResult) {
      return;
    }
    const editorValue = isEditResultDeferred && fastEditingKey === FAST_EDITING_DELETE_KEY ? "" : fastEditingKey;
    const editResultDeferred = isEditResultDeferred ? editResult : Deferred().resolve();
    const waitTemplatesDeferred = this._rowsView.waitAsyncTemplates(true);
    when(editResultDeferred, waitTemplatesDeferred).done((() => {
      this._editingCellHandler(eventArgs, editorValue);
    }));
  }
  _editingCellHandler(eventArgs, editorValue) {
    var _$inputElement$select;
    const $input = this._getFocusedCell().find(INTERACTIVE_ELEMENTS_SELECTOR).eq(0);
    const $inputElement = $input.get(0);
    if (!$inputElement) {
      return;
    }
    const keyDownEvent = createEvent(eventArgs, {
      type: "keydown",
      target: $inputElement
    });
    const keyPressEvent = createEvent(eventArgs, {
      type: "keypress",
      target: $inputElement
    });
    const inputEvent = createEvent(eventArgs, {
      type: "input",
      target: $inputElement
    });
    if (inputEvent.originalEvent) {
      inputEvent.originalEvent = createEvent(inputEvent.originalEvent, {
        data: editorValue
      });
    }
    null === (_$inputElement$select = $inputElement.select) || void 0 === _$inputElement$select || _$inputElement$select.call($inputElement);
    m_events_engine_default.trigger($input, keyDownEvent);
    if (!keyDownEvent.isDefaultPrevented()) {
      m_events_engine_default.trigger($input, keyPressEvent);
      if (!keyPressEvent.isDefaultPrevented()) {
        const timeout = browser_default.mozilla ? 25 : 0;
        setTimeout((() => {
          const inputValue = this._getKeyPressInputValue($input, editorValue);
          $input.val(inputValue);
          const $widgetContainer = $input.closest(`.${WIDGET_CLASS4}`);
          m_events_engine_default.off($widgetContainer, "focusout");
          m_events_engine_default.one($widgetContainer, "focusout", (() => {
            m_events_engine_default.trigger($input, "change");
          }));
          m_events_engine_default.trigger($input, inputEvent);
        }), timeout);
      }
    }
  }
  _getKeyPressInputValue($input, editorValue) {
    const inputCurrentValue = $input.val();
    return "-" === editorValue && "-0" === inputCurrentValue ? "-0" : editorValue;
  }
  _fireFocusChangingEvents($event, $cell, fireRowEvent, isHighlighted) {
    let args = {};
    const cellPosition = this._getCellPosition($cell) ?? {};
    if (this.isCellFocusType()) {
      args = this._fireFocusedCellChanging($event, $cell, isHighlighted);
      if (!args.cancel) {
        cellPosition.columnIndex = args.newColumnIndex;
        cellPosition.rowIndex = args.newRowIndex;
        isHighlighted = args.isHighlighted;
        $cell = renderer_default(this._getCell(cellPosition));
      }
    }
    if (!args.cancel && fireRowEvent && $cell) {
      args = this._fireFocusedRowChanging($event, $cell.parent());
      if (!args.cancel) {
        cellPosition.rowIndex = args.newRowIndex;
        args.isHighlighted = isHighlighted;
      }
    }
    args.$newCellElement = renderer_default(this._getCell(cellPosition));
    if (!args.$newCellElement.length) {
      args.$newCellElement = $cell;
    }
    return args;
  }
  _fireFocusedCellChanging($event, $cellElement, isHighlighted) {
    const prevColumnIndex = this.option("focusedColumnIndex");
    const prevRowIndex = this.option("focusedRowIndex");
    const cellPosition = this._getCellPosition($cellElement);
    const columnIndex = cellPosition ? cellPosition.columnIndex : -1;
    const rowIndex = cellPosition ? cellPosition.rowIndex : -1;
    const visibleRows = this._dataController.getVisibleRows();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const args = {
      cellElement: $cellElement,
      prevColumnIndex,
      prevRowIndex,
      newColumnIndex: columnIndex,
      newRowIndex: rowIndex,
      rows: visibleRows,
      columns: visibleColumns,
      event: $event,
      isHighlighted: isHighlighted || false,
      cancel: false
    };
    this._canceledCellPosition = null;
    this.executeAction("onFocusedCellChanging", args);
    if (args.newColumnIndex !== columnIndex || args.newRowIndex !== rowIndex) {
      args.$newCellElement = renderer_default(this._getCell({
        columnIndex: args.newColumnIndex,
        rowIndex: args.newRowIndex
      }));
    }
    if (args.cancel) {
      this._canceledCellPosition = {
        rowIndex,
        columnIndex
      };
    }
    return args;
  }
  _fireFocusedCellChanged($cell) {
    const columnIndex = this._rowsView.getCellIndex($cell);
    const rowOptions = null === $cell || void 0 === $cell ? void 0 : $cell.parent().data("options");
    const focusedRowKey = null === rowOptions || void 0 === rowOptions ? void 0 : rowOptions.key;
    this._memoFireFocusedCellChanged(focusedRowKey, columnIndex);
  }
  _memoFireFocusedCellChanged(rowKey, columnIndex) {
    const $cell = this._getFocusedCell();
    const $row = null === $cell || void 0 === $cell ? void 0 : $cell.parent();
    const rowIndex = this.getRowIndex();
    const localRowIndex = Math.min(this._getLocalRowIndex($row), this._dataController.items().length - 1);
    const isEditingCell2 = this._editingController.isEditCell(localRowIndex, columnIndex);
    if (isEditingCell2) {
      return;
    }
    const row = this._dataController.items()[localRowIndex];
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    this.executeAction("onFocusedCellChanged", {
      cellElement: $cell ? getPublicElement($cell) : void 0,
      columnIndex,
      rowIndex,
      row,
      column
    });
  }
  _fireFocusedRowChanging(eventArgs, $newFocusedRow) {
    const newRowIndex = this._getRowIndex($newFocusedRow);
    const prevFocusedRowIndex = this.option("focusedRowIndex");
    const loadingOperationTypes = this._dataController.loadingOperationTypes();
    const args = {
      rowElement: $newFocusedRow,
      prevRowIndex: prevFocusedRowIndex,
      newRowIndex,
      event: eventArgs,
      rows: this._dataController.getVisibleRows(),
      cancel: false
    };
    const loadingOperations = loadingOperationTypes.sorting || loadingOperationTypes.grouping || loadingOperationTypes.filtering || loadingOperationTypes.paging;
    if (!this._dataController || this._dataController.isLoading() && loadingOperations) {
      args.cancel = true;
      return args;
    }
    if (this.option("focusedRowEnabled")) {
      this.executeAction("onFocusedRowChanging", args);
      if (!args.cancel && args.newRowIndex !== newRowIndex) {
        args.resetFocusedRow = args.newRowIndex < 0;
        if (!args.resetFocusedRow) {
          this.setFocusedRowIndex(args.newRowIndex);
        }
        args.rowIndexChanged = true;
      }
    }
    return args;
  }
  _fireFocusedRowChanged() {
    var _this$_focusControlle;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const focusedRowKey = this.option("focusedRowKey");
    const focusedRowIndex = null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.getFocusedRowIndexByKey(focusedRowKey);
    if (!focusedRowEnabled || isDefined(focusedRowKey) && focusedRowIndex < 0) {
      return;
    }
    this._memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex);
  }
  _memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex) {
    const localRowIndex = focusedRowIndex - this._dataController.getRowIndexOffset();
    this.executeAction("onFocusedRowChanged", {
      rowElement: focusedRowIndex < 0 ? void 0 : this._rowsView.getRowElement(localRowIndex),
      rowIndex: focusedRowIndex,
      row: focusedRowIndex < 0 ? void 0 : this._dataController.getVisibleRows()[localRowIndex]
    });
  }
  _isEventInCurrentGrid(event) {
    return m_utils_default.isElementInCurrentGrid(this, renderer_default(event.target));
  }
  _isRowEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_FORM;
  }
  _isCellEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_CELL || editMode === EDIT_MODE_BATCH;
  }
  _isFastEditingAllowed() {
    return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress");
  }
  _applyTabIndexToElement($element) {
    const tabIndex = this.option("tabIndex") ?? 0;
    $element.attr("tabindex", tabIndex);
  }
  _getCell(cellPosition) {
    if (this._focusedView && cellPosition) {
      const rowIndexOffset = this._dataController.getRowIndexOffset();
      const column = this._columnsController.getVisibleColumns(null, true)[cellPosition.columnIndex];
      const columnIndexOffset = column && column.fixed ? this._getFixedColumnIndexOffset(column) : this._columnsController.getColumnIndexOffset();
      const rowIndex = cellPosition.rowIndex >= 0 ? cellPosition.rowIndex - rowIndexOffset : -1;
      const columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
      return this._focusedView.getCell({
        rowIndex,
        columnIndex
      });
    }
  }
  _getRowIndex($row) {
    let rowIndex = this._getLocalRowIndex($row);
    if (rowIndex >= 0) {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    return rowIndex;
  }
  _getLocalRowIndex($row) {
    const rowIndex = this._rowsView.getRowIndex($row);
    return rowIndex;
  }
  _hasSkipRow($row) {
    const row = $row && $row.get(0);
    return row && "none" === row.style.display;
  }
  _allowEditingOnEnterKey() {
    return "startEdit" === this.option("keyboardNavigation.enterKeyAction");
  }
  _isLegacyNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDirectionCodeByKey(key) {
    let directionCode;
    switch (key) {
      case "upArrow":
        directionCode = "prevRow";
        break;
      case "downArrow":
        directionCode = "nextRow";
        break;
      case "leftArrow":
        directionCode = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
        break;
      case "rightArrow":
        directionCode = this.option("rtlEnabled") ? "previousInRow" : "nextInRow";
    }
    return directionCode;
  }
  _isVirtualScrolling() {
    const scrollingMode = this.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  _isVirtualRowRender() {
    return this._isVirtualScrolling() || m_utils_default.isVirtualRowRendering(this);
  }
  _isVirtualColumnRender() {
    return "virtual" === this.option("scrolling.columnRenderingMode");
  }
  _scrollBy(left, top, rowIndex, $event) {
    const that = this;
    const scrollable = this._rowsView.getScrollable();
    if (that._focusedCellPosition) {
      const scrollHandler = function() {
        scrollable.off("scroll", scrollHandler);
        setTimeout(that.restoreFocusableElement.bind(that, rowIndex, $event));
      };
      scrollable.on("scroll", scrollHandler);
    }
    return scrollable.scrollBy({
      left,
      top
    });
  }
  _isInsideEditForm(element) {
    const $editForm = renderer_default(element).closest(`.${this.addWidgetPrefix(EDIT_FORM_CLASS)}`);
    return $editForm.length && this.elementIsInsideGrid($editForm);
  }
  getMasterDetailCell(element) {
    const $masterDetailCell = renderer_default(element).closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    if ($masterDetailCell.length && this.elementIsInsideGrid($masterDetailCell)) {
      return $masterDetailCell;
    }
    return null;
  }
  _processNextCellInMasterDetail($nextCell, _$cell) {
    if (!this._isInsideEditForm($nextCell) && $nextCell) {
      this._applyTabIndexToElement($nextCell);
    }
  }
  _handleTabKeyOnMasterDetailCell(target, direction) {
    if (this.getMasterDetailCell(target)) {
      this._updateFocusedCellPosition(renderer_default(target), direction);
      const $nextCell = this._getNextCell(direction, "row");
      this._processNextCellInMasterDetail($nextCell, renderer_default(target));
      return true;
    }
    return false;
  }
  _getElementType(target) {
    return renderer_default(target).is("tr") ? "row" : "cell";
  }
  _isFastEditingStarted() {
    return this._isFastEditingAllowed() && this._fastEditingStarted;
  }
  _getVisibleColumnCount() {
    return this._columnsController.getVisibleColumns(null, true).length;
  }
  _isCellInRow(cellPosition, includeCommandCells) {
    const {
      columnIndex
    } = cellPosition;
    const visibleColumnsCount = this._getVisibleColumnCount();
    return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1;
  }
  _isCellElement($element) {
    return $element.length && "TD" === $element[0].tagName;
  }
  _getCellElementFromTarget(target) {
    const elementType = this._getElementType(target);
    const $targetElement = renderer_default(target);
    let $cell;
    if ("cell" === elementType) {
      $cell = $targetElement.closest(`.${ROW_CLASS} > td`);
    } else {
      $cell = $targetElement.children().not(`.${COMMAND_EXPAND_CLASS2}`).first();
    }
    return $cell;
  }
  _getRowsViewElement() {
    var _this$_rowsView5;
    return null === (_this$_rowsView5 = this._rowsView) || void 0 === _this$_rowsView5 ? void 0 : _this$_rowsView5.element();
  }
  isKeyboardEnabled() {
    return this.option("keyboardNavigation.enabled");
  }
  _processCanceledEditCellPosition(rowIndex, columnIndex) {
    if (this._canceledCellPosition) {
      const isCanceled = this._canceledCellPosition.rowIndex === rowIndex && this._canceledCellPosition.columnIndex === columnIndex;
      this._canceledCellPosition = null;
      return isCanceled;
    }
    return;
  }
  updateFocusedRowIndex() {
    const dataController2 = this._dataController;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleItems = dataController2.items();
    const lastVisibleIndex = visibleItems.length ? visibleItems.length - 1 : -1;
    const rowIndexOffset = dataController2.getRowIndexOffset();
    if (lastVisibleIndex >= 0 && visibleRowIndex > lastVisibleIndex) {
      this.setFocusedRowIndex(lastVisibleIndex + rowIndexOffset);
    }
  }
};
var rowsView10 = (Base) => class extends Base {
  _rowClick(e) {
    const editRowIndex = this._editingController.getEditRowIndex();
    const isKeyboardEnabled = this._keyboardNavigationController.isKeyboardEnabled();
    if (editRowIndex === e.rowIndex) {
      this._keyboardNavigationController.setCellFocusType();
    }
    const needTriggerPointerEventHandler = (isMobile() || !isKeyboardEnabled) && this.option("focusedRowEnabled");
    if (needTriggerPointerEventHandler) {
      this._triggerPointerDownEventHandler(e, !isKeyboardEnabled);
    }
    super._rowClick.apply(this, arguments);
  }
  _triggerPointerDownEventHandler(e, force) {
    const {
      originalEvent
    } = e.event;
    if (originalEvent) {
      const $cell = renderer_default(originalEvent.target);
      const columnIndex = this.getCellIndex($cell);
      const column = this._columnsController.getVisibleColumns()[columnIndex];
      const row = this._dataController.items()[e.rowIndex];
      if (this._keyboardNavigationController._isAllowEditing(row, column) || force) {
        const eventArgs = createEvent(originalEvent, {
          currentTarget: originalEvent.target
        });
        this._keyboardNavigationController._pointerEventHandler(eventArgs);
      }
    }
  }
  renderFocusState(params) {
    super.renderFocusState(params);
    const {
      preventScroll,
      pageSizeChanged
    } = params ?? {};
    const $rowsViewElement = this.element();
    if ($rowsViewElement && !focused($rowsViewElement)) {
      $rowsViewElement.attr("tabindex", null);
    }
    pageSizeChanged && this._keyboardNavigationController.updateFocusedRowIndex();
    let rowIndex = this._keyboardNavigationController.getVisibleRowIndex();
    if (!isDefined(rowIndex) || rowIndex < 0) {
      rowIndex = 0;
    }
    const cellElements = this.getCellElements(rowIndex);
    if (this._keyboardNavigationController.isKeyboardEnabled() && null !== cellElements && void 0 !== cellElements && cellElements.length) {
      this.updateFocusElementTabIndex(cellElements, preventScroll);
    }
  }
  updateFocusElementTabIndex(cellElements, preventScroll) {
    const $row = cellElements.eq(0).parent();
    if (isGroupRow2($row)) {
      this._keyboardNavigationController._applyTabIndexToElement($row);
    } else {
      let columnIndex = this._keyboardNavigationController.getColumnIndex();
      if (!isDefined(columnIndex) || columnIndex < 0) {
        columnIndex = 0;
      }
      this._updateFocusedCellTabIndex(cellElements, columnIndex);
    }
  }
  _updateFocusedCellTabIndex(cellElements, columnIndex) {
    const keyboardController = this._keyboardNavigationController;
    const cellElementsLength = cellElements ? cellElements.length : -1;
    const updateCellTabIndex = function($cell2) {
      const isMasterDetailCell = !!keyboardController.getMasterDetailCell($cell2);
      const isValidCell = keyboardController._isCellValid($cell2);
      if (!isMasterDetailCell && isValidCell && keyboardController._isCellElement($cell2)) {
        keyboardController._applyTabIndexToElement($cell2);
        keyboardController.setCellFocusType();
        return true;
      }
      return;
    };
    const $cell = GridCoreKeyboardNavigationDom.getCellToFocus(cellElements, columnIndex);
    if ($cell.length) {
      updateCellTabIndex($cell);
    } else {
      if (cellElementsLength <= columnIndex) {
        columnIndex = cellElementsLength - 1;
      }
      for (let i = columnIndex; i < cellElementsLength; ++i) {
        if (updateCellTabIndex(renderer_default(cellElements[i]))) {
          break;
        }
      }
    }
  }
  renderDelayedTemplates(change) {
    super.renderDelayedTemplates.apply(this, arguments);
    this.waitAsyncTemplates().done((() => {
      this._renderFocusByChange(change);
    }));
  }
  _renderFocusByChange(change) {
    const {
      operationTypes,
      repaintChangesOnly
    } = change ?? {};
    const {
      fullReload,
      pageSize
    } = operationTypes ?? {};
    if (!change || !repaintChangesOnly || fullReload || pageSize) {
      const preventScroll = shouldPreventScroll(this);
      this.renderFocusState({
        preventScroll,
        pageSizeChanged: pageSize
      });
    }
  }
  _renderCore(change) {
    const deferred = super._renderCore.apply(this, arguments);
    this._renderFocusByChange(change);
    return deferred;
  }
  _editCellPrepared($cell) {
    var _this$_keyboardNaviga;
    const editorInstance = this._getEditorInstance($cell);
    const isEditingNavigationMode = null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga ? void 0 : _this$_keyboardNaviga._isFastEditingStarted();
    if (editorInstance && isEditingNavigationMode) {
      this._handleEditingNavigationMode(editorInstance);
    }
    super._editCellPrepared.apply(this, arguments);
  }
  _handleEditingNavigationMode(editorInstance) {
    ["downArrow", "upArrow"].forEach(((keyName) => {
      const originalKeyHandler = editorInstance._supportedKeys()[keyName];
      editorInstance.registerKeyHandler(keyName, ((e) => {
        const isDropDownOpened = "true" === editorInstance._input().attr("aria-expanded");
        if (isDropDownOpened) {
          return originalKeyHandler && originalKeyHandler.call(editorInstance, e);
        }
      }));
    }));
    editorInstance.registerKeyHandler("leftArrow", noop);
    editorInstance.registerKeyHandler("rightArrow", noop);
    const isDateBoxWithMask = editorInstance.NAME === DATEBOX_WIDGET_NAME && editorInstance.option("useMaskBehavior");
    if (isDateBoxWithMask) {
      editorInstance.registerKeyHandler("enter", noop);
    }
  }
  _getEditorInstance($cell) {
    const $editor = $cell.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
};
var editing2 = (Base) => class extends Base {
  editCell(rowIndex, columnIndex) {
    if (this._keyboardNavigationController._processCanceledEditCellPosition(rowIndex, columnIndex)) {
      return false;
    }
    const isCellEditing = super.editCell(rowIndex, columnIndex);
    if (isCellEditing) {
      this._keyboardNavigationController.setupFocusedView();
    }
    return isCellEditing;
  }
  editRow(rowIndex) {
    const visibleColumnIndex = this._keyboardNavigationController.getVisibleColumnIndex();
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (column && column.type || this.option("editing.mode") === EDIT_MODE_FORM) {
      this._keyboardNavigationController._resetFocusedCell();
    }
    super.editRow(rowIndex);
    return;
  }
  addRow(parentKey) {
    this._keyboardNavigationController.setupFocusedView();
    this._keyboardNavigationController.setCellFocusType();
    return super.addRow.apply(this, arguments);
  }
  getFocusedCellInRow(rowIndex) {
    let $cell = super.getFocusedCellInRow(rowIndex);
    const rowIndexOffset = this._dataController.getRowIndexOffset();
    const focusedRowIndex = this._keyboardNavigationController._focusedCellPosition.rowIndex - rowIndexOffset;
    if (this._keyboardNavigationController.isKeyboardEnabled() && focusedRowIndex === rowIndex) {
      const $focusedCell = this._keyboardNavigationController._getFocusedCell();
      if (isElementDefined($focusedCell) && !$focusedCell.hasClass(COMMAND_EDIT_CLASS2)) {
        $cell = $focusedCell;
      }
    }
    return $cell;
  }
  _processCanceledEditingCell() {
    this.closeEditCell().done((() => {
      this._keyboardNavigationController._updateFocus();
    }));
  }
  closeEditCell() {
    const keyboardNavigation5 = this._keyboardNavigationController;
    keyboardNavigation5._fastEditingStarted = false;
    const result2 = super.closeEditCell.apply(this, arguments);
    const $focusedElement = this._getFocusedElement();
    const isFilterCell = !!$focusedElement.closest(`.${this.addWidgetPrefix(FILTER_ROW_CLASS)}`).length;
    if (!isFilterCell) {
      keyboardNavigation5._updateFocus();
    }
    return result2;
  }
  _getFocusedElement() {
    var _this$component$eleme, _this$component;
    const $element = renderer_default(null === (_this$component$eleme = (_this$component = this.component).element) || void 0 === _this$component$eleme ? void 0 : _this$component$eleme.call(_this$component));
    const $focusedElement = $element.find(":focus");
    return $focusedElement;
  }
  _delayedInputFocus() {
    this._keyboardNavigationController._isNeedScroll = true;
    super._delayedInputFocus.apply(this, arguments);
  }
  _isEditingStart() {
    const cancel = super._isEditingStart.apply(this, arguments);
    if (cancel && !this._keyboardNavigationController._isNeedFocus) {
      const $cell = this._keyboardNavigationController._getFocusedCell();
      this._keyboardNavigationController._focus($cell, true);
    }
    return cancel;
  }
};
var data12 = (Base) => class extends Base {
  _correctRowIndices(getRowIndexCorrection) {
    const focusedCellPosition = this._keyboardNavigationController._focusedCellPosition;
    super._correctRowIndices.apply(this, arguments);
    if (focusedCellPosition && focusedCellPosition.rowIndex >= 0) {
      const focusedRowIndexCorrection = getRowIndexCorrection(focusedCellPosition.rowIndex);
      if (focusedRowIndexCorrection) {
        focusedCellPosition.rowIndex += focusedRowIndexCorrection;
        this._editorFactoryController.refocus();
      }
    }
  }
  getMaxRowIndex() {
    let result2 = this.items().length - 1;
    const virtualItemsCount = this.virtualItemsCount();
    if (virtualItemsCount) {
      const rowIndexOffset = this.getRowIndexOffset();
      result2 += rowIndexOffset + virtualItemsCount.end;
    }
    return result2;
  }
};
var adaptiveColumns = (Base) => class extends Base {
  _showHiddenCellsInView(_ref) {
    let {
      viewName: viewName2,
      $cells,
      isCommandColumn
    } = _ref;
    super._showHiddenCellsInView.apply(this, arguments);
    viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && $cells.each(((_, cellElement) => {
      const $cell = renderer_default(cellElement);
      isCellInHeaderRow($cell) && $cell.attr("tabindex", 0);
    }));
  }
  _hideVisibleCellInView(_ref2) {
    let {
      viewName: viewName2,
      $cell,
      isCommandColumn
    } = _ref2;
    super._hideVisibleCellInView.apply(this, arguments);
    if (viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && isCellInHeaderRow($cell)) {
      $cell.removeAttr("tabindex");
    }
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    super._hideVisibleColumnInView({
      view,
      isCommandColumn,
      visibleIndex
    });
    if (view.name === ROWS_VIEW) {
      this._rowsView.renderFocusState({
        preventScroll: shouldPreventScroll(this)
      });
    }
  }
};
var keyboardNavigationModule = {
  defaultOptions: () => ({
    useLegacyKeyboardNavigation: false,
    keyboardNavigation: {
      enabled: true,
      enterKeyAction: "startEdit",
      enterKeyDirection: "none",
      editOnKeyPress: false
    }
  }),
  controllers: {
    keyboardNavigation: KeyboardNavigationController
  },
  extenders: {
    views: {
      rowsView: rowsView10
    },
    controllers: {
      editing: editing2,
      data: data12,
      adaptiveColumns,
      keyboardNavigation: keyboardNavigationScrollableA11yExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/keyboard_navigation.js
m_core_default.registerModule("keyboardNavigation", keyboardNavigationModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/m_aggregate_calculator.js
function depthFirstSearch(i, depth, root, callback) {
  let j = 0;
  if (i < depth) {
    for (; j < root.items.length; j++) {
      depthFirstSearch(i + 1, depth, root.items[j], callback);
    }
  }
  if (i === depth) {
    callback(root);
  }
}
function map2(array, callback) {
  let i;
  if ("map" in array) {
    return array.map(callback);
  }
  const result2 = new Array(array.length);
  for (i in array) {
    result2[i] = callback(array[i], i);
  }
  return result2;
}
function isEmpty2(x) {
  return x !== x || "" === x || null === x || void 0 === x;
}
function isCount(aggregator) {
  return aggregator === aggregators.count;
}
function normalizeAggregate(aggregate) {
  const selector = compileGetter(aggregate.selector);
  const skipEmptyValues = "skipEmptyValues" in aggregate ? aggregate.skipEmptyValues : true;
  let {
    aggregator
  } = aggregate;
  if ("string" === typeof aggregator) {
    aggregator = aggregators[aggregator];
    if (!aggregator) {
      throw errors.Error("E4001", aggregate.aggregator);
    }
  }
  return {
    selector,
    aggregator,
    skipEmptyValues
  };
}
var AggregateCalculator = class {
  constructor(options2) {
    this._data = options2.data;
    this._groupLevel = options2.groupLevel || 0;
    this._totalAggregates = map2(options2.totalAggregates || [], normalizeAggregate);
    this._groupAggregates = map2(options2.groupAggregates || [], normalizeAggregate);
    this._totals = [];
  }
  calculate() {
    if (this._totalAggregates.length) {
      this._calculateTotals(0, {
        items: this._data
      });
    }
    if (this._groupAggregates.length && this._groupLevel > 0) {
      this._calculateGroups({
        items: this._data
      });
    }
  }
  totalAggregates() {
    return this._totals;
  }
  _aggregate(aggregates, data17, container) {
    const length = data17.items ? data17.items.length : 0;
    for (let i = 0; i < aggregates.length; i++) {
      if (isCount(aggregates[i].aggregator)) {
        container[i] = (container[i] || 0) + length;
        continue;
      }
      for (let j = 0; j < length; j++) {
        this._accumulate(i, aggregates[i], container, data17.items[j]);
      }
    }
  }
  _calculateTotals(level, data17) {
    if (0 === level) {
      this._totals = this._seed(this._totalAggregates);
    }
    if (level === this._groupLevel) {
      this._aggregate(this._totalAggregates, data17, this._totals);
    } else {
      for (let i = 0; i < data17.items.length; i++) {
        this._calculateTotals(level + 1, data17.items[i]);
      }
    }
    if (0 === level) {
      this._totals = this._finalize(this._totalAggregates, this._totals);
    }
  }
  _calculateGroups(root) {
    const maxLevel = this._groupLevel;
    let currentLevel = maxLevel + 1;
    const seedFn = this._seed.bind(this, this._groupAggregates);
    const stepFn = this._aggregate.bind(this, this._groupAggregates);
    const finalizeFn = this._finalize.bind(this, this._groupAggregates);
    function aggregator(node) {
      node.aggregates = seedFn(currentLevel - 1);
      if (currentLevel === maxLevel) {
        stepFn(node, node.aggregates);
      } else {
        depthFirstSearch(currentLevel, maxLevel, node, ((innerNode) => {
          stepFn(innerNode, node.aggregates);
        }));
      }
      node.aggregates = finalizeFn(node.aggregates);
    }
    while (--currentLevel > 0) {
      depthFirstSearch(0, currentLevel, root, aggregator);
    }
  }
  _seed(aggregates, groupIndex) {
    return map2(aggregates, ((aggregate) => {
      const {
        aggregator
      } = aggregate;
      const seed = "seed" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;
      return seed;
    }));
  }
  _accumulate(aggregateIndex, aggregate, results, item) {
    const value2 = aggregate.selector(item);
    const {
      aggregator
    } = aggregate;
    const {
      skipEmptyValues
    } = aggregate;
    if (skipEmptyValues && isEmpty2(value2)) {
      return;
    }
    if (results[aggregateIndex] !== results[aggregateIndex]) {
      results[aggregateIndex] = value2;
    } else {
      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value2);
    }
  }
  _finalize(aggregates, results) {
    return map2(aggregates, ((aggregate, index) => {
      const fin = aggregate.aggregator.finalize;
      return fin ? fin(results[index]) : results[index];
    }));
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/summary/utils.js
function getSummaryCellIndex(column, prevColumn) {
  let isGroupRow3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  const cellIndex = column.index ?? -1;
  if (!isGroupRow3) {
    return cellIndex;
  }
  if ("groupExpand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.type) || "groupExpand" === column.type) {
    return (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.index) ?? -1;
  }
  return !isDefined(column.groupIndex) ? cellIndex : -1;
}

// node_modules/devextreme/esm/__internal/grids/data_grid/summary/m_summary.js
var DATAGRID_CELL_DISABLED = "dx-cell-focus-disabled";
var renderSummaryCell = function(cell, options2) {
  const $cell = renderer_default(cell);
  const {
    column
  } = options2;
  const {
    summaryItems
  } = options2;
  const $summaryItems = [];
  if (!column.command && summaryItems) {
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      const text = m_core_default.getSummaryText(summaryItem, options2.summaryTexts);
      $summaryItems.push(renderer_default("<div>").css("textAlign", summaryItem.alignment || column.alignment).addClass("dx-datagrid-summary-item").addClass("dx-datagrid-text-content").addClass(summaryItem.cssClass).toggleClass("dx-datagrid-group-text-content", "group" === options2.rowType).text(text).attr("aria-label", `${column.caption} ${text}`));
    }
    $cell.append($summaryItems);
  }
};
var getSummaryCellOptions = function(that, options2) {
  const summaryTexts = that.option("summary.texts") || {};
  return {
    totalItem: options2.row,
    summaryItems: options2.row.summaryCells[options2.columnIndex],
    summaryTexts
  };
};
var getGroupAggregates = function(data17) {
  return data17.summary || data17.aggregates || [];
};
var recalculateWhileEditing = function(that) {
  return that.option("summary.recalculateWhileEditing");
};
var forEachGroup = function(groups, groupCount, callback, path) {
  path = path || [];
  for (let i = 0; i < groups.length; i++) {
    path.push(groups[i].key);
    if (1 === groupCount) {
      callback(path, groups[i].items);
    } else {
      forEachGroup(groups[i].items, groupCount - 1, callback, path);
    }
    path.pop();
  }
};
var applyAddedData = function(data17, insertedData, groupLevel) {
  if (groupLevel) {
    return applyAddedData(data17, insertedData.map(((item) => ({
      items: [item]
    })), groupLevel - 1));
  }
  return data17.concat(insertedData);
};
var applyRemovedData = function(data17, removedData, groupLevel) {
  if (groupLevel) {
    return data17.map(((data18) => {
      const updatedData = {};
      const updatedItems = applyRemovedData(data18.items || [], removedData, groupLevel - 1);
      Object.defineProperty(updatedData, "aggregates", {
        get: () => data18.aggregates,
        set: (value2) => {
          data18.aggregates = value2;
        }
      });
      return extend(updatedData, data18, {
        items: updatedItems
      });
    }));
  }
  return data17.filter(((data18) => removedData.indexOf(data18) < 0));
};
var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
  if (!items || !groups.length) {
    return items;
  }
  const group = groups[0];
  const sorts = sortByGroups[0];
  let query;
  if (group && sorts && sorts.length) {
    query = m_query_default(items);
    each(sorts, (function(index) {
      if (0 === index) {
        query = query.sortBy(this.selector, this.desc);
      } else {
        query = query.thenBy(this.selector, this.desc);
      }
    }));
    query.enumerate().done(((sortedItems) => {
      items = sortedItems;
    }));
  }
  groups = groups.slice(1);
  sortByGroups = sortByGroups.slice(1);
  if (groups.length && sortByGroups.length) {
    each(items, (function() {
      this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups);
    }));
  }
  return items;
};
var sortGroupsBySummary = function(data17, group, summary) {
  const sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
  if (sortByGroups && sortByGroups.length) {
    return sortGroupsBySummaryCore(data17, group, sortByGroups);
  }
  return data17;
};
var calculateAggregates = function(that, summary, data17, groupLevel) {
  let calculator;
  if (recalculateWhileEditing(that)) {
    const editingController = that._editingController;
    if (editingController) {
      const insertedData = editingController.getInsertedData();
      if (insertedData.length) {
        data17 = applyAddedData(data17, insertedData, groupLevel);
      }
      const removedData = editingController.getRemovedData();
      if (removedData.length) {
        data17 = applyRemovedData(data17, removedData, groupLevel);
      }
    }
  }
  if (summary) {
    calculator = new AggregateCalculator({
      totalAggregates: summary.totalAggregates,
      groupAggregates: summary.groupAggregates,
      data: data17,
      groupLevel
    });
    calculator.calculate();
  }
  return calculator ? calculator.totalAggregates() : [];
};
var FooterView = class extends ColumnsView {
  _getRows() {
    return this._dataController.footerItems();
  }
  _getCellOptions(options2) {
    return extend(super._getCellOptions(options2), getSummaryCellOptions(this, options2));
  }
  _renderCellContent($cell, options2) {
    renderSummaryCell($cell, options2);
    super._renderCellContent.apply(this, arguments);
  }
  _renderCore(change) {
    let needUpdateScrollLeft = false;
    const totalItem = this._dataController.footerItems()[0];
    if (!change || !change.columnIndices) {
      this.element().empty().addClass("dx-datagrid-total-footer").toggleClass("dx-datagrid-nowrap", !this.option("wordWrapEnabled"));
      needUpdateScrollLeft = true;
    }
    if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
      this._updateContent(this._renderTable({
        change
      }), change);
      needUpdateScrollLeft && this._updateScrollLeftPosition();
    }
    return super._renderCore(change);
  }
  _updateContent($newTable, change) {
    if (change && "update" === change.changeType && change.columnIndices) {
      return this.waitAsyncTemplates().done((() => {
        const $row = this.getTableElement().find(".dx-row");
        const $newRow = $newTable.find(".dx-row");
        this._updateCells($row, $newRow, change.columnIndices[0]);
      }));
    }
    return super._updateContent.apply(this, arguments);
  }
  _rowClick(e) {
    const item = this._dataController.footerItems()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({}, e, item));
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
    }
  }
  _handleDataChanged(e) {
    const {
      changeType
    } = e;
    if ("update" === e.changeType && e.repaintChangesOnly) {
      if (!e.totalColumnIndices) {
        this.render();
      } else if (e.totalColumnIndices.length) {
        this.render(null, {
          changeType: "update",
          columnIndices: [e.totalColumnIndices]
        });
      }
    } else if ("refresh" === changeType || "append" === changeType || "prepend" === changeType) {
      this.render();
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if ("totalFooter" === row.rowType) {
      $row.addClass("dx-footer-row");
      $row.addClass(DATAGRID_CELL_DISABLED);
      $row.attr("tabindex", 0);
    }
    return $row;
  }
  getHeight() {
    return this.getElementHeight();
  }
  isVisible() {
    return !!this._dataController.footerItems().length;
  }
};
var dataSourceAdapterExtender3 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._editingController = this.getController("editing");
    this._totalAggregates = [];
    this._summaryGetter = noop;
  }
  summaryGetter(summaryGetter) {
    if (!arguments.length) {
      return this._summaryGetter;
    }
    if (isFunction(summaryGetter)) {
      this._summaryGetter = summaryGetter;
    }
  }
  summary(summary) {
    if (!arguments.length) {
      return this._summaryGetter();
    }
    this._summaryGetter = function() {
      return summary;
    };
  }
  totalAggregates() {
    return this._totalAggregates;
  }
  isLastLevelGroupItemsPagingLocal() {
    const summary = this.summary();
    const sortByGroupsInfo = null === summary || void 0 === summary ? void 0 : summary.sortByGroups();
    return null === sortByGroupsInfo || void 0 === sortByGroupsInfo ? void 0 : sortByGroupsInfo.length;
  }
  sortLastLevelGroupItems(items, groups, paths) {
    const groupedItems = m_store_helper_default.multiLevelGroup(m_query_default(items), groups).toArray();
    let result2 = [];
    paths.forEach(((path) => {
      forEachGroup(groupedItems, groups.length, ((itemsPath, items2) => {
        if (path.toString() === itemsPath.toString()) {
          result2 = result2.concat(items2);
        }
      }));
    }));
    return result2;
  }
  _customizeRemoteOperations(options2) {
    const summary = this.summary();
    if (summary) {
      if (options2.remoteOperations.summary) {
        if (!options2.isCustomLoading || options2.storeLoadOptions.isLoadingAll) {
          if (options2.storeLoadOptions.group) {
            if (options2.remoteOperations.grouping) {
              options2.storeLoadOptions.groupSummary = summary.groupAggregates;
            } else if (summary.groupAggregates.length) {
              options2.remoteOperations.paging = false;
            }
          }
          options2.storeLoadOptions.totalSummary = summary.totalAggregates;
        }
      } else if (summary.totalAggregates.length || summary.groupAggregates.length && options2.storeLoadOptions.group) {
        options2.remoteOperations.paging = false;
      }
    }
    super._customizeRemoteOperations.apply(this, arguments);
    const cachedExtra = options2.cachedData.extra;
    if (null !== cachedExtra && void 0 !== cachedExtra && cachedExtra.summary && !options2.isCustomLoading) {
      options2.storeLoadOptions.totalSummary = void 0;
    }
  }
  _handleDataLoadedCore(options2) {
    const groups = normalizeSortingInfo(options2.storeLoadOptions.group || options2.loadOptions.group || []);
    const remoteOperations = options2.remoteOperations || {};
    const summary = this.summaryGetter()(remoteOperations);
    if (!options2.isCustomLoading || options2.storeLoadOptions.isLoadingAll) {
      if (remoteOperations.summary) {
        if (!remoteOperations.paging && groups.length && summary) {
          if (!remoteOperations.grouping) {
            calculateAggregates(this, {
              groupAggregates: summary.groupAggregates
            }, options2.data, groups.length);
          }
          options2.data = sortGroupsBySummary(options2.data, groups, summary);
        }
      } else if (!remoteOperations.paging && summary) {
        var _options$cachedData;
        const operationTypes = options2.operationTypes || {};
        const hasOperations = Object.keys(operationTypes).some(((type2) => operationTypes[type2]));
        if (!hasOperations || !(null !== (_options$cachedData = options2.cachedData) && void 0 !== _options$cachedData && null !== (_options$cachedData = _options$cachedData.extra) && void 0 !== _options$cachedData && _options$cachedData.summary) || groups.length && summary.groupAggregates.length) {
          const totalAggregates = calculateAggregates(this, summary, options2.data, groups.length);
          options2.extra = isPlainObject(options2.extra) ? options2.extra : {};
          options2.extra.summary = totalAggregates;
          if (options2.cachedData) {
            options2.cachedData.extra = options2.extra;
          }
        }
        options2.data = sortGroupsBySummary(options2.data, groups, summary);
      }
    }
    if (!options2.isCustomLoading) {
      this._totalAggregates = options2.extra && options2.extra.summary || this._totalAggregates;
    }
    super._handleDataLoadedCore(options2);
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender3);
var data13 = (Base) => class extends Base {
  _isDataColumn(column) {
    return column && (!isDefined(column.groupIndex) || column.showWhenGrouped);
  }
  _isGroupFooterVisible() {
    const groupItems = this.option("summary.groupItems") || [];
    for (let i = 0; i < groupItems.length; i++) {
      const groupItem = groupItems[i];
      const column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
      if (groupItem.showInGroupFooter && this._isDataColumn(column)) {
        return true;
      }
    }
    return false;
  }
  _processGroupItems(items, groupCount, options2) {
    const data17 = options2 && options2.data;
    const result2 = super._processGroupItems.apply(this, arguments);
    if (options2) {
      if (void 0 === options2.isGroupFooterVisible) {
        options2.isGroupFooterVisible = this._isGroupFooterVisible();
      }
      if (data17 && data17.items && options2.isGroupFooterVisible && (options2.collectContinuationItems || !data17.isContinuationOnNextPage)) {
        result2.push({
          rowType: "groupFooter",
          key: options2.path.slice(),
          data: data17,
          groupIndex: options2.path.length - 1,
          values: []
        });
      }
    }
    return result2;
  }
  _processGroupItem(groupItem, options2) {
    const that = this;
    if (!options2.summaryGroupItems) {
      options2.summaryGroupItems = that.option("summary.groupItems") || [];
    }
    if ("group" === groupItem.rowType) {
      let groupColumnIndex = -1;
      let afterGroupColumnIndex = -1;
      each(options2.visibleColumns, (function(visibleIndex) {
        const prevColumn = options2.visibleColumns[visibleIndex - 1];
        if (groupItem.groupIndex === this.groupIndex) {
          groupColumnIndex = this.index;
        }
        if (visibleIndex > 0 && "expand" === prevColumn.command && "expand" !== this.command) {
          afterGroupColumnIndex = this.index;
        }
      }));
      groupItem.summaryCells = this._calculateSummaryCells(options2.summaryGroupItems, getGroupAggregates(groupItem.data), options2.visibleColumns, ((summaryItem, column) => {
        if (summaryItem.showInGroupFooter) {
          return -1;
        }
        if (summaryItem.alignByColumn && column && !isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex) {
          return column.index;
        }
        return groupColumnIndex;
      }), true);
    }
    if ("groupFooter" === groupItem.rowType) {
      groupItem.summaryCells = this._calculateSummaryCells(options2.summaryGroupItems, getGroupAggregates(groupItem.data), options2.visibleColumns, ((summaryItem, column) => summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1));
    }
    return groupItem;
  }
  _calculateSummaryCells(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex, isGroupRow3) {
    const that = this;
    const summaryCells = [];
    const summaryCellsByColumns = {};
    each(summaryItems, ((summaryIndex, summaryItem) => {
      const column = that._columnsController.columnOption(summaryItem.column);
      const showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column;
      const columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn);
      if (columnIndex >= 0) {
        if (!summaryCellsByColumns[columnIndex]) {
          summaryCellsByColumns[columnIndex] = [];
        }
        const aggregate = aggregates[summaryIndex];
        if (aggregate === aggregate) {
          let valueFormat;
          if (isDefined(summaryItem.valueFormat)) {
            valueFormat = summaryItem.valueFormat;
          } else if ("count" !== summaryItem.summaryType) {
            valueFormat = m_core_default.getFormatByDataType(column && column.dataType);
          }
          summaryCellsByColumns[columnIndex].push(extend({}, summaryItem, {
            value: isString(aggregate) && column && column.deserializeValue ? column.deserializeValue(aggregate) : aggregate,
            valueFormat,
            columnCaption: column && column.index !== columnIndex ? column.caption : void 0
          }));
        }
      }
    }));
    if (!isEmptyObject(summaryCellsByColumns)) {
      visibleColumns.forEach(((column, visibleIndex) => {
        const prevColumn = visibleColumns[visibleIndex - 1];
        const columnIndex = getSummaryCellIndex(column, prevColumn, isGroupRow3);
        summaryCells.push(summaryCellsByColumns[columnIndex] || []);
      }));
    }
    return summaryCells;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    const that = this;
    const columnsController = that._columnsController;
    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), ((summaryItem, column) => that._isDataColumn(column) ? column.index : -1));
  }
  _updateItemsCore(change) {
    const that = this;
    let summaryCells;
    const dataSource = that._dataSource;
    const footerItems = that._footerItems;
    const oldSummaryCells = footerItems && footerItems[0] && footerItems[0].summaryCells;
    const summaryTotalItems = that.option("summary.totalItems");
    that._footerItems = [];
    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
      const totalAggregates = dataSource.totalAggregates();
      summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
      if (change && change.repaintChangesOnly && oldSummaryCells) {
        change.totalColumnIndices = summaryCells.map(((summaryCell, index) => {
          if (JSON.stringify(summaryCell) !== JSON.stringify(oldSummaryCells[index])) {
            return index;
          }
          return -1;
        })).filter(((index) => index >= 0));
      }
      if (summaryCells.length) {
        that._footerItems.push({
          rowType: "totalFooter",
          summaryCells
        });
      }
    }
    super._updateItemsCore(change);
  }
  _prepareUnsavedDataSelector(selector) {
    if (recalculateWhileEditing(this)) {
      const editingController = this._editingController;
      if (editingController) {
        return function(data17) {
          data17 = editingController.getUpdatedData(data17);
          return selector(data17);
        };
      }
    }
    return selector;
  }
  _prepareAggregateSelector(selector, aggregator) {
    selector = this._prepareUnsavedDataSelector(selector);
    if ("avg" === aggregator || "sum" === aggregator) {
      return function(data17) {
        const value2 = selector(data17);
        return isDefined(value2) ? Number(value2) : value2;
      };
    }
    return selector;
  }
  _getAggregates(summaryItems, remoteOperations) {
    const that = this;
    let calculateCustomSummary = that.option("summary.calculateCustomSummary");
    const commonSkipEmptyValues = that.option("summary.skipEmptyValues");
    return map(summaryItems || [], ((summaryItem) => {
      const column = this._columnsController.columnOption(summaryItem.column);
      const calculateCellValue = column && column.calculateCellValue ? column.calculateCellValue.bind(column) : compileGetter(column ? column.dataField : summaryItem.column);
      let aggregator = summaryItem.summaryType || "count";
      const skipEmptyValues = isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues;
      if (remoteOperations) {
        return {
          selector: summaryItem.column,
          summaryType: aggregator
        };
      }
      const selector = that._prepareAggregateSelector(calculateCellValue, aggregator);
      if ("custom" === aggregator) {
        if (!calculateCustomSummary) {
          ui_errors_default.log("E1026");
          calculateCustomSummary = function() {
          };
        }
        const options2 = {
          component: that.component,
          name: summaryItem.name
        };
        calculateCustomSummary(options2);
        options2.summaryProcess = "calculate";
        aggregator = {
          seed(groupIndex) {
            options2.summaryProcess = "start";
            options2.totalValue = void 0;
            options2.groupIndex = groupIndex;
            delete options2.value;
            calculateCustomSummary(options2);
            return options2.totalValue;
          },
          step(totalValue, value2) {
            options2.summaryProcess = "calculate";
            options2.totalValue = totalValue;
            options2.value = value2;
            calculateCustomSummary(options2);
            return options2.totalValue;
          },
          finalize(totalValue) {
            options2.summaryProcess = "finalize";
            options2.totalValue = totalValue;
            delete options2.value;
            calculateCustomSummary(options2);
            return options2.totalValue;
          }
        };
      }
      return {
        selector,
        aggregator,
        skipEmptyValues
      };
    }));
  }
  _addSortInfo(sortByGroups, groupColumn, selector, sortOrder) {
    if (groupColumn) {
      const {
        groupIndex
      } = groupColumn;
      sortOrder = sortOrder || groupColumn.sortOrder;
      if (isDefined(groupIndex)) {
        sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
        sortByGroups[groupIndex].push({
          selector,
          desc: "desc" === sortOrder
        });
      }
    }
  }
  _findSummaryItem(summaryItems, name2) {
    let summaryItemIndex = -1;
    if (isDefined(name2)) {
      each(summaryItems || [], (function(index) {
        if (this.name === name2 || index === name2 || this.summaryType === name2 || this.column === name2 || (function(summaryItem) {
          const {
            summaryType
          } = summaryItem;
          const {
            column
          } = summaryItem;
          return summaryType && column && `${summaryType}_${column}`;
        })(this) === name2) {
          summaryItemIndex = index;
          return false;
        }
      }));
    }
    return summaryItemIndex;
  }
  _getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems) {
    const that = this;
    const columnsController = that._columnsController;
    const groupColumns = columnsController.getGroupColumns();
    const sortByGroups = [];
    if (!groupSummaryItems || !groupSummaryItems.length) {
      return;
    }
    each(sortByGroupSummaryInfo || [], (function() {
      const {
        sortOrder
      } = this;
      let {
        groupColumn
      } = this;
      const summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
      if (summaryItemIndex < 0) {
        return;
      }
      const selector = function(data17) {
        return getGroupAggregates(data17)[summaryItemIndex];
      };
      if (isDefined(groupColumn)) {
        groupColumn = columnsController.columnOption(groupColumn);
        that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder);
      } else {
        each(groupColumns, ((groupIndex, groupColumn2) => {
          that._addSortInfo(sortByGroups, groupColumn2, selector, sortOrder);
        }));
      }
    }));
    return sortByGroups;
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const that = this;
    const dataSourceAdapter = super._createDataSourceAdapterCore(dataSource, remoteOperations);
    dataSourceAdapter.summaryGetter(((currentRemoteOperations) => that._getSummaryOptions(currentRemoteOperations || remoteOperations)));
    return dataSourceAdapter;
  }
  _getSummaryOptions(remoteOperations) {
    const that = this;
    const groupSummaryItems = that.option("summary.groupItems");
    const totalSummaryItems = that.option("summary.totalItems");
    const sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo");
    const groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary);
    const totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary);
    const sortByGroups = function() {
      return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems);
    };
    if (groupAggregates.length || totalAggregates.length) {
      return {
        groupAggregates,
        totalAggregates,
        sortByGroups
      };
    }
    return;
  }
  publicMethods() {
    const methods = super.publicMethods();
    methods.push("getTotalSummaryValue");
    return methods;
  }
  getTotalSummaryValue(summaryItemName) {
    const summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName);
    const aggregates = this._dataSource.totalAggregates();
    if (aggregates.length && summaryItemIndex > -1) {
      return aggregates[summaryItemIndex];
    }
  }
  optionChanged(args) {
    if ("summary" === args.name || "sortByGroupSummaryInfo" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
  init() {
    this._footerItems = [];
    super.init();
  }
  footerItems() {
    return this._footerItems;
  }
};
var editing3 = (Base) => class extends Base {
  _refreshSummary() {
    if (recalculateWhileEditing(this) && !this.isSaving()) {
      this._dataController.refresh({
        load: true,
        changesOnly: true
      });
    }
  }
  _addChange(params) {
    const result2 = super._addChange.apply(this, arguments);
    if (params.type) {
      this._refreshSummary();
    }
    return result2;
  }
  _removeChange() {
    const result2 = super._removeChange.apply(this, arguments);
    this._refreshSummary();
    return result2;
  }
  cancelEditData() {
    const result2 = super.cancelEditData.apply(this, arguments);
    this._refreshSummary();
    return result2;
  }
};
var rowsView11 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    row && $row.addClass("groupFooter" === row.rowType ? "dx-datagrid-group-footer" : "");
    return $row;
  }
  _renderCells($row, options2) {
    super._renderCells.apply(this, arguments);
    if ("group" === options2.row.rowType && options2.row.summaryCells && options2.row.summaryCells.length) {
      this._renderGroupSummaryCells($row, options2);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options2) {
    return !isDefined(options2.columns[columnIndex].groupIndex) && options2.row.summaryCells[columnIndex].length;
  }
  _getAlignByColumnCellCount(groupCellColSpan, options2) {
    let alignByColumnCellCount = 0;
    for (let i = 1; i < groupCellColSpan; i++) {
      const columnIndex = options2.row.summaryCells.length - i;
      alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options2) ? i : alignByColumnCellCount;
    }
    return alignByColumnCellCount;
  }
  _renderGroupSummaryCells($row, options2) {
    const $groupCell = $row.children().last();
    const groupCellColSpan = Number($groupCell.attr("colSpan")) || 1;
    const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options2);
    this._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    if (alignByColumnCellCount > 0) {
      $groupCell.attr("colSpan", groupCellColSpan - alignByColumnCellCount);
      for (let i = 0; i < alignByColumnCellCount; i++) {
        const columnIndex = options2.columns.length - alignByColumnCellCount + i;
        this._renderCell($groupCell.parent(), extend({
          column: options2.columns[columnIndex],
          columnIndex: this._getSummaryCellIndex(columnIndex, options2.columns)
        }, options2));
      }
    }
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    return columnIndex;
  }
  _getCellTemplate(options2) {
    if (!options2.column.command && !isDefined(options2.column.groupIndex) && options2.summaryItems && options2.summaryItems.length) {
      return renderSummaryCell;
    }
    return super._getCellTemplate(options2);
  }
  _getCellOptions(options2) {
    const that = this;
    const parameters = super._getCellOptions(options2);
    if (options2.row.summaryCells) {
      return extend(parameters, getSummaryCellOptions(that, options2));
    }
    return parameters;
  }
};
m_core_default.registerModule("summary", {
  defaultOptions: () => ({
    summary: {
      groupItems: void 0,
      totalItems: void 0,
      calculateCustomSummary: void 0,
      skipEmptyValues: true,
      recalculateWhileEditing: false,
      texts: {
        sum: message_default.format("dxDataGrid-summarySum"),
        sumOtherColumn: message_default.format("dxDataGrid-summarySumOtherColumn"),
        min: message_default.format("dxDataGrid-summaryMin"),
        minOtherColumn: message_default.format("dxDataGrid-summaryMinOtherColumn"),
        max: message_default.format("dxDataGrid-summaryMax"),
        maxOtherColumn: message_default.format("dxDataGrid-summaryMaxOtherColumn"),
        avg: message_default.format("dxDataGrid-summaryAvg"),
        avgOtherColumn: message_default.format("dxDataGrid-summaryAvgOtherColumn"),
        count: message_default.format("dxDataGrid-summaryCount")
      }
    },
    sortByGroupSummaryInfo: void 0
  }),
  views: {
    footerView: FooterView
  },
  extenders: {
    controllers: {
      data: data13,
      editing: editing3
    },
    views: {
      rowsView: rowsView11
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/dom.js
var addStickyColumnBorderLeftClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
};
var addStickyColumnBorderRightClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
};
var addStickyColumnClass = ($cell, fixedPosition, addWidgetPrefix) => {
  switch (fixedPosition) {
    case StickyPosition.Right:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnRight));
      break;
    case StickyPosition.Sticky:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumn));
      break;
    default:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnLeft));
  }
};
var toggleFirstHeaderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.firstHeader), value2);
};
var toggleColumnNoBorderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.columnNoBorder), value2);
};
var toggleStickyColumnsClass = ($element, hasStickyColumns, addWidgetPrefix) => {
  $element.toggleClass(addWidgetPrefix(CLASSES3.stickyColumns), hasStickyColumns);
};
var isStickyCellPinnedToLeft = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellLeft = parseFloat($cell[0].style.left);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellLeft = cellRect.left - containerRect.left;
  return Math.round(cellLeft) >= Math.round(calculatedCellLeft);
};
var isStickyCellPinnedToRight = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellRight = parseFloat($cell[0].style.right);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellRight = containerRect.right - cellRect.right;
  return Math.round(cellRight) >= Math.round(calculatedCellRight);
};
var isStickyCellPinned = ($cell, $container, addWidgetPrefix) => isStickyCellPinnedToLeft($cell, $container, addWidgetPrefix) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isFixedCellPinnedToRight = ($cell, $container, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isLastLeftFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
var isFirstRightFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
var isStickyCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var isFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var getLeftFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft))));
var getRightFixedCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight))));
var getNonFixedAndStickyCells = ($cells, addWidgetPrefix) => $cells.filter(((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumn)) || !isFixedCell(renderer_default(cell), addWidgetPrefix)));
var getLastLeftFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray() : $cells.toArray().reverse();
  const lastLeftFixedCell = processedCells.find(((cell) => isStickyCellPinnedToLeft(renderer_default(cell), $container, addWidgetPrefix) || isLastLeftFixedCell(renderer_default(cell), addWidgetPrefix)));
  return renderer_default(lastLeftFixedCell ?? "");
};
var getFirstRightFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray().reverse() : $cells.toArray();
  const firstRightFixedCell = processedCells.find(((cell) => isStickyCellPinnedToRight(renderer_default(cell), $container, addWidgetPrefix) || isFirstRightFixedCell(renderer_default(cell), addWidgetPrefix)));
  return renderer_default(firstRightFixedCell ?? "");
};
var getNonFixedAreaBoundingRect = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const result2 = {
    left: containerRect.left,
    right: containerRect.right
  };
  if (null !== $cells && void 0 !== $cells && $cells.length) {
    const $lastLeftFixedCell = getLastLeftFixedCell($cells, $container, addWidgetPrefix);
    const $firstRightFixedCell = getFirstRightFixedCell($cells, $container, addWidgetPrefix);
    if (null !== $lastLeftFixedCell && void 0 !== $lastLeftFixedCell && $lastLeftFixedCell.length) {
      result2.left = Math.round(getBoundingRect($lastLeftFixedCell[0]).right);
    }
    if (null !== $firstRightFixedCell && void 0 !== $firstRightFixedCell && $firstRightFixedCell.length) {
      result2.right = Math.round(getBoundingRect($firstRightFixedCell[0]).left);
    }
  }
  return result2;
};
var noNeedToCreateResizingPoint = (that, _ref, addWidgetPrefix) => {
  let {
    point,
    column,
    nextColumn
  } = _ref;
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const offsetX = Math.round(point.x);
  const rtlEnabled = that.option("rtlEnabled");
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const $cells = renderer_default(that.getColumnElements() ?? "");
  const $container = renderer_default(that.getContent());
  const isFixedPoint = (null === column || void 0 === column ? void 0 : column.fixed) && (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.fixed);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isFixedPoint || isFixedEdge(point, column, nextColumn)) {
    return false;
  }
  if (isSplitPoint) {
    if (isLastLeftFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
      return isLeftBoundary;
    }
    if (isFirstRightFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
      return isRightBoundary;
    }
  }
  const isOutsideVisibleArea2 = offsetX < nonFixedAreaBoundingRect.left || offsetX > nonFixedAreaBoundingRect.right;
  const isPointBoundary = offsetX === nonFixedAreaBoundingRect.left || offsetX === nonFixedAreaBoundingRect.right;
  const isLastOrFirstPoint = rtlEnabled ? 0 === point.index : point.index === $cells.length;
  return isOutsideVisibleArea2 || !isLastOrFirstPoint && isPointBoundary;
};
var noNeedToCreateReorderingPoint = (point, $cells, $container, addWidgetPrefix) => {
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const pointX = Math.round(point.x);
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isLeftBoundary;
  }
  if (isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isRightBoundary;
  }
  return pointX < nonFixedAreaBoundingRect.left || pointX > nonFixedAreaBoundingRect.right;
};
var doesGroupCellEndInFirstColumn = ($groupCell) => {
  const $groupRow = $groupCell.parent();
  const commandColumns = $groupRow.children().filter(((i) => i < $groupCell.index()));
  const groupColSpanWithoutCommand = $groupCell.attr("colspan") - commandColumns.length;
  return 1 === groupColSpanWithoutCommand;
};
var getScrollPadding = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return {
    left: nonFixedAreaBoundingRect.left - containerRect.left,
    right: containerRect.right - nonFixedAreaBoundingRect.right
  };
};
var isOutsideVisibleArea = ($element, $cells, $container, addWidgetPrefix) => {
  const elementRect = getBoundingRect($element.get(0));
  const elementRectLeft = Math.round(elementRect.left);
  const elementRectRight = Math.round(elementRect.right);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return elementRectLeft < nonFixedAreaBoundingRect.left || elementRectRight > nonFixedAreaBoundingRect.right;
};
var isLastCell = ($cell) => {
  if (!$cell.is("td")) {
    return false;
  }
  const $lastCell = $cell.parent().children().last();
  return $cell[0] === $lastCell[0];
};
var needToSkipHeaderCell = ($cell) => !$cell.is("[tabindex]");
var getNextHeaderCell = function($cell) {
  let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "next";
  let $nextCell = $cell;
  let $nextRow = $cell.parent();
  do {
    $nextCell = "next" === direction ? $nextCell.next() : $nextCell.prev();
    if (!$nextCell.length) {
      $nextRow = "next" === direction ? $nextRow.next() : $nextRow.prev();
      if ($nextRow.length) {
        $nextCell = "next" === direction ? $nextRow.children().first() : $nextRow.children().last();
      }
    }
  } while ($nextCell.length && needToSkipHeaderCell($nextCell));
  return $nextCell;
};
var GridCoreStickyColumnsDom = {
  toggleFirstHeaderClass,
  toggleColumnNoBorderClass,
  addStickyColumnClass,
  addStickyColumnBorderLeftClass,
  addStickyColumnBorderRightClass,
  doesGroupCellEndInFirstColumn,
  toggleStickyColumnsClass,
  getLeftFixedCells,
  getRightFixedCells,
  getNonFixedAndStickyCells,
  getScrollPadding,
  getNextHeaderCell,
  noNeedToCreateResizingPoint,
  isFixedCellPinnedToRight,
  noNeedToCreateReorderingPoint,
  isFixedCell,
  isStickyCell,
  isStickyCellPinned,
  isOutsideVisibleArea,
  isLastCell
};

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/m_sticky_columns.js
var baseStickyColumns = (Base) => class extends Base {
  _addStickyColumnBorderLeftClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isFirstFixedCell = isFirstFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isFirstFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderLeftClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  _addStickyColumnBorderRightClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isLastFixedCell = isLastFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isLastFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  updateBorderCellClasses($cell, column, rowIndex) {
    const columnsController = this._columnsController;
    const isRowsView = "rowsView" === this.name;
    const needToRemoveBorder = needToRemoveColumnBorder(columnsController, column, rowIndex, isRowsView);
    const isFirstColumn = null === columnsController || void 0 === columnsController ? void 0 : columnsController.isFirstColumn(column, rowIndex);
    GridCoreStickyColumnsDom.toggleColumnNoBorderClass($cell, needToRemoveBorder, this.addWidgetPrefix.bind(this));
    GridCoreStickyColumnsDom.toggleFirstHeaderClass($cell, isFirstColumn, this.addWidgetPrefix.bind(this));
  }
  _updateBorderClasses() {
    const isColumnHeadersView = "columnHeadersView" === this.name;
    const $rows = this._getRowElementsCore().not(`.${CLASSES5.detailRow}`).toArray();
    $rows.forEach(((row, index) => {
      const rowIndex = isColumnHeadersView ? index : null;
      const $cells = renderer_default(row).children("td").toArray();
      let columns7 = this.getColumns(rowIndex);
      columns7 = processFixedColumns(this._columnsController, columns7);
      $cells.forEach(((cell, cellIndex) => {
        const $cell = renderer_default(cell);
        const column = columns7[cellIndex];
        if (column.visibleWidth !== HIDDEN_COLUMNS_WIDTH) {
          this.updateBorderCellClasses($cell, column, rowIndex);
        }
      }));
    }));
  }
  _renderCore(options2) {
    const deferred = super._renderCore(options2);
    const $element = this.element();
    const hasStickyColumns = this.hasStickyColumns();
    GridCoreStickyColumnsDom.toggleStickyColumnsClass($element, hasStickyColumns, this.addWidgetPrefix.bind(this));
    if (hasStickyColumns) {
      return deferred.done((() => {
        this.setStickyOffsets();
      }));
    }
    return deferred;
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const {
      rowType
    } = options2;
    const $cell = super._createCell(options2);
    const hasStickyColumns = this.hasStickyColumns();
    const rowIndex = "header" === rowType ? options2.rowIndex : null;
    const isSummary = "groupFooter" === rowType || "totalFooter" === rowType || "group" === rowType;
    const isExpandColumn = column.command && "expand" === column.command;
    if (hasStickyColumns && !needToDisableStickyColumn(this._columnsController, column)) {
      this.updateBorderCellClasses($cell, column, rowIndex);
      if (column.fixed) {
        const fixedPosition = getColumnFixedPosition(this._columnsController, column);
        GridCoreStickyColumnsDom.addStickyColumnClass($cell, fixedPosition, this.addWidgetPrefix.bind(this));
        if (!isSummary && !isExpandColumn) {
          switch (fixedPosition) {
            case StickyPosition.Right:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, false, StickyPosition.Right);
              break;
            case StickyPosition.Sticky:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, true);
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, true);
              break;
            default:
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, false, StickyPosition.Left);
          }
        }
      }
    }
    return $cell;
  }
  setStickyOffsets(rowIndex, offsets) {
    const columnsController = this._columnsController;
    const rtlEnabled = this.option("rtlEnabled");
    const showColumnHeaders = this.option("showColumnHeaders");
    let widths = this.getColumnWidths(void 0, rowIndex);
    let columns7 = this.getColumns(showColumnHeaders ? rowIndex : void 0);
    columns7 = processFixedColumns(this._columnsController, columns7);
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    columns7.forEach(((column, columnIndex) => {
      if (column.fixed) {
        const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
        const offset = getStickyOffset(columnsController, columns7, widths, columnIndex, offsets);
        if (offsets) {
          offsets[column.index] = offset;
        }
        const styleProps = normalizeOffset(offset);
        this.setCellProperties(styleProps, visibleColumnIndex, rowIndex);
      }
    }));
  }
  setColumnWidths(options2) {
    const hasStickyColumns = this.hasStickyColumns();
    const columnsResizerController = this.getController("columnsResizer");
    const isColumnResizing = null === columnsResizerController || void 0 === columnsResizerController ? void 0 : columnsResizerController.isResizing();
    super.setColumnWidths(options2);
    if (hasStickyColumns && isColumnResizing) {
      this.setStickyOffsets();
    }
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    const adaptiveColumns2 = this.getController("adaptiveColumns");
    const hidingColumnsQueue = null === adaptiveColumns2 || void 0 === adaptiveColumns2 ? void 0 : adaptiveColumns2.getHidingColumnsQueue();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this.setStickyOffsets();
      if (null !== hidingColumnsQueue && void 0 !== hidingColumnsQueue && hidingColumnsQueue.length) {
        this._updateBorderClasses();
      }
    }
  }
  hasStickyColumns() {
    var _this$_columnsControl;
    const stickyColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getStickyColumns();
    return true !== this.option("columnFixing.legacyMode") && !!stickyColumns.length;
  }
};
var columnHeadersView6 = (Base) => class extends baseStickyColumns(Base) {
  setStickyOffsets() {
    const offsets = {};
    const rows = this._getRows();
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      var _rows$rowIndex;
      const isFilterRow = "filter" === (null === rows || void 0 === rows || null === (_rows$rowIndex = rows[rowIndex]) || void 0 === _rows$rowIndex ? void 0 : _rows$rowIndex.rowType);
      super.setStickyOffsets(rowIndex, isFilterRow ? void 0 : offsets);
    }
  }
  getContextMenuItems(options2) {
    const {
      column
    } = options2;
    const columnsController = this._columnsController;
    const columnFixingOptions = this.option("columnFixing");
    let items = super.getContextMenuItems(options2);
    if (options2.row && "header" === options2.row.rowType) {
      if (true === columnFixingOptions.enabled && column && column.allowFixing) {
        const onItemClick = (params) => {
          switch (params.itemData.value) {
            case "none":
              this._columnsController.columnOption(column.index, "fixed", false);
              break;
            case "left":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "left"
              });
              break;
            case "right":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "right"
              });
              break;
            case "sticky":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "sticky"
              });
          }
        };
        const fixedPositionItems = [{
          text: columnFixingOptions.texts.leftPosition,
          icon: columnFixingOptions.icons.leftPosition,
          value: "left",
          disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
          onItemClick
        }, {
          text: columnFixingOptions.texts.rightPosition,
          icon: columnFixingOptions.icons.rightPosition,
          value: "right",
          disabled: column.fixed && "right" === column.fixedPosition,
          onItemClick
        }];
        if (true !== this.option("columnFixing.legacyMode") && !columnsController.isVirtualMode()) {
          fixedPositionItems.push({
            text: columnFixingOptions.texts.stickyPosition,
            icon: columnFixingOptions.icons.stickyPosition,
            value: "sticky",
            disabled: column.fixed && column.fixedPosition === StickyPosition.Sticky,
            onItemClick
          });
        }
        items = items || [];
        items.push({
          text: columnFixingOptions.texts.fix,
          icon: columnFixingOptions.icons.fix,
          beginGroup: true,
          items: fixedPositionItems
        }, {
          text: columnFixingOptions.texts.unfix,
          icon: columnFixingOptions.icons.unfix,
          value: "none",
          disabled: !column.fixed,
          onItemClick
        });
      }
    }
    return items;
  }
};
var rowsView12 = (Base) => class extends baseStickyColumns(Base) {
  _getMasterDetailWidth() {
    const componentWidth = getWidth(this.component.$element()) ?? 0;
    const borderWidth = m_utils_default.getComponentBorderWidth(this, this._$element);
    return componentWidth - borderWidth - this.getScrollbarWidth();
  }
  _renderMasterDetailCell($row, row, options2) {
    const $detailCell = super._renderMasterDetailCell($row, row, options2);
    if (this.hasStickyColumns()) {
      const detailContainerSelector = `.${this.addWidgetPrefix(CLASSES5.detailContainer)}`;
      const $detailContainer = $detailCell.find(detailContainerSelector);
      $detailContainer.addClass(this.addWidgetPrefix(CLASSES3.stickyColumnLeft));
      setWidth($detailContainer, this._getMasterDetailWidth());
    }
    return $detailCell;
  }
  _updateMasterDetailWidths() {
    const $detailContainers = this._getRowElements().children(`.${CLASSES5.detailCell}`).children(`.${this.addWidgetPrefix(CLASSES5.detailContainer)}`);
    const width = this._getMasterDetailWidth();
    setWidth($detailContainers, `${width}px`);
  }
  setStickyOffsets(rowIndex, offsets) {
    super.setStickyOffsets(rowIndex, offsets);
    this.setStickyOffsetsForGroupCells();
  }
  setStickyOffsetsForGroupCells() {
    const groupColumns = this._columnsController.getGroupColumns();
    let columns7 = this.getColumns();
    let widths = this.getColumnWidths();
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(columns7);
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    const $tableElement = this.getTableElement();
    groupColumns.forEach(((column) => {
      const columnIndex = columnsCountBeforeGroups + column.groupIndex + 1;
      const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
      const offset = getStickyOffset(this._columnsController, columns7, widths, visibleColumnIndex);
      const styleProps = normalizeOffset(offset);
      const $cells = $tableElement.children().children(".dx-group-row").find(`.dx-group-cell[aria-colindex='${columnIndex + 1}']`);
      for (let i = 0; i < $cells.length; i += 1) {
        const cell = $cells.get(i);
        const container = renderer_default(cell).find(".dx-datagrid-group-row-container").get(0);
        Object.assign(cell.style, styleProps);
        Object.assign(container.style, styleProps);
      }
    }));
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this._updateMasterDetailWidths();
    }
  }
  _renderCellContent($cell, options2, renderOptions) {
    const hasStickyColumns = this.hasStickyColumns();
    const isGroupRowResult = isGroupRow(options2);
    const isDetailRowResult = isDetailRow(options2);
    const needWrapContent = isGroupRowResult || isDetailRowResult;
    if (!hasStickyColumns || !needWrapContent) {
      return super._renderCellContent($cell, options2, renderOptions);
    }
    const $container = renderer_default("<div>").toggleClass(this.addWidgetPrefix(CLASSES3.groupRowContainer), isGroupRowResult).toggleClass(this.addWidgetPrefix(CLASSES5.detailContainer), isDetailRowResult).appendTo($cell);
    return super._renderCellContent($container, options2, renderOptions);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    super._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
    const stickySummarySelector = `.${this.addWidgetPrefix(CLASSES3.stickyColumn)}`;
    if ($groupCell.parent().find(stickySummarySelector).length && GridCoreStickyColumnsDom.doesGroupCellEndInFirstColumn($groupCell)) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($groupCell, this.addWidgetPrefix.bind(this));
    }
  }
  _handleScroll(e) {
    const hasStickyColumns = this.hasStickyColumns();
    super._handleScroll(e);
    if (hasStickyColumns) {
      const editorFactoryController = this.getController("editorFactory");
      const hasOverlayElements = editorFactoryController.hasOverlayElements();
      if (hasOverlayElements) {
        const $focusedElement = editorFactoryController.focus();
        editorFactoryController.focus($focusedElement);
      }
    }
  }
  _scrollToElement($element, offset) {
    let scrollOffset = offset;
    const scrollable = this.getScrollable();
    const hasStickyColumns = this.hasStickyColumns();
    if (hasStickyColumns && scrollable) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      if (!$element.is("td") || isFixedCell2) {
        return;
      }
      const $row = null === $element || void 0 === $element ? void 0 : $element.closest("tr");
      const $cells = null === $row || void 0 === $row ? void 0 : $row.children();
      scrollOffset = GridCoreStickyColumnsDom.getScrollPadding($cells, renderer_default(scrollable.container()), this.addWidgetPrefix.bind(this));
    }
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView = (Base) => class extends baseStickyColumns(Base) {
};
var columnsResizer2 = (Base) => class extends Base {
  getSeparatorOffsetX($cell) {
    var _this$_columnHeadersV;
    const hasStickyColumns = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.hasStickyColumns();
    if (hasStickyColumns) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
      const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
      if (isWidgetResizingMode && isFixedCellPinnedToRight2) {
        var _$cell$offset;
        return (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
      }
    }
    return super.getSeparatorOffsetX($cell);
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    const columnIndex = Math.max(point.index - 1, 0);
    const column = columns7[columnIndex];
    const nextColumnIndex = this._getNextColumnIndex(columnIndex);
    const nextColumn = columns7[nextColumnIndex];
    if (isWidgetResizingMode && !isFixedEdge(point, column, nextColumn)) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight(renderer_default(point.item), $container, this.addWidgetPrefix.bind(this));
      if (isFixedCellPinnedToRight2) {
        point.columnIndex -= rtlEnabled ? 1 : 0;
        return;
      }
    }
    super._correctColumnIndexForPoint(point, correctionValue, columns7);
  }
  _needToInvertResizing($cell) {
    const result2 = super._needToInvertResizing($cell);
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    if (!result2 && isWidgetResizingMode) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      return GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
  _generatePointsByColumns() {
    var _this$_columnHeadersV2;
    const hasStickyColumns = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.hasStickyColumns();
    super._generatePointsByColumns(hasStickyColumns);
  }
  _pointCreated(point, cellsLength, columns7) {
    var _this$_columnHeadersV3;
    const hasStickyColumns = null === (_this$_columnHeadersV3 = this._columnHeadersView) || void 0 === _this$_columnHeadersV3 ? void 0 : _this$_columnHeadersV3.hasStickyColumns();
    const result2 = super._pointCreated(point, cellsLength, columns7);
    const needToCheckPoint = hasStickyColumns && cellsLength > 0;
    if (needToCheckPoint && !result2) {
      const column = columns7[point.index - 1];
      const nextColumnIndex = this._getNextColumnIndex(point.index - 1);
      const nextColumn = columns7[nextColumnIndex];
      return GridCoreStickyColumnsDom.noNeedToCreateResizingPoint(this._columnHeadersView, {
        point,
        column,
        nextColumn
      }, this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
};
var draggingHeader = (Base) => class extends Base {
  _generatePointsByColumns(options2) {
    var _this$_columnHeadersV4;
    const hasStickyColumns = null === (_this$_columnHeadersV4 = this._columnHeadersView) || void 0 === _this$_columnHeadersV4 ? void 0 : _this$_columnHeadersV4.hasStickyColumns();
    const {
      sourceLocation,
      sourceColumn,
      targetDraggingPanel
    } = options2;
    const isDraggingBetweenHeaders = "headers" === sourceLocation && "headers" === (null === targetDraggingPanel || void 0 === targetDraggingPanel ? void 0 : targetDraggingPanel.getName());
    if (hasStickyColumns && isDraggingBetweenHeaders) {
      const columnFixedPosition = getColumnFixedPosition(this._columnsController, sourceColumn);
      switch (true) {
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Left):
          options2.columnElements = GridCoreStickyColumnsDom.getLeftFixedCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
          break;
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Right):
          options2.columnElements = GridCoreStickyColumnsDom.getRightFixedCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
          break;
        default:
          options2.columnElements = GridCoreStickyColumnsDom.getNonFixedAndStickyCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
      }
    }
    return super._generatePointsByColumns(options2, hasStickyColumns);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    const $cells = this._columnHeadersView.getColumnElements();
    const needToCheckPoint = hasStickyColumns && "headers" === location && (null === $cells || void 0 === $cells ? void 0 : $cells.length) && (!sourceColumn.fixed || sourceColumn.fixedPosition === StickyPosition.Sticky);
    const result2 = super._pointCreated(point, columns7, location, sourceColumn);
    if (needToCheckPoint && !result2) {
      return GridCoreStickyColumnsDom.noNeedToCreateReorderingPoint(point, $cells, renderer_default(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
};
var editorFactory2 = (Base) => class extends Base {
  getOverlayContainerIfNeeded($cell) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this));
    if (hasFixedColumns && isFixedCell2) {
      return $cell.closest(`.${this.addWidgetPrefix(CLASSES3.stickyColumns)}`);
    }
    return;
  }
  updateFocusOverlaySize($element, position2) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (!hasFixedColumns) {
      super.updateFocusOverlaySize($element, position2);
    }
  }
  getFocusOverlaySize($element) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (hasFixedColumns) {
      const elementRect = getBoundingRect($element.get(0));
      const isLastCell2 = GridCoreStickyColumnsDom.isLastCell($element);
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      return {
        width: elementRect.right - elementRect.left + (isLastCell2 || isFixedCell2 ? 0 : 1),
        height: elementRect.bottom - elementRect.top
      };
    }
    return super.getFocusOverlaySize($element);
  }
  getValidationMessageContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getValidationMessageContainer($cell);
  }
  getRevertButtonContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getRevertButtonContainer($cell);
  }
  getFocusOverlayContainer($focusedElement) {
    return this.getOverlayContainerIfNeeded($focusedElement) ?? super.getFocusOverlayContainer($focusedElement);
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    const columnHeaders = this.getView("columnHeadersView");
    const hasStickyColumns = columnHeaders.hasStickyColumns();
    super.overlayPositionedHandler(e, isOverlayVisible);
    if (hasStickyColumns) {
      const $cell = renderer_default(e.element).closest("td");
      if (!GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this))) {
        const $wrapper = e.component.$wrapper();
        const $overlayContent = e.component.$content();
        const isOutsideVisibleArea2 = GridCoreStickyColumnsDom.isOutsideVisibleArea($overlayContent, renderer_default(columnHeaders.getColumnElements()), renderer_default(columnHeaders.getContent()), this.addWidgetPrefix.bind(this));
        $wrapper.css("zIndex", isOutsideVisibleArea2 ? 1 : (null === this || void 0 === this ? void 0 : this.getOverlayBaseZIndex()) ?? 0);
      }
    }
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (!isHideBorder) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, isFixedCell2);
      const isGroupElement = isGroupRow2($element);
      const isGroupFooterRowElement = isGroupFooterRow($element);
      const isAdaptiveElement = isAdaptiveItem($element);
      if (isFixedCell2 || isGroupElement || isGroupFooterRowElement || isAdaptiveElement) {
        this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, true);
      }
    }
    super.updateFocusOverlay($element, isHideBorder);
  }
};
var resizing4 = (Base) => class extends Base {
  resize() {
    const result2 = super.resize();
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    if (hasStickyColumns && null !== this && void 0 !== this && this.hasResizeTimeout()) {
      this._rowsView.setStickyOffsets();
    }
    return result2;
  }
};
var keyboardNavigation = (Base) => class extends Base {
  headerTabKeyHandler(_ref) {
    var _this$_columnHeadersV5, _this$_rowsView;
    let {
      originalEvent,
      shift
    } = _ref;
    const hasStickyColumns = null === (_this$_columnHeadersV5 = this._columnHeadersView) || void 0 === _this$_columnHeadersV5 ? void 0 : _this$_columnHeadersV5.hasStickyColumns();
    const scrollable = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.getScrollable();
    if (hasStickyColumns && scrollable) {
      const $cell = renderer_default(originalEvent.target).closest("td");
      const $nextCell = GridCoreStickyColumnsDom.getNextHeaderCell($cell, shift ? "previous" : "next");
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($nextCell, this.addWidgetPrefix.bind(this));
      if ($nextCell.length && !isFixedCell2) {
        const $cells = renderer_default(this._columnHeadersView.getColumnElements());
        const cellIsOutsideVisibleArea = GridCoreStickyColumnsDom.isOutsideVisibleArea($nextCell, $cells, renderer_default(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this));
        if (cellIsOutsideVisibleArea) {
          const scrollPadding = GridCoreStickyColumnsDom.getScrollPadding($cells, renderer_default(scrollable.container()), this.addWidgetPrefix.bind(this));
          const scrollPosition = getElementLocationInternal($nextCell[0], "horizontal", renderer_default(this._columnHeadersView.getContent())[0], scrollable.scrollOffset(), scrollPadding, this.addWidgetPrefix("table"));
          scrollable.scrollTo({
            x: scrollPosition
          });
        }
      }
    }
  }
};
var stickyColumnsModule = {
  extenders: {
    views: {
      columnHeadersView: columnHeadersView6,
      rowsView: rowsView12,
      footerView
    },
    controllers: {
      columnsResizer: columnsResizer2,
      draggingHeader,
      editorFactory: editorFactory2,
      resizing: resizing4,
      keyboardNavigation
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sticky_columns.js
m_core_default.registerModule("stickyColumns", stickyColumnsModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_fixing/m_column_fixing.js
var DETAIL_ROW_CLASS2 = "dx-master-detail-row";
var getTransparentColumnIndex = function(fixedColumns) {
  let transparentColumnIndex = -1;
  each(fixedColumns, ((index, column) => {
    if ("transparent" === column.command) {
      transparentColumnIndex = index;
      return false;
    }
    return;
  }));
  return transparentColumnIndex;
};
var normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
  let fixedColumnIndex = 0;
  if (fixedColumns && widths && fixedWidths) {
    for (let i = 0; i < fixedColumns.length; i++) {
      if ("transparent" === fixedColumns[i].command) {
        fixedColumnIndex += fixedColumns[i].colspan;
      } else {
        if (widths[fixedColumnIndex] < fixedWidths[i]) {
          widths[fixedColumnIndex] = fixedWidths[i];
        }
        fixedColumnIndex++;
      }
    }
  }
  return widths;
};
var baseFixedColumns = (Base) => class extends Base {
  init() {
    super.init();
    this._isFixedTableRendering = false;
    this._isFixedColumns = false;
  }
  _createCol(column) {
    return super._createCol(column).toggleClass("dx-col-fixed", !!(this._isFixedTableRendering && (column.fixed || column.command && "transparent" !== column.command)));
  }
  isIndicesArray(arr) {
    return Array.isArray(arr) && arr.length > 0;
  }
  _correctColumnIndicesForFixedColumns(fixedColumns, change) {
    var _change$items;
    const columnIndicesArray = null === change || void 0 === change ? void 0 : change.columnIndices;
    if (!this.isIndicesArray(columnIndicesArray)) {
      return;
    }
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColspan = fixedColumns[transparentColumnIndex].colspan;
    const transparentOffset = transparentColumnIndex + transparentColspan;
    const rowTypes = null === change || void 0 === change || null === (_change$items = change.items) || void 0 === _change$items ? void 0 : _change$items.map(((_ref) => {
      let {
        rowType
      } = _ref;
      return rowType;
    }));
    change.columnIndices = columnIndicesArray.map(((columnIndices, idx) => {
      if (!this.isIndicesArray(columnIndices)) {
        return columnIndices;
      }
      const isGroupRow3 = rowTypes && "group" === rowTypes[idx];
      if (isGroupRow3) {
        return [...columnIndices];
      }
      return columnIndices.reduce(((result2, colIdx) => {
        switch (true) {
          case colIdx < transparentColumnIndex:
            result2.push(colIdx);
            break;
          case colIdx >= transparentOffset:
            result2.push(colIdx - transparentColspan + 1);
        }
        return result2;
      }), []);
    }));
  }
  _partialUpdateFixedTable(fixedColumns, rows) {
    const fixedTableElement = this._fixedTableElement;
    const $rows = this._getRowElementsCore(fixedTableElement);
    const $colgroup = fixedTableElement.children("colgroup");
    $colgroup.replaceWith(this._createColGroup(fixedColumns));
    for (let i = 0; i < rows.length; i++) {
      this._partialUpdateFixedRow(renderer_default($rows[i]), fixedColumns, rows[i]);
    }
  }
  _partialUpdateFixedRow($row, fixedColumns, row) {
    const cellElements = $row.get(0).childNodes;
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColumn = fixedColumns[transparentColumnIndex];
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    let groupCellOptions;
    let colIndex = columnIndexOffset + 1;
    let {
      colspan
    } = transparentColumn;
    if ($row.hasClass(DETAIL_ROW_CLASS2)) {
      var _this$_columnsControl;
      cellElements[0].setAttribute("colspan", null === (_this$_columnsControl = this._columnsController.getVisibleColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length);
      return;
    }
    if ($row.hasClass("dx-group-row")) {
      groupCellOptions = this._getGroupCellOptions({
        row,
        columns: this._columnsController.getVisibleColumns()
      });
      const hasSummary = row.summaryCells.length > 0;
      if (hasSummary) {
        const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellOptions.colspan, {
          columns: this._columnsController.getVisibleColumns(),
          row,
          isFixed: true
        });
        colspan = groupCellOptions.colspan - alignByColumnCellCount;
      } else {
        colspan = groupCellOptions.colspan - Math.max(0, cellElements.length - (groupCellOptions.columnIndex + 2));
      }
    }
    for (let j = 0; j < cellElements.length; j++) {
      const needUpdateColspan = groupCellOptions ? j === groupCellOptions.columnIndex + 1 : j === transparentColumnIndex;
      cellElements[j].setAttribute("aria-colindex", colIndex);
      if (needUpdateColspan) {
        cellElements[j].setAttribute("colspan", colspan);
        colIndex += colspan;
      } else {
        colIndex++;
      }
    }
  }
  _renderTable(options2) {
    let $fixedTable;
    const fixedColumns = this.getFixedColumns();
    this._isFixedColumns = this.isFixedColumns();
    const $table = super._renderTable(options2);
    if (this._isFixedColumns) {
      var _change$items2;
      const change = null === options2 || void 0 === options2 ? void 0 : options2.change;
      const $fixedDataRows = this._getRowElements(this._fixedTableElement);
      const needPartialUpdate = (null === change || void 0 === change ? void 0 : change.virtualColumnsScrolling) && $fixedDataRows.length === (null === change || void 0 === change || null === (_change$items2 = change.items) || void 0 === _change$items2 ? void 0 : _change$items2.length);
      this._isFixedTableRendering = true;
      if (needPartialUpdate && true !== this.option("scrolling.legacyMode")) {
        var _options$change;
        this._partialUpdateFixedTable(fixedColumns, null === options2 || void 0 === options2 || null === (_options$change = options2.change) || void 0 === _options$change ? void 0 : _options$change.items);
        this._isFixedTableRendering = false;
      } else {
        const columnIndices = null === change || void 0 === change ? void 0 : change.columnIndices;
        this._correctColumnIndicesForFixedColumns(fixedColumns, change);
        $fixedTable = this._createTable(fixedColumns);
        this._renderRows($fixedTable, extend({}, options2, {
          columns: fixedColumns
        }));
        this._updateContent($fixedTable, change, true);
        if (columnIndices) {
          change.columnIndices = columnIndices;
        }
        this._isFixedTableRendering = false;
      }
    } else {
      this._fixedTableElement && this._fixedTableElement.parent().remove();
      this._fixedTableElement = null;
    }
    return $table;
  }
  _renderRow($table, options2) {
    let fixedCorrection;
    let {
      cells
    } = options2.row;
    super._renderRow.apply(this, arguments);
    if (this._isFixedTableRendering && cells && cells.length) {
      fixedCorrection = 0;
      const fixedCells = options2.row.cells || [];
      cells = cells.slice();
      options2.row.cells = cells;
      for (let i = 0; i < fixedCells.length; i++) {
        if (fixedCells[i].column && "transparent" === fixedCells[i].column.command) {
          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;
          continue;
        }
        cells[i + fixedCorrection] = fixedCells[i];
      }
    }
  }
  _createCell(options2) {
    const that = this;
    const {
      column
    } = options2;
    const columnCommand = column && column.command;
    const {
      rowType
    } = options2;
    const $cell = super._createCell.apply(that, arguments);
    let fixedColumns;
    let prevFixedColumn;
    let transparentColumnIndex;
    if (that._isFixedTableRendering || "filter" === rowType) {
      fixedColumns = that.getFixedColumns();
      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];
    }
    if (that._isFixedTableRendering) {
      if ("transparent" === columnCommand) {
        $cell.addClass("dx-pointer-events-none").toggleClass("dx-first-cell", 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass("dx-last-cell", fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);
        if ("freeSpace" !== rowType) {
          m_utils_default.setEmptyText($cell);
        }
      }
    } else if ("filter" === rowType) {
      $cell.toggleClass("dx-first-cell", options2.columnIndex === transparentColumnIndex);
    }
    const isRowAltStyle = that.option("rowAlternationEnabled") && options2.isAltRow;
    const isSelectAllCell = "multiple" === that.option("selection.mode") && 0 === options2.columnIndex && "header" === options2.rowType;
    if (browser_default.mozilla && options2.column.fixed && "group" !== options2.rowType && !isRowAltStyle && !isSelectAllCell) {
      $cell.addClass("dx-col-fixed");
    }
    return $cell;
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = super._wrapTableInScrollContainer.apply(this, arguments);
    if (this._isFixedTableRendering || isFixedTableRendering) {
      $scrollContainer.addClass(this.addWidgetPrefix("content-fixed"));
    }
    return $scrollContainer;
  }
  _renderCellContent($cell, options2) {
    let isEmptyCell;
    const {
      column
    } = options2;
    const isFixedTableRendering = this._isFixedTableRendering;
    const isGroupCell = "group" === options2.rowType && isDefined(column.groupIndex);
    if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {
      $cell.css("pointerEvents", "none");
    }
    if (!isFixedTableRendering && this._isFixedColumns) {
      isEmptyCell = column.fixed || column.command && false !== column.fixed;
      if (isGroupCell) {
        isEmptyCell = false;
        if (options2.row.summaryCells && options2.row.summaryCells.length) {
          var _this$_getAlignByColu;
          const columns7 = this._columnsController.getVisibleColumns();
          const alignByFixedColumnCellCount = (null === (_this$_getAlignByColu = this._getAlignByColumnCellCount) || void 0 === _this$_getAlignByColu ? void 0 : _this$_getAlignByColu.call(this, column.colspan, {
            columns: columns7,
            row: options2.row,
            isFixed: true
          })) ?? 0;
          if (alignByFixedColumnCellCount > 0) {
            const transparentColumnIndex = getTransparentColumnIndex(this._columnsController.getFixedColumns());
            isEmptyCell = columns7.length - alignByFixedColumnCellCount < transparentColumnIndex;
          }
        }
      }
      if (isEmptyCell) {
        if (column.command && "buttons" !== column.type || "group" === options2.rowType) {
          $cell.html("&nbsp;").addClass(column.cssClass);
          return;
        }
        $cell.addClass("dx-hidden-cell");
      }
    }
    if ("transparent" !== column.command) {
      super._renderCellContent.apply(this, arguments);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_fixedTableElem;
    return isFixedTableRendering ? null === (_this$_fixedTableElem = this._fixedTableElement) || void 0 === _this$_fixedTableElem ? void 0 : _this$_fixedTableElem.parent() : super.getContent.apply(this, arguments);
  }
  _getCellElementsCore(rowIndex) {
    const cellElements = super._getCellElementsCore.apply(this, arguments);
    const isGroupRow3 = null === cellElements || void 0 === cellElements ? void 0 : cellElements.parent().hasClass("dx-group-row");
    const headerRowIndex = "columnHeadersView" === this.name ? rowIndex : void 0;
    if (this._fixedTableElement && cellElements) {
      const fixedColumns = this.getFixedColumns(headerRowIndex);
      const fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children("td");
      each(fixedCellElements, ((columnIndex, cell) => {
        if (isGroupRow3) {
          if (cellElements[columnIndex] && "hidden" !== cell.style.visibility) {
            cellElements[columnIndex] = cell;
          }
        } else {
          const fixedColumn = fixedColumns[columnIndex];
          if (fixedColumn) {
            if ("transparent" === fixedColumn.command) {
              if (fixedCellElements.eq(columnIndex).hasClass("dx-master-detail-cell")) {
                cellElements[columnIndex] = cell || cellElements[columnIndex];
              }
            } else {
              const fixedColumnIndex = this._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);
              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];
            }
          }
        }
      }));
    }
    return cellElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const result2 = super.getColumnWidths(fixedTableElement, rowIndex);
    const fixedColumns = this.getFixedColumns();
    const fixedWidths = this._fixedTableElement && result2.length ? super.getColumnWidths(this._fixedTableElement) : void 0;
    return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
  }
  getTableElement(isFixedTableRendering) {
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    const tableElement = isFixedTableRendering ? this._fixedTableElement : super.getTableElement();
    return tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      this._fixedTableElement = tableElement.addClass("dx-pointer-events-none");
    } else {
      super.setTableElement(tableElement);
    }
  }
  getColumns(rowIndex) {
    const $tableElement = this.getTableElement();
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super.getColumns(rowIndex, $tableElement);
  }
  getRowIndex($row) {
    const $fixedTable = this._fixedTableElement;
    if ($fixedTable && $fixedTable.find($row).length) {
      return this._getRowElements($fixedTable).index($row);
    }
    return super.getRowIndex($row);
  }
  getTableElements() {
    let result2 = super.getTableElements.apply(this, arguments);
    if (this._fixedTableElement) {
      result2 = renderer_default([result2.get(0), this._fixedTableElement.get(0)]);
    }
    return result2;
  }
  getFixedColumns(rowIndex) {
    return this._columnsController.getFixedColumns(rowIndex);
  }
  getFixedColumnsOffset() {
    let offset = {
      left: 0,
      right: 0
    };
    let $transparentColumn;
    if (this._fixedTableElement) {
      $transparentColumn = this.getTransparentColumnElement();
      const positionTransparentColumn = $transparentColumn.position();
      offset = {
        left: positionTransparentColumn.left,
        right: getOuterWidth(this.element(), true) - (getOuterWidth($transparentColumn, true) + positionTransparentColumn.left)
      };
    }
    return offset;
  }
  getTransparentColumnElement() {
    return this._fixedTableElement && this._fixedTableElement.find(".dx-pointer-events-none").first();
  }
  getFixedTableElement() {
    return this._fixedTableElement;
  }
  _resizeCore() {
    super._resizeCore();
    this.synchronizeRows();
  }
  setColumnWidths(options2) {
    var _options$optionNames;
    const {
      widths
    } = options2;
    const visibleColumns = this._columnsController.getVisibleColumns();
    const isColumnWidthsSynced = (null === widths || void 0 === widths ? void 0 : widths.length) && visibleColumns.some(((column) => isDefined(column.visibleWidth)));
    const isColumnWidthChanged = null === (_options$optionNames = options2.optionNames) || void 0 === _options$optionNames ? void 0 : _options$optionNames.width;
    super.setColumnWidths(options2);
    if (this._fixedTableElement) {
      const hasAutoWidth = null === widths || void 0 === widths ? void 0 : widths.some(((width) => "auto" === width || !isDefined(width)));
      const needVisibleColumns = hasAutoWidth && (!isColumnWidthsSynced || !this.isScrollbarVisible(true));
      const columns7 = needVisibleColumns ? visibleColumns : this.getFixedColumns();
      this.setFixedTableColumnWidths(columns7, widths);
    }
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const needSynchronizeRows = isColumnWidthsSynced || isColumnWidthChanged && wordWrapEnabled;
    if (needSynchronizeRows) {
      this.synchronizeRows();
    }
  }
  setFixedTableColumnWidths(columns7, widths) {
    if (!this._fixedTableElement || !widths) {
      return;
    }
    const $cols = this._fixedTableElement.children("colgroup").children("col");
    $cols.toArray().forEach(((col) => col.removeAttribute("style")));
    let columnIndex = 0;
    columns7.forEach(((column) => {
      if (column.colspan) {
        columnIndex += column.colspan;
        return;
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
      columnIndex += 1;
    }));
  }
  _getClientHeight(element) {
    const boundingClientRectElement = element.getBoundingClientRect && getBoundingRect(element);
    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;
  }
  synchronizeRows() {
    const rowHeights = [];
    const fixedRowHeights = [];
    let rowIndex;
    let $rowElements;
    let $fixedRowElements;
    let $contentElement;
    this.waitAsyncTemplates(true).done((() => {
      if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {
        const heightTable = this._getClientHeight(this._tableElement.get(0));
        const heightFixedTable = this._getClientHeight(this._fixedTableElement.get(0));
        $rowElements = this._getRowElements(this._tableElement);
        $fixedRowElements = this._getRowElements(this._fixedTableElement);
        $contentElement = this._findContentElement();
        if (heightTable !== heightFixedTable) {
          $contentElement && $contentElement.css("height", heightTable);
          $rowElements.css("height", "");
          $fixedRowElements.css("height", "");
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            rowHeights.push(this._getClientHeight($rowElements.get(rowIndex)));
            fixedRowHeights.push(this._getClientHeight($fixedRowElements.get(rowIndex)));
          }
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            const rowHeight = rowHeights[rowIndex];
            const fixedRowHeight = fixedRowHeights[rowIndex];
            if (rowHeight > fixedRowHeight) {
              $fixedRowElements.eq(rowIndex).css("height", rowHeight);
            } else if (rowHeight < fixedRowHeight) {
              $rowElements.eq(rowIndex).css("height", fixedRowHeight);
            }
          }
          $contentElement && $contentElement.css("height", "");
        }
      }
    }));
  }
  setScrollerSpacing(width, hWidth) {
    const rtlEnabled = this.option("rtlEnabled");
    super.setScrollerSpacing(width);
    this.element().children(`.${this.addWidgetPrefix("content-fixed")}`).css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isFixedColumns() {
    const fixedColumns = this.getFixedColumns();
    const legacyMode = this.option("columnFixing.legacyMode");
    return true === legacyMode && !!fixedColumns.length;
  }
};
var columnHeadersView7 = (Base) => class extends baseFixedColumns(Base) {
  _getRowVisibleColumns(rowIndex) {
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super._getRowVisibleColumns(rowIndex);
  }
  getFixedColumnElements(rowIndex) {
    const that = this;
    if (!this._isFixedColumns) {
      return;
    }
    if (isDefined(rowIndex)) {
      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();
    }
    const columnElements = that.getColumnElements();
    const $transparentColumnElement = that.getTransparentColumnElement();
    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
      var _$transparentColumnEl;
      const transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
      [].splice.apply(columnElements, [transparentColumnIndex, null === (_$transparentColumnEl = $transparentColumnElement.get(0)) || void 0 === _$transparentColumnEl ? void 0 : _$transparentColumnEl.colSpan, $transparentColumnElement.get(0)]);
    }
    return columnElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const that = this;
    let fixedWidths;
    const result2 = super.getColumnWidths(fixedTableElement, rowIndex);
    const $fixedColumnElements = that.getFixedColumnElements();
    const fixedColumns = that.getFixedColumns();
    if (that._fixedTableElement) {
      if ($fixedColumnElements && $fixedColumnElements.length) {
        fixedWidths = that._getWidths($fixedColumnElements);
      } else {
        fixedWidths = super.getColumnWidths(that._fixedTableElement);
      }
    }
    return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
  }
};
var rowsView13 = (Base) => class extends baseFixedColumns(Base) {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._fixedScrollTimeout);
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("hoverStateEnabled" === args.name && this._isFixedColumns) {
      args.value ? this._attachHoverEvents() : this._detachHoverEvents();
    }
  }
  _detachHoverEvents() {
    const element = this.element();
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.off(element, "mouseover mouseout", ".dx-data-row");
    }
  }
  _attachHoverEvents() {
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.on(this.element(), "mouseover mouseout", ".dx-data-row", this.createAction(((args) => {
        const {
          event
        } = args;
        const rowIndex = this.getRowIndex(renderer_default(event.target).closest(".dx-row"));
        const isHover = "mouseover" === event.type;
        if (rowIndex >= 0) {
          this._tableElement && this._getRowElements(this._tableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
          this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
        }
      })));
    }
  }
  _getScrollDelay() {
    var _this$_resizingContro;
    const hasResizeTimeout = null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro ? void 0 : _this$_resizingContro.hasResizeTimeout();
    if (hasResizeTimeout) {
      return this.option("scrolling.updateTimeout");
    }
    return browser_default.mozilla ? 60 : 0;
  }
  _findContentElement(isFixedTableRendering) {
    let $content;
    let scrollTop;
    const contentClass = this.addWidgetPrefix("content");
    const element = this.element();
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    if (element && isFixedTableRendering) {
      $content = element.children(`.${contentClass}`);
      const scrollable = this.getScrollable();
      if (!$content.length && scrollable) {
        $content = renderer_default("<div>").addClass(contentClass);
        m_events_engine_default.on($content, "scroll", ((e) => {
          const {
            target
          } = e;
          const scrollDelay = this._getScrollDelay();
          clearTimeout(this._fixedScrollTimeout);
          this._fixedScrollTimeout = setTimeout((() => {
            scrollTop = renderer_default(target).scrollTop();
            scrollable.scrollTo({
              y: scrollTop
            });
          }), scrollDelay);
        }));
        m_events_engine_default.on($content, EVENT_NAME, ((e) => {
          const $nearestScrollable = renderer_default(e.target).closest(".dx-scrollable");
          let shouldScroll = false;
          if (scrollable && scrollable.$element().is($nearestScrollable)) {
            shouldScroll = true;
          } else {
            const nearestScrollableInstance = $nearestScrollable.length && ui_scrollable_default.getInstance($nearestScrollable.get(0));
            const nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;
            shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar;
          }
          if (shouldScroll) {
            scrollTop = scrollable.scrollTop();
            scrollable.scrollTo({
              y: scrollTop - e.delta
            });
            const scrollableTop = scrollable.scrollTop() + scrollable.clientHeight();
            const scrollableHeight = scrollable.scrollHeight() + this.getScrollbarWidth();
            const isPreventDefault = scrollable.scrollTop() > 0 && scrollableTop < scrollableHeight;
            if (isPreventDefault) {
              return false;
            }
          }
          return;
        }));
        $content.appendTo(element);
      }
      return $content;
    }
    return super._findContentElement();
  }
  _updateScrollable() {
    super._updateScrollable();
    const scrollable = this.getScrollable();
    if (null !== scrollable && void 0 !== scrollable && scrollable._disposed) {
      return;
    }
    const scrollTop = scrollable && scrollable.scrollOffset().top;
    this._updateFixedTablePosition(scrollTop);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      return contentElement.empty().addClass(`${this.addWidgetPrefix("content")} ${this.addWidgetPrefix("content-fixed")}`).append(tableElement);
    }
    return super._renderContent(contentElement, tableElement);
  }
  _getGroupCellOptions(options2) {
    if (this._isFixedTableRendering) {
      return super._getGroupCellOptions(extend({}, options2, {
        columns: this._columnsController.getVisibleColumns()
      }));
    }
    return super._getGroupCellOptions(options2);
  }
  _renderGroupedCells($row, options2) {
    return super._renderGroupedCells($row, extend({}, options2, {
      columns: this._columnsController.getVisibleColumns()
    }));
  }
  _renderGroupSummaryCells($row, options2) {
    if (this._isFixedTableRendering) {
      super._renderGroupSummaryCells($row, extend({}, options2, {
        columns: this._columnsController.getVisibleColumns()
      }));
    } else {
      super._renderGroupSummaryCells($row, options2);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options2) {
    const result2 = super._hasAlignByColumnSummaryItems.apply(this, arguments);
    const column = options2.columns[columnIndex];
    if (options2.isFixed) {
      return column.fixed && (result2 || "right" === column.fixedPosition);
    }
    return result2 && (!this._isFixedColumns || !column.fixed);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    let alignByFixedColumnCellCount;
    if (this._isFixedTableRendering) {
      options2.isFixed = true;
      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options2);
      options2.isFixed = false;
      const startColumnIndex = options2.columns.length - alignByFixedColumnCellCount;
      options2 = extend({}, options2, {
        columns: this.getFixedColumns()
      });
      const transparentColumnIndex = getTransparentColumnIndex(options2.columns);
      if (startColumnIndex < transparentColumnIndex) {
        alignByFixedColumnCellCount -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
        groupCellColSpan -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
      } else if (alignByColumnCellCount > 0) {
        $groupCell.css("visibility", "hidden");
      }
      alignByColumnCellCount = alignByFixedColumnCellCount;
    }
    super._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    if (this._isFixedTableRendering) {
      const transparentColumnIndex = getTransparentColumnIndex(columns7);
      if (columnIndex > transparentColumnIndex) {
        columnIndex += columns7[transparentColumnIndex].colspan - 1;
      }
      return columnIndex;
    }
    return super._getSummaryCellIndex.apply(this, arguments);
  }
  _renderCore(change) {
    this._detachHoverEvents();
    const deferred = super._renderCore(change);
    const isFixedColumns = this._isFixedColumns;
    this.element().toggleClass("dx-fixed-columns", isFixedColumns);
    if (this.option("hoverStateEnabled") && isFixedColumns) {
      this._attachHoverEvents();
    }
    return deferred;
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    if (isFixed) {
      var _this$element;
      const contentFixedClass = this.addWidgetPrefix("content-fixed");
      const $contentFixedElement = null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${contentFixedClass}`);
      const $fixedTableElement = this.getFixedTableElement();
      if ($contentFixedElement.length && null !== $fixedTableElement && void 0 !== $fixedTableElement && $fixedTableElement.length) {
        this.setAria("owns", `${headerTableId ?? ""} ${$fixedTableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentFixedElement);
      }
    } else {
      super.setAriaOwns.apply(this, arguments);
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    super.toggleDraggableColumnClass(columnIndex, value2);
    if (this.isFixedColumns()) {
      const $rows = this._getRowElements(this._fixedTableElement);
      this._toggleDraggableSourceColumnClass($rows, this.getFixedColumns(), columnIndex, value2);
    }
  }
  getCellIndex($cell) {
    const $fixedTable = this._fixedTableElement;
    let cellIndex = 0;
    if ($fixedTable && $cell.is("td") && $cell.closest($fixedTable).length) {
      const columns7 = this.getFixedColumns();
      each(columns7, ((index, column) => {
        if (index === $cell[0].cellIndex) {
          return false;
        }
        if (column.colspan) {
          cellIndex += column.colspan;
          return;
        }
        cellIndex++;
        return;
      }));
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  _updateFixedTablePosition(scrollTop, needFocus) {
    if (this._fixedTableElement && this._tableElement) {
      let $focusedElement;
      this._fixedTableElement.parent().scrollTop(scrollTop);
      if (needFocus && this._editorFactoryController) {
        $focusedElement = this._editorFactoryController.focus();
        $focusedElement && this._editorFactoryController.focus($focusedElement);
      }
    }
  }
  setScrollerSpacing(vWidth, hWidth) {
    const that = this;
    const styles = {
      marginBottom: 0
    };
    const $fixedContent = that.element().children(`.${this.addWidgetPrefix("content-fixed")}`);
    if ($fixedContent.length && that._fixedTableElement) {
      $fixedContent.css(styles);
      that._fixedTableElement.css(styles);
      styles[that.option("rtlEnabled") ? "marginLeft" : "marginRight"] = vWidth;
      styles.marginBottom = hWidth;
      const useNativeScrolling = that._scrollable && that._scrollable.option("useNative");
      (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles);
    }
  }
  _getElasticScrollTop(e) {
    let elasticScrollTop = 0;
    if (e.scrollOffset.top < 0) {
      elasticScrollTop = -e.scrollOffset.top;
    } else if (e.reachedBottom) {
      const $scrollableContent = renderer_default(e.component.content());
      const $scrollableContainer = renderer_default(e.component.container());
      const maxScrollTop = Math.max($scrollableContent.get(0).clientHeight - $scrollableContainer.get(0).clientHeight, 0);
      elasticScrollTop = Math.min(maxScrollTop - e.scrollOffset.top, 0);
    }
    return Math.floor(elasticScrollTop);
  }
  _applyElasticScrolling(e) {
    if (this._fixedTableElement) {
      const elasticScrollTop = this._getElasticScrollTop(e);
      if (0 !== Math.ceil(elasticScrollTop)) {
        move(this._fixedTableElement, {
          top: elasticScrollTop
        });
      } else {
        this._fixedTableElement.css("transform", "");
      }
    }
  }
  _handleScroll(e) {
    this._updateFixedTablePosition(e.scrollOffset.top, true);
    this._applyElasticScrolling(e);
    super._handleScroll(e);
  }
  _updateContentPosition(isRender) {
    super._updateContentPosition.apply(this, arguments);
    if (!isRender) {
      this._updateFixedTablePosition(this._scrollTop);
    }
  }
  _afterRowPrepared(e) {
    if (this._isFixedTableRendering) {
      return;
    }
    super._afterRowPrepared(e);
  }
  _scrollToElement($element, offset) {
    const scrollOffset = this.isFixedColumns() ? this.getFixedColumnsOffset() : offset;
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView2 = (Base) => class extends baseFixedColumns(Base) {
};
var normalizeColumnIndicesByPoints = function(columns7, fixedColumns, pointsByColumns) {
  const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
  const correctIndex = columns7.length - fixedColumns.length;
  each(pointsByColumns, ((_, point) => {
    if (point.index > transparentColumnIndex) {
      point.columnIndex += correctIndex;
      point.index += correctIndex;
    }
  }));
  return pointsByColumns;
};
var draggingHeader2 = (Base) => class extends Base {
  _generatePointsByColumns(options2, needToCheckPrevPoint) {
    const visibleColumns = options2.columns;
    const {
      targetDraggingPanel
    } = options2;
    if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
      if (options2.sourceColumn.fixed) {
        if (!options2.rowIndex) {
          options2.columnElements = targetDraggingPanel.getFixedColumnElements(0);
        }
        options2.columns = targetDraggingPanel.getFixedColumns(options2.rowIndex);
        const pointsByColumns = super._generatePointsByColumns(options2, needToCheckPrevPoint);
        normalizeColumnIndicesByPoints(visibleColumns, options2.columns, pointsByColumns);
        return pointsByColumns;
      }
    }
    return super._generatePointsByColumns(options2, needToCheckPrevPoint);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const result2 = super._pointCreated.apply(this, arguments);
    const targetColumn = columns7[point.columnIndex];
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if (!result2 && "headers" === location && $transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (sourceColumn && sourceColumn.fixed) {
        return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;
      }
      if (targetColumn && targetColumn.fixed && "right" !== targetColumn.fixedPosition) {
        return true;
      }
      return point.x < boundingRect.left || point.x > boundingRect.right;
    }
    return result2;
  }
};
var columnsResizer3 = (Base) => class extends Base {
  _generatePointsByColumns(needToCheckPrevPoint) {
    const that = this;
    const columnsController = that._columnsController;
    const columns7 = columnsController && that._columnsController.getVisibleColumns();
    const fixedColumns = columnsController && that._columnsController.getFixedColumns();
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const correctIndex = columns7.length - fixedColumns.length;
    const cells = that._columnHeadersView.getFixedColumnElements();
    super._generatePointsByColumns(needToCheckPrevPoint);
    if (cells && cells.length > 0) {
      that._pointsByFixedColumns = m_utils_default.getPointsByColumns(cells, ((point) => {
        if (point.index > transparentColumnIndex) {
          point.columnIndex += correctIndex;
          point.index += correctIndex;
        }
        return that._pointCreated(point, columns7.length, columns7);
      }));
    }
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if ($transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
        return super._getTargetPoint(this._pointsByFixedColumns, currentX, deltaX);
      }
    }
    return super._getTargetPoint(pointsByColumns, currentX, deltaX);
  }
};
var resizing5 = (Base) => class extends Base {
  _setAriaOwns() {
    var _this$_columnHeadersV, _this$_footerView, _this$_rowsView;
    super._setAriaOwns.apply(this, arguments);
    const headerFixedTable = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.getFixedTableElement();
    const footerFixedTable = null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.getFixedTableElement();
    null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || _this$_rowsView.setAriaOwns(null === headerFixedTable || void 0 === headerFixedTable ? void 0 : headerFixedTable.attr("id"), null === footerFixedTable || void 0 === footerFixedTable ? void 0 : footerFixedTable.attr("id"), true);
  }
};
var keyboardNavigation2 = (Base) => class extends Base {
  _toggleInertAttr(value2) {
    var _this$_rowsView2;
    const $fixedContent = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.getFixedContentElement();
    if (value2) {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.attr("inert", true);
    } else {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.removeAttr("inert");
    }
  }
};
var editorFactory3 = (Base) => class extends Base {
  getValidationMessageContainer($cell) {
    const isFixedColumns = this._rowsView.isFixedColumns();
    if (isFixedColumns) {
      return this._rowsView.element();
    }
    return super.getValidationMessageContainer($cell);
  }
};
var columnFixingModule = {
  defaultOptions: () => ({
    columnFixing: {
      enabled: false,
      legacyMode: false,
      texts: {
        fix: message_default.format("dxDataGrid-columnFixingFix"),
        unfix: message_default.format("dxDataGrid-columnFixingUnfix"),
        leftPosition: message_default.format("dxDataGrid-columnFixingLeftPosition"),
        rightPosition: message_default.format("dxDataGrid-columnFixingRightPosition"),
        stickyPosition: message_default.format("dxDataGrid-columnFixingStickyPosition")
      },
      icons: {
        fix: "fix-column",
        unfix: "unfix-column",
        leftPosition: "fix-column-left",
        rightPosition: "fix-column-right",
        stickyPosition: "stick-column"
      }
    }
  }),
  extenders: {
    views: {
      columnHeadersView: columnHeadersView7,
      rowsView: rowsView13,
      footerView: footerView2
    },
    controllers: {
      draggingHeader: draggingHeader2,
      columnsResizer: columnsResizer3,
      resizing: resizing5,
      keyboardNavigation: keyboardNavigation2,
      editorFactory: editorFactory3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_fixing.js
m_core_default.registerModule("columnFixing", columnFixingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/m_adaptivity.js
var ROWS_VIEW2 = "rowsView";
var FOOTER_VIEW = "footerView";
var COLUMN_VIEWS = ["columnHeadersView", ROWS_VIEW2, FOOTER_VIEW];
var ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity";
var EXPAND_ARIA_NAME = "dxDataGrid-ariaAdaptiveExpand";
var COLLAPSE_ARIA_NAME = "dxDataGrid-ariaAdaptiveCollapse";
var LEGACY_SCROLLING_MODE4 = "scrolling.legacyMode";
function getColumnId(that, column) {
  return that._columnsController.getColumnId(column);
}
function getDataCellElements($row) {
  return $row.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])");
}
function adaptiveCellTemplate(container, options2) {
  let $adaptiveColumnButton;
  const $container = renderer_default(container);
  const adaptiveColumnsController = options2.component.getController("adaptiveColumns");
  if ("data" === options2.rowType) {
    $adaptiveColumnButton = renderer_default("<span>").addClass(adaptiveColumnsController.addWidgetPrefix("adaptive-more"));
    m_events_engine_default.on($adaptiveColumnButton, addNamespace(CLICK_EVENT_NAME, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction((() => {
      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options2.key);
    })));
    $adaptiveColumnButton.appendTo($container);
  } else {
    m_utils_default.setEmptyText($container);
  }
}
function focusCellHandler(e) {
  var _e$data;
  const $nextCell = null === (_e$data = e.data) || void 0 === _e$data ? void 0 : _e$data.$nextCell;
  m_events_engine_default.off($nextCell, "focus", focusCellHandler);
  m_events_engine_default.trigger($nextCell, "dxclick");
}
var AdaptiveColumnsController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._rowsView = this.getView("rowsView");
    this._columnsController.addCommandColumn({
      type: "adaptive",
      command: "adaptive",
      visible: true,
      adaptiveHidden: true,
      cssClass: "dx-command-adaptive",
      alignment: "center",
      width: "auto",
      cellTemplate: adaptiveCellTemplate,
      fixedPosition: "right"
    });
    this._columnsController.columnsChanged.add((() => {
      const isAdaptiveVisible = !!this.updateHidingQueue(this._columnsController.getColumns()).length;
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true);
    }));
    this._hidingColumnsQueue = [];
    this._hiddenColumns = [];
    this.createAction("onAdaptiveDetailRowPreparing");
    super.init();
  }
  optionChanged(args) {
    if ("columnHidingEnabled" === args.name) {
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value);
    }
    super.optionChanged(args);
  }
  publicMethods() {
    return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"];
  }
  _isRowEditMode() {
    const editMode = this._getEditMode();
    return "row" === editMode;
  }
  _isItemModified(item, cellOptions) {
    const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
    const rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);
    const row = this._dataController.items()[rowIndex + 1];
    return row && row.modifiedValues && isDefined(row.modifiedValues[columnIndex]);
  }
  _renderFormViewTemplate(item, cellOptions, $container) {
    const that = this;
    const {
      column
    } = item;
    const focusAction = that.createAction((() => {
      if (that._editingController.isEditing()) {
        m_events_engine_default.trigger($container, CLICK_EVENT_NAME);
      }
    }));
    const rowData = cellOptions.row.data;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, cellOptions.rowType);
    const text = m_utils_default.formatValue(displayValue, column);
    const isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();
    const rowsView18 = that._rowsView;
    if (column.allowEditing && this._keyboardNavigationController.isKeyboardEnabled()) {
      $container.attr("tabIndex", that.option("tabIndex"));
      if (isCellOrBatchEditMode) {
        m_events_engine_default.off($container, "focus", focusAction);
        m_events_engine_default.on($container, "focus", focusAction);
      }
    }
    if (column.cellTemplate) {
      const templateOptions = extend({}, cellOptions, {
        value: value2,
        displayValue,
        text,
        column
      });
      rowsView18.renderTemplate($container, column.cellTemplate, templateOptions, isElementInDom($container)).done((() => {
        rowsView18._cellPrepared($container, cellOptions);
      }));
    } else {
      const container = $container.get(0);
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
      $container.addClass("dx-adaptive-item-text");
      if (!isDefined(text) || "" === text) {
        $container.html("&nbsp;");
      }
      if (!that._isRowEditMode()) {
        if (that._isItemModified(item, cellOptions)) {
          $container.addClass("dx-item-modified");
        }
      }
      rowsView18._cellPrepared($container, cellOptions);
    }
  }
  _getTemplate(item, cellOptions, updateForm) {
    const that = this;
    const {
      column
    } = item;
    const editingController = this._editingController;
    return function(options2, container) {
      const $container = renderer_default(container);
      const columnIndex = that._columnsController.getVisibleIndex(column.index);
      const templateOptions = extend({}, cellOptions);
      const renderFormTemplate = function() {
        const isItemEdited = that._isItemEdited(item);
        templateOptions.value = cellOptions.row.values[columnIndex];
        if (isItemEdited || column.showEditorAlways) {
          editingController.renderFormEditorTemplate(templateOptions, item, options2, $container, !isItemEdited);
        } else {
          templateOptions.column = column;
          templateOptions.columnIndex = columnIndex;
          that._renderFormViewTemplate(item, templateOptions, $container);
        }
      };
      renderFormTemplate();
      if (templateOptions.watch) {
        const dispose = templateOptions.watch((() => ({
          isItemEdited: that._isItemEdited(item),
          value: cellOptions.row.values[columnIndex]
        })), (() => {
          $container.contents().remove();
          $container.removeClass("dx-adaptive-item-text");
          renderFormTemplate();
        }));
        m_events_engine_default.on($container, removeEvent, dispose);
      }
    };
  }
  _isVisibleColumnsValid(visibleColumns) {
    if (visibleColumns < 2) {
      return false;
    }
    if (visibleColumns.length - (function() {
      let result2 = 0;
      for (let j = 0; j < visibleColumns.length; j++) {
        const visibleColumn = visibleColumns[j];
        if (visibleColumn.command) {
          result2++;
        }
      }
      return result2;
    })() <= 1) {
      return false;
    }
    return true;
  }
  _calculatePercentWidths(widths, visibleColumns) {
    const that = this;
    let percentWidths = 0;
    visibleColumns.forEach(((item, index) => {
      if ("adaptiveHidden" !== widths[index]) {
        percentWidths += that._getItemPercentWidth(item);
      }
    }));
    return percentWidths;
  }
  _isPercentWidth(width) {
    return isString(width) && width.endsWith("%");
  }
  _isColumnHidden(column) {
    return this._hiddenColumns.filter(((hiddenColumn) => hiddenColumn.index === column.index)).length > 0;
  }
  _getAverageColumnsWidth(containerWidth, columns7, columnsCanFit) {
    const that = this;
    let fixedColumnsWidth = 0;
    let columnsWithoutFixedWidthCount = 0;
    columns7.forEach(((column) => {
      if (!that._isColumnHidden(column)) {
        const {
          width
        } = column;
        if (isDefined(width) && !isNaN(parseFloat(width))) {
          fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
            visibleIndex: column.visibleIndex,
            columnsCount: columns7.length,
            columnsCanFit,
            bestFitWidth: column.bestFitWidth,
            columnWidth: width,
            containerWidth
          }) : parseFloat(width);
        } else {
          columnsWithoutFixedWidthCount++;
        }
      }
    }));
    return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;
  }
  _calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    const columnsCount = contentColumns.length;
    let colWidth;
    if (widthOption && "auto" !== widthOption) {
      if (this._isPercentWidth(widthOption)) {
        colWidth = this._calculatePercentWidth({
          visibleIndex: column.visibleIndex,
          columnsCount,
          columnsCanFit,
          bestFitWidth,
          columnWidth: widthOption,
          containerWidth
        });
      } else {
        return parseFloat(widthOption);
      }
    } else {
      const columnAutoWidth = this.option("columnAutoWidth");
      colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);
    }
    return colWidth;
  }
  _calculatePercentWidth(options2) {
    const columnFitted = options2.visibleIndex < options2.columnsCount - 1 && options2.columnsCanFit;
    const partialWidth = options2.containerWidth * parseFloat(options2.columnWidth) / 100;
    const resultWidth = options2.columnsCanFit && partialWidth < options2.bestFitWidth ? options2.bestFitWidth : partialWidth;
    return columnFitted ? options2.containerWidth * parseFloat(options2.columnWidth) / 100 : resultWidth;
  }
  _getNotTruncatedColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    if (widthOption && "auto" !== widthOption && !this._isPercentWidth(widthOption)) {
      return parseFloat(widthOption);
    }
    const colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);
    return colWidth < bestFitWidth ? null : colWidth;
  }
  _getItemPercentWidth(item) {
    let result2 = 0;
    if (item.width && this._isPercentWidth(item.width)) {
      result2 = parseFloat(item.width);
    }
    return result2;
  }
  _getCommandColumnsWidth() {
    const that = this;
    const columns7 = that._columnsController.getVisibleColumns();
    let colWidth = 0;
    each(columns7, ((index, column) => {
      if (column.index < 0 || column.command) {
        colWidth += that._columnsController.columnOption(getColumnId(that, column), "bestFitWidth") || 0;
      }
    }));
    return colWidth;
  }
  _isItemEdited(item) {
    if (this.isFormOrPopupEditMode()) {
      return false;
    }
    if (this._isRowEditMode()) {
      const editRowKey = this.option("editing.editRowKey");
      if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
        return true;
      }
    } else {
      const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
      const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
      return this._editingController.isEditCell(rowIndex, columnIndex);
    }
    return;
  }
  _getFormItemsByHiddenColumns(hiddenColumns) {
    const items = [];
    each(hiddenColumns, ((_, column) => {
      items.push({
        column,
        name: column.name,
        dataField: column.dataField,
        visibleIndex: column.visibleIndex
      });
    }));
    return items;
  }
  _getAdaptiveColumnVisibleIndex(visibleColumns) {
    for (let i = 0; i < visibleColumns.length; i++) {
      const column = visibleColumns[i];
      if ("adaptive" === column.command) {
        return i;
      }
    }
    return;
  }
  _hideAdaptiveColumn(resultWidths, visibleColumns) {
    const visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
    if (isDefined(visibleIndex)) {
      resultWidths[visibleIndex] = "adaptiveHidden";
      this._hideVisibleColumn({
        isCommandColumn: true,
        visibleIndex
      });
    }
  }
  _showHiddenCellsInView(_ref) {
    let {
      $cells,
      isCommandColumn
    } = _ref;
    let cssClassNameToRemove = this.addWidgetPrefix("hidden-column");
    if (isCommandColumn) {
      cssClassNameToRemove = "dx-command-adaptive-hidden";
      $cells.attr({
        tabIndex: 0,
        "aria-hidden": null
      }).removeClass(cssClassNameToRemove);
    } else {
      $cells.removeClass(cssClassNameToRemove);
    }
  }
  _showHiddenColumns() {
    for (let i = 0; i < COLUMN_VIEWS.length; i++) {
      const view = this.getView(COLUMN_VIEWS[i]);
      if (view && view.isVisible() && view.element()) {
        const viewName2 = view.name;
        const $hiddenCommandCells = view.element().find(".dx-command-adaptive-hidden");
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCommandCells,
          isCommandColumn: true
        });
        const $hiddenCells = view.element().find(`.${this.addWidgetPrefix("hidden-column")}`);
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCells
        });
      }
    }
  }
  _isCellValid($cell) {
    return $cell && $cell.length && !$cell.hasClass("dx-master-detail-cell") && !$cell.hasClass("dx-group-cell");
  }
  _hideVisibleColumn(_ref2) {
    let {
      isCommandColumn,
      visibleIndex
    } = _ref2;
    const that = this;
    COLUMN_VIEWS.forEach(((viewName2) => {
      const view = that.getView(viewName2);
      view && that._hideVisibleColumnInView({
        view,
        isCommandColumn,
        visibleIndex
      });
    }));
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    const viewName2 = view.name;
    let $cellElement;
    const column = this._columnsController.getVisibleColumns()[visibleIndex];
    const editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
    if (view && view.isVisible() && column) {
      const rowsCount = view.getRowsCount();
      const $rowElements = view._getRowElements();
      for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
        const cancelClassAdding = rowIndex === editFormRowIndex && viewName2 === ROWS_VIEW2 && "popup" !== this.option("editing.mode");
        if (!cancelClassAdding) {
          const currentVisibleIndex = "columnHeadersView" === viewName2 ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
          if (currentVisibleIndex >= 0) {
            const $rowElement = $rowElements.eq(rowIndex);
            $cellElement = this._findCellElementInRow($rowElement, currentVisibleIndex);
            this._isCellValid($cellElement) && this._hideVisibleCellInView({
              viewName: viewName2,
              isCommandColumn,
              $cell: $cellElement
            });
          }
        }
      }
    }
  }
  _findCellElementInRow($rowElement, visibleColumnIndex) {
    const $rowCells = $rowElement.children();
    let visibleIndex = visibleColumnIndex;
    let cellIsInsideGroup = false;
    if ($rowElement.hasClass("dx-group-row")) {
      const $groupCell = $rowElement.find(".dx-group-cell");
      const colSpan = $groupCell.attr("colspan");
      if ($groupCell.length && isDefined(colSpan)) {
        const groupCellLength = parseInt(colSpan);
        const endGroupIndex = $groupCell.index() + groupCellLength - 1;
        if (visibleColumnIndex > endGroupIndex) {
          visibleIndex = visibleColumnIndex - groupCellLength + 1;
        } else {
          cellIsInsideGroup = true;
        }
      }
    }
    const $cellElement = !cellIsInsideGroup ? $rowCells.eq(visibleIndex) : void 0;
    return $cellElement;
  }
  _hideVisibleCellInView(_ref4) {
    let {
      $cell,
      isCommandColumn
    } = _ref4;
    const cssClassNameToAdd = isCommandColumn ? "dx-command-adaptive-hidden" : this.addWidgetPrefix("hidden-column");
    $cell.attr({
      tabIndex: -1,
      "aria-hidden": true
    }).addClass(cssClassNameToAdd);
  }
  _getEditMode() {
    return this._editingController.getEditMode();
  }
  isFormOrPopupEditMode() {
    const editMode = this._getEditMode();
    return "form" === editMode || "popup" === editMode;
  }
  hideRedundantColumns(resultWidths, visibleColumns, hiddenQueue) {
    const that = this;
    this._hiddenColumns = [];
    if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
      let totalWidth = 0;
      const $rootElement = that.component.$element();
      let rootElementWidth = getWidth($rootElement) - that._getCommandColumnsWidth();
      const getVisibleContentColumns = (function() {
        return visibleColumns.filter(((item) => !item.command && 0 === this._hiddenColumns.filter(((i2) => i2.index === item.index)).length));
      }).bind(this);
      let visibleContentColumns = getVisibleContentColumns();
      const contentColumnsCount = visibleContentColumns.length;
      let i;
      let hasHiddenColumns;
      let needHideColumn;
      do {
        needHideColumn = false;
        totalWidth = 0;
        const percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
        const columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
        for (i = 0; i < visibleColumns.length; i++) {
          const visibleColumn = visibleColumns[i];
          let columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);
          const columnId = getColumnId(that, visibleColumn);
          const widthOption = that._columnsController.columnOption(columnId, "width");
          const minWidth = that._columnsController.columnOption(columnId, "minWidth");
          const columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
          if ("adaptiveHidden" === resultWidths[i]) {
            hasHiddenColumns = true;
            continue;
          }
          if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
            needHideColumn = true;
            break;
          }
          if (!widthOption || "auto" === widthOption) {
            columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);
          }
          if ("adaptive" !== visibleColumn.command || hasHiddenColumns) {
            totalWidth += columnWidth;
          }
        }
        needHideColumn = needHideColumn || totalWidth > getWidth($rootElement);
        if (needHideColumn) {
          const column = hiddenQueue.pop();
          const visibleIndex = that._columnsController.getVisibleIndex(column.index);
          rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);
          that._hideVisibleColumn({
            visibleIndex
          });
          resultWidths[visibleIndex] = "adaptiveHidden";
          this._hiddenColumns.push(column);
          visibleContentColumns = getVisibleContentColumns();
        }
      } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);
      if (contentColumnsCount === visibleContentColumns.length) {
        that._hideAdaptiveColumn(resultWidths, visibleColumns);
      }
    } else {
      that._hideAdaptiveColumn(resultWidths, visibleColumns);
    }
  }
  getAdaptiveDetailItems() {
    return this._$itemContents;
  }
  getItemContentByColumnIndex(visibleColumnIndex) {
    let $itemContent;
    for (let i = 0; i < this._$itemContents.length; i++) {
      $itemContent = this._$itemContents.eq(i);
      const item = $itemContent.data("dx-form-item");
      if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
        return $itemContent;
      }
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    if (!(this.isFormOrPopupEditMode() && this._editingController.isEditing())) {
      this._dataController.toggleExpandAdaptiveDetailRow(key, alwaysExpanded);
    }
  }
  createFormByHiddenColumns(container, options2) {
    const that = this;
    const $container = renderer_default(container);
    const userFormOptions = {
      items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
      formID: `dx-${new guid_default()}`
    };
    const defaultFormOptions = isMaterial() ? {
      colCount: 2
    } : {};
    this.executeAction("onAdaptiveDetailRowPreparing", {
      formOptions: userFormOptions
    });
    that._$itemContents = null;
    that._form = that._createComponent(renderer_default("<div>").appendTo($container), form_default, extend(defaultFormOptions, userFormOptions, {
      customizeItem(item) {
        const column = item.column || that._columnsController.columnOption(item.name || item.dataField);
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          item.column = column;
          item.template = that._getTemplate(item, options2, that.updateForm.bind(that));
        }
        userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);
      },
      onContentReady(e) {
        userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
        that._$itemContents = $container.find(".dx-field-item-content");
      }
    }));
  }
  hasAdaptiveDetailRowExpanded() {
    return isDefined(this._dataController.adaptiveExpandedKey());
  }
  updateForm(hiddenColumns) {
    if (this.hasAdaptiveDetailRowExpanded()) {
      if (this._form && isDefined(this._form._contentReadyAction)) {
        if (hiddenColumns && hiddenColumns.length) {
          this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns));
        } else {
          this._form.repaint();
        }
      }
    }
  }
  updateHidingQueue(columns7) {
    const that = this;
    const hideableColumns = columns7.filter(((column) => column.visible && !column.type && !column.fixed && !(isDefined(column.groupIndex) && column.groupIndex >= 0)));
    let columnsHasHidingPriority;
    let i;
    that._hidingColumnsQueue = [];
    if (that.option("allowColumnResizing") && "widget" === that.option("columnResizingMode")) {
      return that._hidingColumnsQueue;
    }
    for (i = 0; i < hideableColumns.length; i++) {
      if (isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
        columnsHasHidingPriority = true;
        that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];
      }
    }
    if (columnsHasHidingPriority) {
      that._hidingColumnsQueue.reverse();
    } else if (that.option("columnHidingEnabled")) {
      for (i = 0; i < hideableColumns.length; i++) {
        const visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);
        that._hidingColumnsQueue[visibleIndex] = hideableColumns[i];
      }
    }
    that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
    return that._hidingColumnsQueue;
  }
  getHiddenColumns() {
    return this._hiddenColumns;
  }
  hasHiddenColumns() {
    return this._hiddenColumns.length > 0;
  }
  getHidingColumnsQueue() {
    return this._hidingColumnsQueue;
  }
  isAdaptiveDetailRowExpanded(key) {
    const dataController2 = this._dataController;
    return dataController2.adaptiveExpandedKey() && equalByValue(dataController2.adaptiveExpandedKey(), key);
  }
  expandAdaptiveDetailRow(key) {
    if (!this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow(key);
    }
  }
  collapseAdaptiveDetailRow() {
    if (this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow();
    }
  }
  updateCommandAdaptiveAriaLabel(key, label) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    if (-1 === rowIndex) {
      return;
    }
    const $row = renderer_default(this.component.getRowElement(rowIndex));
    this.setCommandAdaptiveAriaLabel($row, label);
  }
  setCommandAdaptiveAriaLabel($row, labelName) {
    const $adaptiveCommand = $row.find(".dx-command-adaptive");
    $adaptiveCommand.attr("aria-label", message_default.format(labelName));
  }
};
var keyboardNavigation3 = (Base) => class extends Base {
  _isCellValid($cell, isClick) {
    return super._isCellValid($cell, isClick) && !$cell.hasClass(this.addWidgetPrefix("hidden-column")) && !$cell.hasClass("dx-command-adaptive-hidden");
  }
  _processNextCellInMasterDetail($nextCell, $cell) {
    super._processNextCellInMasterDetail($nextCell, $cell);
    const isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();
    const isEditing = this._editingController.isEditing();
    if (isEditing && $nextCell && isCellOrBatchMode && !this._isInsideEditForm($nextCell)) {
      m_events_engine_default.off($nextCell, "focus", focusCellHandler);
      m_events_engine_default.on($nextCell, "focus", {
        $nextCell
      }, focusCellHandler);
      m_events_engine_default.trigger($cell, "focus");
    }
  }
  _isCellElement($cell) {
    return super._isCellElement($cell) || $cell.hasClass("dx-adaptive-item-text");
  }
};
var rowsView14 = (Base) => class extends Base {
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    if ("detailAdaptive" === options2.rowType && "detail" === column.command) {
      return function(container, options3) {
        that._adaptiveColumnsController.createFormByHiddenColumns(renderer_default(container), options3);
      };
    }
    return super._getCellTemplate(options2);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row && "detailAdaptive" === row.rowType && row.key === this._dataController.adaptiveExpandedKey()) {
      $row.addClass("dx-adaptive-detail-row");
    }
    return $row;
  }
  _renderCells($row, options2) {
    super._renderCells($row, options2);
    const adaptiveColumnsController = this._adaptiveColumnsController;
    const hidingColumnsQueueLength = adaptiveColumnsController.getHidingColumnsQueue().length;
    const hiddenColumnsLength = adaptiveColumnsController.getHiddenColumns().length;
    if (hidingColumnsQueueLength && !hiddenColumnsLength) {
      getDataCellElements($row).last().addClass("dx-last-data-cell");
    }
    if ("data" === options2.row.rowType) {
      adaptiveColumnsController.setCommandAdaptiveAriaLabel($row, EXPAND_ARIA_NAME);
    }
  }
  _getColumnIndexByElementCore($element) {
    const $itemContent = $element.closest(".dx-field-item-content");
    if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {
      const formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
      return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    }
    return super._getColumnIndexByElementCore($element);
  }
  _cellPrepared($cell, options2) {
    super._cellPrepared.apply(this, arguments);
    if ("detailAdaptive" !== options2.row.rowType && "adaptiveHidden" === options2.column.visibleWidth) {
      $cell.addClass(this.addWidgetPrefix("hidden-column"));
    }
  }
  getCell(cellPosition, rows) {
    const item = this._dataController.items()[null === cellPosition || void 0 === cellPosition ? void 0 : cellPosition.rowIndex];
    if ("detailAdaptive" === (null === item || void 0 === item ? void 0 : item.rowType)) {
      const $adaptiveDetailItems = this._adaptiveColumnsController.getAdaptiveDetailItems();
      return super.getCell(cellPosition, rows, $adaptiveDetailItems);
    }
    return super.getCell.apply(this, arguments);
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const item = this._dataController.items()[rowIndex];
    if (item && "detailAdaptive" === item.rowType) {
      return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);
    }
    return super._getCellElement.apply(this, arguments);
  }
  getContextMenuItems(options2) {
    var _super$getContextMenu;
    if (options2.row && "detailAdaptive" === options2.row.rowType) {
      const view = this._columnHeadersView;
      const formItem = renderer_default(options2.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
      options2.column = formItem ? formItem.column : options2.column;
      return view.getContextMenuItems && view.getContextMenuItems(options2);
    }
    return null === (_super$getContextMenu = super.getContextMenuItems) || void 0 === _super$getContextMenu ? void 0 : _super$getContextMenu.call(this, options2);
  }
  isClickableElement($target) {
    var _super$isClickableEle;
    const isClickable = (null === (_super$isClickableEle = super.isClickableElement) || void 0 === _super$isClickableEle ? void 0 : _super$isClickableEle.call(this, $target)) ?? false;
    return isClickable || !!$target.closest(".dx-command-adaptive").length;
  }
};
var exportExtender = (Base) => class extends Base {
  _updateColumnWidth(column, width) {
    super._updateColumnWidth(column, "adaptiveHidden" === column.visibleWidth ? column.bestFitWidth : width);
  }
};
var columnsResizer4 = (Base) => class extends Base {
  _pointCreated(point, cellsLength, columns7) {
    const result2 = super._pointCreated(point, cellsLength, columns7);
    const currentColumn = columns7[point.columnIndex] || {};
    const nextColumnIndex = this._getNextColumnIndex(point.columnIndex);
    const nextColumn = columns7[nextColumnIndex] || {};
    const hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === currentColumn.visibleWidth || hasHiddenColumnsOnly;
    return result2 || hasAdaptiveHiddenWidth;
  }
  _getNextColumnIndex(currentColumnIndex) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let index = super._getNextColumnIndex(currentColumnIndex);
    while (visibleColumns[index] && "adaptiveHidden" === visibleColumns[index].visibleWidth) {
      index++;
    }
    return index;
  }
};
var draggingHeader3 = (Base) => class extends Base {
  _pointCreated(point, columns7, location, sourceColumn) {
    const result2 = super._pointCreated(point, columns7, location, sourceColumn);
    const column = columns7[point.columnIndex - 1] || {};
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === column.visibleWidth;
    return result2 || hasAdaptiveHiddenWidth;
  }
};
var editing4 = (Base) => class extends Base {
  _isRowEditMode() {
    return "row" === this.getEditMode();
  }
  _getFormEditItemTemplate(cellOptions, column) {
    if ("row" !== this.getEditMode() && "detailAdaptive" === cellOptions.rowType) {
      cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
      return this.getColumnTemplate(cellOptions);
    }
    return super._getFormEditItemTemplate(cellOptions, column);
  }
  _closeEditItem($targetElement) {
    const $itemContents = $targetElement.closest(".dx-field-item-content");
    const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
    const formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null;
    const columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    if (!this.isEditCell(rowIndex, columnIndex)) {
      super._closeEditItem($targetElement);
    }
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
    if (!this._adaptiveColumnsController.isFormOrPopupEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      const items = this._dataController.items();
      const item = items[rowIndex];
      const oldExpandRowIndex = m_utils_default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
      this._isForceRowAdaptiveExpand = !this._adaptiveColumnsController.hasAdaptiveDetailRowExpanded();
      if (oldExpandRowIndex >= 0) {
        rowIndices.push(oldExpandRowIndex + 1);
      }
      rowIndices.push(rowIndex + 1);
      this._dataController.adaptiveExpandedKey(item.key);
    }
  }
  _afterInsertRow(key) {
    super._afterInsertRow.apply(this, arguments);
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key, this.isRowEditMode());
      this._isForceRowAdaptiveExpand = true;
    }
  }
  _collapseAdaptiveDetailRow() {
    if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
      this._isForceRowAdaptiveExpand = false;
    }
  }
  _cancelEditAdaptiveDetailRow() {
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._collapseAdaptiveDetailRow();
    }
  }
  _afterSaveEditData() {
    super._afterSaveEditData.apply(this, arguments);
    const deferred = new Deferred();
    if (this._isRowEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      when(this._validatingController.validate(true)).done(((isValid) => {
        if (isValid) {
          this._cancelEditAdaptiveDetailRow();
        }
        deferred.resolve();
      }));
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _beforeCancelEditData() {
    super._beforeCancelEditData();
    this._cancelEditAdaptiveDetailRow();
  }
  _getRowIndicesForCascadeUpdating(row) {
    const rowIndices = super._getRowIndicesForCascadeUpdating.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(row.key)) {
      rowIndices.push("detailAdaptive" === row.rowType ? row.rowIndex - 1 : row.rowIndex + 1);
    }
    return rowIndices;
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
    const expandedKey = this._dataController._adaptiveExpandedKey;
    if (expandedKey) {
      const rowIndex = m_utils_default.getIndexByKey(expandedKey, this._dataController.items());
      if (rowIndex > -1) {
        rowIndices.unshift(rowIndex);
      }
    }
  }
  editRow(rowIndex) {
    if (this._adaptiveColumnsController.isFormOrPopupEditMode()) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    return super.editRow(rowIndex);
  }
  deleteRow(rowIndex) {
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    if ("batch" === this.getEditMode() && this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(rowKey)) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    super.deleteRow(rowIndex);
  }
};
var data14 = (Base) => class extends Base {
  init() {
    super.init();
    this._adaptiveExpandedKey = void 0;
  }
  _processItems(items, change) {
    const {
      changeType
    } = change;
    items = super._processItems.apply(this, arguments);
    if ("loadingAll" === changeType || !isDefined(this._adaptiveExpandedKey)) {
      return items;
    }
    const expandRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, items);
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    if (expandRowIndex >= 0) {
      const item = items[expandRowIndex];
      items.splice(expandRowIndex + 1, 0, {
        visible: true,
        rowType: "detailAdaptive",
        key: item.key,
        data: item.data,
        node: item.node,
        modifiedValues: item.modifiedValues,
        isNewRow: item.isNewRow,
        values: item.values
      });
    } else if ("refresh" === changeType && !(newMode && change.repaintChangesOnly)) {
      this._adaptiveExpandedKey = void 0;
    }
    return items;
  }
  _getRowIndicesForExpand(key) {
    const rowIndices = super._getRowIndicesForExpand.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(key)) {
      const lastRowIndex = rowIndices[rowIndices.length - 1];
      rowIndices.push(lastRowIndex + 1);
    }
    return rowIndices;
  }
  adaptiveExpandedKey(value2) {
    if (isDefined(value2)) {
      this._adaptiveExpandedKey = value2;
    } else {
      return this._adaptiveExpandedKey;
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    let oldExpandLoadedRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, this._items);
    let newExpandLoadedRowIndex = m_utils_default.getIndexByKey(key, this._items);
    if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {
      key = void 0;
      newExpandLoadedRowIndex = -1;
    }
    const oldKey = this._adaptiveExpandedKey;
    this._adaptiveExpandedKey = key;
    if (oldExpandLoadedRowIndex >= 0) {
      oldExpandLoadedRowIndex++;
    }
    if (newExpandLoadedRowIndex >= 0) {
      newExpandLoadedRowIndex++;
    }
    const rowIndexDelta = this.getRowIndexDelta();
    this.updateItems({
      allowInvisibleRowIndices: true,
      changeType: "update",
      rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]
    });
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(key, COLLAPSE_ARIA_NAME);
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(oldKey, EXPAND_ARIA_NAME);
  }
};
var editorFactory4 = (Base) => class extends Base {
  _needHideBorder($element) {
    return super._needHideBorder($element) || (null === $element || void 0 === $element ? void 0 : $element.hasClass("dx-field-item-content")) && (null === $element || void 0 === $element ? void 0 : $element.find(".dx-checkbox").length);
  }
  _getFocusCellSelector() {
    return `${super._getFocusCellSelector()}, .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content`;
  }
  _getRevertTooltipsSelector() {
    return `${super._getRevertTooltipsSelector()}, .dx-field-item-content .${this.addWidgetPrefix("revert-tooltip")}`;
  }
};
var columns4 = (Base) => class extends Base {
  _isColumnVisible(column) {
    return super._isColumnVisible(column) && !column.adaptiveHidden;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    return super.getVisibleDataColumnsByBandColumn(bandColumnIndex).filter(((column) => "adaptiveHidden" !== column.visibleWidth));
  }
};
var resizing6 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._updateScrollableTimeoutID);
  }
  _needBestFit() {
    return super._needBestFit() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const adaptiveController = this._adaptiveColumnsController;
    const oldHiddenColumns = adaptiveController.getHiddenColumns();
    const hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
    const hiddenColumns = adaptiveController.getHiddenColumns();
    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
      if (oldHiddenColumns.length !== hiddenColumns.length) {
        adaptiveController.updateForm(hiddenColumns);
      }
    }
    !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
    return super._correctColumnWidths.apply(this, arguments);
  }
  _toggleBestFitMode(isBestFit) {
    isBestFit && this._adaptiveColumnsController._showHiddenColumns();
    super._toggleBestFitMode(isBestFit);
  }
  _needStretch() {
    const adaptiveColumnsController = this._adaptiveColumnsController;
    return super._needStretch.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();
  }
};
var adaptivityModule = {
  defaultOptions: () => ({
    columnHidingEnabled: false,
    onAdaptiveDetailRowPreparing: null
  }),
  controllers: {
    adaptiveColumns: AdaptiveColumnsController
  },
  extenders: {
    views: {
      rowsView: rowsView14
    },
    controllers: {
      export: exportExtender,
      columnsResizer: columnsResizer4,
      draggingHeader: draggingHeader3,
      editing: editing4,
      resizing: resizing6,
      data: data14,
      editorFactory: editorFactory4,
      columns: columns4,
      keyboardNavigation: keyboardNavigation3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/adaptivity.js
m_core_default.registerModule("adaptivity", adaptivityModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns_core.js
function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
  rowIndex = rowIndex || 0;
  offsets = offsets || [];
  lastProcessedIndexes = lastProcessedIndexes || [];
  offsets[rowIndex] = offsets[rowIndex] || 0;
  const row = info[rowIndex];
  const startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
  let processedColumnCount = 0;
  let colIndex;
  if (!row) {
    return;
  }
  for (colIndex = startIndex; colIndex < row.length; colIndex++) {
    const cell = row[colIndex];
    const visibleIndex = colIndex + offsets[rowIndex];
    const colspan = cell.colspan || 1;
    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
    offsets[rowIndex] += colspan - 1;
    processedColumnCount += colspan;
    if (cell.rowspan) {
      for (let i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
        offsets[i] = offsets[i] || 0;
        offsets[i] += cell.colspan || 1;
      }
    }
    if (false === callback(cell, visibleIndex, rowIndex, colIndex)) {
      break;
    }
    if (void 0 !== columnCount && processedColumnCount >= columnCount) {
      break;
    }
  }
  lastProcessedIndexes[rowIndex] = colIndex;
}
function createColumnsInfo(info, startIndex, endIndex) {
  const newInfo = [];
  foreachColumnInfo(info, ((columnInfo, visibleIndex, rowIndex) => {
    let cell = columnInfo;
    let colspan;
    const cellColspan = cell.colspan || 1;
    const isVisible = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
    newInfo[rowIndex] = newInfo[rowIndex] || [];
    if (isVisible) {
      if (visibleIndex < startIndex) {
        colspan = cellColspan - (startIndex - visibleIndex);
        visibleIndex = startIndex;
      } else {
        colspan = cellColspan;
      }
      if (visibleIndex + colspan > endIndex) {
        colspan = endIndex - visibleIndex;
      }
      if (colspan !== cellColspan) {
        cell = extend({}, cell, {
          colspan
        });
      }
      newInfo[rowIndex].push(cell);
    } else if (visibleIndex > endIndex) {
      return false;
    }
    return;
  }));
  for (let i = 0; i < newInfo.length; i++) {
    newInfo[i] = newInfo[i] || [];
  }
  return newInfo;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns.js
var baseView = (Base) => class extends Base {
  _needToSetCellWidths() {
    let result2 = super._needToSetCellWidths();
    if (!result2 && this._columnsController.isVirtualMode()) {
      const columns7 = this._columnsController.getColumns();
      result2 = columns7.some(((column) => "auto" === column.width));
    }
    return result2;
  }
};
var rowsView15 = (Base) => class extends baseView(Base) {
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._columnsController.resize();
  }
  _handleScroll(e) {
    const scrollable = this.getScrollable();
    let {
      left
    } = e.scrollOffset;
    super._handleScroll.apply(this, arguments);
    if (this.option("rtlEnabled") && scrollable) {
      left = getWidth(scrollable.$content()) - getWidth(scrollable.$element()) - left;
    }
    this._columnsController.setScrollPosition(left, e.event);
  }
  _renderCore(e) {
    if (null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_columnsControl, _this$_scrollable;
      const $contentElement = this._findContentElement();
      const fixedColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getFixedColumns();
      const useNativeScrolling = null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable ? void 0 : _this$_scrollable.option("useNative");
      const legacyMode = this.option("columnFixing.legacyMode");
      if (null !== fixedColumns && void 0 !== fixedColumns && fixedColumns.length) {
        if (legacyMode && !useNativeScrolling) {
          $contentElement.css({
            minHeight: m_utils_default.getContentHeightLimit(browser_default)
          });
        } else {
          $contentElement.css({
            minHeight: getHeight($contentElement)
          });
        }
        const resizeCompletedHandler = () => {
          this.resizeCompleted.remove(resizeCompletedHandler);
          $contentElement.css({
            minHeight: ""
          });
        };
        this.resizeCompleted.add(resizeCompletedHandler);
      }
    }
    return super._renderCore.apply(this, arguments);
  }
};
var columnHeadersView8 = (Base) => class extends baseView(Base) {
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this._columnsController.isVirtualMode()) {
      this._updateScrollLeftPosition();
    }
    return deferred;
  }
};
var getWidths = function(columns7) {
  return columns7.map(((column) => column.visibleWidth || parseFloat(column.width) || 50));
};
var columns5 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._resizingController = this.getController("resizing");
    this._beginPageIndex = null;
    this._endPageIndex = null;
    this._position ?? (this._position = 0);
    this._virtualVisibleColumns = {};
  }
  dispose() {
    clearTimeout(this._changedTimeout);
    super.dispose.apply(this, arguments);
  }
  resetColumnsCache() {
    super.resetColumnsCache();
    this._virtualVisibleColumns = {};
  }
  getBeginPageIndex(position2) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    for (let index = 0; index < widths.length; index++) {
      if (currentPosition >= position2) {
        return Math.floor(index / this.getColumnPageSize());
      }
      currentPosition += widths[index];
    }
    return 0;
  }
  getTotalWidth() {
    const width = this.option("width");
    if ("number" === typeof width) {
      return width;
    }
    return this._resizingController._lastWidth || getOuterWidth(this.component.$element());
  }
  getEndPageIndex(position2) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    position2 += this.getTotalWidth();
    for (let index = 0; index < widths.length; index++) {
      if (currentPosition >= position2) {
        return Math.ceil(index / this.getColumnPageSize());
      }
      currentPosition += widths[index];
    }
    return Math.ceil(widths.length / this.getColumnPageSize());
  }
  getColumnPageSize() {
    return this.option("scrolling.columnPageSize");
  }
  _fireColumnsChanged(event) {
    const date = /* @__PURE__ */ new Date();
    this.columnsChanged.fire({
      optionNames: {
        all: true,
        length: 1
      },
      changeTypes: {
        columns: true,
        virtualColumnsScrolling: true,
        length: 2,
        event
      }
    });
    this._renderTime = /* @__PURE__ */ new Date() - date;
  }
  getScrollingTimeout() {
    const renderingThreshold = this.option("scrolling.columnRenderingThreshold");
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync) && this._renderTime > renderingThreshold || renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout");
    }
    return scrollingTimeout;
  }
  setScrollPosition(position2, event) {
    const scrollingTimeout = this.getScrollingTimeout();
    if (scrollingTimeout > 0) {
      clearTimeout(this._changedTimeout);
      this._changedTimeout = setTimeout((() => {
        this._setScrollPositionCore(position2, event);
      }), scrollingTimeout);
    } else {
      this._setScrollPositionCore(position2, event);
    }
  }
  resize() {
    this._setScrollPositionCore(this._position);
  }
  _setScrollPositionCore(position2, event) {
    const that = this;
    if (that.isVirtualMode()) {
      const beginPageIndex = that.getBeginPageIndex(position2);
      const endPageIndex = that.getEndPageIndex(position2);
      const needColumnsChanged = position2 < that._position ? that._beginPageIndex > beginPageIndex : that._endPageIndex < endPageIndex;
      that._position = position2;
      if (needColumnsChanged) {
        that._beginPageIndex = beginPageIndex;
        that._endPageIndex = endPageIndex;
        that._fireColumnsChanged(event);
      }
    }
  }
  getFixedColumns(rowIndex, isBase) {
    const fixedColumns = super.getFixedColumns(rowIndex);
    if (this.isVirtualMode() && !isBase && fixedColumns.length) {
      const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
      fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - super.getFixedColumns().length + 1;
      return fixedColumns;
    }
    return fixedColumns;
  }
  _compileVisibleColumns(rowIndex, isBase) {
    var _this$_columns;
    if (isBase || !this.isVirtualMode() || !this._shouldReturnVisibleColumns()) {
      return super._compileVisibleColumns(rowIndex);
    }
    if (null !== (_this$_columns = this._columns) && void 0 !== _this$_columns && _this$_columns.length && !isDefined(this._beginPageIndex) && !isDefined(this._endPageIndex)) {
      this._beginPageIndex = this.getBeginPageIndex(this._position);
      this._endPageIndex = this.getEndPageIndex(this._position);
    }
    const beginPageIndex = this._beginPageIndex;
    const endPageIndex = this._endPageIndex;
    const visibleColumnsHash = `${rowIndex}-${beginPageIndex}-${endPageIndex}`;
    if (this._virtualVisibleColumns[visibleColumnsHash]) {
      return this._virtualVisibleColumns[visibleColumnsHash];
    }
    let visibleColumns = super._compileVisibleColumns();
    const rowCount = this.getRowCount();
    const pageSize = this.getColumnPageSize();
    let startIndex = beginPageIndex * pageSize;
    let endIndex = endPageIndex * pageSize;
    const fixedColumns = this.getFixedColumns(void 0, true);
    const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
    const beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;
    let beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);
    const beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);
    const beginWidth = getWidths(beginColumns).reduce(((a, b) => a + b), 0);
    if (!beginWidth) {
      startIndex = 0;
    }
    const endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;
    let endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);
    const endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);
    const endWidth = getWidths(endColumns).reduce(((a, b) => a + b), 0);
    if (!endWidth) {
      endIndex = visibleColumns.length;
    }
    if (rowCount > 1 && "number" === typeof rowIndex) {
      const columnsInfo = [];
      for (let i = 0; i <= rowCount; i++) {
        columnsInfo.push(super._compileVisibleColumns(i));
      }
      beginFixedColumns = createColumnsInfo(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];
      endFixedColumns = createColumnsInfo(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];
      visibleColumns = createColumnsInfo(columnsInfo, startIndex, endIndex)[rowIndex] || [];
    } else {
      visibleColumns = visibleColumns.slice(startIndex, endIndex);
    }
    if (beginWidth) {
      visibleColumns.unshift({
        command: "virtual",
        type: "virtual",
        width: beginWidth
      });
      visibleColumns = beginFixedColumns.concat(visibleColumns);
    }
    if (endWidth) {
      visibleColumns.push({
        command: "virtual",
        type: "virtual",
        width: endWidth
      });
      visibleColumns = visibleColumns.concat(endFixedColumns);
    }
    this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;
    return visibleColumns;
  }
  getColumnIndexOffset() {
    let offset = 0;
    if (this._beginPageIndex > 0) {
      const fixedColumns = this.getFixedColumns();
      const transparentColumnIndex = fixedColumns.map(((c) => c.command)).indexOf("transparent");
      const leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;
      offset = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1;
    }
    return offset > 0 ? offset : 0;
  }
  isVirtualMode() {
    return hasWindow() && "virtual" === this.option("scrolling.columnRenderingMode");
  }
};
var virtualColumnsModule = {
  defaultOptions: () => ({
    scrolling: {
      columnRenderingMode: "standard",
      columnPageSize: 5,
      columnRenderingThreshold: 300
    }
  }),
  extenders: {
    controllers: {
      columns: columns5
    },
    views: {
      columnHeadersView: columnHeadersView8,
      rowsView: rowsView15
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_columns.js
m_core_default.registerModule("virtualColumns", virtualColumnsModule);

// node_modules/devextreme/esm/__internal/data/data_controller/data_controller.js
var DataController3 = class {
  constructor(dataSourceOptions, _ref) {
    let {
      key
    } = _ref;
    this._isSharedDataSource = false;
    this._keyExpr = key;
    this.updateDataSource(dataSourceOptions);
  }
  _updateDataSource(dataSourceOptions) {
    if (!dataSourceOptions) {
      return;
    }
    if (dataSourceOptions instanceof DataSource) {
      this._isSharedDataSource = true;
      this._dataSource = dataSourceOptions;
    } else {
      const normalizedDataSourceOptions = normalizeDataSourceOptions(dataSourceOptions);
      this._dataSource = new DataSource(extend(true, {}, {}, normalizedDataSourceOptions));
    }
  }
  _updateDataSourceByItems(items) {
    this._dataSource = new DataSource({
      store: new m_array_store_default({
        key: this.key(),
        data: items
      }),
      pageSize: 0
    });
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        this._isSharedDataSource = false;
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
    }
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (!this._dataSource) {
      return new Deferred().reject();
    }
    let pName = propName;
    let pValue = propValue;
    if (arguments.length < 2) {
      pValue = propName;
      pName = this.key();
    }
    return this._dataSource.loadSingle(pName, pValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    if (void 0 === pageIndex) {
      return this._dataSource.pageIndex(void 0);
    }
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSource() {
    this._disposeDataSource();
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  updateDataSource(items, key) {
    const dataSourceOptions = items ?? this.items();
    if (key) {
      this._keyExpr = key;
    }
    this._disposeDataSource();
    if (Array.isArray(dataSourceOptions)) {
      this._updateDataSourceByItems(dataSourceOptions);
    } else {
      this._updateDataSource(dataSourceOptions);
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    return this._dataSource.searchExpr(expr);
  }
  select() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this._dataSource.select(args);
  }
  key() {
    var _this$_dataSource;
    const storeKey = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.key();
    return isDefined(storeKey) && "this" === this._keyExpr ? storeKey : this._keyExpr;
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.items();
  }
  applyMapFunction(data17) {
    return this._dataSource._applyMapFunction(data17);
  }
  getDataSource() {
    return this._dataSource ?? null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var data_controller_default = DataController3;

// node_modules/devextreme/esm/data_controller.js
var data_controller_default2 = data_controller_default;

// node_modules/devextreme/esm/__internal/ui/m_button_group.js
var BUTTON_GROUP_ITEM_HAS_WIDTH = "dx-buttongroup-item-has-width";
var BUTTON_GROUP_STYLING_MODE_CLASS = {
  contained: "dx-buttongroup-mode-contained",
  outlined: "dx-buttongroup-mode-outlined",
  text: "dx-buttongroup-mode-text"
};
var ButtonCollection = class extends ui_collection_widget_edit_default {
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate((($container, data17, model) => {
        this._prepareItemStyles($container);
        const template = this.option("buttonTemplate");
        this._createComponent($container, button_default2, extend({}, model, data17, this._getBasicButtonOptions(), {
          _templateData: this._hasCustomTemplate(template) ? model : {},
          template: model.template || template
        }));
      }), ["text", "type", "icon", "disabled", "visible", "hint"], this.option("integrationOptions.watchMethod"))
    });
  }
  _getBasicButtonOptions() {
    const {
      hoverStateEnabled,
      activeStateEnabled,
      stylingMode
    } = this.option();
    return {
      focusStateEnabled: false,
      onClick: null,
      hoverStateEnabled,
      activeStateEnabled,
      stylingMode
    };
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTemplateProperty: null
    });
  }
  _hasCustomTemplate(template) {
    return isFunction(template) || this.option("integrationOptions.templates")[template];
  }
  _selectedItemClass() {
    return "dx-item-selected dx-state-selected";
  }
  _prepareItemStyles($item) {
    const itemIndex = $item.data("dxItemIndex");
    if (0 === itemIndex) {
      $item.addClass("dx-buttongroup-first-item");
    }
    const {
      items
    } = this.option();
    items && itemIndex === items.length - 1 && $item.addClass("dx-buttongroup-last-item");
    $item.addClass("dx-shape-standard");
  }
  _renderItemContent(args) {
    args.container = renderer_default(args.container).parent();
    return super._renderItemContent(args);
  }
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("pressed", value2, $target);
  }
  _renderItemContentByNode(args, $node) {
    args.container = renderer_default(args.container.children().first());
    return super._renderItemContentByNode(args, $node);
  }
  _focusTarget() {
    return this.$element().parent();
  }
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _itemClass() {
    return "dx-buttongroup-item";
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    if ("single" === selectionMode && this.isItemSelected(e.currentTarget)) {
      return;
    }
    super._itemSelectHandler(e);
  }
};
var ButtonGroup = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      focusStateEnabled: true,
      selectionMode: "single",
      selectedItems: [],
      selectedItemKeys: [],
      stylingMode: "contained",
      keyExpr: "text",
      items: [],
      buttonTemplate: "content",
      onSelectionChanged: null,
      onItemClick: null
    });
  }
  _init() {
    super._init();
    this._createItemClickAction();
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initMarkup() {
    this.setAria("role", "group");
    this.$element().addClass("dx-buttongroup");
    this._renderStylingMode();
    this._renderButtons();
    this._syncSelectionOptions();
    super._initMarkup();
  }
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    for (const key in BUTTON_GROUP_STYLING_MODE_CLASS) {
      this.$element().removeClass(BUTTON_GROUP_STYLING_MODE_CLASS[key]);
    }
    this.$element().addClass(BUTTON_GROUP_STYLING_MODE_CLASS[stylingMode ?? "contained"]);
  }
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  }
  _renderButtons() {
    const $buttons = renderer_default("<div>").addClass("dx-buttongroup-wrapper").appendTo(this.$element());
    const {
      selectedItems
    } = this.option();
    const options2 = {
      selectionMode: this.option("selectionMode"),
      items: this.option("items"),
      keyExpr: this.option("keyExpr"),
      buttonTemplate: this.option("buttonTemplate"),
      scrollingEnabled: false,
      selectedItemKeys: this.option("selectedItemKeys"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode"),
      accessKey: this.option("accessKey"),
      tabIndex: this.option("tabIndex"),
      noDataText: "",
      selectionRequired: false,
      onItemRendered: (e) => {
        const width = this.option("width");
        if (isDefined(width)) {
          renderer_default(e.itemElement).addClass(BUTTON_GROUP_ITEM_HAS_WIDTH);
        }
      },
      onSelectionChanged: (e) => {
        this._syncSelectionOptions();
        this._fireSelectionChangeEvent(e.addedItems, e.removedItems);
      },
      onItemClick: (e) => {
        this._itemClickAction(e);
      }
    };
    if (isDefined(selectedItems) && selectedItems.length) {
      options2.selectedItems = selectedItems;
    }
    this._buttonsCollection = this._createComponent($buttons, ButtonCollection, options2);
  }
  _syncSelectionOptions() {
    this._setOptionWithoutOptionChange("selectedItems", this._buttonsCollection.option("selectedItems"));
    this._setOptionWithoutOptionChange("selectedItemKeys", this._buttonsCollection.option("selectedItemKeys"));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "stylingMode":
      case "selectionMode":
      case "keyExpr":
      case "buttonTemplate":
      case "items":
      case "activeStateEnabled":
      case "focusStateEnabled":
      case "hoverStateEnabled":
      case "tabIndex":
        this._invalidate();
        break;
      case "selectedItemKeys":
      case "selectedItems":
        this._buttonsCollection.option(args.name, args.value);
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onSelectionChanged":
        break;
      case "width":
        super._optionChanged(args);
        this._buttonsCollection.itemElements().toggleClass(BUTTON_GROUP_ITEM_HAS_WIDTH, !!args.value);
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxButtonGroup", ButtonGroup);
var m_button_group_default = ButtonGroup;

// node_modules/devextreme/esm/ui/button_group.js
var button_group_default = m_button_group_default;

// node_modules/devextreme/esm/__internal/ui/m_drop_down_button.js
var DROP_DOWN_BUTTON_CONTENT = "dx-dropdownbutton-content";
var DropDownButton2 = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTemplate: "item",
      keyExpr: "this",
      selectedItem: null,
      selectedItemKey: null,
      stylingMode: "outlined",
      deferRendering: true,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      useSelectMode: false,
      splitButton: false,
      showArrowIcon: true,
      template: null,
      text: "",
      type: "normal",
      onButtonClick: null,
      onSelectionChanged: null,
      onItemClick: null,
      opened: false,
      items: null,
      dataSource: null,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      dropDownOptions: {},
      dropDownContentTemplate: "content",
      wrapItemText: false,
      useItemTextAsTitle: true,
      grouped: false,
      groupTemplate: "group",
      buttonGroupOptions: {}
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  }
  _init() {
    super._init();
    this._createItemClickAction();
    this._createActionClickAction();
    this._createSelectionChangedAction();
    this._initDataController();
    this._compileKeyGetter();
    this._compileDisplayGetter();
    this._options.cache("buttonGroupOptions", this.option("buttonGroupOptions"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  }
  _initDataController() {
    const dataSource = this.option("dataSource");
    this._dataController = new data_controller_default2(dataSource ?? this.option("items"), {
      key: this.option("keyExpr")
    });
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new FunctionTemplate(((options2) => {
        const $popupContent = renderer_default(options2.container);
        const $listContainer = renderer_default("<div>").appendTo($popupContent);
        this._list = this._createComponent($listContainer, list_light_default, this._listOptions());
        this._list.registerKeyHandler("escape", this._escHandler.bind(this));
        this._list.registerKeyHandler("tab", this._escHandler.bind(this));
        this._list.registerKeyHandler("leftArrow", this._escHandler.bind(this));
        this._list.registerKeyHandler("rightArrow", this._escHandler.bind(this));
      }))
    });
    super._initTemplates();
  }
  _compileKeyGetter() {
    this._keyGetter = compileGetter(this._dataController.key());
  }
  _compileDisplayGetter() {
    const {
      displayExpr
    } = this.option();
    this._displayGetter = compileGetter(displayExpr);
  }
  _initMarkup() {
    super._initMarkup();
    this.$element().addClass("dx-dropdownbutton");
    this._renderButtonGroup();
    this._updateArrowClass();
    if (isDefined(this.option("selectedItemKey"))) {
      this._loadSelectedItem().done(this._updateActionButton.bind(this));
    }
  }
  _renderFocusTarget() {
  }
  _render() {
    if (!this.option("deferRendering") || this.option("opened")) {
      this._renderPopup();
    }
    super._render();
  }
  _renderContentImpl() {
    if (this._popup) {
      this._renderPopupContent();
    }
    return super._renderContentImpl();
  }
  _loadSelectedItem() {
    var _this$_loadSingleDefe;
    null === (_this$_loadSingleDefe = this._loadSingleDeferred) || void 0 === _this$_loadSingleDefe || _this$_loadSingleDefe.reject();
    const d = Deferred();
    if (this._list && void 0 !== this._lastSelectedItemData) {
      const cachedResult = this.option("useSelectMode") ? this._list.option("selectedItem") : this._lastSelectedItemData;
      return d.resolve(cachedResult);
    }
    this._lastSelectedItemData = void 0;
    const selectedItemKey = this.option("selectedItemKey");
    this._dataController.loadSingle(selectedItemKey).done(d.resolve).fail((() => {
      d.reject(null);
    }));
    this._loadSingleDeferred = d;
    return d.promise();
  }
  _createActionClickAction() {
    this._actionClickAction = this._createActionByOption("onButtonClick");
  }
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _fireSelectionChangedAction(_ref) {
    let {
      previousValue,
      value: value2
    } = _ref;
    this._selectionChangedAction({
      item: value2,
      previousItem: previousValue
    });
  }
  _fireItemClickAction(_ref2) {
    let {
      event,
      itemElement,
      itemData
    } = _ref2;
    return this._itemClickAction({
      event,
      itemElement,
      itemData: this._actionItem || itemData
    });
  }
  _getButtonTemplate() {
    const {
      template,
      splitButton,
      showArrowIcon
    } = this.option();
    if (template) {
      return template;
    }
    return splitButton || !showArrowIcon ? "content" : (_ref3, buttonContent) => {
      let {
        text,
        icon
      } = _ref3;
      const $firstIcon = getImageContainer(icon);
      const $textContainer = text ? renderer_default("<span>").text(text).addClass("dx-button-text") : void 0;
      const $secondIcon = getImageContainer("spindown").addClass("dx-icon-right");
      renderer_default(buttonContent).append($firstIcon, $textContainer, $secondIcon);
    };
  }
  _getActionButtonConfig() {
    const {
      icon,
      text,
      type: type2,
      splitButton
    } = this.option();
    const actionButtonConfig = {
      text,
      icon,
      type: type2,
      template: this._getButtonTemplate(),
      elementAttr: {
        class: "dx-dropdownbutton-action"
      }
    };
    if (splitButton) {
      actionButtonConfig.elementAttr.role = "menuitem";
    }
    return actionButtonConfig;
  }
  _getSpinButtonConfig() {
    const {
      type: type2
    } = this.option();
    const config2 = {
      type: type2,
      icon: "spindown",
      elementAttr: {
        class: "dx-dropdownbutton-toggle",
        role: "menuitem"
      }
    };
    return config2;
  }
  _getButtonGroupItems() {
    const {
      splitButton
    } = this.option();
    const items = [this._getActionButtonConfig()];
    if (splitButton) {
      items.push(this._getSpinButtonConfig());
    }
    return items;
  }
  _buttonGroupItemClick(_ref4) {
    let {
      event,
      itemData
    } = _ref4;
    const isActionButton = "dx-dropdownbutton-action" === itemData.elementAttr.class;
    const isToggleButton = "dx-dropdownbutton-toggle" === itemData.elementAttr.class;
    if (isToggleButton) {
      this.toggle();
    } else if (isActionButton) {
      this._actionClickAction({
        event,
        selectedItem: this.option("selectedItem")
      });
      if (!this.option("splitButton")) {
        this.toggle();
      }
    }
  }
  _getButtonGroupOptions() {
    const {
      accessKey,
      focusStateEnabled,
      hoverStateEnabled,
      splitButton,
      stylingMode,
      tabIndex
    } = this.option();
    const buttonGroupOptions = _extends({
      items: this._getButtonGroupItems(),
      width: "100%",
      height: "100%",
      selectionMode: "none",
      focusStateEnabled,
      hoverStateEnabled,
      stylingMode,
      accessKey,
      tabIndex,
      elementAttr: {
        role: splitButton ? "menu" : "group"
      },
      onItemClick: this._buttonGroupItemClick.bind(this),
      onKeyboardHandled: (e) => this._keyboardHandler(e)
    }, this._options.cache("buttonGroupOptions"));
    return buttonGroupOptions;
  }
  _renderPopupContent() {
    const $content = this._popup.$content();
    const template = this._getTemplateByOption("dropDownContentTemplate");
    $content.empty();
    this._popupContentId = `dx-${new guid_default()}`;
    this.setAria("id", this._popupContentId, $content);
    const result2 = template.render({
      container: getPublicElement($content),
      model: this.option("items") || this._dataController.getDataSource()
    });
    return result2;
  }
  _popupOptions() {
    const horizontalAlignment = this.option("rtlEnabled") ? "right" : "left";
    return extend({
      dragEnabled: false,
      focusStateEnabled: false,
      deferRendering: this.option("deferRendering"),
      hideOnOutsideClick: (e) => {
        const $element = this.$element();
        const $buttonClicked = renderer_default(e.target).closest(".dx-dropdownbutton");
        return !$buttonClicked.is($element);
      },
      showTitle: false,
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      position: {
        of: this.$element(),
        collision: "flipfit",
        my: `${horizontalAlignment} top`,
        at: `${horizontalAlignment} bottom`
      },
      _wrapperClassExternal: "dx-dropdowneditor-overlay",
      contentTemplate: null
    }, this._options.cache("dropDownOptions"), {
      visible: this.option("opened")
    });
  }
  _listOptions() {
    const selectedItemKey = this.option("selectedItemKey");
    const useSelectMode = this.option("useSelectMode");
    return {
      selectionMode: useSelectMode ? "single" : "none",
      wrapItemText: this.option("wrapItemText"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: () => this._fireContentReadyAction(),
      selectedItemKeys: isDefined(selectedItemKey) && useSelectMode ? [selectedItemKey] : [],
      grouped: this.option("grouped"),
      groupTemplate: this.option("groupTemplate"),
      keyExpr: this._dataController.key(),
      noDataText: this.option("noDataText"),
      displayExpr: this.option("displayExpr"),
      itemTemplate: this.option("itemTemplate"),
      items: this.option("items"),
      dataSource: this._dataController.getDataSource(),
      onItemClick: (e) => {
        if (!this.option("useSelectMode")) {
          this._lastSelectedItemData = e.itemData;
        }
        this.option("selectedItemKey", this._keyGetter(e.itemData));
        const actionResult = this._fireItemClickAction(e);
        if (false !== actionResult) {
          this.toggle(false);
          this._buttonGroup.focus();
        }
      }
    };
  }
  _upDownKeyHandler() {
    var _this$_popup;
    if (null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible") && this._list) {
      this._list.focus();
    } else {
      this.open();
    }
    return true;
  }
  _escHandler() {
    this.close();
    this._buttonGroup.focus();
    return true;
  }
  _tabHandler() {
    this.close();
    return true;
  }
  _renderPopup() {
    const $popup = renderer_default("<div>");
    this.$element().append($popup);
    this._popup = this._createComponent($popup, m_popup_default, this._popupOptions());
    this._popup.$content().addClass(DROP_DOWN_BUTTON_CONTENT);
    this._popup.$wrapper().addClass("dx-dropdownbutton-popup-wrapper");
    this._popup.$overlayContent().attr("aria-label", "Dropdown");
    this._popup.on("hiding", this._popupHidingHandler.bind(this));
    this._popup.on("showing", this._popupShowingHandler.bind(this));
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _popupHidingHandler() {
    this.option("opened", false);
    this._updateAriaAttributes(false);
  }
  _popupOptionChanged(args) {
    const options2 = widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  }
  _dimensionChanged() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", (() => getElementWidth(this.$element())));
    }
  }
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  }
  _popupShowingHandler() {
    this.option("opened", true);
    this._updateAriaAttributes(true);
  }
  _setElementAria(value2) {
    const elementAria = {
      owns: value2 ? this._popupContentId : void 0
    };
    this.setAria(elementAria, this.$element());
  }
  _setButtonsAria(value2) {
    const commonButtonAria = {
      expanded: value2,
      haspopup: "listbox"
    };
    const firstButtonAria = {};
    if (!this.option("text")) {
      firstButtonAria.label = "dropdownbutton";
    }
    this._getButtons().each(((index, $button) => {
      if (0 === index) {
        this.setAria(_extends({}, firstButtonAria, commonButtonAria), renderer_default($button));
      } else {
        this.setAria(commonButtonAria, renderer_default($button));
      }
    }));
  }
  _updateAriaAttributes(value2) {
    this._setElementAria(value2);
    this._setButtonsAria(value2);
  }
  _getButtons() {
    return this._buttonGroup.$element().find(".dx-button");
  }
  _renderButtonGroup() {
    var _this$_buttonGroup;
    const $buttonGroup = (null === (_this$_buttonGroup = this._buttonGroup) || void 0 === _this$_buttonGroup ? void 0 : _this$_buttonGroup.$element()) || renderer_default("<div>");
    if (!this._buttonGroup) {
      this.$element().append($buttonGroup);
    }
    this._buttonGroup = this._createComponent($buttonGroup, button_group_default, this._getButtonGroupOptions());
    this._buttonGroup.registerKeyHandler("downArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("tab", this._tabHandler.bind(this));
    this._buttonGroup.registerKeyHandler("upArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("escape", this._escHandler.bind(this));
    this._bindInnerWidgetOptions(this._buttonGroup, "buttonGroupOptions");
    this._updateAriaAttributes(this.option("opened"));
  }
  _updateArrowClass() {
    const hasArrow = this.option("splitButton") || this.option("showArrowIcon");
    this.$element().toggleClass("dx-dropdownbutton-has-arrow", hasArrow);
  }
  toggle(visible) {
    var _this$_popup2;
    if (!this._popup) {
      this._renderPopup();
      this._renderContent();
    }
    return null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 ? void 0 : _this$_popup2.toggle(visible);
  }
  open() {
    return this.toggle(true);
  }
  close() {
    return this.toggle(false);
  }
  _setListOption(name2, value2) {
    var _this$_list;
    null === (_this$_list = this._list) || void 0 === _this$_list || _this$_list.option(name2, value2);
  }
  _getDisplayValue(item) {
    const isPrimitiveItem = !isObject(item);
    const displayValue = isPrimitiveItem ? item : this._displayGetter(item);
    return !isObject(displayValue) ? String(ensureDefined(displayValue, "")) : "";
  }
  _updateActionButton(selectedItem) {
    if (this.option("useSelectMode")) {
      this.option({
        text: this._getDisplayValue(selectedItem),
        icon: isPlainObject(selectedItem) ? selectedItem.icon : void 0
      });
    }
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
    this._setOptionWithoutOptionChange("selectedItemKey", this._keyGetter(selectedItem));
  }
  _clean() {
    var _this$_list2, _this$_popup3;
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2.$element().remove();
    null === (_this$_popup3 = this._popup) || void 0 === _this$_popup3 || _this$_popup3.$element().remove();
  }
  _selectedItemKeyChanged(value2) {
    this._setListOption("selectedItemKeys", this.option("useSelectMode") && isDefined(value2) ? [value2] : []);
    const previousItem = this.option("selectedItem");
    this._loadSelectedItem().always(((selectedItem) => {
      this._updateActionButton(selectedItem);
      if (this._displayGetter(previousItem) !== this._displayGetter(selectedItem)) {
        this._fireSelectionChangedAction({
          previousValue: previousItem,
          value: selectedItem
        });
      }
    }));
  }
  _updateButtonGroup(name2, value2) {
    this._buttonGroup.option(name2, value2);
    this._updateAriaAttributes(this.option("opened"));
  }
  _actionButtonOptionChanged(_ref5) {
    let {
      name: name2,
      value: value2
    } = _ref5;
    const newConfig = {};
    newConfig[name2] = value2;
    this._updateButtonGroup("items[0]", extend({}, this._getActionButtonConfig(), newConfig));
    this._popup && this._popup.repaint();
  }
  _selectModeChanged(value2) {
    if (value2) {
      this._setListOption("selectionMode", "single");
      const selectedItemKey = this.option("selectedItemKey");
      this._setListOption("selectedItemKeys", isDefined(selectedItemKey) ? [selectedItemKey] : []);
      this._selectedItemKeyChanged(this.option("selectedItemKey"));
    } else {
      this._setListOption("selectionMode", "none");
      this.option({
        selectedItemKey: void 0,
        selectedItem: void 0
      });
      this._actionButtonOptionChanged({
        text: this.option("text")
      });
    }
  }
  _updateItemCollection(optionName) {
    const selectedItemKey = this.option("selectedItemKey");
    this._setListOption("selectedItem", null);
    this._setWidgetOption("_list", [optionName]);
    if (isDefined(selectedItemKey)) {
      this._loadSelectedItem().done(((selectedItem) => {
        this._setListOption("selectedItemKeys", [selectedItemKey]);
        this._setListOption("selectedItem", selectedItem);
      })).fail(((error) => {
        this._setListOption("selectedItemKeys", []);
      })).always(this._updateActionButton.bind(this));
    }
  }
  _updateDataController(items) {
    this._dataController.updateDataSource(items, this.option("keyExpr"));
    this._updateKeyExpr();
  }
  _updateKeyExpr() {
    this._compileKeyGetter();
    this._setListOption("keyExpr", this._dataController.key());
  }
  focus() {
    this._buttonGroup.focus();
  }
  _optionChanged(args) {
    var _this$_popup4;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useSelectMode":
        this._selectModeChanged(value2);
        break;
      case "splitButton":
        this._updateArrowClass();
        this._renderButtonGroup();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._setListOption(name2, value2);
        this._updateActionButton(this.option("selectedItem"));
        break;
      case "keyExpr":
        this._updateDataController();
        break;
      case "buttonGroupOptions":
        this._innerWidgetOptionChanged(this._buttonGroup, args);
        break;
      case "dropDownOptions":
        if ("dropDownOptions.visible" === args.fullName) {
          break;
        }
        if (void 0 !== args.value.visible) {
          delete args.value.visible;
        }
        this._popupOptionChanged(args);
        this._innerWidgetOptionChanged(this._popup, args);
        break;
      case "opened":
        this.toggle(value2);
        break;
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setListOption(name2, value2);
        this._updateButtonGroup(name2, value2);
        super._optionChanged(args);
        break;
      case "items":
        this._updateDataController(this.option("items"));
        this._updateItemCollection(name2);
        break;
      case "dataSource":
        this._dataController.updateDataSource(value2);
        this._updateKeyExpr();
        this._updateItemCollection(name2);
        break;
      case "icon":
      case "text":
        this._actionButtonOptionChanged(args);
        break;
      case "showArrowIcon":
        this._updateArrowClass();
        this._renderButtonGroup();
        this._popup && this._popup.repaint();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_popup4 = this._popup) || void 0 === _this$_popup4 || _this$_popup4.repaint();
        break;
      case "stylingMode":
      case "tabIndex":
        this._updateButtonGroup(name2, value2);
        break;
      case "type":
        this._updateButtonGroup("items", this._getButtonGroupItems());
        break;
      case "itemTemplate":
      case "grouped":
      case "noDataText":
      case "groupTemplate":
      case "wrapItemText":
      case "useItemTextAsTitle":
        this._setListOption(name2, value2);
        break;
      case "dropDownContentTemplate":
        this._renderContent();
        break;
      case "selectedItemKey":
        this._selectedItemKeyChanged(value2);
        break;
      case "selectedItem":
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onButtonClick":
        this._createActionClickAction();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "deferRendering": {
        const {
          opened
        } = this.option();
        this.toggle(opened);
        break;
      }
      case "template":
        this._renderButtonGroup();
        break;
      default:
        super._optionChanged(args);
    }
  }
  getDataSource() {
    return this._dataController.getDataSource();
  }
};
component_registrator_default("dxDropDownButton", DropDownButton2);

// node_modules/devextreme/esm/__internal/grids/grid_core/m_export.js
function prepareItems(items, emptyCell) {
  const defaultSetter = (value2) => !value2 ? 1 : value2;
  const resultItems = [];
  const cols = (items[0] || []).reduce(((sum, item2) => sum + defaultSetter(item2.colspan)), 0);
  const getItem = /* @__PURE__ */ ((items2) => {
    let rowIndex2 = 0;
    let cellIndex = 0;
    return () => {
      const row = items2[rowIndex2] || [];
      const item2 = row[cellIndex++];
      if (cellIndex >= row.length) {
        rowIndex2++;
        cellIndex = 0;
      }
      if (item2) {
        item2.colspan = defaultSetter(item2.colspan);
        item2.rowspan = defaultSetter(item2.rowspan);
      }
      return item2;
    };
  })(items);
  const addItem2 = (rowIndex2, cellIndex, item2) => {
    const row = resultItems[rowIndex2] = resultItems[rowIndex2] || [];
    row[cellIndex] = item2;
    if (item2.colspan > 1 || item2.rowspan > 1) {
      const clone = ((item3) => extend({}, item3, emptyCell))(item2);
      for (let c = 1; c < item2.colspan; c++) {
        addItem2(rowIndex2, cellIndex + c, clone);
      }
      for (let r = 1; r < item2.rowspan; r++) {
        for (let c = 0; c < item2.colspan; c++) {
          addItem2(rowIndex2 + r, cellIndex + c, clone);
        }
      }
    }
  };
  let item = getItem();
  let rowIndex = 0;
  while (item) {
    for (let cellIndex = 0; cellIndex < cols; cellIndex++) {
      if (!item) {
        break;
      }
      if (resultItems[rowIndex] && resultItems[rowIndex][cellIndex]) {
        continue;
      }
      addItem2(rowIndex, cellIndex, item);
      cellIndex += item.colspan - 1;
      item = getItem();
    }
    rowIndex++;
  }
  return resultItems;
}

// node_modules/devextreme/esm/__internal/grids/data_grid/export/m_export.js
var DataProvider = class {
  constructor(exportController, initialColumnWidthsByColumnIndex, selectedRowsOnly) {
    this._exportController = exportController;
    this._initialColumnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
    this._selectedRowsOnly = selectedRowsOnly;
  }
  _getGroupValue(item) {
    const {
      key,
      data: data17,
      rowType,
      groupIndex,
      summaryCells
    } = item;
    const groupColumn = this._options.groupColumns[groupIndex];
    const value2 = m_core_default.getDisplayValue(groupColumn, groupColumn.deserializeValue ? groupColumn.deserializeValue(key[groupIndex]) : key[groupIndex], data17, rowType);
    let result2 = `${groupColumn.caption}: ${m_core_default.formatValue(value2, groupColumn)}`;
    if (summaryCells && summaryCells[0] && summaryCells[0].length) {
      result2 += ` ${m_core_default.getGroupRowSummaryText(summaryCells[0], this._options.summaryTexts)}`;
    }
    return result2;
  }
  _correctCellIndex(cellIndex) {
    return cellIndex;
  }
  _initOptions() {
    const exportController = this._exportController;
    const groupColumns = exportController._columnsController.getGroupColumns();
    this._options = {
      columns: exportController._getColumns(this._initialColumnWidthsByColumnIndex),
      groupColumns,
      items: this._selectedRowsOnly || exportController._selectionOnly ? exportController._getSelectedItems() : exportController._getAllItems(),
      isHeadersVisible: exportController.option("showColumnHeaders"),
      summaryTexts: exportController.option("summary.texts"),
      rtlEnabled: exportController.option("rtlEnabled")
    };
  }
  getHeaderStyles() {
    return [{
      bold: true,
      alignment: "center"
    }, {
      bold: true,
      alignment: "left"
    }, {
      bold: true,
      alignment: "right"
    }];
  }
  getGroupRowStyle() {
    return {
      bold: true,
      alignment: getDefaultAlignment(this._options.rtlEnabled)
    };
  }
  getColumnStyles() {
    const columnStyles = [];
    this.getColumns().forEach(((column) => {
      columnStyles.push({
        alignment: column.alignment || "left",
        format: column.format,
        dataType: column.dataType
      });
    }));
    return columnStyles;
  }
  getStyles() {
    return [...this.getHeaderStyles(), ...this.getColumnStyles(), this.getGroupRowStyle()];
  }
  _getTotalCellStyleId(cellIndex) {
    var _this$getColumns$cell;
    const alignment = (null === (_this$getColumns$cell = this.getColumns()[cellIndex]) || void 0 === _this$getColumns$cell ? void 0 : _this$getColumns$cell.alignment) || "right";
    return this.getHeaderStyles().map(((style) => style.alignment)).indexOf(alignment);
  }
  getStyleId(rowIndex, cellIndex) {
    if (rowIndex < this.getHeaderRowCount()) {
      return 0;
    }
    if (this.isTotalCell(rowIndex - this.getHeaderRowCount(), cellIndex)) {
      return this._getTotalCellStyleId(cellIndex);
    }
    if (this.isGroupRow(rowIndex - this.getHeaderRowCount())) {
      return this.getHeaderStyles().length + this.getColumns().length;
    }
    return cellIndex + this.getHeaderStyles().length;
  }
  getColumns(getColumnsByAllRows) {
    const {
      columns: columns7
    } = this._options;
    return getColumnsByAllRows ? columns7 : columns7[columns7.length - 1];
  }
  getColumnsWidths() {
    const columns7 = this.getColumns();
    return isDefined(columns7) ? columns7.map(((c) => c.width)) : void 0;
  }
  getRowsCount() {
    return this._options.items.length + this.getHeaderRowCount();
  }
  getHeaderRowCount() {
    if (this.isHeadersVisible()) {
      return this._options.columns.length - 1;
    }
    return 0;
  }
  isGroupRow(rowIndex) {
    return rowIndex < this._options.items.length && "group" === this._options.items[rowIndex].rowType;
  }
  getGroupLevel(rowIndex) {
    const item = this._options.items[rowIndex - this.getHeaderRowCount()];
    const groupIndex = item && item.groupIndex;
    if (item && "totalFooter" === item.rowType) {
      return 0;
    }
    return isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length;
  }
  getCellType(rowIndex, cellIndex) {
    const columns7 = this.getColumns();
    if (rowIndex < this.getHeaderRowCount()) {
      return "string";
    }
    rowIndex -= this.getHeaderRowCount();
    if (cellIndex < columns7.length) {
      const item = this._options.items.length && this._options.items[rowIndex];
      const column = columns7[cellIndex];
      if (item && "data" === item.rowType) {
        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !isDefined(column.customizeText)) {
          return isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
        }
      }
      return "string";
    }
  }
  ready() {
    this._initOptions();
    const options2 = this._options;
    return when(options2.items).done(((items) => {
      options2.items = items;
    })).fail((() => {
      options2.items = [];
    }));
  }
  _convertFromGridGroupSummaryItems(gridGroupSummaryItems) {
    if (isDefined(gridGroupSummaryItems) && gridGroupSummaryItems.length > 0) {
      return gridGroupSummaryItems.map(((item) => ({
        value: item.value,
        name: item.name
      })));
    }
  }
  getCellData(rowIndex, cellIndex, isExcelJS) {
    let value2;
    let column;
    const result2 = {
      cellSourceData: {},
      value: value2
    };
    const columns7 = this.getColumns();
    const correctedCellIndex = this._correctCellIndex(cellIndex);
    if (rowIndex < this.getHeaderRowCount()) {
      const columnsRow = this.getColumns(true)[rowIndex];
      column = columnsRow[cellIndex];
      result2.cellSourceData.rowType = "header";
      result2.cellSourceData.column = column && column.gridColumn;
      result2.value = column && column.caption;
    } else {
      rowIndex -= this.getHeaderRowCount();
      const item = this._options.items.length && this._options.items[rowIndex];
      if (item) {
        const itemValues = item.values;
        result2.cellSourceData.rowType = item.rowType;
        result2.cellSourceData.column = columns7[cellIndex] && columns7[cellIndex].gridColumn;
        switch (item.rowType) {
          case "groupFooter":
          case "totalFooter":
            if (correctedCellIndex < itemValues.length) {
              value2 = itemValues[correctedCellIndex];
              if (isDefined(value2)) {
                result2.cellSourceData.value = value2.value;
                result2.cellSourceData.totalSummaryItemName = value2.name;
                result2.value = m_core_default.getSummaryText(value2, this._options.summaryTexts);
              } else {
                result2.cellSourceData.value = void 0;
              }
            }
            break;
          case "group":
            result2.cellSourceData.groupIndex = item.groupIndex;
            if (cellIndex < 1) {
              result2.cellSourceData.column = this._options.groupColumns[item.groupIndex];
              result2.cellSourceData.value = item.key[item.groupIndex];
              result2.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(item.summaryCells[0]);
              result2.value = this._getGroupValue(item);
            } else {
              const summaryItems = item.values[correctedCellIndex];
              if (Array.isArray(summaryItems)) {
                result2.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(summaryItems);
                value2 = "";
                for (let i = 0; i < summaryItems.length; i++) {
                  value2 += (i > 0 ? isExcelJS ? "\n" : " \n " : "") + m_core_default.getSummaryText(summaryItems[i], this._options.summaryTexts);
                }
                result2.value = value2;
              } else {
                result2.cellSourceData.value = void 0;
              }
            }
            break;
          default:
            column = columns7[cellIndex];
            if (column) {
              const value3 = itemValues[correctedCellIndex];
              const displayValue = m_core_default.getDisplayValue(column, value3, item.data, item.rowType);
              if (!isFinite(displayValue) || isDefined(column.customizeText)) {
                if (isExcelJS && isDefined(column.customizeText) && column.customizeText === this._exportController._columnsController.getCustomizeTextByDataType("boolean")) {
                  result2.value = displayValue;
                } else {
                  result2.value = m_core_default.formatValue(displayValue, column);
                }
              } else {
                result2.value = displayValue;
              }
              result2.cellSourceData.value = value3;
            }
            result2.cellSourceData.data = item.data;
        }
      }
    }
    return result2;
  }
  isHeadersVisible() {
    return this._options.isHeadersVisible;
  }
  isTotalCell(rowIndex, cellIndex) {
    const {
      items
    } = this._options;
    const item = items[rowIndex];
    const correctCellIndex = this._correctCellIndex(cellIndex);
    const isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
    return item && "groupFooter" === item.rowType || "totalFooter" === item.rowType || isSummaryAlignByColumn;
  }
  getCellMerging(rowIndex, cellIndex) {
    const {
      columns: columns7
    } = this._options;
    const column = columns7[rowIndex] && columns7[rowIndex][cellIndex];
    return column ? {
      colspan: (column.exportColspan || 1) - 1,
      rowspan: (column.rowspan || 1) - 1
    } : {
      colspan: 0,
      rowspan: 0
    };
  }
  getFrozenArea() {
    return {
      x: 0,
      y: this.getHeaderRowCount()
    };
  }
};
var ExportController = class extends m_core_default.ViewController {
  init() {
    this.throwWarningIfNoOnExportingEvent();
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._rowsView = this.getView("rowsView");
    this._headersView = this.getView("columnHeadersView");
    this.createAction("onExporting", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getEmptyCell() {
    return {
      caption: "",
      colspan: 1,
      rowspan: 1
    };
  }
  _updateColumnWidth(column, width) {
    column.width = width;
  }
  _getColumns(initialColumnWidthsByColumnIndex) {
    let result2 = [];
    let i;
    let columns7;
    const columnsController = this._columnsController;
    const rowCount = columnsController.getRowCount();
    for (i = 0; i <= rowCount; i++) {
      const currentHeaderRow = [];
      columns7 = columnsController.getVisibleColumns(i, true);
      let columnWidthsByColumnIndex;
      if (i === rowCount) {
        if (this._updateLockCount) {
          columnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
        } else {
          const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
          if (columnWidths && columnWidths.length) {
            columnWidthsByColumnIndex = {};
            for (let i2 = 0; i2 < columns7.length; i2++) {
              columnWidthsByColumnIndex[columns7[i2].index] = columnWidths[i2];
            }
          }
        }
      }
      for (let j = 0; j < columns7.length; j++) {
        const column = extend({}, columns7[j], {
          dataType: "datetime" === columns7[j].dataType ? "date" : columns7[j].dataType,
          gridColumn: columns7[j]
        });
        if (this._needColumnExporting(column)) {
          const currentColspan = this._calculateExportColspan(column);
          if (isDefined(currentColspan)) {
            column.exportColspan = currentColspan;
          }
          if (columnWidthsByColumnIndex) {
            this._updateColumnWidth(column, columnWidthsByColumnIndex[column.index]);
          }
          currentHeaderRow.push(column);
        }
      }
      result2.push(currentHeaderRow);
    }
    columns7 = result2[rowCount];
    result2 = prepareItems(result2.slice(0, -1), this._getEmptyCell());
    result2.push(columns7);
    return result2;
  }
  _calculateExportColspan(column) {
    if (!column.isBand) {
      return;
    }
    const childColumns = this._columnsController.getChildrenByBandColumn(column.index, true);
    if (!isDefined(childColumns)) {
      return;
    }
    return childColumns.reduce(((result2, childColumn) => {
      if (this._needColumnExporting(childColumn)) {
        return result2 + (this._calculateExportColspan(childColumn) || 1);
      }
      return result2;
    }), 0);
  }
  _needColumnExporting(column) {
    return !column.command && (column.allowExporting || void 0 === column.allowExporting);
  }
  _getFooterSummaryItems(summaryCells, isTotal) {
    const result2 = [];
    let estimatedItemsCount = 1;
    let i = 0;
    do {
      const values = [];
      for (let j = 0; j < summaryCells.length; j++) {
        const summaryCell = summaryCells[j];
        const itemsLength = summaryCell.length;
        if (estimatedItemsCount < itemsLength) {
          estimatedItemsCount = itemsLength;
        }
        values.push(summaryCell[i]);
      }
      result2.push({
        values,
        rowType: isTotal ? "totalFooter" : "groupFooter"
      });
    } while (i++ < estimatedItemsCount - 1);
    return result2;
  }
  _hasSummaryGroupFooters() {
    const groupItems = this.option("summary.groupItems");
    if (isDefined(groupItems)) {
      for (let i = 0; i < groupItems.length; i++) {
        if (groupItems[i].showInGroupFooter) {
          return true;
        }
      }
    }
    return false;
  }
  _getItemsWithSummaryGroupFooters(sourceItems) {
    let result2 = [];
    let beforeGroupFooterItems = [];
    let groupFooterItems = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      if ("groupFooter" === item.rowType) {
        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
        result2 = result2.concat(beforeGroupFooterItems, groupFooterItems);
        beforeGroupFooterItems = [];
      } else {
        beforeGroupFooterItems.push(item);
      }
    }
    return result2.length ? result2 : beforeGroupFooterItems;
  }
  _updateGroupValuesWithSummaryByColumn(sourceItems) {
    let summaryValues = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      const {
        summaryCells
      } = item;
      if ("group" === item.rowType && summaryCells && summaryCells.length > 1) {
        const groupColumnCount = item.values.length;
        for (let j = 1; j < summaryCells.length; j++) {
          for (let k = 0; k < summaryCells[j].length; k++) {
            const summaryItem = summaryCells[j][k];
            if (summaryItem && summaryItem.alignByColumn) {
              if (!Array.isArray(summaryValues[j - groupColumnCount])) {
                summaryValues[j - groupColumnCount] = [];
              }
              summaryValues[j - groupColumnCount].push(summaryItem);
            }
          }
        }
        if (summaryValues.length > 0) {
          item.values.push(...summaryValues);
          summaryValues = [];
        }
      }
    }
  }
  _processUnExportedItems(items) {
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const groupColumns = this._columnsController.getGroupColumns();
    let values;
    let summaryCells;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      let isCommand = false;
      values = [];
      summaryCells = [];
      for (let j = 0; j < columns7.length; j++) {
        const column = columns7[j];
        isCommand || (isCommand = ["detailExpand", "buttons"].includes(column.type));
        if (this._needColumnExporting(column)) {
          if (item.values) {
            if ("group" === item.rowType && !values.length) {
              values.push(item.key[item.groupIndex]);
            } else {
              values.push(item.values[j]);
            }
          }
          if (item.summaryCells) {
            if ("group" === item.rowType && !summaryCells.length) {
              const index = j - groupColumns.length + item.groupIndex;
              summaryCells.push(item.summaryCells[isCommand ? index : index + 1]);
            } else {
              summaryCells.push(item.summaryCells[j]);
            }
          }
        }
      }
      if (values.length) {
        item.values = values;
      }
      if (summaryCells.length) {
        item.summaryCells = summaryCells;
      }
    }
  }
  _getAllItems(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const footerItems = this._dataController.footerItems();
    const totalItem = footerItems.length && footerItems[0];
    const summaryTotalItems = that.option("summary.totalItems");
    let summaryCells;
    when(data17).done(((data18) => {
      this._dataController.loadAll(data18, skipFilter).done(((sourceItems, totalAggregates) => {
        that._updateGroupValuesWithSummaryByColumn(sourceItems);
        if (that._hasSummaryGroupFooters()) {
          sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
        }
        summaryCells = totalItem && totalItem.summaryCells;
        if (isDefined(totalAggregates) && summaryTotalItems) {
          summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
        }
        const summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
        if (summaryItems) {
          sourceItems = sourceItems.concat(summaryItems);
        }
        that._processUnExportedItems(sourceItems);
        d.resolve(sourceItems);
      })).fail(d.reject);
    })).fail(d.reject);
    return d;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    return this._dataController._calculateSummaryCells(summaryTotalItems, totalAggregates, this._columnsController.getVisibleColumns(null, true), ((summaryItem, column) => this._dataController._isDataColumn(column) ? column.index : -1));
  }
  _getSelectedItems() {
    if (this.needLoadItemsOnExportingSelectedItems()) {
      return this._getAllItems(this._selectionController.loadSelectedItemsWithFilter(), true);
    }
    return this._getAllItems(this._selectionController.getSelectedRowsData());
  }
  _getColumnWidths(headersView, rowsView18) {
    return headersView && headersView.isVisible() ? headersView.getColumnWidths() : rowsView18.getColumnWidths();
  }
  throwWarningIfNoOnExportingEvent() {
    var _this$component$hasAc, _this$component;
    const hasOnExporting = null === (_this$component$hasAc = (_this$component = this.component).hasActionSubscription) || void 0 === _this$component$hasAc ? void 0 : _this$component$hasAc.call(_this$component, "onExporting");
    if (this.option("export.enabled") && !hasOnExporting) {
      ui_errors_default.log("W1024");
    }
  }
  callbackNames() {
    return ["selectionOnlyChanged"];
  }
  getDataProvider(selectedRowsOnly) {
    const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
    let initialColumnWidthsByColumnIndex;
    if (columnWidths && columnWidths.length) {
      initialColumnWidthsByColumnIndex = {};
      const columnsLastRowVisibleColumns = this._columnsController.getVisibleColumns(this._columnsController.getRowCount(), true);
      for (let i = 0; i < columnsLastRowVisibleColumns.length; i++) {
        initialColumnWidthsByColumnIndex[columnsLastRowVisibleColumns[i].index] = columnWidths[i];
      }
    }
    return new DataProvider(this, initialColumnWidthsByColumnIndex, selectedRowsOnly);
  }
  exportTo(selectedRowsOnly, format2) {
    this._selectionOnly = selectedRowsOnly;
    const onExporting = this.getAction("onExporting");
    const eventArgs = {
      rtlEnabled: this.option("rtlEnabled"),
      selectedRowsOnly: !!selectedRowsOnly,
      format: format2,
      fileName: "DataGrid",
      cancel: false
    };
    isFunction(onExporting) && onExporting(eventArgs);
  }
  publicMethods() {
    return ["getDataProvider"];
  }
  selectionOnly(value2) {
    if (isDefined(value2)) {
      this._isSelectedRows = value2;
      this.selectionOnlyChanged.fire();
    } else {
      return this._isSelectedRows;
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      this.throwWarningIfNoOnExportingEvent();
    }
  }
  needLoadItemsOnExportingSelectedItems() {
    return this.option("loadItemsOnExportingSelectedItems") ?? this._dataController._dataSource.remoteOperations().filtering;
  }
};
var editing5 = (Base) => class extends Base {
  callbackNames() {
    const callbackList = super.callbackNames();
    return isDefined(callbackList) ? callbackList.push("editingButtonsUpdated") : ["editingButtonsUpdated"];
  }
  _updateEditButtons() {
    super._updateEditButtons();
    this.editingButtonsUpdated.fire();
  }
};
var headerPanel7 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const exportButton = this._getExportToolbarButton();
    if (exportButton) {
      items.push(exportButton);
      this._correctItemsPosition(items);
    }
    return items;
  }
  _getExportToolbarButton() {
    const items = this._getExportToolbarItems();
    if (0 === items.length) {
      return null;
    }
    const disabled = this._needDisableExportButton();
    const toolbarButtonOptions = {
      name: "exportButton",
      location: "after",
      locateInMenu: "auto",
      sortIndex: 30,
      options: {
        items
      },
      disabled
    };
    if (1 === items.length) {
      const widgetOptions = _extends({}, items[0], {
        hint: items[0].text,
        elementAttr: {
          class: "dx-datagrid-export-button"
        }
      });
      toolbarButtonOptions.widget = "dxButton";
      toolbarButtonOptions.showText = "inMenu";
      toolbarButtonOptions.options = widgetOptions;
    } else {
      const widgetOptions = {
        icon: "export",
        displayExpr: "text",
        items,
        hint: this.option("export.texts.exportTo"),
        elementAttr: {
          class: "dx-datagrid-export-button"
        },
        dropDownOptions: {
          width: "auto",
          _wrapperClassExternal: "dx-datagrid-export-menu"
        }
      };
      toolbarButtonOptions.options = widgetOptions;
      toolbarButtonOptions.widget = "dxDropDownButton";
      toolbarButtonOptions.menuItemTemplate = (_data, _index, container) => {
        this._createComponent(renderer_default(container), list_light_default, {
          items
        });
      };
    }
    return toolbarButtonOptions;
  }
  _getExportToolbarItems() {
    const exportOptions = this.option("export");
    const texts = this.option("export.texts");
    const formats = this.option("export.formats") ?? [];
    if (!exportOptions.enabled) {
      return [];
    }
    const items = [];
    formats.forEach(((formatType) => {
      let formatName = formatType.toUpperCase();
      let exportAllIcon = "export";
      if ("xlsx" === formatType) {
        formatName = "Excel";
        exportAllIcon = "xlsxfile";
      }
      if ("pdf" === formatType) {
        exportAllIcon = "pdffile";
      }
      items.push({
        text: format(texts.exportAll, formatName),
        icon: exportAllIcon,
        onClick: () => {
          this._exportController.exportTo(false, formatType);
        }
      });
      if (exportOptions.allowExportSelectedData) {
        items.push({
          text: format(texts.exportSelectedRows, formatName),
          icon: "exportselected",
          onClick: () => {
            this._exportController.exportTo(true, formatType);
          }
        });
      }
    }));
    return items;
  }
  _correctItemsPosition(items) {
    items.sort(((itemA, itemB) => itemA.sortIndex - itemB.sortIndex));
  }
  _isExportButtonVisible() {
    return this.option("export.enabled");
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      args.handled = true;
      this._invalidate();
    }
  }
  _needDisableExportButton() {
    const isDataColumnsInvisible = !this._columnsController.hasVisibleDataColumns();
    const hasUnsavedChanges = this._editingController.hasChanges();
    return isDataColumnsInvisible || hasUnsavedChanges;
  }
  _columnOptionChanged(e) {
    super._columnOptionChanged(e);
    const isColumnLocationChanged = m_core_default.checkChanges(e.optionNames, ["groupIndex", "visible", "all"]);
    if (isColumnLocationChanged) {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    }
  }
  init() {
    super.init();
    this._exportController = this.getController("export");
    this._editingController.editingButtonsUpdated.add((() => {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    }));
  }
};
m_core_default.registerModule("export", {
  defaultOptions: () => ({
    export: {
      enabled: false,
      fileName: "DataGrid",
      formats: ["xlsx"],
      allowExportSelectedData: false,
      texts: {
        exportTo: message_default.format("dxDataGrid-exportTo"),
        exportAll: message_default.format("dxDataGrid-exportAll"),
        exportSelectedRows: message_default.format("dxDataGrid-exportSelectedRows")
      }
    }
  }),
  controllers: {
    export: ExportController
  },
  extenders: {
    controllers: {
      editing: editing5
    },
    views: {
      headerPanel: headerPanel7
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus_utils.js
var getSortFilterValue = (sortInfo, rowData, _ref) => {
  let {
    isRemoteFiltering,
    dateSerializationFormat,
    getSelector
  } = _ref;
  const {
    selector
  } = sortInfo;
  const getter = isFunction(selector) ? selector : getSelector(selector);
  const rawValue = getter ? getter(rowData) : rowData[selector];
  const safeValue = isRemoteFiltering && isDate(rawValue) ? date_serialization_default.serializeDate(rawValue, dateSerializationFormat) : rawValue;
  return {
    getter,
    rawValue,
    safeValue
  };
};
var UiGridCoreFocusUtils = {
  getSortFilterValue
};

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus.js
var FOCUSED_ROW_SELECTOR = ".dx-row.dx-row-focused";
var FocusController = class extends m_modules_default.ViewController {
  getKeyboardController() {
    return this.getController("keyboardNavigation");
  }
  getDataController() {
    return this.getController("data");
  }
  init() {
    this.component._optionsByReference.focusedRowKey = true;
  }
  optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "focusedRowIndex":
        this._focusRowByIndex(value2);
        this.getKeyboardController()._fireFocusedRowChanged();
        args.handled = true;
        break;
      case "focusedRowKey":
        if (Array.isArray(value2) && JSON.stringify(value2) === JSON.stringify(previousValue)) {
          return;
        }
        this._focusRowByKey(value2).done((() => {
          this.getKeyboardController()._fireFocusedRowChanged();
        }));
        args.handled = true;
        break;
      case "focusedColumnIndex":
      case "focusedRowEnabled":
      case "autoNavigateToFocusedRow":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["navigateToRow", "isRowFocused"];
  }
  isAutoNavigateToFocusedRow() {
    return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow");
  }
  _focusRowByIndex(index, operationTypes) {
    if (!this.option("focusedRowEnabled")) {
      return;
    }
    const currentIndex = void 0 !== index ? index : this.option("focusedRowIndex");
    if (currentIndex < 0) {
      if (this.isAutoNavigateToFocusedRow()) {
        this._resetFocusedRow();
      }
    } else {
      this._focusRowByIndexCore(currentIndex, operationTypes);
    }
  }
  _focusRowByIndexCore(index, operationTypes) {
    const pageSize = this.getDataController().pageSize();
    const setKeyByIndex = () => {
      if (this._isValidFocusedRowIndex(index)) {
        let rowIndex = index - this.getDataController().getRowIndexOffset(true);
        if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
          const lastItemIndex = this.getDataController()._getLastItemIndex();
          rowIndex = Math.min(rowIndex, lastItemIndex);
        }
        const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex, true);
        if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
          this.option("focusedRowKey", focusedRowKey);
        }
      }
    };
    if (pageSize >= 0) {
      if (!this._isLocalRowIndex(index)) {
        const pageIndex = Math.floor(index / this.getDataController().pageSize());
        when(this.getDataController().pageIndex(pageIndex), this.getDataController().waitReady()).done((() => {
          setKeyByIndex();
        }));
      } else {
        setKeyByIndex();
      }
    }
  }
  _isLocalRowIndex(index) {
    const isVirtualScrolling = this.getKeyboardController()._isVirtualScrolling();
    if (isVirtualScrolling) {
      const pageIndex = Math.floor(index / this.getDataController().pageSize());
      const virtualItems = this.getDataController().virtualItemsCount();
      const virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
      const visibleRowsCount = this.getDataController().getVisibleRows().length + this.getDataController().getRowIndexOffset();
      const visiblePagesCount = Math.ceil(visibleRowsCount / this.getDataController().pageSize());
      return virtualItemsBegin <= index && visiblePagesCount > pageIndex;
    }
    return true;
  }
  _setFocusedRowKeyByIndex(index) {
    if (this._isValidFocusedRowIndex(index)) {
      const rowIndex = Math.min(index - this.getDataController().getRowIndexOffset(), this.getDataController().items().length - 1);
      const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex);
      if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
        this.option("focusedRowKey", focusedRowKey);
      }
    }
  }
  _focusRowByKey(key) {
    if (!isDefined(key)) {
      this._resetFocusedRow();
      return Deferred().resolve();
    }
    return this._navigateToRow(key, true);
  }
  _resetFocusedRow() {
    const focusedRowKey = this.option("focusedRowKey");
    const isFocusedRowKeyDefined = isDefined(focusedRowKey);
    if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
      return;
    }
    if (isFocusedRowKeyDefined) {
      this.option("focusedRowKey", null);
    }
    this.getKeyboardController().setFocusedRowIndex(-1);
    this.option("focusedRowIndex", -1);
    this.getDataController().updateItems({
      changeType: "updateFocusedRow",
      focusedRowKey: null
    });
    this.getKeyboardController()._fireFocusedRowChanged();
  }
  _isValidFocusedRowIndex(rowIndex) {
    const row = this.getDataController().getVisibleRows()[rowIndex];
    return !row || "data" === row.rowType || "group" === row.rowType;
  }
  navigateToRow(key) {
    if (!this.isAutoNavigateToFocusedRow()) {
      this.option("focusedRowIndex", -1);
    }
    return this._navigateToRow(key, false);
  }
  _navigateToRow(key, needFocusRow) {
    const that = this;
    const isAutoNavigate = that.isAutoNavigateToFocusedRow();
    const d = new Deferred();
    const rowsView18 = this.getView("rowsView");
    if (void 0 === key || !this.getDataController().dataSource()) {
      return d.reject().promise();
    }
    const rowIndexByKey = that.getFocusedRowIndexByKey(key);
    if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
      that._navigateTo(key, d, needFocusRow);
    } else {
      this.getDataController().getPageIndexByKey(key).done(((pageIndex) => {
        if (pageIndex < 0) {
          d.resolve(-1);
          return;
        }
        if (pageIndex === this.getDataController().pageIndex()) {
          this.getDataController().reload().done((() => {
            if (that.isRowFocused(key) && this.getDataController().getRowIndexByKey(key) >= 0) {
              d.resolve(that.getFocusedRowIndexByKey(key));
            } else {
              that._navigateTo(key, d, needFocusRow);
            }
          })).fail(d.reject);
        } else {
          this.getDataController().pageIndex(pageIndex).done((() => {
            rowsView18.waitAsyncTemplates(true).done((() => {
              that._navigateTo(key, d, needFocusRow);
            }));
          })).fail(d.reject);
        }
      })).fail(d.reject);
    }
    return d.promise();
  }
  _navigateTo(key, deferred, needFocusRow) {
    const visibleRowIndex = this.getDataController().getRowIndexByKey(key);
    const isVirtualRowRenderingMode = m_utils_default.isVirtualRowRendering(this);
    const isAutoNavigate = this.isAutoNavigateToFocusedRow();
    if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
      this._navigateToVirtualRow(key, deferred, needFocusRow);
    } else {
      this._navigateToVisibleRow(key, deferred, needFocusRow);
    }
  }
  _navigateToVisibleRow(key, deferred, needFocusRow) {
    if (needFocusRow) {
      this._triggerUpdateFocusedRow(key, deferred);
    } else {
      const focusedRowIndex = this.getFocusedRowIndexByKey(key);
      this.getView("rowsView").scrollToRowElement(key, deferred).done((() => {
        deferred.resolve(focusedRowIndex);
      }));
    }
  }
  _navigateToVirtualRow(key, deferred, needFocusRow) {
    const rowsScrollController = this.getDataController()._rowsScrollController;
    const rowIndex = m_utils_default.getIndexByKey(key, this.getDataController().items(true));
    const scrollable = this.getView("rowsView").getScrollable();
    if (rowsScrollController && scrollable && rowIndex >= 0) {
      const focusedRowIndex = rowIndex + this.getDataController().getRowIndexOffset(true);
      const offset = rowsScrollController.getItemOffset(focusedRowIndex);
      const triggerUpdateFocusedRow = () => {
        if (this.getDataController().totalCount() && !this.getDataController().items().length) {
          return;
        }
        this.component.off("contentReady", triggerUpdateFocusedRow);
        if (needFocusRow) {
          this._triggerUpdateFocusedRow(key, deferred);
        } else {
          deferred.resolve(focusedRowIndex);
        }
      };
      this.component.on("contentReady", triggerUpdateFocusedRow);
      this.getView("rowsView").scrollTopPosition(offset);
    } else {
      deferred.resolve(-1);
    }
  }
  _triggerUpdateFocusedRow(key, deferred) {
    const focusedRowIndex = this.getFocusedRowIndexByKey(key);
    if (this._isValidFocusedRowIndex(focusedRowIndex)) {
      let d;
      if (this.option("focusedRowEnabled")) {
        this.getDataController().updateItems({
          changeType: "updateFocusedRow",
          focusedRowKey: key
        });
      } else {
        d = this.getView("rowsView").scrollToRowElement(key);
      }
      when(d).done((() => {
        this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
        deferred && deferred.resolve(focusedRowIndex);
      }));
    } else {
      deferred && deferred.resolve(-1);
    }
  }
  getFocusedRowIndexByKey(key) {
    const loadedRowIndex = this.getDataController().getRowIndexByKey(key, true);
    return loadedRowIndex >= 0 ? loadedRowIndex + this.getDataController().getRowIndexOffset(true) : -1;
  }
  _focusRowByKeyOrIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    let currentFocusedRowIndex = this.option("focusedRowIndex");
    if (isDefined(focusedRowKey)) {
      const visibleRowIndex = this.getDataController().getRowIndexByKey(focusedRowKey);
      if (visibleRowIndex >= 0) {
        if (this.getKeyboardController()._isVirtualScrolling()) {
          currentFocusedRowIndex = visibleRowIndex + this.getDataController().getRowIndexOffset();
        }
        this.getKeyboardController().setFocusedRowIndex(currentFocusedRowIndex);
        this._triggerUpdateFocusedRow(focusedRowKey);
      } else {
        this._navigateToRow(focusedRowKey, true).done(((focusedRowIndex) => {
          if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
            this._focusRowByIndex();
          } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
            this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
          }
        }));
      }
    } else if (currentFocusedRowIndex >= 0) {
      this._focusRowByIndex(currentFocusedRowIndex);
    }
  }
  isRowFocused(key) {
    const focusedRowKey = this.option("focusedRowKey");
    if (isDefined(focusedRowKey)) {
      return equalByValue(key, this.option("focusedRowKey"));
    }
    return;
  }
  updateFocusedRow(e) {
    const that = this;
    const focusedRowIndex = that.getDataController().getRowIndexByKey(e.focusedRowKey);
    const rowsView18 = that.getView("rowsView");
    let $tableElement;
    let $mainRow;
    each(rowsView18.getTableElements(), ((index, element) => {
      const isMainTable = 0 === index;
      $tableElement = renderer_default(element);
      that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
      const $row = that._prepareFocusedRow({
        changedItem: that.getDataController().getVisibleRows()[focusedRowIndex],
        $tableElement,
        focusedRowIndex
      });
      if (isMainTable) {
        $mainRow = $row;
      }
    }));
    if (!e.preventScroll && $mainRow) {
      rowsView18.scrollToElementVertically($mainRow);
    }
  }
  _clearPreviousFocusedRow($tableElement, focusedRowIndex) {
    const $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter(((_, focusedRow) => {
      const $focusedRowTable = renderer_default(focusedRow).closest(`.${this.addWidgetPrefix("table")}`);
      return $tableElement.is($focusedRowTable);
    }));
    $prevRowFocusedElement.removeClass("dx-row-focused").removeClass("dx-cell-focus-disabled").removeAttr("tabindex");
    $prevRowFocusedElement.children("td").removeAttr("tabindex");
    if (0 !== focusedRowIndex) {
      const $firstRow = renderer_default(this.getView("rowsView").getRowElement(0));
      $firstRow.removeClass("dx-cell-focus-disabled").removeAttr("tabIndex");
    }
  }
  _prepareFocusedRow(options2) {
    let $row;
    const {
      changedItem
    } = options2;
    if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
      const {
        focusedRowIndex
      } = options2;
      const {
        $tableElement
      } = options2;
      const tabIndex = this.option("tabindex") || 0;
      const rowsView18 = this.getView("rowsView");
      $row = renderer_default(rowsView18._getRowElements($tableElement).eq(focusedRowIndex));
      $row.addClass("dx-row-focused").attr("tabindex", tabIndex);
    }
    return $row;
  }
};
var keyboardNavigation4 = (Base) => class extends Base {
  init() {
    const rowIndex = this.option("focusedRowIndex");
    const columnIndex = this.option("focusedColumnIndex");
    this.createAction("onFocusedRowChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedRowChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    super.init();
    this.setRowFocusType();
    this._focusedCellPosition = {};
    if (isDefined(rowIndex) && rowIndex >= 0) {
      this._focusedCellPosition.rowIndex = rowIndex;
    }
    if (isDefined(columnIndex) && columnIndex >= 0) {
      this._focusedCellPosition.columnIndex = columnIndex;
    }
  }
  setFocusedRowIndex(rowIndex) {
    super.setFocusedRowIndex(rowIndex);
    this.option("focusedRowIndex", rowIndex);
  }
  setFocusedColumnIndex(columnIndex) {
    super.setFocusedColumnIndex(columnIndex);
    this.option("focusedColumnIndex", columnIndex);
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    if (isEditing || !this.option("focusedRowEnabled")) {
      return super._escapeKeyHandler(eventArgs, isEditing);
    }
    if (this.isCellFocusType()) {
      this.setRowFocusType();
      this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
      return true;
    }
    return false;
  }
  _updateFocusedCellPosition($cell, direction) {
    const position2 = super._updateFocusedCellPosition($cell, direction);
    if (position2 && position2.columnIndex >= 0) {
      this._fireFocusedCellChanged($cell);
    }
    return position2;
  }
};
var editorFactory5 = (Base) => class extends Base {
  renderFocusOverlay($element, isHideBorder) {
    var _this$_keyboardNaviga;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    if (!focusedRowEnabled || !(null !== (_this$_keyboardNaviga = this._keyboardNavigationController) && void 0 !== _this$_keyboardNaviga && _this$_keyboardNaviga.isRowFocusType()) || this._editingController.isEditing() || this._columnHeadersView.isFilterRowCell($element)) {
      super.renderFocusOverlay($element, isHideBorder);
    } else if (focusedRowEnabled) {
      const isRowElement = "row" === this._keyboardNavigationController._getElementType($element);
      if (isRowElement && !$element.hasClass("dx-row-focused")) {
        const $cell = this._keyboardNavigationController.getFirstValidCellInRow($element);
        this._keyboardNavigationController.focus($cell);
      }
    }
  }
};
var columns6 = (Base) => class extends Base {
  getSortDataSourceParameters(_, sortByKey) {
    let result2 = super.getSortDataSourceParameters.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    const store = this._dataController.store();
    let key = store && store.key();
    const remoteOperations = dataSource && dataSource.remoteOperations() || {};
    const isLocalOperations = Object.keys(remoteOperations).every(((operationName) => !remoteOperations[operationName]));
    if (key && (this.option("focusedRowEnabled") && false !== this._focusController.isAutoNavigateToFocusedRow() || sortByKey)) {
      key = Array.isArray(key) ? key : [key];
      const notSortedKeys = key.filter(((key2) => !this.columnOption(key2, "sortOrder")));
      if (notSortedKeys.length) {
        result2 = result2 || [];
        if (isLocalOperations) {
          result2.push({
            selector: dataSource.getDataIndexGetter(),
            desc: false
          });
        } else {
          notSortedKeys.forEach(((notSortedKey) => result2.push({
            selector: notSortedKey,
            desc: false
          })));
        }
      }
    }
    return result2;
  }
};
var data15 = (Base) => class extends Base {
  constructor() {
    super(...arguments);
    this._isDataPushed = false;
  }
  _applyChange(change) {
    if (change && "updateFocusedRow" === change.changeType) {
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged(e);
    const forceUpdateFocusedRow = this._isDataPushed;
    this._isDataPushed = false;
    if (this.option("focusedRowEnabled") && this._dataSource) {
      const isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
      const isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
      if (forceUpdateFocusedRow && this.isEmpty()) {
        this._focusController._resetFocusedRow();
      } else if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
        this._updatePageIndexes();
        this._updateFocusedRowIfNeeded(e, forceUpdateFocusedRow);
      } else if ("append" === e.changeType || "prepend" === e.changeType) {
        this._updatePageIndexes();
      } else if (isPartialUpdate) {
        this._updateFocusedRowIfNeeded(e, forceUpdateFocusedRow);
      }
    }
  }
  _handleDataPushed(changes) {
    super._handleDataPushed(changes);
    const focusedRowKey = this.option("focusedRowKey");
    this._isDataPushed = isDefined(focusedRowKey) && !!changes.length;
  }
  _updatePageIndexes() {
    const prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
    const renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
    this._lastRenderingPageIndex = renderingPageIndex;
    this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex;
  }
  isPagingByRendering() {
    return this._isPagingByRendering;
  }
  _updateFocusedRowIfNeeded(e) {
    let forceUpdate2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const operationTypes = e.operationTypes || {};
    const {
      reload,
      fullReload,
      pageIndex,
      paging
    } = operationTypes;
    const isVirtualScrolling = this._keyboardNavigationController._isVirtualScrolling();
    const pagingWithoutVirtualScrolling = paging && !isVirtualScrolling;
    const focusedRowKey = this.option("focusedRowKey");
    const isAutoNavigate = this._focusController.isAutoNavigateToFocusedRow();
    const isReload = reload && false === pageIndex;
    const rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
    switch (true) {
      case forceUpdate2:
        this._focusController._focusRowByKeyOrIndex();
        break;
      case (isReload && !fullReload && isDefined(focusedRowKey)):
        this._focusController._navigateToRow(focusedRowKey, true).done(((focusedRowIndex) => {
          if (focusedRowIndex < 0) {
            this._focusController._focusRowByIndex(void 0, operationTypes);
          }
        }));
        break;
      case (pagingWithoutVirtualScrolling && isAutoNavigate): {
        const focusedRowIndex = this.option("focusedRowIndex");
        const isValidRowIndexByKey = rowIndexByKey >= 0;
        const isValidFocusedRowIndex = focusedRowIndex >= 0;
        const isSameRowIndex = focusedRowIndex === rowIndexByKey;
        if (isValidFocusedRowIndex && (isSameRowIndex || !isValidRowIndexByKey)) {
          this._focusController._focusRowByIndex(focusedRowIndex, operationTypes);
        }
        break;
      }
      case (pagingWithoutVirtualScrolling && !isAutoNavigate && rowIndexByKey < 0):
        this.option("focusedRowIndex", -1);
        break;
      case operationTypes.fullReload:
        this._focusController._focusRowByKeyOrIndex();
    }
  }
  getPageIndexByKey(key) {
    const that = this;
    const d = new Deferred();
    that.getGlobalRowIndexByKey(key).done(((globalIndex) => {
      d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1);
    })).fail(d.reject);
    return d.promise();
  }
  getGlobalRowIndexByKey(key) {
    if (this._dataSource.group()) {
      return this._calculateGlobalRowIndexByGroupedData(key);
    }
    return this._calculateGlobalRowIndexByFlatData(key);
  }
  _calculateGlobalRowIndexByFlatData(key, groupFilter, useGroup) {
    const that = this;
    const deferred = new Deferred();
    const dataSource = that._dataSource;
    if (Array.isArray(key) || isNewRowTempKey(key)) {
      return deferred.resolve(-1).promise();
    }
    let filter = that._generateFilterByKey(key);
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      skip: 0,
      take: 1
    }).done(((data17) => {
      if (data17.length > 0) {
        filter = that._generateOperationFilterByKey(key, data17[0], useGroup);
        dataSource.load({
          filter: that._concatWithCombinedFilter(filter, groupFilter),
          skip: 0,
          take: 1,
          requireTotalCount: true
        }).done(((_, extra) => {
          deferred.resolve(extra.totalCount);
        }));
      } else {
        deferred.resolve(-1);
      }
    }));
    return deferred.promise();
  }
  _concatWithCombinedFilter(filter, groupFilter) {
    const combinedFilter = this.getCombinedFilter();
    return m_utils_default.combineFilters([filter, combinedFilter, groupFilter]);
  }
  _generateBooleanFilter(selector, value2, sortInfo) {
    const {
      desc
    } = sortInfo;
    switch (true) {
      case (false === value2 && desc):
        return [selector, "=", true];
      case (false === value2 && !desc):
        return [selector, "=", null];
      case (true === value2 && !desc):
      case (!isBoolean(value2) && desc):
        return [selector, "<>", value2];
      default:
        return;
    }
  }
  _generateOperationFilterByKey(key, rowData, useGroup) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const isRemoteFiltering = that._dataSource.remoteOperations().filtering;
    const isRemoteSorting = that._dataSource.remoteOperations().sorting;
    let filter = that._generateFilterByKey(key, "<");
    let sort = that._columnsController.getSortDataSourceParameters(!isRemoteFiltering, true);
    if (useGroup) {
      const group = that._columnsController.getGroupDataSourceParameters(!isRemoteFiltering);
      if (group) {
        sort = sort ? group.concat(sort) : group;
      }
    }
    if (sort) {
      sort.slice().reverse().forEach(((sortInfo) => {
        const {
          selector,
          desc,
          compare: compare3
        } = sortInfo;
        const {
          getter,
          rawValue,
          safeValue
        } = UiGridCoreFocusUtils.getSortFilterValue(sortInfo, rowData, {
          isRemoteFiltering,
          dateSerializationFormat,
          getSelector: (selector2) => that._columnsController.columnOption(selector2, "selector")
        });
        filter = [
          [selector, "=", safeValue],
          "and",
          filter
        ];
        if (null === rawValue || isBoolean(rawValue)) {
          const booleanFilter = that._generateBooleanFilter(selector, safeValue, desc);
          if (booleanFilter) {
            filter = [booleanFilter, "or", filter];
          }
        } else {
          const filterOperation = desc ? ">" : "<";
          let sortFilter;
          if (compare3 && !isRemoteSorting) {
            sortFilter = (data17) => {
              if ("<" === filterOperation) {
                return compare3(rawValue, getter(data17)) >= 1;
              }
              return compare3(rawValue, getter(data17)) <= -1;
            };
          } else {
            sortFilter = [selector, filterOperation, safeValue];
            if (!desc) {
              sortFilter = [sortFilter, "or", [selector, "=", null]];
            }
          }
          filter = [sortFilter, "or", filter];
        }
      }));
    }
    return filter;
  }
  _generateFilterByKey(key, operation) {
    const dataSourceKey = this._dataSource.key();
    let filter = [];
    if (!operation) {
      operation = "=";
    }
    if (Array.isArray(dataSourceKey)) {
      for (let i = 0; i < dataSourceKey.length; ++i) {
        const keyPart = key[dataSourceKey[i]];
        if (keyPart) {
          if (filter.length > 0) {
            filter.push("and");
          }
          filter.push([dataSourceKey[i], operation, keyPart]);
        }
      }
    } else {
      filter = [dataSourceKey, operation, key];
    }
    return filter;
  }
  _getLastItemIndex() {
    return this.items(true).length - 1;
  }
};
var editing6 = (Base) => class extends Base {
  _deleteRowCore(rowIndex) {
    const deferred = super._deleteRowCore.apply(this, arguments);
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    deferred.done((() => {
      const rowIndex2 = this._dataController.getRowIndexByKey(rowKey);
      const visibleRows = this._dataController.getVisibleRows();
      if (-1 === rowIndex2 && !visibleRows.length) {
        this._focusController._resetFocusedRow();
      }
    }));
  }
};
var rowsView16 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (this.option("focusedRowEnabled") && row) {
      if (this._focusController.isRowFocused(row.key)) {
        $row.addClass("dx-row-focused");
      }
    }
    return $row;
  }
  _checkRowKeys(options2) {
    super._checkRowKeys.apply(this, arguments);
    if (this.option("focusedRowEnabled") && this.option("dataSource")) {
      const store = this._dataController.store();
      if (store && !store.key()) {
        this._dataController.fireError("E1042", "Row focusing");
      }
    }
  }
  _update(change) {
    if ("updateFocusedRow" === change.changeType) {
      if (this.option("focusedRowEnabled")) {
        this._focusController.updateFocusedRow(change);
      }
    } else {
      super._update(change);
    }
  }
  updateFocusElementTabIndex($cellElements, preventScroll) {
    if (this.option("focusedRowEnabled")) {
      this._setFocusedRowElementTabIndex(preventScroll);
    } else {
      super.updateFocusElementTabIndex($cellElements);
    }
  }
  _setFocusedRowElementTabIndex(preventScroll) {
    const focusedRowKey = this.option("focusedRowKey");
    const tabIndex = this.option("tabIndex") ?? 0;
    const columnsController = this._columnsController;
    let rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    let columnIndex = this.option("focusedColumnIndex");
    const $row = this._findRowElementForTabIndex();
    const dataSource = this._dataController.dataSource();
    const operationTypes = null === dataSource || void 0 === dataSource ? void 0 : dataSource.operationTypes();
    const isPaging = !operationTypes || operationTypes.paging;
    if (!isDefined(this._scrollToFocusOnResize)) {
      this._scrollToFocusOnResize = () => {
        this.scrollToElementVertically(this._findRowElementForTabIndex());
        this.resizeCompleted.remove(this._scrollToFocusOnResize);
      };
    }
    $row.attr("tabIndex", tabIndex);
    const rowIndexFromOption = this.option("focusedRowIndex") - this._dataController.getRowIndexOffset(true);
    if (!isPaging && rowIndex < 0 && rowIndexFromOption >= 0) {
      this._focusController.updateFocusedRow({
        focusedRowKey,
        preventScroll
      });
    }
    if (rowIndex >= 0 && !preventScroll) {
      if (columnIndex < 0) {
        columnIndex = 0;
      }
      rowIndex += this._dataController.getRowIndexOffset();
      columnIndex += columnsController.getColumnIndexOffset();
      this._keyboardNavigationController.setFocusedCellPosition(rowIndex, columnIndex);
      if (this._focusController.isAutoNavigateToFocusedRow()) {
        if (!isPaging && !this._dataController.isPagingByRendering()) {
          this.resizeCompleted.remove(this._scrollToFocusOnResize);
          this.resizeCompleted.add(this._scrollToFocusOnResize);
        }
      }
    }
  }
  _findRowElementForTabIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    return renderer_default(this.getRowElement(rowIndex >= 0 ? rowIndex : 0));
  }
  scrollToRowElement(key) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    const $row = renderer_default(this.getRow(rowIndex));
    return this.scrollToElementVertically($row);
  }
  scrollToElementVertically($row) {
    const scrollable = this.getScrollable();
    if (scrollable && $row.length) {
      const position2 = scrollable.getScrollElementPosition($row, "vertical");
      return this.scrollTopPosition(position2);
    }
    return new Deferred().resolve();
  }
  scrollTopPosition(scrollTop) {
    const d = new Deferred();
    const scrollable = this.getScrollable();
    if (scrollable) {
      const currentScrollTop = scrollable.scrollTop();
      const scrollHandler = () => {
        scrollable.off("scroll", scrollHandler);
        d.resolve();
      };
      if (scrollTop !== currentScrollTop) {
        scrollable.on("scroll", scrollHandler);
        this._dataController.resetFilterApplying();
        scrollable.scrollTo({
          top: scrollTop
        });
        return d.promise();
      }
    }
    return d.resolve();
  }
};
var focusModule = {
  defaultOptions: () => ({
    focusedRowEnabled: false,
    autoNavigateToFocusedRow: true,
    focusedRowKey: null,
    focusedRowIndex: -1,
    focusedColumnIndex: -1
  }),
  controllers: {
    focus: FocusController
  },
  extenders: {
    controllers: {
      keyboardNavigation: keyboardNavigation4,
      editorFactory: editorFactory5,
      columns: columns6,
      data: data15,
      editing: editing6
    },
    views: {
      rowsView: rowsView16
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/focus/m_focus.js
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var data16 = (Base) => class extends focusModule.extenders.controllers.data(Base) {
  changeRowExpand(path, isRowClick) {
    if (this.option("focusedRowEnabled") && Array.isArray(path) && this.isRowExpanded(path)) {
      if ((!isRowClick || !this._keyboardNavigationController.isKeyboardEnabled()) && this._isFocusedRowInsideGroup(path)) {
        this.option("focusedRowKey", path);
      }
    }
    return super.changeRowExpand(path, isRowClick);
  }
  _isFocusedRowInsideGroup(path) {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this.getRowIndexByKey(focusedRowKey);
    const focusedRow = rowIndex >= 0 && this.getVisibleRows()[rowIndex];
    const groups = this._columnsController.getGroupDataSourceParameters(true);
    if (focusedRow) {
      for (let i = 0; i < path.length; ++i) {
        const getter = compileGetter(groups[i] && groups[i].selector);
        if (getter(focusedRow.data) !== path[i]) {
          return false;
        }
      }
    }
    return true;
  }
  _getGroupPath(groupItems, groupCount) {
    const groupPath = [];
    let groupItem = groupItems[0];
    while (groupItem && groupPath.length < groupCount) {
      var _groupItem$items;
      groupPath.push(groupItem.key);
      groupItem = null === (_groupItem$items = groupItem.items) || void 0 === _groupItem$items ? void 0 : _groupItem$items[0];
    }
    return groupPath;
  }
  _expandGroupByPath(that, groupPath, level) {
    const d = new Deferred();
    level++;
    that.expandRow(groupPath.slice(0, level)).done((() => {
      if (level === groupPath.length) {
        d.resolve();
      } else {
        that._expandGroupByPath(that, groupPath, level).done(d.resolve).fail(d.reject);
      }
    })).fail(d.reject);
    return d.promise();
  }
  _calculateGlobalRowIndexByGroupedData(key) {
    const that = this;
    const dataSource = that._dataSource;
    const filter = that._generateFilterByKey(key);
    const deferred = new Deferred();
    const isGroupKey = Array.isArray(key);
    const group = dataSource.group();
    if (isGroupKey) {
      return deferred.resolve(-1).promise();
    }
    if (!dataSource._grouping._updatePagingOptions) {
      that._calculateGlobalRowIndexByFlatData(key, null, true).done(deferred.resolve).fail(deferred.reject);
      return deferred;
    }
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      group
    }).done(((data17) => {
      const hasData = isDefined(data17) && data17.length > 0;
      if (!hasData) {
        return deferred.resolve(-1).promise();
      }
      const groupPath = that._getGroupPath(data17, group.length);
      that._expandGroupByPath(that, groupPath, 0).done((() => {
        that._calculateExpandedRowGlobalIndex(deferred, key, groupPath, group);
      })).fail(deferred.reject);
    })).fail(deferred.reject);
    return deferred.promise();
  }
  _calculateExpandedRowGlobalIndex(deferred, key, groupPath, group) {
    const groupFilter = createGroupFilter(groupPath, {
      group
    });
    const dataSource = this._dataSource;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrolling = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const pageSize = dataSource.pageSize();
    let groupOffset;
    dataSource._grouping._updatePagingOptions({
      skip: 0,
      take: MAX_SAFE_INTEGER2
    }, ((groupInfo, totalOffset) => {
      if (equalByValue(groupInfo.path, groupPath)) {
        groupOffset = totalOffset;
      }
    }));
    this._calculateGlobalRowIndexByFlatData(key, groupFilter).done(((dataOffset) => {
      let count;
      let groupContinuationCount;
      if (dataOffset < 0) {
        deferred.resolve(-1);
        return;
      }
      const currentPageOffset = groupOffset % pageSize || pageSize;
      count = currentPageOffset + dataOffset - groupPath.length;
      if (isVirtualScrolling) {
        groupContinuationCount = 0;
      } else {
        groupContinuationCount = Math.floor(count / (pageSize - groupPath.length)) * groupPath.length;
      }
      count = groupOffset + dataOffset + groupContinuationCount;
      deferred.resolve(count);
    })).fail(deferred.reject);
  }
};
m_core_default.registerModule("focus", _extends({}, focusModule, {
  extenders: _extends({}, focusModule.extenders, {
    controllers: _extends({}, focusModule.extenders.controllers, {
      data: data16
    })
  })
}));

// node_modules/devextreme/esm/__internal/m_draggable.js
var window13 = getWindow();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME2 = addNamespace(DRAG_START_EVENT, DRAGGABLE);
var DRAG_EVENT_NAME = addNamespace(DRAG_EVENT, DRAGGABLE);
var DRAGEND_EVENT_NAME = addNamespace(DRAG_END_EVENT, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = addNamespace(DRAG_ENTER_EVENT, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = addNamespace(DRAG_LEAVE_EVENT, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = addNamespace(m_pointer_default.down, DRAGGABLE);
var KEYDOWN_EVENT_NAME = addNamespace("keydown", DRAGGABLE);
var targetDraggable;
var sourceDraggable;
var getMousePosition = (event) => ({
  x: event.pageX - renderer_default(window13).scrollLeft(),
  y: event.pageY - renderer_default(window13).scrollTop()
});
var ScrollHelper = class {
  constructor(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if ("vertical" === orientation) {
      this._scrollValue = "scrollTop";
      this._overFlowAttr = "overflowY";
      this._sizeAttr = "height";
      this._scrollSizeProp = "scrollHeight";
      this._clientSizeProp = "clientHeight";
      this._limitProps = {
        start: "top",
        end: "bottom"
      };
    } else {
      this._scrollValue = "scrollLeft";
      this._overFlowAttr = "overflowX";
      this._sizeAttr = "width";
      this._scrollSizeProp = "scrollWidth";
      this._clientSizeProp = "clientWidth";
      this._limitProps = {
        start: "left",
        end: "right"
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    let isScrollableFound = false;
    elements.some(((element) => {
      const $element = renderer_default(element);
      const isTargetOverOverlayWrapper = $element.hasClass("dx-overlay-wrapper");
      const isTargetOverOverlayContent = $element.hasClass("dx-overlay-content");
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    }));
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ("auto" === $element.css(this._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > Math.ceil("width" === this._sizeAttr ? getWidth($element) : getHeight($element));
  }
  _trySetScrollable(element, mousePosition) {
    const that = this;
    const $element = renderer_default(element);
    let distanceToBorders;
    const sensitivity = that._component.option("scrollSensitivity");
    let isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    const area = $area.get(0);
    let areaBoundingRect;
    if (area) {
      areaBoundingRect = getBoundingRect(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  }
  _calculateScrollSpeed(distance) {
    const component = this._component;
    const sensitivity = component.option("scrollSensitivity");
    const maxSpeed = component.option("scrollSpeed");
    return Math.ceil(((sensitivity - distance) / sensitivity) ** 2 * maxSpeed);
  }
  scrollByStep() {
    const that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        const $scrollable = that._$scrollableAtPointer.closest(".dx-scrollable");
        const scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
        if (scrollableInstance) {
          const nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        const nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);
      }
      const dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    const scrollableSize = getBoundingRect($scrollable.get(0));
    const start = scrollableSize[this._limitProps.start];
    const size = scrollableSize[this._sizeAttr];
    const mousePosition = getMousePosition(event);
    const location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
};
var ScrollAnimator = class extends m_animator_default {
  ctor(strategy) {
    super.ctor();
    this._strategy = strategy;
  }
  _step() {
    const horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    const verticalScrollHelper = this._strategy._verticalScrollHelper;
    null === horizontalScrollHelper || void 0 === horizontalScrollHelper || horizontalScrollHelper.scrollByStep();
    null === verticalScrollHelper || void 0 === verticalScrollHelper || verticalScrollHelper.scrollByStep();
  }
};
var Draggable = class extends dom_component_default {
  reset() {
  }
  dragMove(e) {
  }
  dragEnter() {
  }
  dragLeave() {
  }
  dragEnd(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2._fireRemoveEvent(sourceEvent);
    return Deferred().resolve();
  }
  _fireRemoveEvent(sourceEvent) {
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: "both",
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference.apply(this, arguments);
    extend(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  }
  _init() {
    super._init();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
    this._verticalScrollHelper = new ScrollHelper("vertical", this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  }
  _normalizeCursorOffset(offset) {
    if (isObject(offset)) {
      offset = {
        h: offset.x,
        v: offset.y
      };
    }
    offset = splitPair(offset).map(((value2) => parseFloat(value2)));
    return {
      left: offset[0],
      top: 1 === offset.length ? offset[0] : offset[1]
    };
  }
  _getNormalizedCursorOffset(offset, options2) {
    if (isFunction(offset)) {
      offset = offset.call(this, options2);
    }
    return this._normalizeCursorOffset(offset);
  }
  _calculateElementOffset(options2) {
    let elementOffset;
    let dragElementOffset;
    const {
      event
    } = options2;
    const $element = renderer_default(options2.itemElement);
    const $dragElement = renderer_default(options2.dragElement);
    const isCloned = this._dragElementIsCloned();
    const cursorOffset = this.option("cursorOffset");
    let normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    const currentLocate = this._initialLocate = locate($dragElement);
    if (isCloned || options2.initialOffset || cursorOffset) {
      elementOffset = options2.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options2);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  }
  _initPosition(options2) {
    const $dragElement = renderer_default(options2.dragElement);
    const elementOffset = this._calculateElementOffset(options2);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = locate($dragElement);
  }
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  }
  _stopAnimator() {
    this._scrollAnimator.stop();
  }
  _addWidgetPrefix(className) {
    const componentName = this.NAME;
    return dasherize(componentName) + (className ? `-${className}` : "");
  }
  _getItemsSelector() {
    return this.option("filter") || "";
  }
  _$content() {
    const $element = this.$element();
    const $wrapper = $element.children(".dx-template-wrapper");
    return $wrapper.length ? $wrapper : $element;
  }
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    let $element = this._$content();
    let itemsSelector = this._getItemsSelector();
    const allowMoveByClick = this.option("allowMoveByClick");
    const data17 = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: ($target, event) => {
        const targetGroup = this.option("group");
        const sourceGroup = this._getSourceDraggable().option("group");
        const $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      m_events_engine_default.on($element, POINTERDOWN_EVENT_NAME, data17, this._pointerDownHandler.bind(this));
    }
    if (">" === itemsSelector[0]) {
      itemsSelector = itemsSelector.slice(1);
    }
    m_events_engine_default.on($element, DRAGSTART_EVENT_NAME2, itemsSelector, data17, this._dragStartHandler.bind(this));
    m_events_engine_default.on($element, DRAG_EVENT_NAME, data17, this._dragMoveHandler.bind(this));
    m_events_engine_default.on($element, DRAGEND_EVENT_NAME, data17, this._dragEndHandler.bind(this));
    m_events_engine_default.on($element, DRAG_ENTER_EVENT_NAME, data17, this._dragEnterHandler.bind(this));
    m_events_engine_default.on($element, DRAGEND_LEAVE_EVENT_NAME, data17, this._dragLeaveHandler.bind(this));
    if (this.option("onCancelByEsc")) {
      m_events_engine_default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  }
  _dragElementIsCloned() {
    var _this$_$dragElement;
    return null === (_this$_$dragElement = this._$dragElement) || void 0 === _this$_$dragElement ? void 0 : _this$_$dragElement.hasClass(this._addWidgetPrefix("clone"));
  }
  _getDragTemplateArgs($element, $container) {
    return {
      container: getPublicElement($container),
      model: {
        itemData: this.option("itemData"),
        itemElement: getPublicElement($element)
      }
    };
  }
  _createDragElement($element) {
    let result2 = $element;
    const clone = this.option("clone");
    const $container = this._getContainer();
    let template = this.option("dragTemplate");
    if (template) {
      template = this._getTemplate(template);
      result2 = renderer_default("<div>").appendTo($container);
      template.render(this._getDragTemplateArgs($element, result2));
    } else if (clone) {
      result2 = renderer_default("<div>").appendTo($container);
      $element.clone().css({
        width: $element.css("width"),
        height: $element.css("height")
      }).appendTo(result2);
    }
    return result2.toggleClass(this._addWidgetPrefix("clone"), result2.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  }
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      var _this$_$dragElement2;
      null === (_this$_$dragElement2 = this._$dragElement) || void 0 === _this$_$dragElement2 || _this$_$dragElement2.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  }
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this._$content(), `.${DRAGGABLE}`);
    m_events_engine_default.off(this._getArea(), `.${DRAGGABLE}`);
  }
  _move(position2, $element) {
    move($element || this._$dragElement, position2);
  }
  _getDraggableElement(e) {
    const $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    const allowMoveByClick = this.option("allowMoveByClick");
    if (allowMoveByClick) {
      return this.$element();
    }
    let $target = renderer_default(null === e || void 0 === e ? void 0 : e.target);
    const itemsSelector = this._getItemsSelector();
    if (">" === itemsSelector[0]) {
      const $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  }
  _getSourceElement() {
    const draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  }
  _pointerDownHandler(e) {
    if (needSkipEvent(e)) {
      return;
    }
    const position2 = {};
    const $element = this.$element();
    const {
      dragDirection
    } = this.option();
    if ("horizontal" === dragDirection || "both" === dragDirection) {
      position2.left = e.pageX - $element.offset().left + locate($element).left - getWidth($element) / 2;
    }
    if ("vertical" === dragDirection || "both" === dragDirection) {
      position2.top = e.pageY - $element.offset().top + locate($element).top - getHeight($element) / 2;
    }
    this._move(position2, $element);
    this._getAction("onDragMove")(this._getEventArgs(e));
  }
  _isValidElement(event, $element) {
    var _event$originalEvent;
    const {
      handle
    } = this.option();
    const $target = renderer_default(null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is(".dx-state-disabled, .dx-state-disabled *");
  }
  _dragStartHandler(e) {
    const $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    const dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction("onDragStart")(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option("itemData", dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    let initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option("autoScroll")) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    const $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    const isFixedPosition = "fixed" === $dragElement.css("position");
    this._initPosition(extend({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction("onDraggableElementShown")(_extends({}, dragStartArgs, {
      dragElement: $dragElement
    }));
    const $area = this._getArea();
    const areaOffset = this._getAreaOffset($area);
    const boundOffset = this._getBoundOffset();
    const areaWidth = getOuterWidth($area);
    const areaHeight = getOuterHeight($area);
    const elementWidth = getWidth($dragElement);
    const elementHeight = getHeight($dragElement);
    const startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
    if ($area.length) {
      e.maxLeftOffset = startOffset_left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset_top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
    }
    if (this.option("autoScroll")) {
      this._startAnimator();
    }
  }
  _getAreaOffset($area) {
    const offset = $area && position_default.offset($area);
    return offset || {
      left: 0,
      top: 0
    };
  }
  _toggleDraggingClass(value2) {
    var _this$_$dragElement3;
    null === (_this$_$dragElement3 = this._$dragElement) || void 0 === _this$_$dragElement3 || _this$_$dragElement3.toggleClass(this._addWidgetPrefix("dragging"), value2);
  }
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    null === $sourceElement || void 0 === $sourceElement || $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
  }
  _setGestureCoverCursor($element) {
    renderer_default(".dx-gesture-cover").css("cursor", $element.css("cursor"));
  }
  _getBoundOffset() {
    let boundOffset = this.option("boundOffset");
    if (isFunction(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return quadToObject(boundOffset);
  }
  _getArea() {
    let area = this.option("boundary");
    if (isFunction(area)) {
      area = area.call(this);
    }
    return renderer_default(area);
  }
  _getContainer() {
    let {
      container
    } = this.option();
    if (void 0 === container) {
      container = value();
    }
    return renderer_default(container);
  }
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _this$_startPosition, _this$_startPosition2;
    const initScrollTop = this._initScrollTop;
    const initScrollLeft = this._initScrollLeft;
    const scrollTop = this._getScrollableScrollTop();
    const scrollLeft = this._getScrollableScrollLeft();
    const elementPosition = renderer_default(this.element()).css("position");
    const isFixedPosition = "fixed" === elementPosition;
    const result2 = {
      left: ((null === (_this$_startPosition = this._startPosition) || void 0 === _this$_startPosition ? void 0 : _this$_startPosition.left) ?? 0) + initialOffsetX,
      top: ((null === (_this$_startPosition2 = this._startPosition) || void 0 === _this$_startPosition2 ? void 0 : _this$_startPosition2.top) ?? 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result2;
    }
    return {
      left: isNumeric(scrollLeft) ? result2.left + scrollLeft - initScrollLeft : result2.left,
      top: isNumeric(scrollTop) ? result2.top + scrollTop - initScrollTop : result2.top
    };
  }
  _hasClonedDraggable() {
    return this.option("clone") || this.option("dragTemplate");
  }
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    const offset = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset);
    this._updateScrollable(e);
    const eventArgs = this._getEventArgs(e);
    this._getAction("onDragMove")(eventArgs);
    if (true === eventArgs.cancel) {
      return;
    }
    const targetDraggable2 = this._getTargetDraggable();
    targetDraggable2.dragMove(e, scrollBy);
  }
  _updateScrollable(e) {
    const that = this;
    if (that.option("autoScroll")) {
      const mousePosition = getMousePosition(e);
      const allObjects = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  }
  _getScrollable($element) {
    let $scrollable;
    $element.parents().toArray().some(((parent) => {
      const $parent = renderer_default(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    }));
    return $scrollable;
  }
  _getScrollableScrollTop() {
    var _this$_getScrollable;
    return (null === (_this$_getScrollable = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable ? void 0 : _this$_getScrollable.scrollTop()) ?? 0;
  }
  _getScrollableScrollLeft() {
    var _this$_getScrollable2;
    return (null === (_this$_getScrollable2 = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable2 ? void 0 : _this$_getScrollable2.scrollLeft()) ?? 0;
  }
  _defaultActionArgs() {
    const args = super._defaultActionArgs.apply(this, arguments);
    const component = this.option("component");
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  }
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable2.option("itemData"),
      itemElement: getPublicElement(sourceDraggable2._$sourceElement),
      fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
      toComponent: targetDraggable2.option("component") || targetDraggable2,
      fromData: sourceDraggable2.option("data"),
      toData: targetDraggable2.option("data")
    };
  }
  _getDragStartArgs(e, $itemElement) {
    const args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  }
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  }
  _dragEndHandler(e) {
    const d = Deferred();
    const dragEndEventArgs = this._getEventArgs(e);
    const dropEventArgs = this._getEventArgs(e);
    const targetDraggable2 = this._getTargetDraggable();
    let needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction("onDragEnd")(dragEndEventArgs);
    } finally {
      when(fromPromise(dragEndEventArgs.cancel)).done(((cancel) => {
        if (!cancel) {
          if (targetDraggable2 !== this) {
            targetDraggable2._getAction("onDrop")(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      })).fail(d.resolve);
      d.done((() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this._resetDragOptions(targetDraggable2);
      }));
    }
  }
  _isTargetOverAnotherDraggable(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    if (this === sourceDraggable2) {
      return false;
    }
    const $dragElement = sourceDraggable2._$dragElement;
    const $sourceDraggableElement = sourceDraggable2.$element();
    const $targetDraggableElement = this.$element();
    const mousePosition = getMousePosition(e);
    const elements = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    const firstWidgetElement = elements.filter(((element) => {
      const $element = renderer_default(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    }))[0];
    const $sourceElement = this._getSourceElement();
    const isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    const isTargetOverNestedDraggable = renderer_default(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  }
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragEnter(e);
  }
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragLeave(e);
  }
  _keydownHandler(e) {
    if (this.dragInProgress && "Escape" === e.key) {
      this._keydownEscapeHandler(e);
    }
  }
  _keydownEscapeHandler(e) {
    var _sourceDraggable;
    const $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    const dragCancelEventArgs = this._getEventArgs(e);
    this._getAction("onDragCancel")(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    null === (_sourceDraggable = sourceDraggable) || void 0 === _sourceDraggable || _sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    const targetDraggable2 = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable2);
    this._attachEventHandlers();
  }
  _getAction(name2) {
    return this[`_${name2}Action`] || this._createActionByOption(name2);
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    if (!this.option("contentTemplate")) {
      return;
    }
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    super._initTemplates.apply(this, arguments);
  }
  _render() {
    super._render();
    this.$element().addClass(this._addWidgetPrefix());
    const transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
    const template = this._getTemplateByOption("contentTemplate");
    if (template) {
      renderer_default(template.render({
        container: this.element(),
        transclude
      }));
    }
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
      case "onDragCancel":
      case "onDraggableElementShown":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "onCancelByEsc":
        this._keydownHandler();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getTargetDraggable() {
    return targetDraggable || this;
  }
  _getSourceDraggable() {
    return sourceDraggable || this;
  }
  _setTargetDraggable() {
    const currentGroup = this.option("group");
    const sourceDraggable2 = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
      targetDraggable = this;
    }
  }
  _setSourceDraggable() {
    sourceDraggable = this;
  }
  _resetSourceDraggable() {
    sourceDraggable = null;
  }
  _resetTargetDraggable() {
    targetDraggable = null;
  }
  _resetDragOptions(targetDraggable2) {
    this.reset();
    targetDraggable2.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  }
  _dispose() {
    super._dispose();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  }
  _fireDragEnterEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragEnter")(args);
  }
  _fireDragLeaveEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragLeave")(args);
  }
};
component_registrator_default(DRAGGABLE, Draggable);
var m_draggable_default = Draggable;

// node_modules/devextreme/esm/__internal/m_sortable.js
var window14 = getWindow();
var SORTABLE = "dxSortable";
var isElementVisible = (itemElement) => renderer_default(itemElement).is(":visible");
var animate = (element, config2) => {
  var _config$to, _config$to2;
  if (!element) {
    return;
  }
  const left = (null === (_config$to = config2.to) || void 0 === _config$to ? void 0 : _config$to.left) || 0;
  const top = (null === (_config$to2 = config2.to) || void 0 === _config$to2 ? void 0 : _config$to2.top) || 0;
  element.style.transform = `translate(${left}px,${top}px)`;
  element.style.transition = fx_default.off ? "" : `transform ${config2.duration}ms ${config2.easing}`;
};
var stopAnimation = (element) => {
  if (!element) {
    return;
  }
  element.style.transform = "";
  element.style.transition = "";
};
function getScrollableBoundary($scrollable) {
  const offset = $scrollable.offset();
  const {
    style
  } = $scrollable[0];
  const paddingLeft = parseFloat(style.paddingLeft) || 0;
  const paddingRight = parseFloat(style.paddingRight) || 0;
  const paddingTop = parseFloat(style.paddingTop) || 0;
  const width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);
  const height = getHeight($scrollable);
  const left = offset.left + paddingLeft;
  const top = offset.top + paddingTop;
  return {
    left,
    right: left + width,
    top,
    bottom: top + height
  };
}
var Sortable = class extends m_draggable_default {
  _init() {
    super._init();
    this._sourceScrollHandler = this._handleSourceScroll.bind(this);
    this._sourceScrollableInfo = null;
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      clone: true,
      filter: "> *",
      itemOrientation: "vertical",
      dropFeedbackMode: "push",
      allowDropInsideItem: false,
      allowReordering: true,
      moveItemOnDrop: false,
      onDragChange: null,
      onAdd: null,
      onRemove: null,
      onReorder: null,
      onPlaceholderPrepared: null,
      animation: {
        type: "slide",
        duration: 300,
        easing: "ease"
      },
      fromIndex: null,
      toIndex: null,
      dropInsideItem: false,
      itemPoints: null,
      fromIndexOffset: 0,
      offset: 0,
      autoUpdate: false,
      draggableElementSize: 0
    });
  }
  reset() {
    this.option({
      dropInsideItem: false,
      toIndex: null,
      fromIndex: null,
      itemPoints: null,
      fromIndexOffset: 0,
      draggableElementSize: 0
    });
    if (this._$placeholderElement) {
      this._$placeholderElement.remove();
    }
    this._$placeholderElement = null;
    if (!this._isIndicateMode() && this._$modifiedItem) {
      this._$modifiedItem.css("marginBottom", this._modifiedItemMargin);
      this._$modifiedItem = null;
    }
  }
  _getPrevVisibleItem(items, index) {
    return items.slice(0, index).reverse().filter(isElementVisible)[0];
  }
  _dragStartHandler(e) {
    super._dragStartHandler.apply(this, arguments);
    if (true === e.cancel) {
      return;
    }
    const $sourceElement = this._getSourceElement();
    this._updateItemPoints();
    this._subscribeToSourceScroll(e);
    this.option("fromIndex", this._getElementIndex($sourceElement));
    this.option("fromIndexOffset", this.option("offset"));
  }
  _subscribeToSourceScroll(e) {
    const $scrollable = this._getScrollable(renderer_default(e.target));
    if ($scrollable) {
      this._sourceScrollableInfo = {
        element: $scrollable,
        scrollLeft: $scrollable.scrollLeft(),
        scrollTop: $scrollable.scrollTop()
      };
      m_events_engine_default.off($scrollable, "scroll", this._sourceScrollHandler);
      m_events_engine_default.on($scrollable, "scroll", this._sourceScrollHandler);
    }
  }
  _unsubscribeFromSourceScroll() {
    if (this._sourceScrollableInfo) {
      m_events_engine_default.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler);
      this._sourceScrollableInfo = null;
    }
  }
  _handleSourceScroll(e) {
    const sourceScrollableInfo = this._sourceScrollableInfo;
    if (sourceScrollableInfo) {
      ["scrollLeft", "scrollTop"].forEach(((scrollProp) => {
        if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {
          const scrollBy2 = e.target[scrollProp] - sourceScrollableInfo[scrollProp];
          this._correctItemPoints(scrollBy2);
          this._movePlaceholder();
          sourceScrollableInfo[scrollProp] = e.target[scrollProp];
        }
      }));
    }
  }
  _dragEnterHandler(e) {
    super._dragEnterHandler.apply(this, arguments);
    if (this === this._getSourceDraggable()) {
      return;
    }
    this._subscribeToSourceScroll(e);
    this._updateItemPoints();
    this.option("fromIndex", -1);
    if (!this._isIndicateMode()) {
      const itemPoints = this.option("itemPoints");
      const lastItemPoint = itemPoints[itemPoints.length - 1];
      if (lastItemPoint) {
        const $element = this.$element();
        const $sourceElement = this._getSourceElement();
        const isVertical = this._isVerticalOrientation();
        const sourceElementSize = isVertical ? getOuterHeight($sourceElement, true) : getOuterWidth($sourceElement, true);
        const scrollSize = $element.get(0)[isVertical ? "scrollHeight" : "scrollWidth"];
        const scrollPosition = $element.get(0)[isVertical ? "scrollTop" : "scrollLeft"];
        const positionProp = isVertical ? "top" : "left";
        const lastPointPosition = lastItemPoint[positionProp];
        const elementPosition = $element.offset()[positionProp];
        const freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;
        if (freeSize < sourceElementSize) {
          if (isVertical) {
            const items = this._getItems();
            const $lastItem = renderer_default(this._getPrevVisibleItem(items));
            this._$modifiedItem = $lastItem;
            this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;
            $lastItem.css("marginBottom", sourceElementSize - freeSize);
            const $sortable = $lastItem.closest(".dx-sortable");
            const sortable = $sortable.data("dxScrollable") || $sortable.data("dxScrollView");
            null === sortable || void 0 === sortable || sortable.update();
          }
        }
      }
    }
  }
  _dragLeaveHandler() {
    super._dragLeaveHandler.apply(this, arguments);
    if (this !== this._getSourceDraggable()) {
      this._unsubscribeFromSourceScroll();
    }
  }
  dragEnter() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", -1);
    }
  }
  dragLeave() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", this.option("fromIndex"));
    }
  }
  _allowDrop(event) {
    const targetDraggable2 = this._getTargetDraggable();
    const $targetDraggable = targetDraggable2.$element();
    const $scrollable = this._getScrollable($targetDraggable);
    if ($scrollable) {
      const {
        left,
        right,
        top,
        bottom
      } = getScrollableBoundary($scrollable);
      const toIndex = this.option("toIndex");
      const itemPoints = this.option("itemPoints");
      const itemPoint = null === itemPoints || void 0 === itemPoints ? void 0 : itemPoints.filter(((item) => item.index === toIndex))[0];
      if (itemPoint && void 0 !== itemPoint.top) {
        const isVertical = this._isVerticalOrientation();
        if (isVertical) {
          return top <= Math.ceil(itemPoint.top) && Math.floor(itemPoint.top) <= bottom;
        }
        return left <= Math.ceil(itemPoint.left) && Math.floor(itemPoint.left) <= right;
      }
    }
    return true;
  }
  dragEnd(sourceEvent) {
    this._unsubscribeFromSourceScroll();
    const $sourceElement = this._getSourceElement();
    const sourceDraggable2 = this._getSourceDraggable();
    const isSourceDraggable = sourceDraggable2.NAME !== this.NAME;
    const toIndex = this.option("toIndex");
    const {
      event
    } = sourceEvent;
    const allowDrop = this._allowDrop(event);
    if (null !== toIndex && toIndex >= 0 && allowDrop) {
      let cancelAdd;
      let cancelRemove;
      if (sourceDraggable2 !== this) {
        cancelAdd = this._fireAddEvent(event);
        if (!cancelAdd) {
          cancelRemove = this._fireRemoveEvent(event);
        }
      }
      if (isSourceDraggable) {
        resetPosition($sourceElement);
      }
      if (this.option("moveItemOnDrop")) {
        !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove);
      }
      if (sourceDraggable2 === this) {
        return this._fireReorderEvent(event);
      }
    }
    return Deferred().resolve();
  }
  dragMove(e) {
    const itemPoints = this.option("itemPoints");
    if (!itemPoints) {
      return;
    }
    const isVertical = this._isVerticalOrientation();
    const axisName = isVertical ? "top" : "left";
    const cursorPosition = isVertical ? e.pageY : e.pageX;
    const rtlEnabled = this.option("rtlEnabled");
    let itemPoint;
    for (let i = itemPoints.length - 1; i >= 0; i--) {
      const centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;
      if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || void 0 === centerPosition) {
        itemPoint = itemPoints[i];
      } else {
        break;
      }
    }
    if (itemPoint) {
      this._updatePlaceholderPosition(e, itemPoint);
      if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {
        this._movePlaceholder();
      }
    }
  }
  _isIndicateMode() {
    return "indicate" === this.option("dropFeedbackMode") || this.option("allowDropInsideItem");
  }
  _createPlaceholder() {
    let $placeholderContainer;
    if (this._isIndicateMode()) {
      $placeholderContainer = renderer_default("<div>").addClass(this._addWidgetPrefix("placeholder")).insertBefore(this._getSourceDraggable()._$dragElement);
    }
    this._$placeholderElement = $placeholderContainer;
    return $placeholderContainer;
  }
  _getItems() {
    const itemsSelector = this._getItemsSelector();
    return this._$content().find(itemsSelector).not(`.${this._addWidgetPrefix("placeholder")}`).not(`.${this._addWidgetPrefix("clone")}`).toArray();
  }
  _allowReordering() {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return sourceDraggable2 !== targetDraggable2 || this.option("allowReordering");
  }
  _isValidPoint(visibleIndex, draggableVisibleIndex, dropInsideItem) {
    const allowDropInsideItem = this.option("allowDropInsideItem");
    const allowReordering2 = dropInsideItem || this._allowReordering();
    if (!allowReordering2 && (0 !== visibleIndex || !allowDropInsideItem)) {
      return false;
    }
    if (!this._isIndicateMode()) {
      return true;
    }
    return -1 === draggableVisibleIndex || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1);
  }
  _getItemPoints() {
    const that = this;
    let result2 = [];
    let $item;
    let offset;
    let itemWidth;
    const {
      rtlEnabled
    } = that.option();
    const isVertical = that._isVerticalOrientation();
    const itemElements = that._getItems();
    const visibleItemElements = itemElements.filter(isElementVisible);
    const visibleItemCount = visibleItemElements.length;
    const $draggableItem = this._getDraggableElement();
    const draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));
    if (visibleItemCount) {
      for (let i = 0; i <= visibleItemCount; i++) {
        const needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;
        const needCorrectTopPosition = isVertical && i === visibleItemCount;
        if (i < visibleItemCount) {
          $item = renderer_default(visibleItemElements[i]);
          offset = $item.offset();
          itemWidth = getOuterWidth($item);
        }
        result2.push({
          dropInsideItem: false,
          left: offset.left + (needCorrectLeftPosition ? itemWidth : 0),
          top: offset.top + (needCorrectTopPosition ? result2[i - 1].height : 0),
          index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),
          $item,
          width: getOuterWidth($item),
          height: getOuterHeight($item),
          isValid: that._isValidPoint(i, draggableVisibleIndex)
        });
      }
      if (this.option("allowDropInsideItem")) {
        const points = result2;
        result2 = [];
        for (let i = 0; i < points.length; i++) {
          result2.push(points[i]);
          if (points[i + 1]) {
            result2.push(extend({}, points[i], {
              dropInsideItem: true,
              top: Math.floor((points[i].top + points[i + 1].top) / 2),
              left: Math.floor((points[i].left + points[i + 1].left) / 2),
              isValid: this._isValidPoint(i, draggableVisibleIndex, true)
            }));
          }
        }
      }
    } else {
      result2.push({
        dropInsideItem: false,
        index: 0,
        isValid: true
      });
    }
    return result2;
  }
  _updateItemPoints(forceUpdate2) {
    if (forceUpdate2 || this.option("autoUpdate") || !this.option("itemPoints")) {
      this.option("itemPoints", this._getItemPoints());
    }
  }
  _correctItemPoints(scrollBy2) {
    const itemPoints = this.option("itemPoints");
    if (scrollBy2 && itemPoints && !this.option("autoUpdate")) {
      const isVertical = this._isVerticalOrientation();
      const positionPropName = isVertical ? "top" : "left";
      itemPoints.forEach(((itemPoint) => {
        itemPoint[positionPropName] -= scrollBy2;
      }));
    }
  }
  _getElementIndex($itemElement) {
    return this._getItems().indexOf($itemElement.get(0));
  }
  _getDragTemplateArgs($element) {
    const args = super._getDragTemplateArgs.apply(this, arguments);
    args.model.fromIndex = this._getElementIndex($element);
    return args;
  }
  _togglePlaceholder(value2) {
    var _this$_$placeholderEl;
    null === (_this$_$placeholderEl = this._$placeholderElement) || void 0 === _this$_$placeholderEl || _this$_$placeholderEl.toggle(value2);
  }
  _isVerticalOrientation() {
    const {
      itemOrientation
    } = this.option();
    return "vertical" === itemOrientation;
  }
  _normalizeToIndex(toIndex, skipOffsetting) {
    const isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();
    const fromIndex = this._getActualFromIndex();
    if (null === toIndex) {
      return fromIndex;
    }
    return Math.max(isAnotherDraggable || fromIndex >= toIndex || skipOffsetting ? toIndex : toIndex - 1, 0);
  }
  _updatePlaceholderPosition(e, itemPoint) {
    const sourceDraggable2 = this._getSourceDraggable();
    const toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);
    const eventArgs = extend(this._getEventArgs(e), {
      toIndex,
      dropInsideItem: itemPoint.dropInsideItem
    });
    itemPoint.isValid && this._getAction("onDragChange")(eventArgs);
    if (eventArgs.cancel || !itemPoint.isValid) {
      if (!itemPoint.isValid) {
        this.option({
          dropInsideItem: false,
          toIndex: null
        });
      }
      return;
    }
    this.option({
      dropInsideItem: itemPoint.dropInsideItem,
      toIndex: itemPoint.index
    });
    this._getAction("onPlaceholderPrepared")(extend(this._getEventArgs(e), {
      placeholderElement: getPublicElement(this._$placeholderElement),
      dragElement: getPublicElement(sourceDraggable2._$dragElement)
    }));
    this._updateItemPoints();
  }
  _makeWidthCorrection($item, width) {
    this._$scrollable = this._getScrollable($item);
    if (this._$scrollable) {
      const scrollableWidth = getWidth(this._$scrollable);
      const overflowLeft = this._$scrollable.offset().left - $item.offset().left;
      const overflowRight = getOuterWidth($item) - overflowLeft - scrollableWidth;
      if (overflowLeft > 0) {
        width -= overflowLeft;
      }
      if (overflowRight > 0) {
        width -= overflowRight;
      }
    }
    return width;
  }
  _updatePlaceholderSizes($placeholderElement, itemElement) {
    const dropInsideItem = this.option("dropInsideItem");
    const $item = renderer_default(itemElement);
    const isVertical = this._isVerticalOrientation();
    let width = "";
    let height = "";
    $placeholderElement.toggleClass(this._addWidgetPrefix("placeholder-inside"), dropInsideItem);
    if (isVertical || dropInsideItem) {
      width = getOuterWidth($item);
    }
    if (!isVertical || dropInsideItem) {
      height = getOuterHeight($item);
    }
    width = this._makeWidthCorrection($item, width);
    $placeholderElement.css({
      width,
      height
    });
  }
  _moveItem($itemElement, index, cancelRemove) {
    let $prevTargetItemElement;
    const $itemElements = this._getItems();
    const $targetItemElement = $itemElements[index];
    const sourceDraggable2 = this._getSourceDraggable();
    if (cancelRemove) {
      $itemElement = $itemElement.clone();
      sourceDraggable2._toggleDragSourceClass(false, $itemElement);
    }
    if (!$targetItemElement) {
      $prevTargetItemElement = $itemElements[index - 1];
    }
    this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement);
  }
  _moveItemCore($targetItem, item, prevItem) {
    if (!item && !prevItem) {
      $targetItem.appendTo(this.$element());
    } else if (prevItem) {
      $targetItem.insertAfter(renderer_default(prevItem));
    } else {
      $targetItem.insertBefore(renderer_default(item));
    }
  }
  _getDragStartArgs(e, $itemElement) {
    return extend(super._getDragStartArgs.apply(this, arguments), {
      fromIndex: this._getElementIndex($itemElement)
    });
  }
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    const dropInsideItem = targetDraggable2.option("dropInsideItem");
    return extend(super._getEventArgs.apply(this, arguments), {
      fromIndex: sourceDraggable2.option("fromIndex"),
      toIndex: this._normalizeToIndex(targetDraggable2.option("toIndex"), dropInsideItem),
      dropInsideItem
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragChange":
      case "onPlaceholderPrepared":
      case "onAdd":
      case "onRemove":
      case "onReorder":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "itemOrientation":
      case "allowDropInsideItem":
      case "moveItemOnDrop":
      case "dropFeedbackMode":
      case "itemPoints":
      case "animation":
      case "allowReordering":
      case "fromIndexOffset":
      case "offset":
      case "draggableElementSize":
      case "autoUpdate":
        break;
      case "fromIndex":
        [false, true].forEach(((isDragSource) => {
          const fromIndex = isDragSource ? args.value : args.previousValue;
          if (null !== fromIndex) {
            const $fromElement = renderer_default(this._getItems()[fromIndex]);
            this._toggleDragSourceClass(isDragSource, $fromElement);
          }
        }));
        break;
      case "dropInsideItem":
        this._optionChangedDropInsideItem(args);
        break;
      case "toIndex":
        this._optionChangedToIndex(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _optionChangedDropInsideItem() {
    if (this._isIndicateMode() && this._$placeholderElement) {
      this._movePlaceholder();
    }
  }
  _isPositionVisible(position2) {
    const $element = this.$element();
    let scrollContainer;
    if ("hidden" !== $element.css("overflow")) {
      scrollContainer = $element.get(0);
    } else {
      $element.parents().each((function() {
        if ("visible" !== renderer_default(this).css("overflow")) {
          scrollContainer = this;
          return false;
        }
        return;
      }));
    }
    if (scrollContainer) {
      const clientRect = getBoundingRect(scrollContainer);
      const isVerticalOrientation = this._isVerticalOrientation();
      const start = isVerticalOrientation ? "top" : "left";
      const end = isVerticalOrientation ? "bottom" : "right";
      const pageOffset = isVerticalOrientation ? window14.pageYOffset : window14.pageXOffset;
      if (position2[start] < clientRect[start] + pageOffset || position2[start] > clientRect[end] + pageOffset) {
        return false;
      }
    }
    return true;
  }
  _optionChangedToIndex(args) {
    const toIndex = args.value;
    if (this._isIndicateMode()) {
      const showPlaceholder = null !== toIndex && toIndex >= 0;
      this._togglePlaceholder(showPlaceholder);
      if (showPlaceholder) {
        this._movePlaceholder();
      }
    } else {
      this._moveItems(args.previousValue, args.value, args.fullUpdate);
    }
  }
  update() {
    if (null === this.option("fromIndex") && null === this.option("toIndex")) {
      return;
    }
    this._updateItemPoints(true);
    this._updateDragSourceClass();
    const toIndex = this.option("toIndex");
    this._optionChangedToIndex({
      value: toIndex,
      fullUpdate: true
    });
  }
  _updateDragSourceClass() {
    const fromIndex = this._getActualFromIndex();
    const $fromElement = renderer_default(this._getItems()[fromIndex]);
    if ($fromElement.length) {
      this._$sourceElement = $fromElement;
      this._toggleDragSourceClass(true, $fromElement);
    }
  }
  _makeLeftCorrection(left) {
    const $scrollable = this._$scrollable;
    if ($scrollable && this._isVerticalOrientation()) {
      const overflowLeft = $scrollable.offset().left - left;
      if (overflowLeft > 0) {
        left += overflowLeft;
      }
    }
    return left;
  }
  _movePlaceholder() {
    const that = this;
    const $placeholderElement = that._$placeholderElement || that._createPlaceholder();
    if (!$placeholderElement) {
      return;
    }
    const items = that._getItems();
    const toIndex = that.option("toIndex");
    const isVerticalOrientation = that._isVerticalOrientation();
    const rtlEnabled = this.option("rtlEnabled");
    const dropInsideItem = that.option("dropInsideItem");
    let position2 = null;
    let itemElement = items[toIndex];
    if (itemElement) {
      const $itemElement = renderer_default(itemElement);
      position2 = $itemElement.offset();
      if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {
        position2.left += getOuterWidth($itemElement, true);
      }
    } else {
      const prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);
      if (prevVisibleItemElement) {
        position2 = renderer_default(prevVisibleItemElement).offset();
        if (isVerticalOrientation) {
          position2.top += getOuterHeight(prevVisibleItemElement, true);
        } else if (!rtlEnabled) {
          position2.left += getOuterWidth(prevVisibleItemElement, true);
        }
      }
    }
    that._updatePlaceholderSizes($placeholderElement, itemElement);
    if (position2 && !that._isPositionVisible(position2)) {
      position2 = null;
    }
    if (position2) {
      const isLastVerticalPosition = isVerticalOrientation && toIndex === items.length;
      const outerPlaceholderHeight = getOuterHeight($placeholderElement);
      position2.left = that._makeLeftCorrection(position2.left);
      position2.top = isLastVerticalPosition && position2.top >= outerPlaceholderHeight ? position2.top - outerPlaceholderHeight : position2.top;
      that._move(position2, $placeholderElement);
    }
    $placeholderElement.toggle(!!position2);
  }
  _getPositions(items, elementSize, fromIndex, toIndex) {
    const positions = [];
    for (let i = 0; i < items.length; i++) {
      let position2 = 0;
      if (null === toIndex || null === fromIndex) {
        positions.push(position2);
        continue;
      }
      if (-1 === fromIndex) {
        if (i >= toIndex) {
          position2 = elementSize;
        }
      } else if (-1 === toIndex) {
        if (i > fromIndex) {
          position2 = -elementSize;
        }
      } else if (fromIndex < toIndex) {
        if (i > fromIndex && i < toIndex) {
          position2 = -elementSize;
        }
      } else if (fromIndex > toIndex) {
        if (i >= toIndex && i < fromIndex) {
          position2 = elementSize;
        }
      }
      positions.push(position2);
    }
    return positions;
  }
  _getDraggableElementSize(isVerticalOrientation) {
    const $draggableItem = this._getDraggableElement();
    let size = this.option("draggableElementSize");
    if (!size) {
      size = isVerticalOrientation ? (getOuterHeight($draggableItem) + getOuterHeight($draggableItem, true)) / 2 : (getOuterWidth($draggableItem) + getOuterWidth($draggableItem, true)) / 2;
      if (!this.option("autoUpdate")) {
        this.option("draggableElementSize", size);
      }
    }
    return size;
  }
  _getActualFromIndex() {
    const {
      fromIndex,
      fromIndexOffset,
      offset
    } = this.option();
    return null == fromIndex ? null : fromIndex + fromIndexOffset - offset;
  }
  _moveItems(prevToIndex, toIndex, fullUpdate) {
    const fromIndex = this._getActualFromIndex();
    const isVerticalOrientation = this._isVerticalOrientation();
    const positionPropName = isVerticalOrientation ? "top" : "left";
    const elementSize = this._getDraggableElementSize(isVerticalOrientation);
    const items = this._getItems();
    const prevPositions = this._getPositions(items, elementSize, fromIndex, prevToIndex);
    const positions = this._getPositions(items, elementSize, fromIndex, toIndex);
    const animationConfig = this.option("animation");
    const rtlEnabled = this.option("rtlEnabled");
    for (let i = 0; i < items.length; i++) {
      const itemElement = items[i];
      const prevPosition = prevPositions[i];
      const position2 = positions[i];
      if (null === toIndex || null === fromIndex) {
        stopAnimation(itemElement);
      } else if (prevPosition !== position2 || fullUpdate && isDefined(position2)) {
        animate(itemElement, extend({}, animationConfig, {
          to: {
            [positionPropName]: !isVerticalOrientation && rtlEnabled ? -position2 : position2
          }
        }));
      }
    }
  }
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    super._toggleDragSourceClass.apply(this, arguments);
    if (!this._isIndicateMode()) {
      null === $sourceElement || void 0 === $sourceElement || $sourceElement.toggleClass(this._addWidgetPrefix("source-hidden"), value2);
    }
  }
  _dispose() {
    this.reset();
    super._dispose();
  }
  _fireAddEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onAdd")(args);
    return args.cancel;
  }
  _fireRemoveEvent(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    const args = this._getEventArgs(sourceEvent);
    sourceDraggable2._getAction("onRemove")(args);
    return args.cancel;
  }
  _fireReorderEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onReorder")(args);
    return args.promise || Deferred().resolve();
  }
};
component_registrator_default(SORTABLE, Sortable);
var m_sortable_default = Sortable;

// node_modules/devextreme/esm/ui/sortable.js
var sortable_default = m_sortable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/const.js
var ATTRIBUTES2 = {
  dragCell: "dx-drag-cell"
};
var CLASSES6 = {
  cellFocusDisabled: "dx-cell-focus-disabled",
  handleIcon: "drag-icon",
  commandDrag: "dx-command-drag",
  sortableWithoutHandle: "dx-sortable-without-handle",
  rowsView: "rowsview",
  dragView: "dragview"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/dom.js
var createHandleTemplateFunc = (addWidgetPrefix) => (container, options2) => {
  const $container = renderer_default(container);
  if ("data" === options2.rowType) {
    $container.addClass(CLASSES6.cellFocusDisabled);
    return renderer_default("<span>").addClass(addWidgetPrefix(CLASSES6.handleIcon));
  }
  m_utils_default.setEmptyText($container);
  return;
};
var GridCoreRowDraggingDom = {
  createHandleTemplateFunc
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/m_row_dragging.js
var rowsView17 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._updateHandleColumn();
  }
  optionChanged(args) {
    if ("rowDragging" === args.name) {
      this._updateHandleColumn();
      this._invalidate(true, true);
      args.handled = true;
    }
    super.optionChanged.apply(this, arguments);
  }
  _allowReordering() {
    const rowDragging = this.option("rowDragging");
    return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group));
  }
  _updateHandleColumn() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const columnsController = this._columnsController;
    const isHandleColumnVisible = allowReordering2 && rowDragging.showDragIcons;
    null === columnsController || void 0 === columnsController || columnsController.addCommandColumn({
      type: "drag",
      command: "drag",
      visibleIndex: -2,
      alignment: "center",
      elementAttr: [{
        name: ATTRIBUTES2.dragCell,
        value: ""
      }],
      cssClass: CLASSES6.commandDrag,
      width: "auto",
      cellTemplate: this._getHandleTemplate(),
      visible: isHandleColumnVisible
    });
    null === columnsController || void 0 === columnsController || columnsController.columnOption("type:drag", "visible", isHandleColumnVisible);
  }
  _renderContent() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const $content = super._renderContent.apply(this, arguments);
    const isFixedTableRendering = this._isFixedTableRendering;
    const currentSortableName = isFixedTableRendering ? "_sortableFixed" : "_sortable";
    const anotherSortableName = isFixedTableRendering ? "_sortable" : "_sortableFixed";
    const togglePointerEventsStyle = (toggle) => {
      var _this$sortableFixedNa;
      null === (_this$sortableFixedNa = this._sortableFixed) || void 0 === _this$sortableFixedNa || _this$sortableFixedNa.$element().css("pointerEvents", toggle ? "auto" : "");
    };
    const rowSelector = ".dx-row:not(.dx-freespace-row):not(.dx-virtual-row):not(.dx-header-row):not(.dx-footer-row)";
    const filter = this.option("dataRowTemplate") ? `> table > tbody${rowSelector}` : `> table > tbody > ${rowSelector}`;
    if ((allowReordering2 || this[currentSortableName]) && $content.length) {
      this[currentSortableName] = this._createComponent($content, sortable_default, extend({
        component: this.component,
        contentTemplate: null,
        filter,
        cursorOffset: (options2) => {
          const {
            event
          } = options2;
          const rowsViewOffset = renderer_default(this.element()).offset();
          return {
            x: event.pageX - rowsViewOffset.left
          };
        },
        onDraggableElementShown: (e) => {
          if (rowDragging.dragTemplate) {
            return;
          }
          const $dragElement = renderer_default(e.dragElement);
          const gridInstance = $dragElement.children(".dx-widget").data(this.component.NAME);
          this._synchronizeScrollLeftPosition(gridInstance);
        },
        dragTemplate: this._getDraggableRowTemplate(),
        handle: rowDragging.showDragIcons && `.${CLASSES6.commandDrag}`,
        dropFeedbackMode: "indicate"
      }, rowDragging, {
        onDragStart: (e) => {
          var _this$getController, _rowDragging$onDragSt;
          null === (_this$getController = this.getController("keyboardNavigation")) || void 0 === _this$getController || _this$getController._resetFocusedCell();
          const row = e.component.getVisibleRows()[e.fromIndex];
          e.itemData = row && row.data;
          const isDataRow2 = row && "data" === row.rowType;
          e.cancel = !allowReordering2 || !isDataRow2;
          null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt || _rowDragging$onDragSt.call(rowDragging, e);
        },
        onDragEnter: (e) => {
          if (e.fromComponent !== e.toComponent) {
            togglePointerEventsStyle(true);
          }
        },
        onDragLeave: () => {
          togglePointerEventsStyle(false);
        },
        onDragEnd: (e) => {
          var _rowDragging$onDragEn;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn || _rowDragging$onDragEn.call(rowDragging, e);
        },
        onAdd: (e) => {
          var _rowDragging$onAdd;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd || _rowDragging$onAdd.call(rowDragging, e);
        },
        dropFeedbackMode: rowDragging.dropFeedbackMode,
        onOptionChanged: (e) => {
          const hasFixedSortable = this._sortableFixed;
          if (hasFixedSortable) {
            if ("fromIndex" === e.name || "toIndex" === e.name) {
              this[anotherSortableName].option(e.name, e.value);
            }
          }
        }
      }));
      $content.toggleClass("dx-scrollable-container", isFixedTableRendering);
      $content.toggleClass(CLASSES6.sortableWithoutHandle, allowReordering2 && !rowDragging.showDragIcons);
    }
    return $content;
  }
  _renderCore(e) {
    super._renderCore.apply(this, arguments);
    if (e && "update" === e.changeType && e.repaintChangesOnly && m_utils_default.isVirtualRowRendering(this)) {
      deferUpdate((() => {
        this._updateSortable();
      }));
    }
  }
  _updateSortable() {
    const offset = this._dataController.getRowIndexOffset();
    const offsetDiff = offset - this._previousOffset;
    [this._sortable, this._sortableFixed].forEach(((sortable) => {
      const toIndex = null === sortable || void 0 === sortable ? void 0 : sortable.option("toIndex");
      if (isDefined(toIndex) && isDefined(this._previousOffset)) {
        null === sortable || void 0 === sortable || sortable.option("toIndex", toIndex - offsetDiff);
      }
      null === sortable || void 0 === sortable || sortable.option("offset", offset);
      null === sortable || void 0 === sortable || sortable.update();
    }));
    this._previousOffset = offset;
  }
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._updateSortable();
  }
  _getDraggableGridOptions(options2) {
    const gridOptions = this.option();
    const columns7 = this.getColumns();
    const $rowElement = renderer_default(this.getRowElement(options2.rowIndex));
    return {
      dataSource: [{
        id: 1,
        parentId: 0
      }],
      showBorders: true,
      showColumnHeaders: false,
      scrolling: {
        useNative: false,
        showScrollbar: "never"
      },
      pager: {
        visible: false
      },
      loadingTimeout: null,
      columnFixing: gridOptions.columnFixing,
      columnAutoWidth: gridOptions.columnAutoWidth,
      showColumnLines: gridOptions.showColumnLines,
      columns: columns7.map(((column) => ({
        width: column.width || column.visibleWidth,
        fixed: column.fixed,
        fixedPosition: column.fixedPosition
      }))),
      isDragging: true,
      onRowPrepared: (e) => {
        const rowsView18 = e.component.getView("rowsView");
        renderer_default(e.rowElement).replaceWith($rowElement.eq(rowsView18._isFixedTableRendering ? 1 : 0).clone());
      }
    };
  }
  _synchronizeScrollLeftPosition(gridInstance) {
    const scrollable = null === gridInstance || void 0 === gridInstance ? void 0 : gridInstance.getScrollable();
    null === scrollable || void 0 === scrollable || scrollable.scrollTo({
      x: this._scrollLeft
    });
  }
  _getDraggableRowTemplate() {
    return (options2) => {
      const $rootElement = this.component.$element();
      const $dataGridContainer = renderer_default("<div>");
      setWidth($dataGridContainer, getWidth($rootElement));
      const items = this._dataController.items();
      const row = items && items[options2.fromIndex];
      const gridOptions = this._getDraggableGridOptions(row);
      this._createComponent($dataGridContainer, this.component.NAME, gridOptions);
      $dataGridContainer.find(".dx-gridbase-container").children(`:not(.${this.addWidgetPrefix(CLASSES6.rowsView)})`).hide();
      $dataGridContainer.addClass(this.addWidgetPrefix(CLASSES6.dragView));
      return $dataGridContainer;
    };
  }
  _getHandleTemplate() {
    return GridCoreRowDraggingDom.createHandleTemplateFunc(((string) => this.addWidgetPrefix(string)));
  }
};
var rowDraggingModule = {
  defaultOptions: () => ({
    rowDragging: {
      showDragIcons: true,
      dropFeedbackMode: "indicate",
      allowReordering: false,
      allowDropInsideItem: false
    }
  }),
  extenders: {
    views: {
      rowsView: rowsView17
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/row_dragging.js
m_core_default.registerModule("rowDragging", rowDraggingModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget.js
var m_widget_default = m_widget_base_default;

// node_modules/devextreme/esm/ui/data_grid.js
var data_grid_default = m_widget_default;

// node_modules/devextreme-vue/esm/data-grid.js
var componentConfig = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowColumnReordering: Boolean,
    allowColumnResizing: Boolean,
    autoNavigateToFocusedRow: Boolean,
    cacheEnabled: Boolean,
    cellHintEnabled: Boolean,
    columnAutoWidth: Boolean,
    columnChooser: Object,
    columnFixing: Object,
    columnHidingEnabled: Boolean,
    columnMinWidth: Number,
    columnResizingMode: String,
    columns: Array,
    columnWidth: [String, Number],
    customizeColumns: Function,
    dataRowTemplate: {},
    dataSource: [Array, Object, String],
    dateSerializationFormat: String,
    disabled: Boolean,
    editing: Object,
    elementAttr: Object,
    errorRowEnabled: Boolean,
    export: Object,
    filterBuilder: Object,
    filterBuilderPopup: Object,
    filterPanel: Object,
    filterRow: Object,
    filterSyncEnabled: [Boolean, String],
    filterValue: [Array, Function, String],
    focusedColumnIndex: Number,
    focusedRowEnabled: Boolean,
    focusedRowIndex: Number,
    focusedRowKey: {},
    grouping: Object,
    groupPanel: Object,
    headerFilter: Object,
    height: [Function, Number, String],
    highlightChanges: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    keyboardNavigation: Object,
    keyExpr: [Array, String],
    loadPanel: Object,
    masterDetail: Object,
    noDataText: String,
    onAdaptiveDetailRowPreparing: Function,
    onCellClick: Function,
    onCellDblClick: Function,
    onCellHoverChanged: Function,
    onCellPrepared: Function,
    onContentReady: Function,
    onContextMenuPreparing: Function,
    onDataErrorOccurred: Function,
    onDisposing: Function,
    onEditCanceled: Function,
    onEditCanceling: Function,
    onEditingStart: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onExporting: Function,
    onFocusedCellChanged: Function,
    onFocusedCellChanging: Function,
    onFocusedRowChanged: Function,
    onFocusedRowChanging: Function,
    onInitialized: Function,
    onInitNewRow: Function,
    onKeyDown: Function,
    onOptionChanged: Function,
    onRowClick: Function,
    onRowCollapsed: Function,
    onRowCollapsing: Function,
    onRowDblClick: Function,
    onRowExpanded: Function,
    onRowExpanding: Function,
    onRowInserted: Function,
    onRowInserting: Function,
    onRowPrepared: Function,
    onRowRemoved: Function,
    onRowRemoving: Function,
    onRowUpdated: Function,
    onRowUpdating: Function,
    onRowValidating: Function,
    onSaved: Function,
    onSaving: Function,
    onSelectionChanged: Function,
    onToolbarPreparing: Function,
    pager: Object,
    paging: Object,
    remoteOperations: [Boolean, String, Object],
    renderAsync: Boolean,
    repaintChangesOnly: Boolean,
    rowAlternationEnabled: Boolean,
    rowDragging: Object,
    rowTemplate: {},
    rtlEnabled: Boolean,
    scrolling: Object,
    searchPanel: Object,
    selectedRowKeys: Array,
    selection: Object,
    selectionFilter: [Array, Function, String],
    showBorders: Boolean,
    showColumnHeaders: Boolean,
    showColumnLines: Boolean,
    showRowLines: Boolean,
    sortByGroupSummaryInfo: Array,
    sorting: Object,
    stateStoring: Object,
    summary: Object,
    syncLookupFilterValues: Boolean,
    tabIndex: Number,
    toolbar: Object,
    twoWayBindingEnabled: Boolean,
    visible: Boolean,
    width: [Function, Number, String],
    wordWrapEnabled: Boolean
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowColumnReordering": null,
    "update:allowColumnResizing": null,
    "update:autoNavigateToFocusedRow": null,
    "update:cacheEnabled": null,
    "update:cellHintEnabled": null,
    "update:columnAutoWidth": null,
    "update:columnChooser": null,
    "update:columnFixing": null,
    "update:columnHidingEnabled": null,
    "update:columnMinWidth": null,
    "update:columnResizingMode": null,
    "update:columns": null,
    "update:columnWidth": null,
    "update:customizeColumns": null,
    "update:dataRowTemplate": null,
    "update:dataSource": null,
    "update:dateSerializationFormat": null,
    "update:disabled": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:errorRowEnabled": null,
    "update:export": null,
    "update:filterBuilder": null,
    "update:filterBuilderPopup": null,
    "update:filterPanel": null,
    "update:filterRow": null,
    "update:filterSyncEnabled": null,
    "update:filterValue": null,
    "update:focusedColumnIndex": null,
    "update:focusedRowEnabled": null,
    "update:focusedRowIndex": null,
    "update:focusedRowKey": null,
    "update:grouping": null,
    "update:groupPanel": null,
    "update:headerFilter": null,
    "update:height": null,
    "update:highlightChanges": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:keyboardNavigation": null,
    "update:keyExpr": null,
    "update:loadPanel": null,
    "update:masterDetail": null,
    "update:noDataText": null,
    "update:onAdaptiveDetailRowPreparing": null,
    "update:onCellClick": null,
    "update:onCellDblClick": null,
    "update:onCellHoverChanged": null,
    "update:onCellPrepared": null,
    "update:onContentReady": null,
    "update:onContextMenuPreparing": null,
    "update:onDataErrorOccurred": null,
    "update:onDisposing": null,
    "update:onEditCanceled": null,
    "update:onEditCanceling": null,
    "update:onEditingStart": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onExporting": null,
    "update:onFocusedCellChanged": null,
    "update:onFocusedCellChanging": null,
    "update:onFocusedRowChanged": null,
    "update:onFocusedRowChanging": null,
    "update:onInitialized": null,
    "update:onInitNewRow": null,
    "update:onKeyDown": null,
    "update:onOptionChanged": null,
    "update:onRowClick": null,
    "update:onRowCollapsed": null,
    "update:onRowCollapsing": null,
    "update:onRowDblClick": null,
    "update:onRowExpanded": null,
    "update:onRowExpanding": null,
    "update:onRowInserted": null,
    "update:onRowInserting": null,
    "update:onRowPrepared": null,
    "update:onRowRemoved": null,
    "update:onRowRemoving": null,
    "update:onRowUpdated": null,
    "update:onRowUpdating": null,
    "update:onRowValidating": null,
    "update:onSaved": null,
    "update:onSaving": null,
    "update:onSelectionChanged": null,
    "update:onToolbarPreparing": null,
    "update:pager": null,
    "update:paging": null,
    "update:remoteOperations": null,
    "update:renderAsync": null,
    "update:repaintChangesOnly": null,
    "update:rowAlternationEnabled": null,
    "update:rowDragging": null,
    "update:rowTemplate": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:searchPanel": null,
    "update:selectedRowKeys": null,
    "update:selection": null,
    "update:selectionFilter": null,
    "update:showBorders": null,
    "update:showColumnHeaders": null,
    "update:showColumnLines": null,
    "update:showRowLines": null,
    "update:sortByGroupSummaryInfo": null,
    "update:sorting": null,
    "update:stateStoring": null,
    "update:summary": null,
    "update:syncLookupFilterValues": null,
    "update:tabIndex": null,
    "update:toolbar": null,
    "update:twoWayBindingEnabled": null,
    "update:visible": null,
    "update:width": null,
    "update:wordWrapEnabled": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = data_grid_default;
    this.$_hasAsyncTemplate = false;
    this.$_expectedChildren = {
      column: { isCollectionItem: true, optionName: "columns" },
      columnChooser: { isCollectionItem: false, optionName: "columnChooser" },
      columnFixing: { isCollectionItem: false, optionName: "columnFixing" },
      dataGridHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
      dataGridSelection: { isCollectionItem: false, optionName: "selection" },
      editing: { isCollectionItem: false, optionName: "editing" },
      export: { isCollectionItem: false, optionName: "export" },
      filterBuilder: { isCollectionItem: false, optionName: "filterBuilder" },
      filterBuilderPopup: { isCollectionItem: false, optionName: "filterBuilderPopup" },
      filterPanel: { isCollectionItem: false, optionName: "filterPanel" },
      filterRow: { isCollectionItem: false, optionName: "filterRow" },
      grouping: { isCollectionItem: false, optionName: "grouping" },
      groupPanel: { isCollectionItem: false, optionName: "groupPanel" },
      headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
      keyboardNavigation: { isCollectionItem: false, optionName: "keyboardNavigation" },
      loadPanel: { isCollectionItem: false, optionName: "loadPanel" },
      masterDetail: { isCollectionItem: false, optionName: "masterDetail" },
      pager: { isCollectionItem: false, optionName: "pager" },
      paging: { isCollectionItem: false, optionName: "paging" },
      remoteOperations: { isCollectionItem: false, optionName: "remoteOperations" },
      rowDragging: { isCollectionItem: false, optionName: "rowDragging" },
      scrolling: { isCollectionItem: false, optionName: "scrolling" },
      searchPanel: { isCollectionItem: false, optionName: "searchPanel" },
      selection: { isCollectionItem: false, optionName: "selection" },
      sortByGroupSummaryInfo: { isCollectionItem: true, optionName: "sortByGroupSummaryInfo" },
      sorting: { isCollectionItem: false, optionName: "sorting" },
      stateStoring: { isCollectionItem: false, optionName: "stateStoring" },
      summary: { isCollectionItem: false, optionName: "summary" },
      toolbar: { isCollectionItem: false, optionName: "toolbar" }
    };
  }
};
prepareComponentConfig(componentConfig);
var DxDataGrid = defineComponent(componentConfig);
var DxAnimationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
prepareConfigurationComponentConfig(DxAnimationConfig);
var DxAnimation = defineComponent(DxAnimationConfig);
DxAnimation.$_optionName = "animation";
DxAnimation.$_expectedChildren = {
  hide: { isCollectionItem: false, optionName: "hide" },
  show: { isCollectionItem: false, optionName: "show" }
};
var DxAsyncRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxAsyncRuleConfig);
var DxAsyncRule = defineComponent(DxAsyncRuleConfig);
DxAsyncRule.$_optionName = "validationRules";
DxAsyncRule.$_isCollectionItem = true;
DxAsyncRule.$_predefinedProps = {
  type: "async"
};
var DxAtConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxAtConfig);
var DxAt = defineComponent(DxAtConfig);
DxAt.$_optionName = "at";
var DxBoundaryOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxBoundaryOffsetConfig);
var DxBoundaryOffset = defineComponent(DxBoundaryOffsetConfig);
DxBoundaryOffset.$_optionName = "boundaryOffset";
var DxButtonConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:hint": null,
    "update:icon": null,
    "update:name": null,
    "update:onClick": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    cssClass: String,
    disabled: [Boolean, Function],
    hint: String,
    icon: String,
    name: String,
    onClick: Function,
    template: {},
    text: String,
    visible: [Boolean, Function]
  }
};
prepareConfigurationComponentConfig(DxButtonConfig);
var DxButton = defineComponent(DxButtonConfig);
DxButton.$_optionName = "buttons";
DxButton.$_isCollectionItem = true;
var DxChangeConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:data": null,
    "update:insertAfterKey": null,
    "update:insertBeforeKey": null,
    "update:type": null
  },
  props: {
    data: {},
    insertAfterKey: {},
    insertBeforeKey: {},
    type: String
  }
};
prepareConfigurationComponentConfig(DxChangeConfig);
var DxChange = defineComponent(DxChangeConfig);
DxChange.$_optionName = "changes";
DxChange.$_isCollectionItem = true;
var DxColCountByScreenConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:lg": null,
    "update:md": null,
    "update:sm": null,
    "update:xs": null
  },
  props: {
    lg: Number,
    md: Number,
    sm: Number,
    xs: Number
  }
};
prepareConfigurationComponentConfig(DxColCountByScreenConfig);
var DxColCountByScreen = defineComponent(DxColCountByScreenConfig);
DxColCountByScreen.$_optionName = "colCountByScreen";
var DxCollisionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxCollisionConfig);
var DxCollision = defineComponent(DxCollisionConfig);
DxCollision.$_optionName = "collision";
var DxColumnConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:allowEditing": null,
    "update:allowExporting": null,
    "update:allowFiltering": null,
    "update:allowFixing": null,
    "update:allowGrouping": null,
    "update:allowHeaderFiltering": null,
    "update:allowHiding": null,
    "update:allowReordering": null,
    "update:allowResizing": null,
    "update:allowSearch": null,
    "update:allowSorting": null,
    "update:autoExpandGroup": null,
    "update:buttons": null,
    "update:calculateCellValue": null,
    "update:calculateDisplayValue": null,
    "update:calculateFilterExpression": null,
    "update:calculateGroupValue": null,
    "update:calculateSortValue": null,
    "update:caption": null,
    "update:cellTemplate": null,
    "update:columns": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editCellTemplate": null,
    "update:editorOptions": null,
    "update:encodeHtml": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:filterType": null,
    "update:filterValue": null,
    "update:filterValues": null,
    "update:fixed": null,
    "update:fixedPosition": null,
    "update:format": null,
    "update:formItem": null,
    "update:groupCellTemplate": null,
    "update:groupIndex": null,
    "update:headerCellTemplate": null,
    "update:headerFilter": null,
    "update:hidingPriority": null,
    "update:isBand": null,
    "update:lookup": null,
    "update:minWidth": null,
    "update:name": null,
    "update:ownerBand": null,
    "update:renderAsync": null,
    "update:selectedFilterOperation": null,
    "update:setCellValue": null,
    "update:showEditorAlways": null,
    "update:showInColumnChooser": null,
    "update:showWhenGrouped": null,
    "update:sortIndex": null,
    "update:sortingMethod": null,
    "update:sortOrder": null,
    "update:trueText": null,
    "update:type": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null,
    "update:width": null
  },
  props: {
    alignment: String,
    allowEditing: Boolean,
    allowExporting: Boolean,
    allowFiltering: Boolean,
    allowFixing: Boolean,
    allowGrouping: Boolean,
    allowHeaderFiltering: Boolean,
    allowHiding: Boolean,
    allowReordering: Boolean,
    allowResizing: Boolean,
    allowSearch: Boolean,
    allowSorting: Boolean,
    autoExpandGroup: Boolean,
    buttons: Array,
    calculateCellValue: Function,
    calculateDisplayValue: [Function, String],
    calculateFilterExpression: Function,
    calculateGroupValue: [Function, String],
    calculateSortValue: [Function, String],
    caption: String,
    cellTemplate: {},
    columns: Array,
    cssClass: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editCellTemplate: {},
    editorOptions: {},
    encodeHtml: Boolean,
    falseText: String,
    filterOperations: Array,
    filterType: String,
    filterValue: {},
    filterValues: Array,
    fixed: Boolean,
    fixedPosition: String,
    format: [Object, String, Function],
    formItem: Object,
    groupCellTemplate: {},
    groupIndex: Number,
    headerCellTemplate: {},
    headerFilter: Object,
    hidingPriority: Number,
    isBand: Boolean,
    lookup: Object,
    minWidth: Number,
    name: String,
    ownerBand: Number,
    renderAsync: Boolean,
    selectedFilterOperation: String,
    setCellValue: Function,
    showEditorAlways: Boolean,
    showInColumnChooser: Boolean,
    showWhenGrouped: Boolean,
    sortIndex: Number,
    sortingMethod: Function,
    sortOrder: String,
    trueText: String,
    type: String,
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnConfig);
var DxColumn = defineComponent(DxColumnConfig);
DxColumn.$_optionName = "columns";
DxColumn.$_isCollectionItem = true;
DxColumn.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  button: { isCollectionItem: true, optionName: "buttons" },
  columnHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
  columnLookup: { isCollectionItem: false, optionName: "lookup" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  format: { isCollectionItem: false, optionName: "format" },
  formItem: { isCollectionItem: false, optionName: "formItem" },
  headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
  lookup: { isCollectionItem: false, optionName: "lookup" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxColumnChooserConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:container": null,
    "update:emptyPanelText": null,
    "update:enabled": null,
    "update:height": null,
    "update:mode": null,
    "update:position": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:selection": null,
    "update:sortOrder": null,
    "update:title": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    container: {},
    emptyPanelText: String,
    enabled: Boolean,
    height: [Number, String],
    mode: String,
    position: Object,
    search: Object,
    searchTimeout: Number,
    selection: Object,
    sortOrder: String,
    title: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnChooserConfig);
var DxColumnChooser = defineComponent(DxColumnChooserConfig);
DxColumnChooser.$_optionName = "columnChooser";
DxColumnChooser.$_expectedChildren = {
  columnChooserSearch: { isCollectionItem: false, optionName: "search" },
  columnChooserSelection: { isCollectionItem: false, optionName: "selection" },
  position: { isCollectionItem: false, optionName: "position" },
  search: { isCollectionItem: false, optionName: "search" },
  selection: { isCollectionItem: false, optionName: "selection" }
};
var DxColumnChooserSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSearchConfig);
var DxColumnChooserSearch = defineComponent(DxColumnChooserSearchConfig);
DxColumnChooserSearch.$_optionName = "search";
var DxColumnChooserSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:recursive": null,
    "update:selectByClick": null
  },
  props: {
    allowSelectAll: Boolean,
    recursive: Boolean,
    selectByClick: Boolean
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSelectionConfig);
var DxColumnChooserSelection = defineComponent(DxColumnChooserSelectionConfig);
DxColumnChooserSelection.$_optionName = "selection";
var DxColumnFixingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:icons": null,
    "update:texts": null
  },
  props: {
    enabled: Boolean,
    icons: Object,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxColumnFixingConfig);
var DxColumnFixing = defineComponent(DxColumnFixingConfig);
DxColumnFixing.$_optionName = "columnFixing";
DxColumnFixing.$_expectedChildren = {
  columnFixingTexts: { isCollectionItem: false, optionName: "texts" },
  icons: { isCollectionItem: false, optionName: "icons" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxColumnFixingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxColumnFixingTextsConfig);
var DxColumnFixingTexts = defineComponent(DxColumnFixingTextsConfig);
DxColumnFixingTexts.$_optionName = "texts";
var DxColumnHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterConfig);
var DxColumnHeaderFilter = defineComponent(DxColumnHeaderFilterConfig);
DxColumnHeaderFilter.$_optionName = "headerFilter";
DxColumnHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  search: { isCollectionItem: false, optionName: "search" }
};
var DxColumnHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterSearchConfig);
var DxColumnHeaderFilterSearch = defineComponent(DxColumnHeaderFilterSearchConfig);
DxColumnHeaderFilterSearch.$_optionName = "search";
var DxColumnLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: String
  }
};
prepareConfigurationComponentConfig(DxColumnLookupConfig);
var DxColumnLookup = defineComponent(DxColumnLookupConfig);
DxColumnLookup.$_optionName = "lookup";
var DxCompareRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxCompareRuleConfig);
var DxCompareRule = defineComponent(DxCompareRuleConfig);
DxCompareRule.$_optionName = "validationRules";
DxCompareRule.$_isCollectionItem = true;
DxCompareRule.$_predefinedProps = {
  type: "compare"
};
var DxCursorOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxCursorOffsetConfig);
var DxCursorOffset = defineComponent(DxCursorOffsetConfig);
DxCursorOffset.$_optionName = "cursorOffset";
var DxCustomOperationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataTypes": null,
    "update:editorTemplate": null,
    "update:hasValue": null,
    "update:icon": null,
    "update:name": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataTypes: Array,
    editorTemplate: {},
    hasValue: Boolean,
    icon: String,
    name: String
  }
};
prepareConfigurationComponentConfig(DxCustomOperationConfig);
var DxCustomOperation = defineComponent(DxCustomOperationConfig);
DxCustomOperation.$_optionName = "customOperations";
DxCustomOperation.$_isCollectionItem = true;
var DxCustomRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxCustomRuleConfig);
var DxCustomRule = defineComponent(DxCustomRuleConfig);
DxCustomRule.$_optionName = "validationRules";
DxCustomRule.$_isCollectionItem = true;
DxCustomRule.$_predefinedProps = {
  type: "custom"
};
var DxDataGridHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:height": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    height: [Number, String],
    search: Object,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterConfig);
var DxDataGridHeaderFilter = defineComponent(DxDataGridHeaderFilterConfig);
DxDataGridHeaderFilter.$_optionName = "headerFilter";
DxDataGridHeaderFilter.$_expectedChildren = {
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" },
  search: { isCollectionItem: false, optionName: "search" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxDataGridHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterSearchConfig);
var DxDataGridHeaderFilterSearch = defineComponent(DxDataGridHeaderFilterSearchConfig);
DxDataGridHeaderFilterSearch.$_optionName = "search";
var DxDataGridHeaderFilterTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cancel": null,
    "update:emptyValue": null,
    "update:ok": null
  },
  props: {
    cancel: String,
    emptyValue: String,
    ok: String
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterTextsConfig);
var DxDataGridHeaderFilterTexts = defineComponent(DxDataGridHeaderFilterTextsConfig);
DxDataGridHeaderFilterTexts.$_optionName = "texts";
var DxDataGridSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:selectAllMode": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    selectAllMode: String,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxDataGridSelectionConfig);
var DxDataGridSelection = defineComponent(DxDataGridSelectionConfig);
DxDataGridSelection.$_optionName = "selection";
var DxEditingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowUpdating": null,
    "update:changes": null,
    "update:confirmDelete": null,
    "update:editColumnName": null,
    "update:editRowKey": null,
    "update:form": null,
    "update:mode": null,
    "update:newRowPosition": null,
    "update:popup": null,
    "update:refreshMode": null,
    "update:selectTextOnEditStart": null,
    "update:startEditAction": null,
    "update:texts": null,
    "update:useIcons": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: [Boolean, Function],
    allowUpdating: [Boolean, Function],
    changes: Array,
    confirmDelete: Boolean,
    editColumnName: String,
    editRowKey: {},
    form: Object,
    mode: String,
    newRowPosition: String,
    popup: Object,
    refreshMode: String,
    selectTextOnEditStart: Boolean,
    startEditAction: String,
    texts: {},
    useIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxEditingConfig);
var DxEditing = defineComponent(DxEditingConfig);
DxEditing.$_optionName = "editing";
DxEditing.$_expectedChildren = {
  change: { isCollectionItem: true, optionName: "changes" },
  editingTexts: { isCollectionItem: false, optionName: "texts" },
  form: { isCollectionItem: false, optionName: "form" },
  popup: { isCollectionItem: false, optionName: "popup" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxEditingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:undeleteRow": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    deleteRow: String,
    editRow: String,
    saveAllChanges: String,
    saveRowChanges: String,
    undeleteRow: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxEditingTextsConfig);
var DxEditingTexts = defineComponent(DxEditingTextsConfig);
DxEditingTexts.$_optionName = "texts";
var DxEmailRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxEmailRuleConfig);
var DxEmailRule = defineComponent(DxEmailRuleConfig);
DxEmailRule.$_optionName = "validationRules";
DxEmailRule.$_isCollectionItem = true;
DxEmailRule.$_predefinedProps = {
  type: "email"
};
var DxExportConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowExportSelectedData": null,
    "update:enabled": null,
    "update:formats": null,
    "update:texts": null
  },
  props: {
    allowExportSelectedData: Boolean,
    enabled: Boolean,
    formats: Array,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxExportConfig);
var DxExport = defineComponent(DxExportConfig);
DxExport.$_optionName = "export";
DxExport.$_expectedChildren = {
  exportTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxExportTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null
  },
  props: {
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String
  }
};
prepareConfigurationComponentConfig(DxExportTextsConfig);
var DxExportTexts = defineComponent(DxExportTextsConfig);
DxExportTexts.$_optionName = "texts";
var DxFieldConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editorOptions": null,
    "update:editorTemplate": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:format": null,
    "update:lookup": null,
    "update:name": null,
    "update:trueText": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editorOptions: {},
    editorTemplate: {},
    falseText: String,
    filterOperations: Array,
    format: [Object, String, Function],
    lookup: Object,
    name: String,
    trueText: String
  }
};
prepareConfigurationComponentConfig(DxFieldConfig);
var DxField = defineComponent(DxFieldConfig);
DxField.$_optionName = "fields";
DxField.$_isCollectionItem = true;
DxField.$_expectedChildren = {
  fieldLookup: { isCollectionItem: false, optionName: "lookup" },
  format: { isCollectionItem: false, optionName: "format" },
  lookup: { isCollectionItem: false, optionName: "lookup" }
};
var DxFieldLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    dataSource: [Array, Object],
    displayExpr: [Function, String],
    valueExpr: [Function, String]
  }
};
prepareConfigurationComponentConfig(DxFieldLookupConfig);
var DxFieldLookup = defineComponent(DxFieldLookupConfig);
DxFieldLookup.$_optionName = "lookup";
var DxFilterBuilderConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowHierarchicalFields": null,
    "update:bindingOptions": null,
    "update:customOperations": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:fields": null,
    "update:filterOperationDescriptions": null,
    "update:focusStateEnabled": null,
    "update:groupOperationDescriptions": null,
    "update:groupOperations": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxGroupLevel": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onValueChanged": null,
    "update:rtlEnabled": null,
    "update:tabIndex": null,
    "update:value": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowHierarchicalFields: Boolean,
    bindingOptions: Object,
    customOperations: Array,
    disabled: Boolean,
    elementAttr: Object,
    fields: Array,
    filterOperationDescriptions: Object,
    focusStateEnabled: Boolean,
    groupOperationDescriptions: Object,
    groupOperations: Array,
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    maxGroupLevel: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onValueChanged: Function,
    rtlEnabled: Boolean,
    tabIndex: Number,
    value: [Array, Function, String],
    visible: Boolean,
    width: [Function, Number, String]
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderConfig);
var DxFilterBuilder = defineComponent(DxFilterBuilderConfig);
DxFilterBuilder.$_optionName = "filterBuilder";
DxFilterBuilder.$_expectedChildren = {
  customOperation: { isCollectionItem: true, optionName: "customOperations" },
  field: { isCollectionItem: true, optionName: "fields" },
  filterOperationDescriptions: { isCollectionItem: false, optionName: "filterOperationDescriptions" },
  groupOperationDescriptions: { isCollectionItem: false, optionName: "groupOperationDescriptions" }
};
var DxFilterBuilderPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderPopupConfig);
var DxFilterBuilderPopup = defineComponent(DxFilterBuilderPopupConfig);
DxFilterBuilderPopup.$_optionName = "filterBuilderPopup";
DxFilterBuilderPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxFilterOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:isBlank": null,
    "update:isNotBlank": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    isBlank: String,
    isNotBlank: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxFilterOperationDescriptionsConfig);
var DxFilterOperationDescriptions = defineComponent(DxFilterOperationDescriptionsConfig);
DxFilterOperationDescriptions.$_optionName = "filterOperationDescriptions";
var DxFilterPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customizeText": null,
    "update:filterEnabled": null,
    "update:texts": null,
    "update:visible": null
  },
  props: {
    customizeText: Function,
    filterEnabled: Boolean,
    texts: Object,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterPanelConfig);
var DxFilterPanel = defineComponent(DxFilterPanelConfig);
DxFilterPanel.$_optionName = "filterPanel";
DxFilterPanel.$_expectedChildren = {
  filterPanelTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxFilterPanelTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:clearFilter": null,
    "update:createFilter": null,
    "update:filterEnabledHint": null
  },
  props: {
    clearFilter: String,
    createFilter: String,
    filterEnabledHint: String
  }
};
prepareConfigurationComponentConfig(DxFilterPanelTextsConfig);
var DxFilterPanelTexts = defineComponent(DxFilterPanelTextsConfig);
DxFilterPanelTexts.$_optionName = "texts";
var DxFilterRowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:applyFilter": null,
    "update:applyFilterText": null,
    "update:betweenEndText": null,
    "update:betweenStartText": null,
    "update:operationDescriptions": null,
    "update:resetOperationText": null,
    "update:showAllText": null,
    "update:showOperationChooser": null,
    "update:visible": null
  },
  props: {
    applyFilter: String,
    applyFilterText: String,
    betweenEndText: String,
    betweenStartText: String,
    operationDescriptions: Object,
    resetOperationText: String,
    showAllText: String,
    showOperationChooser: Boolean,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterRowConfig);
var DxFilterRow = defineComponent(DxFilterRowConfig);
DxFilterRow.$_optionName = "filterRow";
DxFilterRow.$_expectedChildren = {
  operationDescriptions: { isCollectionItem: false, optionName: "operationDescriptions" }
};
var DxFormConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:alignItemLabels": null,
    "update:alignItemLabelsInAllGroups": null,
    "update:bindingOptions": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:customizeItem": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:formData": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:isDirty": null,
    "update:items": null,
    "update:labelLocation": null,
    "update:labelMode": null,
    "update:minColWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorEnterKey": null,
    "update:onFieldDataChanged": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:optionalMark": null,
    "update:readOnly": null,
    "update:requiredMark": null,
    "update:requiredMessage": null,
    "update:rtlEnabled": null,
    "update:screenByWidth": null,
    "update:scrollingEnabled": null,
    "update:showColonAfterLabel": null,
    "update:showOptionalMark": null,
    "update:showRequiredMark": null,
    "update:showValidationSummary": null,
    "update:tabIndex": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    alignItemLabels: Boolean,
    alignItemLabelsInAllGroups: Boolean,
    bindingOptions: Object,
    colCount: [String, Number],
    colCountByScreen: Object,
    customizeItem: Function,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    formData: {},
    height: [Function, Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    isDirty: Boolean,
    items: Array,
    labelLocation: String,
    labelMode: String,
    minColWidth: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorEnterKey: Function,
    onFieldDataChanged: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    optionalMark: String,
    readOnly: Boolean,
    requiredMark: String,
    requiredMessage: String,
    rtlEnabled: Boolean,
    screenByWidth: Function,
    scrollingEnabled: Boolean,
    showColonAfterLabel: Boolean,
    showOptionalMark: Boolean,
    showRequiredMark: Boolean,
    showValidationSummary: Boolean,
    tabIndex: Number,
    validationGroup: String,
    visible: Boolean,
    width: [Function, Number, String]
  }
};
prepareConfigurationComponentConfig(DxFormConfig);
var DxForm = defineComponent(DxFormConfig);
DxForm.$_optionName = "form";
DxForm.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: false, optionName: "colCountByScreen" }
};
var DxFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxFormatConfig);
var DxFormat = defineComponent(DxFormatConfig);
DxFormat.$_optionName = "format";
var DxFormItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:isRequired": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:template": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    dataField: String,
    editorOptions: {},
    editorType: String,
    helpText: String,
    isRequired: Boolean,
    itemType: String,
    label: Object,
    name: String,
    template: {},
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
prepareConfigurationComponentConfig(DxFormItemConfig);
var DxFormItem = defineComponent(DxFormItemConfig);
DxFormItem.$_optionName = "formItem";
DxFormItem.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  label: { isCollectionItem: false, optionName: "label" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxFromConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxFromConfig);
var DxFrom = defineComponent(DxFromConfig);
DxFrom.$_optionName = "from";
DxFrom.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxGroupingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowCollapsing": null,
    "update:autoExpandAll": null,
    "update:contextMenuEnabled": null,
    "update:expandMode": null,
    "update:texts": null
  },
  props: {
    allowCollapsing: Boolean,
    autoExpandAll: Boolean,
    contextMenuEnabled: Boolean,
    expandMode: String,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxGroupingConfig);
var DxGrouping = defineComponent(DxGroupingConfig);
DxGrouping.$_optionName = "grouping";
DxGrouping.$_expectedChildren = {
  groupingTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxGroupingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:ungroup": null,
    "update:ungroupAll": null
  },
  props: {
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    ungroup: String,
    ungroupAll: String
  }
};
prepareConfigurationComponentConfig(DxGroupingTextsConfig);
var DxGroupingTexts = defineComponent(DxGroupingTextsConfig);
DxGroupingTexts.$_optionName = "texts";
var DxGroupItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignByColumn": null,
    "update:column": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:showInGroupFooter": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignByColumn: Boolean,
    column: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    showInGroupFooter: Boolean,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxGroupItemConfig);
var DxGroupItem = defineComponent(DxGroupItemConfig);
DxGroupItem.$_optionName = "groupItems";
DxGroupItem.$_isCollectionItem = true;
DxGroupItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxGroupOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:and": null,
    "update:notAnd": null,
    "update:notOr": null,
    "update:or": null
  },
  props: {
    and: String,
    notAnd: String,
    notOr: String,
    or: String
  }
};
prepareConfigurationComponentConfig(DxGroupOperationDescriptionsConfig);
var DxGroupOperationDescriptions = defineComponent(DxGroupOperationDescriptionsConfig);
DxGroupOperationDescriptions.$_optionName = "groupOperationDescriptions";
var DxGroupPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowColumnDragging": null,
    "update:emptyPanelText": null,
    "update:visible": null
  },
  props: {
    allowColumnDragging: Boolean,
    emptyPanelText: String,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxGroupPanelConfig);
var DxGroupPanel = defineComponent(DxGroupPanelConfig);
DxGroupPanel.$_optionName = "groupPanel";
var DxHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxHeaderFilterConfig);
var DxHeaderFilter = defineComponent(DxHeaderFilterConfig);
DxHeaderFilter.$_optionName = "headerFilter";
DxHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" }
};
var DxHideConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxHideConfig);
var DxHide = defineComponent(DxHideConfig);
DxHide.$_optionName = "hide";
DxHide.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxIconsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxIconsConfig);
var DxIcons = defineComponent(DxIconsConfig);
DxIcons.$_optionName = "icons";
var DxItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:name": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    name: String,
    options: {},
    showText: String,
    template: {},
    text: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxItemConfig);
var DxItem = defineComponent(DxItemConfig);
DxItem.$_optionName = "items";
DxItem.$_isCollectionItem = true;
var DxKeyboardNavigationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editOnKeyPress": null,
    "update:enabled": null,
    "update:enterKeyAction": null,
    "update:enterKeyDirection": null
  },
  props: {
    editOnKeyPress: Boolean,
    enabled: Boolean,
    enterKeyAction: String,
    enterKeyDirection: String
  }
};
prepareConfigurationComponentConfig(DxKeyboardNavigationConfig);
var DxKeyboardNavigation = defineComponent(DxKeyboardNavigationConfig);
DxKeyboardNavigation.$_optionName = "keyboardNavigation";
var DxLabelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:location": null,
    "update:showColon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    alignment: String,
    location: String,
    showColon: Boolean,
    template: {},
    text: String,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxLabelConfig);
var DxLabel = defineComponent(DxLabelConfig);
DxLabel.$_optionName = "label";
var DxLoadPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:height": null,
    "update:indicatorSrc": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showIndicator": null,
    "update:showPane": null,
    "update:text": null,
    "update:width": null
  },
  props: {
    enabled: [Boolean, String],
    height: [Number, String],
    indicatorSrc: String,
    shading: Boolean,
    shadingColor: String,
    showIndicator: Boolean,
    showPane: Boolean,
    text: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxLoadPanelConfig);
var DxLoadPanel = defineComponent(DxLoadPanelConfig);
DxLoadPanel.$_optionName = "loadPanel";
var DxLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: [String, Function]
  }
};
prepareConfigurationComponentConfig(DxLookupConfig);
var DxLookup = defineComponent(DxLookupConfig);
DxLookup.$_optionName = "lookup";
var DxMasterDetailConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoExpandAll": null,
    "update:enabled": null,
    "update:template": null
  },
  props: {
    autoExpandAll: Boolean,
    enabled: Boolean,
    template: {}
  }
};
prepareConfigurationComponentConfig(DxMasterDetailConfig);
var DxMasterDetail = defineComponent(DxMasterDetailConfig);
DxMasterDetail.$_optionName = "masterDetail";
var DxMyConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxMyConfig);
var DxMy = defineComponent(DxMyConfig);
DxMy.$_optionName = "my";
var DxNumericRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxNumericRuleConfig);
var DxNumericRule = defineComponent(DxNumericRuleConfig);
DxNumericRule.$_optionName = "validationRules";
DxNumericRule.$_isCollectionItem = true;
DxNumericRule.$_predefinedProps = {
  type: "numeric"
};
var DxOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxOffsetConfig);
var DxOffset = defineComponent(DxOffsetConfig);
DxOffset.$_optionName = "offset";
var DxOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxOperationDescriptionsConfig);
var DxOperationDescriptions = defineComponent(DxOperationDescriptionsConfig);
DxOperationDescriptions.$_optionName = "operationDescriptions";
var DxPagerConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowedPageSizes": null,
    "update:displayMode": null,
    "update:infoText": null,
    "update:label": null,
    "update:showInfo": null,
    "update:showNavigationButtons": null,
    "update:showPageSizeSelector": null,
    "update:visible": null
  },
  props: {
    allowedPageSizes: [Array, String],
    displayMode: String,
    infoText: String,
    label: String,
    showInfo: Boolean,
    showNavigationButtons: Boolean,
    showPageSizeSelector: Boolean,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxPagerConfig);
var DxPager = defineComponent(DxPagerConfig);
DxPager.$_optionName = "pager";
var DxPagingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:pageIndex": null,
    "update:pageSize": null
  },
  props: {
    enabled: Boolean,
    pageIndex: Number,
    pageSize: Number
  }
};
prepareConfigurationComponentConfig(DxPagingConfig);
var DxPaging = defineComponent(DxPagingConfig);
DxPaging.$_optionName = "paging";
var DxPatternRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:pattern": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    pattern: [RegExp, String],
    type: String
  }
};
prepareConfigurationComponentConfig(DxPatternRuleConfig);
var DxPatternRule = defineComponent(DxPatternRuleConfig);
DxPatternRule.$_optionName = "validationRules";
DxPatternRule.$_isCollectionItem = true;
DxPatternRule.$_predefinedProps = {
  type: "pattern"
};
var DxPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:closeOnOutsideClick": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    closeOnOutsideClick: [Boolean, Function],
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Function, Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Function, Number, String],
    maxWidth: [Function, Number, String],
    minHeight: [Function, Number, String],
    minWidth: [Function, Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Function, Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxPopupConfig);
var DxPopup = defineComponent(DxPopupConfig);
DxPopup.$_optionName = "popup";
DxPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxPositionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
prepareConfigurationComponentConfig(DxPositionConfig);
var DxPosition = defineComponent(DxPositionConfig);
DxPosition.$_optionName = "position";
DxPosition.$_expectedChildren = {
  at: { isCollectionItem: false, optionName: "at" },
  boundaryOffset: { isCollectionItem: false, optionName: "boundaryOffset" },
  collision: { isCollectionItem: false, optionName: "collision" },
  my: { isCollectionItem: false, optionName: "my" },
  offset: { isCollectionItem: false, optionName: "offset" }
};
var DxRangeRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:reevaluate": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    reevaluate: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRangeRuleConfig);
var DxRangeRule = defineComponent(DxRangeRuleConfig);
DxRangeRule.$_optionName = "validationRules";
DxRangeRule.$_isCollectionItem = true;
DxRangeRule.$_predefinedProps = {
  type: "range"
};
var DxRemoteOperationsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:filtering": null,
    "update:grouping": null,
    "update:groupPaging": null,
    "update:paging": null,
    "update:sorting": null,
    "update:summary": null
  },
  props: {
    filtering: Boolean,
    grouping: Boolean,
    groupPaging: Boolean,
    paging: Boolean,
    sorting: Boolean,
    summary: Boolean
  }
};
prepareConfigurationComponentConfig(DxRemoteOperationsConfig);
var DxRemoteOperations = defineComponent(DxRemoteOperationsConfig);
DxRemoteOperations.$_optionName = "remoteOperations";
var DxRequiredRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:message": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    message: String,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRequiredRuleConfig);
var DxRequiredRule = defineComponent(DxRequiredRuleConfig);
DxRequiredRule.$_optionName = "validationRules";
DxRequiredRule.$_isCollectionItem = true;
DxRequiredRule.$_predefinedProps = {
  type: "required"
};
var DxRowDraggingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowDropInsideItem": null,
    "update:allowReordering": null,
    "update:autoScroll": null,
    "update:boundary": null,
    "update:container": null,
    "update:cursorOffset": null,
    "update:data": null,
    "update:dragDirection": null,
    "update:dragTemplate": null,
    "update:dropFeedbackMode": null,
    "update:filter": null,
    "update:group": null,
    "update:handle": null,
    "update:onAdd": null,
    "update:onDragChange": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:onReorder": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null,
    "update:showDragIcons": null
  },
  props: {
    allowDropInsideItem: Boolean,
    allowReordering: Boolean,
    autoScroll: Boolean,
    boundary: {},
    container: {},
    cursorOffset: [Object, String],
    data: {},
    dragDirection: String,
    dragTemplate: {},
    dropFeedbackMode: String,
    filter: String,
    group: String,
    handle: String,
    onAdd: Function,
    onDragChange: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    onReorder: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number,
    showDragIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxRowDraggingConfig);
var DxRowDragging = defineComponent(DxRowDraggingConfig);
DxRowDragging.$_optionName = "rowDragging";
DxRowDragging.$_expectedChildren = {
  cursorOffset: { isCollectionItem: false, optionName: "cursorOffset" }
};
var DxScrollingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:columnRenderingMode": null,
    "update:mode": null,
    "update:preloadEnabled": null,
    "update:renderAsync": null,
    "update:rowRenderingMode": null,
    "update:scrollByContent": null,
    "update:scrollByThumb": null,
    "update:showScrollbar": null,
    "update:useNative": null
  },
  props: {
    columnRenderingMode: String,
    mode: String,
    preloadEnabled: Boolean,
    renderAsync: Boolean,
    rowRenderingMode: String,
    scrollByContent: Boolean,
    scrollByThumb: Boolean,
    showScrollbar: String,
    useNative: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxScrollingConfig);
var DxScrolling = defineComponent(DxScrollingConfig);
DxScrolling.$_optionName = "scrolling";
var DxSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxSearchConfig);
var DxSearch = defineComponent(DxSearchConfig);
DxSearch.$_optionName = "search";
var DxSearchPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:highlightCaseSensitive": null,
    "update:highlightSearchText": null,
    "update:placeholder": null,
    "update:searchVisibleColumnsOnly": null,
    "update:text": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    highlightCaseSensitive: Boolean,
    highlightSearchText: Boolean,
    placeholder: String,
    searchVisibleColumnsOnly: Boolean,
    text: String,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSearchPanelConfig);
var DxSearchPanel = defineComponent(DxSearchPanelConfig);
DxSearchPanel.$_optionName = "searchPanel";
var DxSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:recursive": null,
    "update:selectAllMode": null,
    "update:selectByClick": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    recursive: Boolean,
    selectAllMode: String,
    selectByClick: Boolean,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxSelectionConfig);
var DxSelection = defineComponent(DxSelectionConfig);
DxSelection.$_optionName = "selection";
var DxShowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxShowConfig);
var DxShow = defineComponent(DxShowConfig);
DxShow.$_optionName = "show";
DxShow.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxSortByGroupSummaryInfoConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupColumn": null,
    "update:sortOrder": null,
    "update:summaryItem": null
  },
  props: {
    groupColumn: String,
    sortOrder: String,
    summaryItem: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSortByGroupSummaryInfoConfig);
var DxSortByGroupSummaryInfo = defineComponent(DxSortByGroupSummaryInfoConfig);
DxSortByGroupSummaryInfo.$_optionName = "sortByGroupSummaryInfo";
DxSortByGroupSummaryInfo.$_isCollectionItem = true;
var DxSortingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ascendingText": null,
    "update:clearText": null,
    "update:descendingText": null,
    "update:mode": null,
    "update:showSortIndexes": null
  },
  props: {
    ascendingText: String,
    clearText: String,
    descendingText: String,
    mode: String,
    showSortIndexes: Boolean
  }
};
prepareConfigurationComponentConfig(DxSortingConfig);
var DxSorting = defineComponent(DxSortingConfig);
DxSorting.$_optionName = "sorting";
var DxStateStoringConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customLoad": null,
    "update:customSave": null,
    "update:enabled": null,
    "update:savingTimeout": null,
    "update:storageKey": null,
    "update:type": null
  },
  props: {
    customLoad: Function,
    customSave: Function,
    enabled: Boolean,
    savingTimeout: Number,
    storageKey: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStateStoringConfig);
var DxStateStoring = defineComponent(DxStateStoringConfig);
DxStateStoring.$_optionName = "stateStoring";
var DxStringLengthRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: Number,
    message: String,
    min: Number,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStringLengthRuleConfig);
var DxStringLengthRule = defineComponent(DxStringLengthRuleConfig);
DxStringLengthRule.$_optionName = "validationRules";
DxStringLengthRule.$_isCollectionItem = true;
DxStringLengthRule.$_predefinedProps = {
  type: "stringLength"
};
var DxSummaryConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateCustomSummary": null,
    "update:groupItems": null,
    "update:recalculateWhileEditing": null,
    "update:skipEmptyValues": null,
    "update:texts": null,
    "update:totalItems": null
  },
  props: {
    calculateCustomSummary: Function,
    groupItems: Array,
    recalculateWhileEditing: Boolean,
    skipEmptyValues: Boolean,
    texts: Object,
    totalItems: Array
  }
};
prepareConfigurationComponentConfig(DxSummaryConfig);
var DxSummary = defineComponent(DxSummaryConfig);
DxSummary.$_optionName = "summary";
DxSummary.$_expectedChildren = {
  groupItem: { isCollectionItem: true, optionName: "groupItems" },
  summaryTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" },
  totalItem: { isCollectionItem: true, optionName: "totalItems" }
};
var DxSummaryTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:count": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:sum": null,
    "update:sumOtherColumn": null
  },
  props: {
    avg: String,
    avgOtherColumn: String,
    count: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    sum: String,
    sumOtherColumn: String
  }
};
prepareConfigurationComponentConfig(DxSummaryTextsConfig);
var DxSummaryTexts = defineComponent(DxSummaryTextsConfig);
DxSummaryTexts.$_optionName = "texts";
var DxTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:cancel": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:clearFilter": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:count": null,
    "update:createFilter": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:emptyValue": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null,
    "update:filterEnabledHint": null,
    "update:fix": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:leftPosition": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:ok": null,
    "update:rightPosition": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:stickyPosition": null,
    "update:sum": null,
    "update:sumOtherColumn": null,
    "update:undeleteRow": null,
    "update:unfix": null,
    "update:ungroup": null,
    "update:ungroupAll": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    avg: String,
    avgOtherColumn: String,
    cancel: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    clearFilter: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    count: String,
    createFilter: String,
    deleteRow: String,
    editRow: String,
    emptyValue: String,
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String,
    filterEnabledHint: String,
    fix: String,
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    leftPosition: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    ok: String,
    rightPosition: String,
    saveAllChanges: String,
    saveRowChanges: String,
    stickyPosition: String,
    sum: String,
    sumOtherColumn: String,
    undeleteRow: String,
    unfix: String,
    ungroup: String,
    ungroupAll: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxTextsConfig);
var DxTexts = defineComponent(DxTextsConfig);
DxTexts.$_optionName = "texts";
var DxToConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxToConfig);
var DxTo = defineComponent(DxToConfig);
DxTo.$_optionName = "to";
DxTo.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxToolbarConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:disabled": null,
    "update:items": null,
    "update:visible": null
  },
  props: {
    disabled: Boolean,
    items: Array,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxToolbarConfig);
var DxToolbar = defineComponent(DxToolbarConfig);
DxToolbar.$_optionName = "toolbar";
DxToolbar.$_expectedChildren = {
  item: { isCollectionItem: true, optionName: "items" }
};
var DxToolbarItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxToolbarItemConfig);
var DxToolbarItem = defineComponent(DxToolbarItemConfig);
DxToolbarItem.$_optionName = "toolbarItems";
DxToolbarItem.$_isCollectionItem = true;
var DxTotalItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:column": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignment: String,
    column: String,
    cssClass: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxTotalItemConfig);
var DxTotalItem = defineComponent(DxTotalItemConfig);
DxTotalItem.$_optionName = "totalItems";
DxTotalItem.$_isCollectionItem = true;
DxTotalItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxValidationRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:pattern": null,
    "update:reevaluate": null,
    "update:trim": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    pattern: [RegExp, String],
    reevaluate: Boolean,
    trim: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxValidationRuleConfig);
var DxValidationRule = defineComponent(DxValidationRuleConfig);
DxValidationRule.$_optionName = "validationRules";
DxValidationRule.$_isCollectionItem = true;
DxValidationRule.$_predefinedProps = {
  type: "required"
};
var DxValueFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxValueFormatConfig);
var DxValueFormat = defineComponent(DxValueFormatConfig);
DxValueFormat.$_optionName = "valueFormat";
var data_grid_default2 = DxDataGrid;
export {
  DxAnimation,
  DxAsyncRule,
  DxAt,
  DxBoundaryOffset,
  DxButton,
  DxChange,
  DxColCountByScreen,
  DxCollision,
  DxColumn,
  DxColumnChooser,
  DxColumnChooserSearch,
  DxColumnChooserSelection,
  DxColumnFixing,
  DxColumnFixingTexts,
  DxColumnHeaderFilter,
  DxColumnHeaderFilterSearch,
  DxColumnLookup,
  DxCompareRule,
  DxCursorOffset,
  DxCustomOperation,
  DxCustomRule,
  DxDataGrid,
  DxDataGridHeaderFilter,
  DxDataGridHeaderFilterSearch,
  DxDataGridHeaderFilterTexts,
  DxDataGridSelection,
  DxEditing,
  DxEditingTexts,
  DxEmailRule,
  DxExport,
  DxExportTexts,
  DxField,
  DxFieldLookup,
  DxFilterBuilder,
  DxFilterBuilderPopup,
  DxFilterOperationDescriptions,
  DxFilterPanel,
  DxFilterPanelTexts,
  DxFilterRow,
  DxForm,
  DxFormItem,
  DxFormat,
  DxFrom,
  DxGroupItem,
  DxGroupOperationDescriptions,
  DxGroupPanel,
  DxGrouping,
  DxGroupingTexts,
  DxHeaderFilter,
  DxHide,
  DxIcons,
  DxItem,
  DxKeyboardNavigation,
  DxLabel,
  DxLoadPanel,
  DxLookup,
  DxMasterDetail,
  DxMy,
  DxNumericRule,
  DxOffset,
  DxOperationDescriptions,
  DxPager,
  DxPaging,
  DxPatternRule,
  DxPopup,
  DxPosition,
  DxRangeRule,
  DxRemoteOperations,
  DxRequiredRule,
  DxRowDragging,
  DxScrolling,
  DxSearch,
  DxSearchPanel,
  DxSelection,
  DxShow,
  DxSortByGroupSummaryInfo,
  DxSorting,
  DxStateStoring,
  DxStringLengthRule,
  DxSummary,
  DxSummaryTexts,
  DxTexts,
  DxTo,
  DxToolbar,
  DxToolbarItem,
  DxTotalItem,
  DxValidationRule,
  DxValueFormat,
  data_grid_default2 as default
};
/*! Bundled license information:

devextreme-vue/esm/core/helpers.js:
devextreme-vue/esm/core/children-processing.js:
devextreme-vue/esm/core/vue-helper.js:
devextreme-vue/esm/core/config.js:
devextreme-vue/esm/core/configuration.js:
devextreme-vue/esm/core/configuration-component.js:
devextreme-vue/esm/core/constants.js:
devextreme-vue/esm/core/templates-discovering.js:
devextreme-vue/esm/core/templates-manager.js:
devextreme-vue/esm/core/component.js:
devextreme-vue/esm/core/extension-component.js:
devextreme-vue/esm/core/index.js:
devextreme-vue/esm/data-grid.js:
  (*!
   * devextreme-vue
   * Version: 24.2.9
   * Build date: Tue Aug 05 2025
   *
   * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=devextreme-vue_data-grid.js.map
